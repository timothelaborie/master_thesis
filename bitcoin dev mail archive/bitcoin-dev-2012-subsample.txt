
Well, I hope at some point to push libcoin to bitcoin, but that is not for me to decide ;)

Anyway, I will strive at keeping the two synced - currently, they are almost in sync - even bip 16 is part of libcoin, but I have postponed generation of P2SH till after we were certain of 16 vs 17. So that is high on the list. 

I did a presentation of libcoin at BitCon12 in San Antonio - I will trow the slides at the web-side asap.


More people is always nice! I am using libcoin for my own bitcoin project, so that should guarantee that it will be kept up to date.


Yes, I even have an account :)


Nope...

/M


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------

Primarily that block verification and therefore propagation is too
slow because it's very CPU and IO intensive. The CPU work can be
multi-threaded. The IO work, not as much. As Bitcoin grows we need to
scale the nodes. Eventually there may be multi-machine nodes, but for
now we can buy more time by making the existing nodes faster.

I don't see this as a replacement for moving users to SPV clients.
Obviously, otherwise I would not be writing one ;)


I have no experience with how robust LevelDB is. It has an API call to
try and repair the database and I know from experience that BigTable
is pretty solid. But that doesn't mean LevelDB is.


The code is a lot simpler for sure.


It was refactored out of BigTable and made standalone for usage in
Chrome. Therefore it's as portable as Chrome is. Mac/Windows/Linux
should all work. Solaris, I believe, may need 64 bit binaries to avoid
low FD limits.


Yes: http://code.google.com/p/py-leveldb/

First look at the code is here, but it's not ready for a pull req yet,
and I'll force push over it a few times to get it into shape. So don't
branch:

https://github.com/mikehearn/bitcoin/commit/2b601dd4a0093f834084241735d84d84e484f183

It has misc other changes I made whilst profiling, isn't well
commented enough, etc.


-------------------------------------
Hello all,

pull #649 now also defines an import/export format for private keys
whose public key is compressed.

Rationale: even though a compressed and uncompressed public key share
the same actual 32-byte secret, the import/export format needs a
marker that states whether the corresponding compressed or
uncompressed public key should be used (since they have different
addresses).

Format:
* uncompressed: 0x80 + [32-byte secret] + [4 bytes of Hash() of
previous 33 bytes], base58 encoded
* compressed: 0x80 + [32-byte secret] + 0x01 + [4 bytes of Hash()
previous 34 bytes], base58 encoded

Any comments or suggestions regarding this format? Below I've included
3 cases to test implementations with.

Test cases:

case 1:
  * secret (hex):
1111111111111111111111111111111111111111111111111111111111111111
  * uncompressed:
    * secret (base58): 5HwoXVkHoRM8sL2KmNRS217n1g8mPPBomrY7yehCuXC1115WWsh
    * pubkey (hex):
044f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa385b6b1b8ead809ca67454d9683fcf2ba03456d6fe2c4abe2b07f0fbdbb2f1c1
    * address (base58): 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a
  * compressed:
    * secret (base58): KwntMbt59tTsj8xqpqYqRRWufyjGunvhSyeMo3NTYpFYzZbXJ5Hp
    * pubkey (hex):
034f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa
    * address (base58): 1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9

case 2:
  * secret (hex):
dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd
  * uncompressed:
    * secret (base58): 5KVzsHJiUxgvBBgtVS7qBTbbYZpwWM4WQNCCyNSiuFCJzYMxg8H
    * pubkey (hex):
04ed83704c95d829046f1ac27806211132102c34e9ac7ffa1b71110658e5b9d1bdedc416f5cefc1db0625cd0c75de8192d2b592d7e3b00bcfb4a0e860d880fd1fc
    * address (base58): 1JyMKvPHkrCQd8jQrqTR1rBsAd1VpRhTiE
  * compressed:
    * secret (base58): L4ezQvyC6QoBhxB4GVs9fAPhUKtbaXYUn8YTqoeXwbevQq4U92vN
    * pubkey (hex):
02ed83704c95d829046f1ac27806211132102c34e9ac7ffa1b71110658e5b9d1bd
    * address (base58): 1NKRhS7iYUGTaAfaR5z8BueAJesqaTyc4a

case 3:
  * secret (hex):
47f7616ea6f9b923076625b4488115de1ef1187f760e65f89eb6f4f7ff04b012
  * uncompressed:
    * secret (base58): 5JMys7YfK72cRVTrbwkq5paxU7vgkMypB55KyXEtN5uSnjV7K8Y
    * pubkey (hex):
042596957532fc37e40486b910802ff45eeaa924548c0e1c080ef804e523ec3ed3ed0a9004acf927666eee18b7f5e8ad72ff100a3bb710a577256fd7ec81eb1cb3
    * address (base58): 1PM35qz2uwCDzcUJtiqDSudAaaLrWRw41L
  * compressed:
    * secret (base58): KydbzBtk6uc7M6dXwEgTEH2sphZxSPbmDSz6kUUHi4eUpSQuhEbq
    * pubkey (hex):
032596957532fc37e40486b910802ff45eeaa924548c0e1c080ef804e523ec3ed3
    * address (base58): 19ck9VKC6KjGxR9LJg4DNMRc45qFrJguvV

-- 
Pieter


-------------------------------------
By the way, by far the most common support request I have at my pool is


For 0.7 we've added a red "(out of sync)" warning to the balances when the
block chain is out of date.

However, due to the design of the protocol there is a large variance in
block timings, and it is not possible to determine up-to-date status with
certainty, so quite a large safety margin is used. To be precise the
warning is shown when the last received block was generated more than 90
minutes ago.

Wladimir
-------------------------------------
On 5/3/12, Andreas Schildbach <andreas@schildbach.de> wrote:

Someone said to me that the cell phone apps they had tried were still
too slow. I'm still using an old phone so I didn't know well what to
answer him. I recomended him bitcoin wallet and bitcoin spinner, but I
warned him that I haven't really used them.

It would be nice to also have a list with smartphone clients near the
list that is being prepared.

-- 
Jorge Timn


-------------------------------------
On Mon, Nov 26, 2012 at 7:16 PM, Walter Stanish <walter@stani.sh> wrote:

I hate to inform you that you have been mislead. The IETF and the IANA
do not operate as you outlined above. Having spent too many years
within ICANN/IETF/IANA I can assure you are mistaken.
Your drafts are expired and it appears that there is no support for a
"finance" working group in the IETF.


-rick


-------------------------------------
Now that I've seen and read through the forum thread on this, I think I'll
step back and let others get on with it. As Amir notes, we could be "Bike
Shedding" this for years.

On 2 May 2012 21:25, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
RE: Changing SignedInvoice's invoice field to 'bytes serialized_invoice':

Good Idea, I agree it will avoid potential issues. I think it then
makes sense to pull the pki_type and pki_data into SignedInvoice, too,
and specify that the signature is on the SHA256-HMAC of pki_type,
pki_data, and serialized_invoice (being careful to combine them in a
way that is secure).

RE: Changing Payment to include just merchant_data and not the entire Invoice:

Agreed, good idea.


RE: Mr. Stanish's suggestion to punt all of this and wait for a Grand
Unified Solution:

No, we have problems that need a solution right now. And, having
written one (I was the lead author of the ISO/IEC 14772-1
international standard) I'm very pessimistic about your chances for
anything like IFEX to actually be adopted.

-- 
--
Gavin Andresen


-------------------------------------
On Mon, Jan 16, 2012 at 2:35 AM, Wladimir <laanwj@gmail.com> wrote:

Very few people actually care if they can load that particular URL ...
if you were talking about the forums it might matter more.   It also
might make sense to run some informative popup, except people are
going to be seeing them all over the internet on higher traffic sites.

E.g.: http://en.wikipedia.org/wiki/File:Wikipedia_SOPA_Blackout_Design_%28derivative_A%29.png


-------------------------------------
But is he the only one using the broken URLs? It was my impression that
they were widespread already.

Wladimir

On Mon, Jul 16, 2012 at 10:52 AM, Gary Rowe <g.rowe@froot.co.uk> wrote:

-------------------------------------
I had some difficulty setting up and maintaining my own gitian build
system. So in the time-honored tradition of scratching my own itch, I
recorded the necessary steps into a makefile so that doing a gitian build
is a simple as "cd contrib/vagrant && make", on any platform provided that
you have the necessary dependencies installed.

I hope that others find this useful. I have submitted these scripts as
pull-request #1597 on github.

Cheers,
Mark Friedenbach
-------------------------------------
Thanks for the thoughts. For those who don't know, Stephen works for BitPay.


The term "merchant" is just being used to mean the entity requesting
the payment. I'm hopeful that in future mobile wallets will be
creating these messages where today they'd make URLs and QRcodes. So
it's definitely intended for person to person payments too.


Nothing stops you converting them into whatever form you want on the
server side. If you don't care about the signature checking then it's
no problem to use a server. If you do then you'd need to ship all the
code for verifying signatures that to the client anyway, at which
point a small protobuf parser is hardly a deal killer.


They can send an unsigned payment request. Note that if you mail it as
an attachment from a competent, up to date email provider then the
attachment isn't really unsigned. The whole thing is covered by the
emails DKIM signature which is applied transparently by the ESP. If
the signature fails to verify then the mail client can show that or
treat the mail differently (as Gmail does). This is easy to use for
the end user - they don't have to think about cryptography or PKI. As
long as their email account is secure then they can send signed mails
asserting to their identity.


Useful feedback, thanks. Still, there may be other types of merchants
for whom it's useful, and many users won't change their wallet. It
certainly simplifies things if you can present the refund address and
give a one-click option to use it. If the user wants to use a
different address, then they can go onto the slow/complicated path.

This current spec deliberately punts on the topic of identifying end
users. It's a difficult problem. Whereas many merchants have SSL
certs, most end users don't have published keys in any useful form. By
far the easiest way for 99% of people to generate a signed message is
to send email that's signed by DKIM (from gmail, hotmail, yahoo, other
providers etc). Then it's all transparent and behind the scenes. Their
identity is their email address.

So for BitPays scenario, you could require an email to be sent by the
end user containing new instructions. Your MTA can show you whether
the mail is correctly DKIM signed or not when deciding whether to
follow the instructions.


Yeah, I like the term "check"/"cheque" for that concept of a reversible payment.


It's still a good idea to use one for privacy reasons. The merchant
data is there so you can stuff whatever state you want into it. So
it's like cookies. You don't have to keep state on the server side.
Just encrypt/sign it, put it in the invoice, and when you get a
payment message back there's no need to do database lookups or
anything, you can just do some crypto and know who is submitting it.


What's wrong with it? Isn't your proposal more complex? I don't see
why it's better than just embedding it.


There's no Receipt message, a SignedPaymentRequest + transactions that
pay to the requested outputs are together the proof of payment.

Re a new URI scheme. Interesting idea, thanks for the suggestion. It
seemed like it'd be easier for merchants to integrate if a single
linked worked for all wallet implementations/versions. But I guess we
could do both schemes, even.


-------------------------------------
On Sunday, January 29, 2012 9:30:10 AM Gavin Andresen wrote:

In other words, if the max-sigops-per-block were ever approaching a real 
problem, we could just start using these kind of transactions instead hidden 
behind the P2SH... so the one remotely-tangible benefit of BIP 16 over 17 has 
been solved, right? ;)


-------------------------------------
Hi Wladimir / others,

I just downloaded the latest (0.6 rc1) source of bitcoin-qt and built it using qt-creator on MacOSX 10.7.3. Nice and easy experience, even though I had to change BDB version to 5.1 ;)

However, when running it, it is using 100% CPU (after initial block chain download that is...)
* All activity in debug.log seems normal (blocks/txes/addresses are processes and accepted etc) so it is not stuck (at least not in the MessageThread)
* Sampling the process shows that the majority of time in each thread is used for:
** __semwait_signal
** kevent
** __select
** mach_msg_trap
** boost::date_time::micro_sec_clock

None of this would usually alert me - sleeping and waiting for conditions should not consume CPU, the only issue seems to be the last line which is called from qtipcserver.cpp line 31:

       if(mq->timed_receive(&strBuf, sizeof(strBuf), nSize, nPriority, d))

As I see it this should not consume cpu either, but, it is the only thing that seems a bit strange..

Have you seen this before?

/M

-------------------------------------
On Fri, Feb 24, 2012 at 11:15 PM, Amir Taaki <zgenjix@yahoo.com> wrote:


https://forums.oracle.com/forums/thread.jspa?messageID=4018239

Wladimir
-------------------------------------
+list

On Mon, Jun 18, 2012 at 9:07 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

Maybe ... looking again I think I may be wrong about being IO bound in
the last benchmark. The core running the main Bitcoin thread is still
pegged and the LevelDB background thread is only spending around 20%
of its time in iowait. An oprofile shows most of the time being spent
inside a std::map.

OK, to make progress on this work I need a few decisions (Gavin?)

1) Shall we do it?

2) LevelDB is obscure, new and has a very minimalist build system. It
supports "make" but not "make install", for example, and is unlikely
to be packaged. It's also not very large. I suggest we just check the
source into the main Bitcoin tree and link it statically rather than
complicate the build.

3) As the DB format would change and a slow migration period
necessary, any other tweaks to db format we could make at the same
time? Right now the key/values are the same as before, though using
satoshi serialization for everything is a bit odd.

We'd need UI for migration as well.


-------------------------------------
On Wed, May 16, 2012 at 12:34 PM, Amir Taaki <zgenjix@yahoo.com> wrote:


I do not object to the concept, but the discovery process should be
improved.  Even venerable SMTP has a better, more flexible
capabilities discovery process.

Instead of further overloading service bits in the version message, or
altering the version message, let us instead make feature discovery an
easy, flexible, extensible process.

We can add new commands without impacting older nodes, so let's create
a new command "get-features" (or pick your name) that returns a list
of key/value pairs.  The key is a string, the value type is determined
by the key.

Standard behavior of clients would be to send "get-features" after
seeing remote version info, as part of the initial connection
handshake.

In any case, the basic point is to move FAR away from fighting over a
limited, inflexible resource (service bits in "version" msg) to
something string-based and easily extensible.

I can create this as BIP 34, if people wish.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Both blocks

38304 00000000015bb4069249fa1f41ae61d8a7447aaacc33c50dacd3c3654377fa43

and

40320 000000008011f56b8c92ff27fb502df5723171c5374673670ef0eee3696aee6d

are difficulty transition blocks. However, block 40320 has a difficulty
of 1. I know there is this special testnet rule that allows mining a
block at difficulty 1, but I always thought you can't use this exception
on difficulty transition blocks.

As a result, bitcoinj based clients do not advance their blockchain past
block 40319.



-------------------------------------
On 01/30/2012 11:33 PM, Michael Hendricks wrote:
If the number of outbound connections is increased the delay of
transaction broadcast code needs to be improved to avoid a broadcast storm.

-------------------------------------
On Wed, Oct 3, 2012 at 1:38 PM, Ian Miers <imiers1@jhu.edu> wrote:

You have to be specific about what you're measuring, because
"performance" is vague.

You can measure many aspects of blockchain performance by importing
blocks via -loadblock=FILE.

Other performance measurements like "how fast does a block relay
through the network" cannot be as easily measured.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wed, Oct 24, 2012 at 05:56:07PM +0200, Mike Hearn wrote:

Two comments I made on the pullreq page, which are probably better discussed here:
* The 0xFFFFFFFF/(n-1)*i seed value seems intended to result in large bit
  differences between the different hash function's seeds. Together with the tweak,
  however, the first and the last now get seeds tweak and tweak-1. I think
  something simpler like k1*i+k2*n+tweak is better (with k1 and k2 arbitrary large
  odd 32-bit integers).
* I feel uneasy about the arbitrary filter parameters used for the implicitly
  created filter when sending filteradd without filterload. The server cannot be
  expected to make a reasonable guess how the client is going to use the filter,
  and the client still has to track how large the server-side filter grows anyway.
  I'd prefer to make this simply illegal (DoS 100): filteradd always requires an
  active filter. Maybe the actual filter data in filterload can be made optional:
  if it is omitted, it's assumed to be all zeroes (though that would mean the size
  has to be specified).

-- 
Pieter



-------------------------------------
On Thu, May 24, 2012 at 1:27 PM, Robert McKay <robert@mckay.com> wrote:

Yes.  This was stated in the original email.



At current rates it is potentially years before that point is reached
-- years of degraded service for existing users.



If you see a rule change, you have misunderstood the proposal.

This is an -implementation- change, which users and miners are free to
accept or reject as part of their choice of software to use in the
bitcoin ecosystem.

As such, miners continue to be free to build upon empty blocks, and
let those blocks become part of a useful chain.  You would not simply
/ban/ empty blocks completely, but avoid relaying top-of-chain empty
blocks.

Mining power and network collaborate to choose the best chain at that
point -- perhaps even including those empty blocks.  Clients will
continue to follow the longest, strongest chain, even after this
implementation change.

An implementation change is a soft vote of choice by the user, not a
hard requirement on all users.


See above -- such behavior is perfectly fine.

It should be noted that out of band (OOB) TXs, transited through third
party means outside P2P network, would not cause _empty_ blocks, as
the block chain will continue to have traffic for the foreseeable
future.

OOB TXs are a great idea, too.  In a hyperscaled bitcoin future, OOB
TXs might even be the norm.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hello everyone,

Luke's getmemorypool/BIP22 pull request has been open for a long time, and
didn't receive too much discussion.

I think that having a stable and flexible API for negotiating block
generation is important to be standardized. The fact that it allows moving
block generation to specialized programs is a step in the right direction.
However, it seems to me that too few people (myself included) understand
all the details of BIP22 (or don't care enough) to judge their necessity. I
gave up trying to follow all design decisions some time ago, and as it
seems I'm not alone, nobody liked merging support for it in the Satoshi
client. This is a pity, and I hope the situation can be improved soon.

I'm sorry for being this late with these comments, but I think it's
essential that the standard is not more complex than necessary (making it
as easy as possible to write either servers or clients for it), and perhaps
even more important, that its purpose and intended use cases are clear.

submit. The general idea is that
 1) a miner requests a block template
 2) builds/modifies a block based on this, and optionally uses propose to
check whether the server is willing to accept it before doing work
 3) submits when valid proof-of-work is found
I'd like to see this process described in the BIP at least, it too me way
too long to extract this.

Regarding the block template: is there a particular reason for sending the
full transactions (serialized in hex) both in templates and submissions?
The server will always need to have access to the transaction database
anyway, and clients will (afaics) rarely care about the actual
transactions. My suggestion would be to just transfer txids - if the client
is interested in the actual transactions, we have the gettransaction RPC
call already. This seems to be captured by the several "submit/*" and
"share/*" variations, but making it optional seems way more complex than
just limiting the API to that way of working.

That's another thing that bothers me in the standard: too many optional
features. In particular, I understand the usefulness of having some
flexibility in what miner clients are allowed to modify, but I'm
unconvinced we need 10 individually selectable variations. In particular:
* coinbase outputs: can we just add a list of required coinbase outputs
(amount + scriptPubKey) to the template? If no generation+fee amount
remains, nothing can be added.
* coinbase input: put the required part in the template; miners can always
add whatever they like. Is there any known use case where a server would
not allow a client to add stuff to the coinbase?
* noncerange limiting: if coinbase input variation is not limited, there is
certainly no reason to limit nonceranges. This adds unnecessary complexity
to clients, in my option.
* time/*: put a minimum and maximum timestamp in the template (i believe
those are already there anyway). Anything in between is valid.
* transactions/add: what is the use case?
* transactions/remove: i'd just standarize on having all transactions be
removable (perhaps except those marked 'required').
* prevblock: one getmemorypool per new block shouldn't be a problem imho,
so do a longpoll instead of having the client able to modify prevblock
themselves.

One more thing that I do not like is often several ways for specifying the
same behaviour. For example, txrequires specifies that the first N
transactions are mandatory, a 'required' field in the transaction list
itself specifies that that transaction is mandatory, and the lack of
transactions as variation means that they must not be touched at all. Pick
one way that is flexible enough, and discard the others.

In summary, I'd like to see the standard simplified. I have no problem
merging code that makes getmemorypool compliant to a standard that is
agreed upon, but like to understand it first.

In my opinion - but I'm certainly open to discussion here - the standard
could be simplified to:
* getblocktemplate: create a new block template, and return it. The result
contains:
 * bits, previousblockhash, version: as to be used in block
 * curtime, maxtimeoff, maxtimeoff: client chooses a timestamp between
(curtime - local_time_at_receipt + local_time), decreased by mintimeoff and
increased maxtimeoff
 * expires, sigoplimit, sizelimit: unchanged
 * subsidy: amount generated (5000000000 for now)
 * coinbaseaux: what generated coinbase's scriptSig must start with
 * coinbaseoutputs: list of objects, each specifying a required coinbase
output. Each has fields:
   * amount: sent amount
   * scriptPubKey: hex serialized of the output script
 * transactions: list of object, each specifying a suggested transaction
(except for the coinbase) in the generated block. Each has fields:
   * txid: transaction id
   * depends: list of dependencies (txids of earlier objects in this same
transactions list).
   * fee: fee generated by this transaction, which increases the max output
of the coinbase.
   * required: if present, transaction may not be dropped.
* submitblocktemplate: submit an object containing a hex serialized block
header, hex serialized coinbase transaction, and a list of txids. Returns
true or string describing the problem. Proof of work is checked last, so
that error is only returned if there is no other problem with the suggested
block (this allows it to replace both propose and submit).

Are there important use cases I'm missing?

--
Pieter
-------------------------------------
OK, I have a few thoughts on this:

1) Germane to the original conversation, anything hard to implement will
not get implemented by miners.
2) Coinbase is hard-limited to 100 bytes; this has to include space for
voting as well as extra nonce, etc. So, I'm not sure that a full URL is a
good plan.
3) I'm a little fuzzy on the details of BIP governance; but I'm happy to
write one up and get my thoughts down, or someone who's more familiar could
do it, I suppose.

I propose the following spec:

periodically a miner may choose to publish a url through their coinbase as
follows:

1) They shall prepend \mi: to the url to designate it as a url for miner
info, and append a trailing \ to the url
2) The url given in the coinbase shall have http:// prepended to it before
processing.
3) The destination may be a redirect (to allow short URLs), or may deliver
content
4) The content-type returned by the final site post-redirect shall be
either (preferred text/json) or text/plain or text/html
4) The text of the document delivered shall be a JSON format dictionary,
and shall include at minimum the following fields: 'min_fee', 'pool_name',
and 'last_modified' Optional fields can be determined over time as
necessary by the mining community
5) The Service Level Agreement isn't binding, but miners who implement it
are expected to make a best efforts attempt to follow it.

So a valid coinbase could be:
/P2SH/\mi:goo.gl/mr2D\extra_nonce:2110

Generally a miner would occasionally publish the \mi:\ when they had
updated their SLA, or just every so often, but the canonical location would
be the final destination URL from the redirects.

Inre: Luke's complaint about JSON, it is the language of the web. There is
no easier format for both computers and humans to read, and in this case,
it includes extensibility, which is nice, since we have no idea how miners
will wish to divvy up their services; I think one would need to make a
strong case against JSON for a specific reason to not choose it by default.

Thoughts welcome!

Best,

Peter



On Tue, May 29, 2012 at 10:47 AM, Luke-Jr <luke@dashjr.org> wrote:



-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
On Wed, Feb 1, 2012 at 9:18 AM, Michael Grønager <gronager@ceptacle.com> wrote:

Very interesting. Do you know where this speedup came from?  It's not
typical for straight refactors that don't change datastructures and
the like to see such big speedups.

I see you have commented out code that disables fsync, which was my
first guess since I get big speedups from doing similar things.


-------------------------------------
My point is that stuffing nonces into whatever spaces we can find to
eke out a bit more scalability in pools seems like a very short term
fix with potentially very long term consequences.

Although it may sound harsh, if your pool is struggling to keep up
with calculating merkle roots (which is cheap!) then it's time to
either upgrade your pool or for some of those users to migrate to
p2pool and handle creation of work themselves. Trying to squash more
nonce bits out of fields that were never meant for that seems like a
bad precedent with no real motivation beyond making running
centralized pools a bit cheaper.

What I'm interested in is, can a powerful server-class machine really
not keep up with work generation for things like the BitForce SC
devices? How many devices would you need to exhaust the ability to
generate work for them? You'll need powerful machines just to run a
node at all sooner or later.


-------------------------------------

On 13 Sep 2012, at 19:59, Pieter Wuille <pieter.wuille@gmail.com> wrote:


This is not fully correct. I propose downloading the roots of the segments when you are not looking to remove redundant transaction downloads. This would be the case when the node is not up-to-date and is unlikely to have transactions in the required blocks. When a node is up-to-date and can benefit from removing redundant transaction downloads it can switch to downloading all the transactions hashes by specifying a high level number. Also I wouldn't recommend using one thread per connection, I'd recommend using one thread for all connections.


This isn't what I was suggesting. I was suggesting you only need to download one level. Once you have done that you verify everything for the hashes on that level.


Well you will need to ask for the headers first. Once you do that you can start downloading the full blocks for the headers.  The node should use "get blocks" to find nodes with segments of the blocks they need. Now for each block:

1. Send getsiginv to a number of peers to know the segments of the blocks they have. 
2. Send gettreelevel requesting a level of the merkle tree from a peer that can provide it. When up-to-date use a high level to get the transaction hashes to find redundant data.
3. Validate the treelevel response
4. Send getsegment for each segment wanted (at the same time where possible) to the peers that have these segments. Skip transactions already known.
5. Validate the transactions in each segment received. Stop if the block is invalid and disconnect peers that give transactions which do not fit the merkle tree.
6. Revert to getdata if peers using the protocol cannot satisfy the block download.

When a valid block segment is received, include the block in inv and headers messages for other peers using the protocol. Thus relaying can begin before the entire block is downloaded.

I'm thinking about improvements to this proposal. I'll get to that tomorrow perhaps

Thank you everyone for the replies.

-------------------------------------
On Wed, Oct 10, 2012 at 7:19 AM, Mike Hearn <mike@plan99.net> wrote:

I tried in IRC and got no response. These messages are copying the
only contact email address I could find.



Yes, so do a lot of people. It doesn't.


There is a middle ground: You can not hide it without explaining it.
AFAICT we don't see ~any questions about the reference client waiting
for six confirmations before saying confirmed.


There have been a great many circulated on the network. People don't
report all losses— e.g. we've never seen a report from those who've
burned hundreds of bitcoins in fees on transactions.


Perhaps.


I think this is very hard because this matter is rapidly politicized.
There are some in the community who will instantly allege misconduct
when there is a mis-agreement.

Basically: No one sane should want the job, and anyone who wants
should on no account be allowed to have it.

At this point I think we also will get better results communicating
among technical people in order to get the development focus adjusted
in a way that mitigates those risks that can be mitigated and those
cautions that can be offered offered.

After all, if the Electrum project is _unwilling_ to disclose the
limitations of their implementation and security model on their own
site, even after having them pointed out then someone updating
Bitcoin.org to include them will be politically contentious.  I want
to make sure that we've followed all reasonable avenues before going
that route— first I attempted informally on IRC, now I've brought the
discussion here... instead of, e.g. starting the process to remove it
from the bitcoin.org clients page.


I agree, thats why I started this thread.


-------------------------------------
Dear all,
A draft of my paper is up at
http://wbl.github.com/bitcoinanon.pdf
Comments are welcome, as is discussion about implications I haven't thought of.
Sincerely,
Watson Ladd


-------------------------------------
On Tuesday, November 27, 2012 12:16:07 AM Gregory Maxwell wrote:

There is a common subset of CAs which are included in all OSs.
That's the "whitelist equivalent". We or someone else could even setup a list 
of these common CAs for merchants if that is needed.

The fees CAs charge for certs is a flaw in the CA model in general, I don't 
see that it's important for us to solve it.



-------------------------------------
On Friday, January 27, 2012 7:36:31 PM bitcoin-list@bluematt.me wrote:

It's been implemented in many clients for nearly all 2011.
Bitcoin-Qt is just behind the pace. Not relevant.


You mean 3 months *after* the spec had a consensus and multiple 
implementations.


-------------------------------------
Although Jenkins may not be the best system, we already have jenkins and
pull-tester (which is a dumb python script I wrote to test all incoming
pull requests from github).  

They both run the same set of scripts, namely those at
https://github.com/TheBlueMatt/test-scripts (its pretty basic right now,
but since it is on github, I was hoping someone would find the
inspiration to add to it).

I dont really care if we keep using jenkins, but I figure we might as
well keep all the tests in one place?

Anyway, I'm all for more testing (I'm always complaining about how we
need more tests for stuff...).

Matt

On Tue, 2012-09-25 at 19:32 +0100, steve wrote:



-------------------------------------
On Tuesday, May 29, 2012 3:28:56 PM Peter Vessenes wrote:

20 byte keyhashes are a fundamental building block of the Bitcoin protocol.

ripemd160(sha256(ecdsaPubKey))


-------------------------------------
In the CMakeLists.txt file in the libcoin root find the lines regarding Boost - it says 

... 1.48  ...

Change that to 1.47 and try again. I suggest you first remove your CMakeCache.txt though...

(the Qt stuff is most likely not the culprit)

/M



On 01/02/2012, at 18:37, Luke-Jr wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Zooko is spot on - slower confirmations will give people a reason to set
higher fees. As soon as fees reach a level where they matter, even
botnet operators will be looking into ways of including transactions for
some extra profit.

In the meantime slightly slower confirmations aren't a problem. Consider
that even if it takes four blocks to get your transaction included
instead of one, once it is included, you still benefit from every new
block in terms of security. So if you're looking for six confirmations
for example, even a three block delay will only be a 50% delay for you.
And of course there are techniques for instant transactions which
continue to be refined and improved.

As for the proposed solutions: Punishing 1-tx blocks is complete and
utter nonsense. It's trivial to include a bogus second transaction.

Any additional challenges towards miners like hashes of the previous
block are at best useless. If I was running a botnet, I'd just grab that
hash from a website (pretty good chance Blockchain.info will have it :P)
or mining pool or wherever and keep going undeterred. At worst they may
affect scalability one day. You might imagine a peer-to-peer network of
miners who for cost reasons don't download all blocks anymore, but
verify only a percentage of them at random. They might then exchange
messages about invalid blocks including a proof (invalid tx, merkle
branch) why the block is invalid. This is just one idea, the point is
that assumptions about what a legitimate miner looks like may not always
hold in the future.

Finally, there is an ethical aspect as well. If a miner wishes not to
include my transaction that is his choice. He has no more an obligation
to sell his service to me than I have to buy it from him. If I really,
really want him to include my transaction I will have to offer to pay more.

If we as developers think that confirmations are too slow or that more
blocks should include transactions, then the right measures would be:

- Educating users about the relationship between confirmation speed and fees
- Raising the default transaction fee

Every market has a supply curve, so it is economically to be expected
that there will be some miners who don't include transactions, simply
because they are at that end of the supply curve where it is not worth
it for them to sell their service. All markets must have a certain
tension - there must be miners who don't include transactions for there
to be users who want their transactions included more quickly. In other
words there must be somebody not confirming if confirmations are to have
value. If you interfere with that all you'll accomplish is keep
transaction fees below market level, which will make the transition from
inflation-financed hashing to transaction-financed hashing more painful
and disruptive.

Cheers,

Stefan


-------------------------------------
Thanks Mike for the writeup - I'm very sad to have missed the discussion
on IRC since fee economics are probably my favorite topic, but I'll try
to contribute to the email discussion instead.


Fees are a product of both real and artificial limits to transaction
validation.

The artificial limits like the block size limit are essentially putting
a floor on prices by limiting supply beyond what it would otherwise be.
E.g. the network could confirm more transactions theoretically, but the
block size limit prevents it.

The real limits are the bandwidth, computing and memory resources of
participating nodes. For the sake of argument suppose a 1 TB block was
released into the network right now and we'll also assume there was no
block size limit of any kind. Many nodes would likely not be able to
successfully download this block in under 10-30 minutes, so there is a
very good chance that other miners will have generated two blocks before
this block makes its way to them.

What does this mean? The miner generating a 1 TB block knows this would
happen. So in terms of economic self interest he will generate the
largest possible block that he is still confident that other miners will
accept and process. A miner who receives a block will also consider
whether to build on it based on whether they think other miners will be
able to download it. In other words, if I receive a large block I may
decide not to mine on it, because I believe that the majority of mining
power will not mine on it - because it is either too large for them to
download or because their rules against large blocks reject it.

It's important to understand that in practice economic actors tend to
plan ahead. In other words, if there is no block size limit that doesn't
mean that there will be constant forks and total chaos. Rather, no miner
will ever want to have a block rejected due to size, there is plenty of
incentive to be conservative with your limits. Even if there are forks,
this simply means that miners have decided that they can make more money
by including more transactions at the cost of the occasional dud.

Therefore, from an economic perspective, we do not need a global block
size limit of any kind. As "guardians of the network" the only thing we
need to do is to let miners figure out what they wanna do.

HOWEVER, the existing economic incentives won't manifest unless somebody
translates them into code. We have to give our users (miners & endusers)
the tools to create a genuine fee-based verification market.

On the miner side: I would make the block size limit configurable with a
relatively high default. If the default is too low few people will
bother changing it, which means that it is not worth changing (because a
majority uses the default anyway), which means even fewer people will
change it and so on.

The block size limit should also be a soft rather than a hard limit -
here are some ideas for this:

- The default limit for accepting blocks from others should always be
significantly greater than the default limit for blocks that the client
itself will generate.

- There should be different size limits for side chains that are longer
than the currently active chain. In other words, I might reject a block
for being slightly too large, but if everyone else accepts it I should
eventually accept it too, and my client should also consider
automatically raising my size limit if this happens a lot.

The rationale for the soft limit is to allow for gradual upward
adjustment. It needs to be risky for individual miners to raise the size
of their blocks to new heights, but ideally there won't be one solid
wall for them to run into.

On the user side: I would display the fee on the Send Coins dialog and
allow users to choose a different fee per transaction. We also talked
about adding some UI feedback where the client tries to estimate how
long a transaction will take to confirm given a certain fee, based on
recent information about what it observed from the network. If the fee
can be changed on the Send Coins tab, then this could be a red, yellow,
green visual indication whether the fee is sufficient, adequate or
dangerously low.

A criticism one might raise is: "The block size limit is not to protect
miners, but to protect end users who may have less resources than miners
and can't download gigantic block chains." - That's a viewpoint that is
certainly valid. I believe that we will be able to do a lot just with
efficiency improvements, pruning, compression and whatnot. But when it
comes down to it, I'd prefer a large network with cheap
microtransactions even if that means that consumer hardware can't
operate as a standalone validating node anymore. Headers-only mode is
already a much-requested feature anyway and there are many ways of
improving the security of various header-only or lightweight protocols.

(I just saw Greg's message advocating the opposite viewpoint, I'll
respond to that as soon as I can.)



+1 Very good change. This would allow miners to maximize their revenue
and in doing so better represent the existing priorities that users
express through fees.



Discouraging address reuse will not change the amount of transactions, I
think we all agree on that. As for whether it improves the
prioritization, I'm not sure. Use cases that we seek to discourage may
simply switch to random addresses and I don't agree in and of itself
this is a benefit (see item 4 below). Here are a few reasons one might
be against this proposal:

1) Certain use cases like green addresses will be forced to become more
complicated than they would otherwise need to be.

2) It will be harder to read information straight out of the block
chain, for example right now we can pretty easily see how much volume is
caused by Satoshi Dice, perhaps allowing us to make better decisions.

3) The address index that is used by block explorers and lightweight
client servers will grow unnecessarily (an address -> tx index will be
larger if the number of unique addresses increases given the same number
of txs), so for people like myself who work on that type of software
you're actually making our scalability equation slightly worse.

4) You're forcing people into privacy best practices which you think are
good, but others may not subscribe to. For example I have absolutely
zero interest in privacy, anyone who cares that I buy Bitcoins with my
salary and spend them on paragliding is welcome to know about it.
Frankly, if I cared about privacy I wouldn't be using Bitcoin. If other
people want to use mixing services and randomize their addresses and
communicate through Tor that's fine, but the client shouldn't force me
to do those things if I don't want to by "deprioritizing" my transactions.

5) We may not like firstbits, but the fact remains that for now they are
extremely popular, because they improve the user experience where we
failed to do so. If you deprioritize transactions to reused addresses
you'll for example deprioritize all/most of Girls Gone Bitcoin, which
(again, like it or not) is one of the few practical, sustainable niches
that Bitcoin has managed to carve out for itself so far.



Free is just an extreme form of cheap, so if we can make transactions
very cheap (through efficiency and very large blocks) then it will be
easier for charitable miners to include free transactions. In practice,
my prediction is that free transactions on the open network will simply
not be possible in the long run. Dirty hacks aside there is simply no
way of distinguishing a spam transaction from a charity-worthy
transaction. So the way I envision free transactions in the future is
that there may be miners in partnership with wallet providers like
BlockChain.info that let you submit feeless transactions straight to
them based on maybe a captcha or some ads. (For the purist, the captcha
challenge and response could be communicated across the bitcoin network,
but I think we agree that such things should ideally take place
out-of-band.)

That way, the available charity of miners who wish to include feeless
transactions would go to human users as opposed to the potentially
infinite demand of auto-generated feeless transactions.



On 6/15/2012 1:29 PM, Mike Hearn wrote:



-------------------------------------
Analysis, comments, constructive criticism, etc welcome for the following:

==Background==
At present, an attacker can harm a pool by intentionally NOT submitting shares 
that are also valid blocks. All pools are vulnerable to this attack, whether 
centralized or decentralized and regardless of reward system used. The 
attack's effectiveness is proportional to ratio of the attacker's hashrate to 
the rest of the pool.

There are obvious solutions that can be used to defeat this attack on 
centralized pools. For example, including a secret in the coinbase transaction 
that is accepted by the network as a partial preimage proof-of-work. All these 
solutions require changes to Bitcoin's proof-of-work acceptance terms, and 
since centralized pools can be harmful to the network's security, these rule 
changes are not likely to gain enough acceptance among the greater Bitcoin 
community.

==Proposed Solution==
Please comment on the viability of this new proof-of-work algorithm, which I 
think should be viable for even decentralized pools:

Blocks are accepted at a lower difficulty N (choosable by the pool; eg, the 
share difficulty) iff they are submitted with a candidate for the next block 
and SHA256(SHA256(NewBlockHash + NextBlockCandidateHash)) meets difficulty M.
The relationship between M and N must be comparable to the normal network 
difficulty; details on the specifics of this can be figured out later, ideally 
by someone more qualified than me. M and N must be chosen prior to searching 
for the block: it should be safe to steal some always-zero bytes from the 
prevblock header for this.

This algorithm should guarantee that every share has an equal chance of being 
a valid block at the time it is found, and that which ones are actually blocks 
cannot be known until the subsequent block is found. Thus, attackers have no 
way to identify which shares to withhold even while they have full knowledge 
of the shares/blocks themselves.

==Backward Compatibility==
Obviously, this change creates a hard-fork in the blockchain. I propose that 
if it solves the block withholding risk, the gain is sufficient that the 
community may approve a hard-fork to take place 1-2 years from consensus.

Since mining continues to use a double-SHA256 on a fixed 80 byte header, 
existing miners, FPGAs, etc should work unmodified. Poolservers will need to 
adapt significantly.


-------------------------------------
The OP_EVAL discussion went into some private discussion for a bit, so 
here is a summary of what we talked about.

Roconnor pointed out that the currently proposed OP_EVAL removes the 
ability to statically reason about scripts. Justmoon pointed out that 
this is evidenced by the changes to GetSigOpCount:

Currently, the client first counts the number of sigops and if it is 
over a certain limit, it doesn't execute the script at all. This is no 
longer possible with OP_EVAL, since OP_EVAL can stand for any number of 
other operations, which might be part of some piece of data. The script 
that is executed by OP_EVAL can be changed (polymorphic code). Gavin's 
patch deals with this, by counting the sigops at runtime and aborting 
only after the limit has been reached.

Here is an example for a script that based on naive counting contains no 
sigops, but in fact contains 20:

[20 signatures] 20 [pubkey] OP_DUP OP_DUP OP_2DUP OP_3DUP OP_3DUP     
OP_3DUP OP_3DUP OP_3DUP 20 "58959998C76C231F" OP_RIPEMD160 OP_EVAL

RIPEMD160( 58 95 99 98 C7 6C 23 1F )

hashes to

AE4C10400B7DF3A56FE2B32B9906BCF1B1AFE975

which OP_EVAL interprets as

OP_CHECKMULTISIG "400B7DF3A56FE2B32B9906BCF1B1AFE9" OP_DROP

The nonce 58959998C76C231F was generated using this code: 
https://gist.github.com/1546061

Gavin and Amir argued that it is possible to "dry run" the script, 
avoiding the expensive OP_CHECKSIG operation and running only the other 
very cheap operations. However, sipa pointed out that in the presence of 
an OP_CHECKSIG a dry runner cannot predict the outcome of conditional 
branches, so it has to either do the OP_CHECKSIG (and become just a 
regular execution) or it has to follow both branches. Roconnor and 
justmoon suggested the following script to illustrate this point:

[sig] [pubkey]
[some data]
[sig] [pubkey] OP_CHECKSIG OP_IF OP_HASH160 OP_ELSE OP_HASH256 OP_ENDIF
(previous line repeated 33 times with different sigs/pubkeys)
OP_EVAL

This script is valid assuming that the resulting hash from the branch 
that is chosen based on what signatures are valid contains an 
OP_CHECKSIG. (And the initial [sig] and [pubkey] are valid.) But a dry 
runner trying to count how many OP_CHECKSIGs this script contains would 
run into the first OP_CHECKSIG OP_IF and have to run both branches. In 
both branches it would again encounter a OP_CHECKSIG OP_IF and run all 
four branches, etc. In total it has to run (2^33 - 2) * 1.5 SHA256 
operations (8 GHash) and 2^32 - 1 RIPEMD160 operations. Therefore we now 
believe a dry runner is not possible or at least too complicated to be 
involved in protocol rules such as the sigops limit.

As a result people are now on a spectrum from those who feel strongly 
that static analysis is an important property and not something to give 
up easily all the way to those who think it's superfluous and the other 
side is just unnecessarily delaying OP_EVAL deployment.

One thing I want to note is that static analysis is a property for which 
there is a better argument than for other, weaker properties, such as 
limited recursion depth. Bitcoin currently allows you to:

* Tell if a script contains a specific opcode or not
* Count how many times a script will execute an operation at most
* Count how many total operations a script will execute at most
* Count how many signatures a script will execute at most
* Find the maximum length of a datum pushed onto the stack
* Find the maximum number of items that can be pushed onto the stack
* Find the maximum size (in bytes) of the stack
* Calculate how long a script will run at most

OP_EVAL as proposed makes these upper bounds almost meaningless as it 
can contain, indirectly, up to 32 instances of any other opcode. (About 
3-6 instances are currently practical.) The only way to answer these 
questions would then be to fully execute the script.

Suppose we want to one day allow arbitrary scripts as IsStandard, but 
put constraints on them, such as enforcing a subset of allowed opcodes. 
(See list above for other possible restrictions.) If we want to include 
OP_EVAL in the set of allowed opcodes, it's important that OP_EVAL is 
implemented in a way that allows static analysis, because we can then 
allow it while still maintaining other restrictions.

If proponents of the current implementation want to argue that we don't 
need static analysis now, the burden is on them to show how we could 
retrofit it when/if we get to this point or why they think we will never 
want to allow some freedom in IsStandard that includes OP_EVAL.

There are several proposals for OP_EVAL that allow static analysis:

* Using a fixed position reference prefix (sipa)
* Using an execute bit on data set by an opcode (justmoon)
* Using OP_CODEHASH (roconnor)
* Using OP_CHECKEDEVAL (sipa)
* Using OP_HASH160 OP_EQUALVERIFY as a special sigPubKey (gavinandresen)

Let's fully develop these proposals and see how much of a hassle it 
would actually be to get a statically verifiable OP_EVAL. I think that's 
a prerequisite for having the argument on whether it is *worth* the hassle.

(Update: Gavin's latest proposal looks *very* good, so that may settle 
the debate quickly.)




On 12/30/2011 6:19 PM, roconnor@theorem.ca wrote:

-------------------------------------
Gavin said:
"Part of the controversy is whether really long bitcoin addresses would work-- would it be OK if the new bitcoin addresses were really long and looked something like this:57HrrfEw6ZgRS58dygiHhfN7vVhaPaBE7HrrfEw6ZgRS58dygiHhfN7vVhaPaBiTE7vVhaPaBE7Hr
(or possibly even longer)

I've argued no: past 70 or so characters it becomes a lot harder to copy and paste, a lot harder to scan an address with your eyes to see if you're paying who you think you're paying, harder to create a readable QR code, harder to upgrade website or database code that deals with bitcoin addresses, etc. There is rough consensus that very-long addresses are not workable."

How could you have a 70 byte long address without a P2SH scheme? Is this a mistake?


-------------------------------------
A forum post worth tracking: https://bitcointalk.org/index.php?topic=127604.0

Every little standardization helps.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I don't think that's a good idea as it can easily confuse or annoy users
when things move around. The ordering should be preserved as much as
possible so users can remember where they found a client they liked
(e.g. 2nd row, 1st column and screenshot with light and blue colors).
Making them search the entire page is inefficient and will just get
worse once there are many clients on the page (and I think that's the goal).

On 09.07.2012 17:54, Amir Taaki wrote:



-------------------------------------
Any objections from other transaction-validating implementations?

I strongly support more precisely defining the transaction validity
rules by changing the reference implementation.

-- 
--
Gavin Andresen


-------------------------------------
RE:
class][3-byte checksum]

How will the code distinguish between the old scheme:
[one-byte-version][20-byte-hash][4-byte-checksum]
and the new?

1 in 256 old addresses will have a first-byte-of-checksum that matches the
new address class; I guess the code would do something like:

a) If the 4-byte checksum matches, then assume it is a singlesig address (1
in 2^32 multisig addresses will incorrectly match)
b) If the one-byte-address-class and 3-byte checksum match, then it is a
valid p2sh
c) Otherwise, invalid address

The 1 in 2^32 multisig addresses also being valid singlesig addresses makes
me think this scheme won't work-- an attacker willing to generate 8 billion
or so ECDSA keys could generate a single/multisig collision.  I'm not sure
how that could be leveraged to their advantage, but I bet they'd find a way.

RE: should it be a BIP:  The BIP process is described in BIP
0001<https://en.bitcoin.it/wiki/BIP_0001#BIP_Work_Flow>,
and you're following it perfectly so far:

1) Post a rough draft of the idea here to see if there's any chance it'll
be adopted
2) Assuming a positive response and no major flaws: write up a draft BIP
3) Post the draft BIP here, where it can be picked apart.
4) Assuming no major flaws, ask the BIP editor (Amir) for a BIP number

I'd also encourage you to actually implement your idea between steps 3 and
4. But in this particular case, I think an attacker being able to create
singlesig/p2sh address collisions counts as a major flaw.

-- 
--
Gavin Andresen
-------------------------------------
The laws in question are OFAC sanctions:

http://en.wikipedia.org/wiki/Office_of_Foreign_Assets_Control

The specific acts that enable this are varied. In theory they apply to
any US citizen or resident. The issue is not cryptography, it's "trade
with sanctioned countries", period, where making files available to
download is considered trade.

For Bitcoin to be available in these places, the sites and download
mirrors would need to be hosted outside the USA by non-citizens. EU
sanctions are primarily financial at this time, as far as I know there
are no attempts to prevent people from serving data to Iran.

Example of places where there are no sanctions in effect: Switzerland.
Unfortunately datacenter space in Zurich is quite expensive (as is
everything here).

I would not ever describe OFAC as "effective law". The SDN list has
repeatedly been found unconstitutional, representing as it does a
complete evasion of the judicial system. If you end up on the
sanctions list no evidence is required, no process is followed and no
appeals are possible. The list itself assumes names are globally
unique.


-------------------------------------
Btw, I sent updated text to Genjix Armory.  I hope that gets included or
reviewed.

And I agree about the $4k donations thing.  That's complete immaterial for
this page.  Though the rest of the description there is reasonable, and
might even be better than what I sent Genjix.

-Alan


On Wed, May 2, 2012 at 9:42 AM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
On Tue, Mar 6, 2012 at 6:05 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:
One doesn't use this opcode as the sole thing to secure a transaction.
Instead this opcode prevents double spend attacks against
anonymization schemes. The idea is for Alice to give signatures to the
recipients of funds, all signatures being equivalent. To avoid this
from leading to a double-spend, we use a quorum method based on
showing earlier redemptions happened.
Because you can't blind a lamport signature, it isn't. I'm searching
for a place to post the current draft: it's not ready for anything
official yet, but does seem to be of interest. Drop me a (offlist)line
if you have ideas about where I can put  it.
Sincerely,
Watson Ladd

-- 
"Those who would give up Essential Liberty to purchase a little
Temporary Safety deserve neither  Liberty nor Safety."
-- Benjamin Franklin


-------------------------------------
Hi Gavin / Luke,

BIP-13 again... I started to implement a bitfield based parsing of the version byte using the description I got from Luke, but I then discovered that it does not hold:
Network class:
00xxxxxx - main network
01xxxxxx - reserved
10xxxxxx - reserved
11xxxxxx - test network

Network:
xx00xxxx - bitcoin
xx01xxxx - reserved
xx10xxxx - OTHER (next octet)
xx11xxxx - Namecoin

Network specific:
xxxx000y - PubKeyHash
xxxx001y - reserved
xxxx010y - p2sh
xxxx011y - public key (raw)
xxxx100y - signature
xxxx101y - reserved
xxxx110y - private key (raw)
xxxx111y - OTHER (next octet)

However, the definitions en base58.h are:

        PUBKEY_ADDRESS = 0, (00000000)
        SCRIPT_ADDRESS = 5, (00000101)
        PUBKEY_ADDRESS_TEST = 111, (01101111) !!!
        SCRIPT_ADDRESS_TEST = 196, (11000100) !!!

[as a side note litecoin is 48 (00110000) and namecoin is 52 (00110100)]

So there is no logic ?? I have searched the mailing list and the forum for discussions on this but found it hard to find any. If I overlooked something please direct me.

Cheers,

M

PS: I have said so before, but it would *really* be nice if discussions / conclusions / irc-summaries were taking place at one place - e.g. at the bitcoin-dev mailing list, not at 5-10 different threads in bitcointalk or in bip notes or solely on IRC...


On 20/02/2012, at 18:17, Gavin Andresen wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Hey,

Will get around to that write-up. Here is the page for next Tuesday:


https://en.bitcoin.it/wiki//10_Jan_2012

Feel free to add talking/discussion points to the agenda.



-------------------------------------
On Sat, Jun 16, 2012 at 10:16 AM, Andy Parkins <andyparkins@gmail.com>wrote:


It's currently (nearly) stateless, however it would be short-sighted to
think it will stay that way. State is being introduced as we speak; for
example, connection-specific filters.

I like the idea of a capabilities command; as time goes on and the ecosystem

Which is a perfectly reasonable requirement. However, one could simply
standardize what a 'thin client' and what a 'thick client' does and offers
(at a certain version level), without having to explicitly enumerate
everything over the protocol.

This also makes it easier to deprecate (lack of) certain features later on.
You can simply drop support for protocol versions before a certain number
(which has happened before). With the extension system this is much harder,
which likely means you keep certain workarounds forever.

Letting the node know of each others capabilities at connection time helps
somewhat. It'd allow refusing clients that do not implement a certain
feature. Then again, to me it's unclear what this wins compared to
incremental protocol versions with clear requirements.

I'm just afraid that the currently simple P2P protocol will turn into a zoo
of complicated (and potentially buggy/insecure) interactions.

So maybe a capability system is a good idea but then the granularity should
be large, not command-level. The interaction between protocol versions and
capabilities needs to be defined as well. Does offering "getdata" at
protocol version 10 mean the same as offering it at protocol version 11"?
Probably not guaranteed. The arguments might have changed. So it's not
entirely self-documenting either.

Wladimir
-------------------------------------
Or we could just point everyone here:
http://lovebitcoins.org/getStarted.html

:-)

On 2 May 2012 20:40, Raphael NICOLLE <raphbot@gmail.com> wrote:

-------------------------------------
On Tuesday, January 31, 2012 11:50:58 AM Andy Parkins wrote:

I'm not aware of any remaining *tangible* objections to BIP 17 at this point 
(Gavin seems concerned over a theoretical risk-that-nobody-has-thought-of), 
but if there's a better solution, I'm perfectly fine Withdrawing BIP 17 to 
support it.


Both BIP 16 and 17 are backward compatible enough that people can continue to 
use the old clients with each other. An upgrade is only required to send to 
(or create/receive on) the new 3...-form addresses. That being said, it's 
quite possible to rewrite the practical implications of both BIP 16 and 17 in 
the format you seem to be suggesting. Doing so would even get rid of one of 
the major objections to BIP 16 (its inconsistency).



-------------------------------------

The problem with this "accept everything even if broken" approach is
that people will probably never fix the broken stuff. So we likely end
up with a fragmented de-facto standard.

That does not mean I am totally against accepting broken URLs, but there
should be at least a promise that they will be fixed at the source.



-------------------------------------
Here are my (mostly half baked) thoughts on the payments protocol proposal.

My first observation is that the proposal is too heavily oriented around a
merchant/customer interaction.  I think it's equally important to consider
the person to person scenarios.  It would be very cool if people could
send/receive payments by copying and pasting stuff on facebook or email
(you can kind of do it now, but it's not safe unless you go to
extraordinary lengths using PGP signatures and the like).

Protobufs vs JSON: Protobufs are fine, although I will mention that the
serialization/JOSE arguments are irrelevant...you only need that if you
need a reliable way of signing an in memory object structure...in this case
you would be signing a serialized form of the object...the recipient
doesn't have to be able to reproduce the serialized form, they only need to
verify the signature on the already serialized bytes...I see protobufs as a
good serialization format for storage, while JSON being more practical for
communications in a web oriented environment...with protobufs & a web
wallet, you may find yourself in a situation needing to parse a protobuf
message in a web browser...the protobuf parsing and serializing code is
just going to add bloat to the web page...personally, I probably would have
gone with JSON, but hey, I'm not writing the code.

X.509 - nasty, but maybe ok ...as long as you can add root CAs to your
Bitcoin client or explicitly trust a certificate, I don't see that it poses
any privacy issues...but there are some other things to think about here
...like what about the casual user that wants to create a payment request
to send to their friend over email (wrapped in a clear text block similar
to PGP...it could also be sent as a file attachment)?  Are you now
requiring them to go and setup a certificate?  Btw, I really like the use
of a payment request in this manner because you have a signed payment
request that can be verified against an address book of known identities.
 This could be much safer than simply emailing an unsigned bitcoin address
around.

Refund addresses...this is not going to be as useful as people might
think...most refunds that bitpay needs to process happen days or even
months after the initial purchase...in that span of time, people can change
wallets, rendering such a refund address useless...so, as I think about the
situation, we would still need to contact the buyer to confirm a refund
address anyway.  What we really need is to verify the identity of the
person we're potentially sending the refund to...we need a way of
determining that the person we're sending the refund to is the same person
that paid the original invoice.  Bitcoin addresses are identities, but they
are too low level.  HD wallets come to mind...the top level or intermediate
levels of a deterministic hierarchy could be used for identity
purposes...but it also seems like it might be conflating payments and
identity (which for many reasons you might want to keep separate).  What if
bitcoin clients could manage one or more identities used for the purpose of
communications?  You could have a bitcoin identity file that could be used
by multiple wallets.  These identities would be used for signing messages
and verifying the authenticity of communications...when sending a payment,
instead of a refund address, you would include one of these identities
which could later be used to confirm a refund address.  In fact, the refund
would be processed by the buyer generating another payment request message
signed by the identity used in the original payment.

People would understand that their identities are important for
communications and they would keep those even when changing to new wallets
and such (identities could be stored in ~/.bitcoin/id or something
(encrypted of course)).

There are some other interesting possibilities if messaging and identities
are done right...for example, I could add "check" feature (analogous to
paper checks).  It would work like this...you create a transaction that
spends to a newly generated address...you put that transaction, along with
the private key into an encrypted container (sent to the identity of the
person you want to pay).  The recipient can open it and their wallet would
go ahead and generate and broadcast a transaction moving the funds into
their wallet (optionally including a fee).  But, if the recipient never
cashes the check, the sender could pull those funds back after a certain
period of time.  This also eliminates the possibility of accidentally
sending the funds to the wrong address (or an old address) and the bitcoins
being forever lost...the recipient can sweep the transaction into any
wallet of their choice.

As I'm writing this, I'm beginning to wonder if the identity management
problem is unavoidable.  Maybe that needs to be dealt with first.  It would
enable so many other interesting possibilities.

I like the use of merchant_data...this means that you no longer will need a
unique bitcoin address for every invoice.

In the signed invoice structure, why embed the serialized invoice?  Why not
make that a reference using a hash?  Generally speaking, I'm not a fan of
embedding things like that.  You could have an over-arching structure
called Message which is just "repeated bytes objects" (in protobuf lingo)
...references between objects would use a hash and the first object would
be treated as the message.  In a payment request message, the
SignedPaymentRequest would be the first object, the PaymentRequest the
second.

I think the Payment structure should refer to the SignedPaymentRequest (by
its hash) instead of the merchant_data...you can of course access the
merchant_data through the SignedPaymentRequest.  I suppose you could always
index payment requests based on the merchant_data, but it just seems
cleaner to refer back the the signed payment request when sending a payment.

You might want to include an optional memo for each output...I could
imagine including one output that says "Don't forget to tip your
waiter"...any amount sent to that address could go directly to the waiter's
wallet.

What about payments from multiple wallets?  We see this a lot.  I think
this scheme would handle it ok, but just want to mention it.  I can imagine
someone paying first from one wallet, then the invoice webpage updates with
a clickable link to a new PaymentRequest for the remaining amount.

The Receipt should be signed...it could be used as proof of payment by
wallets.

Finally, I've seen seen suggestions to tack on a payment request URI to the
current bitcoin: URI for backward compatibility...I say no.  A bitcoin URI
already has a lot of data (especially if it includes a memo)...this makes
QR codes more dense and hence more difficult to scan...I say we stake a
claim on the "pay" URI .... pay:https://somewhere.com/payment/94kd83  ...or
for a clickable link, you could embed it right on the web page, eliminating
the need for a second https request... pay:data:<PaymentRequestMessage>
 ...and finally, to further shorten the URI, https could be assumed if the
protocol is omitted ... pay:somewhere.com/payment/94kd83

We can deal with backward compatibility by including a link on invoices to
display an old style bitcoin payment address.
-------------------------------------
The bitcoin 0.2 protocol (the one with no checksums on version/verack) ended its life Feb 20th.

I had forgot to add the date check in libcoin, so after Feb 20th you might have seen some errors in the log file (and having trouble getting blocks) - the code is fixed now...

Also, there are a lot of updates for 0.6:
* New internal address classes: PubKeyHash and ScriptHash to support P2SH
* Adapted a lot of other code from the 0.6 branch
* Support for BitcoinQt: I am porting BitcoinQt to use libcoin - this required a couple of interface enhancements. More on this later...

(detail:
https://github.com/ceptacle/libcoin/commit/98531e971152d4fff41c30b14d58b9fd548b21db
)

Cheers,

Michael

-------------------------------------
This is the next big "lets all agree to do things the same way" thing
I think we should tackle. I'm particularly looking for feedback from
other bitcoin client developers, even if it is just a quick "looks
reasonable, if everybody else is going to do it then I will
(eventually) too..."

Thanks to Pieter Wuille and Mike Hearn for lots of feedback and
suggestions and brainstorming.

This document is online at https://gist.github.com/4120476

If you respond to this message, please be considerate of people who
subscribe to the digest version of this mailing list and trim your
response.


Invoices, Payments and Receipts for Bitcoin Transactions
========================================================

This document proposes protocol buffer-based formats for signed,
authenticated "invoices" and "receipts" -- requests for payment, and
proof-of-payment.

Separate documents propose an extension to the Bitcoin URI syntax and
new MIME types to support them.

Motivation
==========

The idea of a "payment protocol" to improve on Bitcoin addresses has
been around for over a year. Users have been asking for some features
in this proposal (like the ability to provide a refund address so
overpayments or refunds can be returned to customers without the need
to ask them for their address) for two or three years, and have
started to work around shortcomings in the Bitcoin payment process
with creative (but inefficient) uses of transactions.

The key features of this proposal are:

+ Requests for payment (Invoices) are tied to authenticated identities
using the only widely-deployed identity authentication system we have
right now (X.509 certificates signed by root certificate authorities)
+ Invoices include a user-friendly description of what the payment is for
+ Payments include where refunds should be sent
+ At the end of the payment process, the customer holds a
cryptographically signed Receipt that can be used as proof-of-payment
if there is any dispute with the merchant.


Specification
=============

Invoice/SignedInvoice
---------------------

An Invoice is a request for payment from a merchant to a customer:

::

    message Output {
	optional uint64 amount = 1;
	required bytes script = 2;
    }

amount: Number of satoshis (0.00000001 BTC) to be paid. If not given
or zero, then the customer will be asked how much to pay.

script: a "TxOut" script to which the customer should direct payment.
This will normally be one of the standard Bitcoin transaction script
(e.g. pubkey OP_CHECKSIG).

::

    message Invoice {
        repeated bytes x509chain = 1;
        repeated Output outputs = 2;
        required uint64 time = 3;
        optional uint64 expires = 4;
        optional bool single_use = 5 [default = true];
        optional string memo = 6;
        optional string receiptURI = 7;
        optional bytes merchant_data = 8;
    }

outputs: one or more outputs where Bitcoins are to be sent.

x509chain: one or more DER-encoded X.509 certificates that identifies
the merchant. See the "Certificates" section below for details.

time: Unix timestamp (seconds since 1-Jan-1970) when the Invoice was created.

expires: Unix timestamp after which the Invoice should be considered
invalid. If not given, the Invoice may be re-used until the earliest
certificate expiration date in the X509chain.

single_use: If true, this Invoice should be used for only one payment.
If false, it may be added to the user's address book and used
repeatedly until it expires (e.g. for donations or a recurring
payment).

memo: UTF-8 encoded, plain-text (no formatting) note that should be
displayed to the customer, explaining what this Invoice is for.

receiptURI: Secure (https) URI where a Payment message (see below) may
be sent to obtain a SignedReceipt as proof-of-payment.

merchant_data : Arbitrary data ignored by the client that may be used
by the merchant to identify the Invoice.

::

    message SignedInvoice {
        required Invoice invoice = 1;
        required bytes signature = 2;
    }

A SignedInvoice is an Invoice signed using the private key
corresponding to the public key in the first certificate in the
x509chain and the HMAC SHA-256 algorithm.

When a Bitcoin client receives a SignedInvoice, it must authorize
payment by doing the following:

1. Validate the x509chain certificate chain up to it's list of root
certificate authorities
2. Validate that the time on the customer's system is before Invoice.expires
3. Display the "Common Name" (CN) string from the first x509chain
certificate and ask the customer if they would like to submit payment

Payment
-------

::

    message Payment {
        required Invoice invoice = 1;
        repeated bytes transactions = 2;
        repeated Output refund_to = 3;
        optional string memo = 4;
    }

invoice : the invoice received from the merchant. A merchant must
validate the Invoice and may reject the Payment if the Invoice was
altered by the customer.

transactions : One or more valid, signed Bitcoin transactions that
fully pay the Invoice

refund_to : One or more outputs where the merchant may return funds,
if necessary.

memo : UTF-8 encoded, plain-text note from the customer to the merchant.

If the customer authorizes payment, then the Bitcoin client:

1. Creates and signs a transaction with one output sending the Invoice.script
2. If there is no Invoice.receiptURI, then the transaction is
broadcast on the Bitcoin p2p network.
3. Else POST a Payment message to Invoice.receiptURI and expect a
SignedReceipt in response.

Invoice.receiptURI must be secure against man-in-the-middle attacks
that might alter Payment.refund_to.

*Note: an alternative would be a SignedPayment message that ties the
signatures in Payment.transactions to a signature for the entire
Payment message. Spending multisig inputs that may be controlled by
more than one person or spending arbitrary non-standard transactions
makes that non-trivial.*

Receipt/SignedReceipt
---------------------

::

    message Receipt {
        required Payment payment = 1;
        required bool accepted = 2;
        optional string memo = 3;
    }

accepted : true if the Payment is accepted and will be broadcast on
the Bitcoin p2p network.

memo : UTF-8 encoded note that should be displayed to the customer
indicating that the transaction is complete.

::

    message SignedReceipt {
        required Receipt receipt = 1;
        required bytes signature = 3;
    }

A SignedReceipt is a Receipt signed using the private key
corresponding to the public key in the first certificate in the
Receipt->Payment->Invoice.x509chain and the HMAC SHA-256 algorithm.

Upon receiving a SignedReceipt, a Bitcoin client should validate the
signature and, if valid, display the Receipt.memo and store the
SignedReceipt as proof-of-payment.

If a SignedReceipt is not received for any reason (timeout, error) and
Payment.transactions has not been broadcast by the merchant on the
Bitcoin p2p network, then the Bitcoin client should assume that the
payment failed, inform the customer that the payment failed, and
return coins involved in the transaction to the customer's wallet.


Certificates
============

The Invoice.x509chain (X.509 Certificate Chain) field contains the
X.509 public key certificate or certificate chain [RFC5280]
corresponding to the key used to digitally sign the Invoice and
Receipt. The certificate or certificate chain is represented as an
array of DER [ITU.X690.1994] PKIX certificate value. The certificate
containing the public key of the entity that digitally signed the
Invoice MUST be the first certificate. This MAY be followed by
additional certificates, with each subsequent certificate being the
one used to certify the previous one. The recipient MUST verify the
certificate chain according to [RFC5280] and reject the payment
request if any validation failure occurs.

*What should we say about root certificates and certificate management
in general? Any requirements, or leave it up to each Bitcoin client to
determine which root CA's are trustworthy, as happens with web
browsers? Gavin suggests trusting only (say) ten of the Extended
Validation authorities:
http://en.wikipedia.org/wiki/Extended_Validation_Certificate#Extended_Validation_certificate_identification
*

*X.509 is widely criticised for doing too much. However, it is the
Public Key Infrastructure (PKI) system we're stuck with. Do web
browsers / certificate authorities support the full X.509 spec, or
only a subset? Should Bitcoin clients only support some well-defined
subset of X.509 ? More research needed here... *

Use Cases
=========

Merchant Payment Service
------------------------

A merchant payment service (like Paysius or bit-pay.com) would use
Invoices and Receipts as follows:

1. Merchant pays for a certificate from a certificate authority, and
then gives the payment service the certificate and their private key.
This could be the same certificate and private key as is used for the
merchant's web site, but best security practice would be to purchase a
separate certificate for authenticating Invoices. Very successful
merchant payment services might act as intermediate certificate
authorities, issuing certificates for their merchants.
2. Customer goes through the checkout process on either the merchant's
or payment service's web site.
3. At the end of the checkout process, a SignedInvoice is generated
and sent to the customer's Bitcoin client.
4. Customer's Bitcoin client displays the Invoice, showing that the
payment is for the merchant.
5. On customer approval, a Payment is sent to the payment service's
paymentURI. The merchant is notified of the payment, and the customer
receives a SignedReceipt as proof-of-payment.

SatoshiDice
-----------

SatoshiDice (www.satoshidice.com) is an extremely popular game that
uses tiny transactions for some customer/service communications. In
particular, customers can add an extra output to their transactions to
indicate where winnings should be sent. And SatoshiDice creates tiny
transactions to let their customers know that a bet was received, but
lost.

Assuming Bitcoin clients upgrade to support this proposal, a bet on
SatoshiDice would proceed as follows:

1. Customer clicks on a link on SatoshiDice.com and their Bitcoin
client receives a SignedInvoice.
2. Customer authorizes payment, and their Bitcoin client creates a
Payment message and submits it directly to
https://satoshidice.com/something
3. The SatoshiDice web server checks to make sure the transaction is
valid, broadcasts it, and determines whether the customer wins or
loses. It returns a SignedReceipt with either a "You win" or "You
lost" memo.
4. If the customer won, it broadcasts a transaction to pay them using
Payment.refund_to
5. Customer's Bitcoin client displays the win/lose memo, and if they
won the winnings appear in their wallet when received over the p2p
network.

Multiperson Wallet
------------------

This use case starts with a multi-signature Bitcoin address or wallet,
with keys held by two different people (Alice and Bob). Payments from
that address/wallet must be authorized by both Alice and Bob, and both
are running multi-signature-capable Bitcoin clients.

Alice begins the payment process by getting a SignedInvoice from a
merchant that needs to be paid. She authorizes payment and her Bitcoin
client creates a Payment message with a partially-signed transaction,
which is then sent to Bob any way that is convenient (email
attachment, smoke signals...).

Bob's Bitcoin client validates the SignedInvoice and asks Bob to
authorize the transaction. He says OK, his Bitcoin client completes
the transaction by providing his signature, submits the payment to the
merchant, and then sends a message to Alice with the SignedReceipt he
received from the merchant, completing the payment process.


Design Notes
============

Why X.509 Certificates?
-----------------------

This proposal uses X.509 certificates as the identity system for
merchants because most of them will have already purchased a
certificate to secure their website and will be familiar with the
process of proving their identity to a certificate issuing authority.

Implementing a better global PKI is outside the scope of this
proposal. If a better PKI is adopted, the only change to this proposal
would be to replace the Invoice.x509chain with whatever that better
infrastructure uses to identify entities.


Why not JSON?
-------------

Invoice, Payment and Receipt messages could all be JSON-encoded. And
the Javascript Object Signing and Encryption (JOSE) working group at
the IETF has a draft specification for signing JSON data.

But the spec is non-trivial. Signing JSON data is troublesome because
JSON can encode the same data in multiple ways (whitespace is
insignificant, characters in strings can be represented escaped or
un-escaped, etc.), and the standards committee identified at least one
security-related issue that will require special JSON parsers for
handling JSON-Web-Signed (JWS) data (duplicate keys must be rejected
by the parser, which is more strict than the JSON spec requires).

A binary message format has none of those complicating issues. Which
encoding format to pick is largely a matter of taste, but Protocol
Buffers is a simple, robust, multi-programming-language,
well-documented, easy-to-work-with, extensible format.

What about a merchant-pays-fee feature?
---------------------------------------

It is desireable to allow a merchant to pay the cost of any Bitcoin
network transaction processing fees, so if a customer is paying for a
1 BTC item they pay exactly 1 BTC.

One way of accomplishing that is to add a 'maxfee' field to the
Invoice, and have the Bitcoin client construct a transaction that pays
the merchant (amount-maxfee).

Another way of accomplishing that is to change the transaction
selection code used by Bitcoin miners, so that dependent transactions
are considered as a group. Then a merchant with several unconfirmed
zero-fee transaction from customers can create a pay-to-self
transaction with a large enough fee to pay for the set of transactions
to be confirmed.

A third way of accomplishing that is for the Bitcoin client to sign
Payment.transactions[0] using the SIGHASH_ANYONECANPAY flag, and for
the merchant to add an additional, small-BTC-value input to the
transaction before broadcasting it. That additional input would go
directly to miners as a fee. *Note: Gavin is not sure if he loves or
hates this idea.*

Checking for revoked certificates
---------------------------------

The Online Certificate Checking Protocol (OCSP) is supposed to be a
quick and easy way for applications to check for revoked certificates.

In practice, it doesn't work very well. Certificate Authorities have
no financial incentive to support a robust infrastructure that can
handle millions of OCSP validation requests quickly.

Ideally, Bitcoin clients would use OCSP to check certificate statuses
every time they received or re-used an Invoice. But if that results in
long pauses or lots of false-positive rejections (because an OCSP
endpoint is offline or overwhelmed, perhaps) then merchants and
customers might revert to just using "never fails" Bitcoin addresses.



References
==========

Public-Key Infrastructure (X.509) working group :
http://datatracker.ietf.org/wg/pkix/charter/

RFC 2560, X.509 Internet Public Key Infrastructure Online Certificate
Status Protocol - OCSP : http://tools.ietf.org/html/rfc2560

Protocol Buffers : https://developers.google.com/protocol-buffers/

See Also
========

Javascript Object Signing and Encryption working group :
http://datatracker.ietf.org/wg/jose/

sipa's payment protocol proposal: https://gist.github.com/1237788

ThomasV's "Signed Aliases" proposal : http://ecdsa.org/bitcoin_URIs.html


-------------------------------------
Hi Gavin, others?

I am trying to redo the performance test of the libcoin client against the 0.5.2 Satoshi client, that I have learned also have received quite some improvements in speed since 0.4.0 (e.g. from not verifying signatures on early blocks).

However, I cannot find any tag with v0.5.2 in github:
https://github.com/bitcoin/bitcoin/tags

Am I missing something, or wasn't that release tagged ?

What I am looking for in particular is the number "140700", the last block not to be verified - I can see this in:

https://github.com/bitcoin/bitcoin/blob/master/src/checkpoints.cpp

But I would like to be sure that this is also the number used in 0.5.2.

Thanks,

Michael

-------------------------------------
You guys are representing both extremes of the issue.  In response to 
Jeff and Luke-Jr, I don't see how this is /just any other poltical 
issue/.  It strikes at the heart of everything Bitcoin is about.  
Barring Bitcoin-specific legislation, I don't see how any legislation 
could be more relevant to Bitcoin and the community around it.

On the other hand, Bitcoin is still a non-entity, and shouldn't get in 
the business of making statements.  A central voice for Bitcoin gives 
the impression that it is actually centralized, and one that has 
opinions.  Plus I wouldn't be surprised if some, heavily-invested 
Bitcoin users were of the opinion that SOPA/PIPA/whatever could be a 
huge profit for themselves:  once SOPA kicks in and businesses around 
the world start getting cut off for legit or illegitimate purposes, a 
lot of them could potentially switch to Bitcoin to keep their business 
going.  That could be a huge boon for Bitcoin.  You may not agree it's 
worth the tradeoff, but people are selfish and may not actually 
understand or even care about SOPA legislation itself.

I think it's /not inappropriate/ for something to be mentioned on the 
website about Bitcoin's philosophy being threatened by SOPA, but I agree 
Bitcoin should avoid making any bold political stands.  Users could be 
reminded that SOPA affects yet another thing they care about, but it 
might be better to avoid it altogether.  If any response is made, it 
should be a very light one.

-Alan


On 01/16/2012 07:30 PM, Amir Taaki wrote:

-------------------------------------
On Sat, Apr 14, 2012 at 11:13 AM, Mike Hearn <mike@plan99.net> wrote:

ACK on the concept


Agreed.  A TX is just a signed message.  No reason why it -must- use
mainnet's distributed notary service.


IIRC pay-to-IP was removed because it was unreliable -and- detrimental
to privacy?  ISTR Satoshi specifically disliking the privacy elements
of p2ip.

But I also have a "gut feeling" that these sorts of payments and
direct communication should be done via a wholly separate protocol
than the bitcoin P2P protocol.  Doing p2ip as it was done originally,
inside the bitcoin P2P protocol, was a mistake.  Extensible as it is,
I think a better job -- and faster evolution -- can be done with a
separate protocol on a separate port.

Some HTTP derivative would probably make life easier for mobile
payments and firewalled scenarios, and for client->merchant
communications, for instance.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------


Luke-Jr <luke@dashjr.org> wrote:

I'm really not gonna reopen this debate.  You made a poll that was worded in the most biased way I could think of and still lost.  The multiple implementations were written but you and I know of no sites that actually had links to your version.


-------------------------------------
Jeff,

This rocks. Thank you!

Peter

On Wed, Nov 28, 2012 at 3:26 AM, Mike Hearn <mike@plan99.net> wrote:




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
Support for BIP16 has been approximately 70% of hashing power for the
last two days, and is 54% over the last week, so we're going to
announce that the BIP16 switchover time of April 1 is final and
strongly encourage any pools/miners that haven't yet upgraded their
software to do so in the next two weeks or risk hashing on a minority
chain.

I'll be checking to make sure support doesn't slip before April 1.

I've learned a lot, and have started writing up a document that
suggests how we can make the next upgrade process less painful for
everybody; when I've got a reasonable draft I'll start a discussion
about it here.

-- 
--
Gavin Andresen


PS: If you're curious, here is what support over the last 30 days
looks like, beginning with the last 24 hours (144 blocks) and going
backwards for each 24 hour period:

Found 103 matches in 144 blocks (71.5 percent)
Found 99 matches in 144 blocks (68.8 percent)
Found 87 matches in 144 blocks (60.4 percent)
Found 70 matches in 144 blocks (48.6 percent)
Found 73 matches in 144 blocks (50.7 percent)
Found 57 matches in 144 blocks (39.6 percent)
Found 52 matches in 144 blocks (36.1 percent)
Found 40 matches in 144 blocks (27.8 percent)
Found 40 matches in 144 blocks (27.8 percent)
Found 46 matches in 144 blocks (31.9 percent)
Found 41 matches in 144 blocks (28.5 percent)
Found 45 matches in 144 blocks (31.2 percent)
Found 57 matches in 144 blocks (39.6 percent)
Found 69 matches in 144 blocks (47.9 percent)
Found 51 matches in 144 blocks (35.4 percent)
Found 53 matches in 144 blocks (36.8 percent)
Found 65 matches in 144 blocks (45.1 percent)
Found 43 matches in 144 blocks (29.9 percent)
Found 48 matches in 144 blocks (33.3 percent)
Found 51 matches in 144 blocks (35.4 percent)
Found 46 matches in 144 blocks (31.9 percent)
Found 57 matches in 144 blocks (39.6 percent)
Found 61 matches in 144 blocks (42.4 percent)
Found 54 matches in 144 blocks (37.5 percent)
Found 53 matches in 144 blocks (36.8 percent)
Found 44 matches in 144 blocks (30.6 percent)
Found 52 matches in 144 blocks (36.1 percent)
Found 51 matches in 144 blocks (35.4 percent)
Found 53 matches in 144 blocks (36.8 percent)

Command used to get that data:
  for i in {1..30}; do ./search_coinbases.py --n=$(($i * 144))
--start=$(( ($i -1) * 144)); done

search_coinbases is one of my bitcointools:
  https://github.com/gavinandresen/bitcointools

Pretty graph of support over the last 100 blocks here:
  github.com/bitcoin/bitcoin/


-------------------------------------
On Wed, May 2, 2012 at 12:58 PM, grarpamp <grarpamp@gmail.com> wrote:

"Reply-To" Munging Considered Harmful
http://www.unicom.com/pw/reply-to-harmful.html



-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wed, Oct 3, 2012 at 7:49 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

We definitely need that one in.


Agreed


I think we should also pull #1859 "add LOCK() for proxy related
data-structures" Missing synchronization primitives are a sure way to
get reports about random crashes.

The rest can wait.

Wladimir


-------------------------------------
Is it worth having a few more people email Ben to ask him politely to fall
into line with the BIP? No point encouraging broken windows by not speaking
out.

On 16 July 2012 09:16, Andreas Schildbach <andreas@schildbach.de> wrote:

-------------------------------------
On Wed, Mar 21, 2012 at 6:02 PM, Watson Ladd <wbl@uchicago.edu> wrote:

If the final step fails (someone says their address is missing) you
challenge the mixes to disclose half of their correspondences. You can
then prove which (if any) mixes defected.

Why I didn't bother elaborating is ... I think you can even avoid the
fancy protocol where you must take care to only disclose alternating
halves at each mix because the addresses are throwaway: If the it
fails in the final stage everyone publishes _everything_ and the
cheater is instantly and provably identified and can be excluded from
the next attempt which is then performed using totally new addresses
and the disclosed addresses are never used.  Care would need to be
taken to avoid fake-failures (e.g. the exchange says 'it fails'
triggering disclosure then sending anyways— but the participants could
prove this cheating and stop using the exchange), I think there isn't
much risk there if the participants are themselves the mixes.  I need
to think this through a bit more.

[snip]

It's not something I thought about— In general the P2SH tends to be
a superset of other schemes, e.g. you can do a signature to prove you
access to a private key, then you can show someone a script using that
key to show control of a P2SH address.

There are lot of interesting things you can do with bitcoin if you can
construct (potentially interactive) proofs for knowing the preimages of hashes.


-------------------------------------
I was just thinking about the way block difficulty is calculated, and how
people may (in future) decide whether to mine or not.

Is it possible that when the difficulty is low, many will decide to mine,
producing blocks every 3 or 5 minutes, and then in 1 week, bitcoin will
increase the difficulty, and many will decide it is no longer cost
effective, stop mining, and find blocks are being produced every 30 minutes
for the next 6 weeks, before the returning to a previous difficulty where
people decide to mine again, etc, etc.

Seems reasonably possible in my mind, and I'm wondering if the stability so
far has been purely due to people mining without thinking too much about
the immediate cost-effectiveness (or mining by zombie-farms).

Thoughts, anyone?

Ed
-------------------------------------
On Friday, January 27, 2012 5:51:04 PM Amir Taaki wrote:

It's been Final (even according to BIP 1 standards) since late January 2011. 
The only change recently is assigning it a BIP number for formality.


Once P2SH is deployed, it will probably make good sense to revisit the URI 
Scheme for revision, and eventually move BIP 20 to Replaced/Superceded status.


-------------------------------------
On Sat, May 26, 2012 at 03:14:40PM +0200, Pieter Wuille wrote:

I can confirm this seems to work quite well now. I tried running an
IPv6-only node a few days ago, and with the default seeds it couldn't
start up and sync with the network unless I manually created a dual-net
node and manually added it. Now things work just fine out of the box and
last I checked I had 5 peers.

-- 
'peter'[:-1]@petertodd.org
-------------------------------------
On 2012-12-21 17:05:21 +0000, Stephen Pair said:

Your distinction between "identity" and "trust-based identity" is one 
of the most important insights to emerge from this thread.  Thank you 
for pointing this out.





-------------------------------------

True, it's those compromises that people should base their decision on.
To make that easier was the motivation for me to suggest feature
matrices in the first place.

Right now if I read Electrum's description, it doesn't say anything
about the tradeoffs with a lightweight client like the slightly weaker
privacy guarantees. At best I could deduce that from the fact that
unlike Bitcoin-Qt it doesn't explicitly list privacy as an advantage.

So applying the same "MyBitcoin test" to the current Bitcoin Clients
page and if you want to be fair, we'd have to assume that if it was
indeed included it would also just be a short pitch listing only pros
and no cons. So it would say something like: "MyBitcoin starts instantly
and is really easy to use and great for beginners." etc.

Obviously if you compare a bad matrix to good short descriptions and
vice versa you'll get the conclusion you're trying to get.

I think Alan had the best idea - let's have the Clients page as it is
and have it link to the wiki for those who want a more detailed
comparison. On the wiki page we can then have explanations of the basic
client types, separate matrices for features and for security/privacy
and whatever else might be useful to know when choosing a client. Then
users who don't really care aren't bothered by "too much information"
and users who do can easily click through and find out about the
different tradeoffs.

On 7/10/2012 5:05 AM, Gregory Maxwell wrote:




-------------------------------------
On Thu, May 24, 2012 at 12:33 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

In the last 2016 blocks, as I write this, there are only 35 1 txn blocks.

This is about 1.73%, which wouldn't be surprising just from timing
alone.  Moreover, a fair amount (I didn't measure the percentage)
appear to be mined by Eligius— Luke does some clever pre-computation
of the hash tree for faster distribution right after new blocks.

Resources expended on fancy (and potentially risky) techno-economic
hacks to discourage empty blocks would probably be better spent
writing very fast transaction tree generating code.

Can we kill this thread now?


-------------------------------------
Hi Luke,

Your CMake cannot find boost - use ccmake or cmake-gui to help it with the location. Btw what platform are you using ?

/M

On 01/02/2012, at 16:26, Luke-Jr wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
MacOS X 10.8 makes application signing borderline mandatory, in that
you cannot run unsigned apps unless you tweak your settings via the
control panel. You must sign with a certificate issued by Apple via
their "identified developer" program.

Windows allows but does not require signing. However, anti-virus
systems tend to use signers with good reputation as a whitelisting
signal. Signing Bitcoin releases makes sense because it may lead to,
at minimum, higher performance if AV engines ignore file reads/writes
by Bitcoin. And it can also shield us from false positives. You only
need to see the mess that the mining tools world has become to
understand why this is important.

As I don't take part in the release process, I can't help out with
this directly, but I believe it's important and would be willing to
throw some money in towards buying the signing certs for both
platforms. I guess Gavin would be the final signer.


-------------------------------------

I guess that moves the discussion from developers to lawyers ;) Even though you send a signed receipt, if you can proof you didn't get the money, you will never be expected to deliver the goods. (and you can even write that in the the receipt ...)

So the SignedReceipt is legally not worth the bits it is composed of, hence I don't see the point in supporting it.

If you are selling atoms you can usually wait for N confirmations (even though you start shipping I guess you can recall a parcel within 144 blocks). If you are selling bits (like access to a site), you can revoke that access once you discover the transaction did not go through. So I can't find a use case where a Signed Receipt in the proposed form is advantageous.

/M

-------------------------------------

The point is to expand the circle of contributors. I'm pretty sure there
are more people who can edit a wiki than people who know HTML and how to
create a git pull request. :)



My apologies, I vaguely remembered Luke's original proposal and that it
got rejected, but you're correct, the reason wasn't a debate on the
columns but that people didn't like the feature matrix at all.


I didn't really mean to argue on the details of what the page should
look like, but just to briefly respond to Mike's point:


A well-designed feature matrix can quite useful and user-friendly.

http://www.apple.com/ipod/compare-ipod-models/

Prose is better to get a sense of the philosophy and basic idea of a
client. If it was between having only a feature matrix or only prose,
I'd probably go for the prose as well.

What a feature matrix is good at though is it allows you to very quickly
find the specific feature or general criteria you're looking for without
reading through all of the text. So it might be a useful addition maybe
not on Bitcoin.org, but certainly on the wiki.


On 7/10/2012 12:37 AM, Mike Hearn wrote:




-------------------------------------
+1. I love this proposal.

It's two less bytes than OP_EVAL even.
It allows static analysis.
It doesn't require any change to the script interpreter. (You can do a 
static replacement step between parsing and execution.)
It allows all urgent use cases.
It doesn't consume a NOP. If we ever want recursion or something else, 
we can still add OP_EVAL,... then.

@roconnor:

I disagree. If people actually do mean HASH160 <hash> EQUAL, let *them* 
add a NOP. Or better to avoid NOP let them use HASH160 <hash> 
EQUALVERIFY 1. Point is, if you don't want code replacement you can 
easily break the pattern. But code replacement will be overwhelmingly 
more common, so it should be as small as possible. Every byte matters.


On 1/2/2012 4:59 PM, Gavin Andresen wrote:



-------------------------------------
Thanks. Using --disable-thread_api --disable-replication got it to compile, but now when actually running bitcoind it throws DbRunRecoveryException over the DB_RUNRECOVERY flag.

It seems people aren't actually using MingW to compile bitcoind on Windows? The lack of pthreads seems crippling and there's lots of missing functions like strncasecmp, _strlwr, _fileno and swprintf.


________________________________
 From: Wladimir <laanwj@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com> 
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net> 
Sent: Saturday, February 25, 2012 7:18 AM
Subject: Re: [Bitcoin-development] Building BDB on MingW
 




On Fri, Feb 24, 2012 at 11:15 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

I followed the instructions from build-msw.txt and am getting the same issue from here:

https://forums.oracle.com/forums/thread.jspa?messageID=4018239

Wladimir
-------------------------------------
On Fri, Jul 27, 2012 at 12:20 AM, grarpamp <grarpamp@gmail.com> wrote:

I now have an 1.8 ghz p3 celeron (128k cache) which should be
substantially slower than your machine, running vintage 2.6.20 linux.
Unfortunately I forgot to turn on timestamp logging so I don't know
how long it took to sync the chain, but it was less than two days as
that was the span between when I checked on it. It's staying current
just fine.

Again, I encourage you to investigate your software configuration.


-------------------------------------
Hi, I've made some corrections.

Se ha descubierto un fallo potencial de seguridad en Bitcoin-Qt
 para Windows. Si tienes Bitcoin-Qt para Windows en alguna versin
 entre 0.5 y 0.6, deberas salir del programa, y actualizar a la
 versin 0.5.3.1 o 0.6rc4 AHORA.

 La aplicacin de lnea de comandos (bitcoind), las versiones Mac y
 Linux de Bitcoin-Qt, y las versiones anteriores a 0.5 no estn afectadas.

 Debido a la naturaleza de este fallo, creemos que sera muy difcil
 para un atacante hacer algo ms que bloquear el proceso de
 Bitcoin-Qt. Sin embargo, debido a que existe la posibilidad de que un cierre
 inesperado permita la ejecucin de cdigo remoto, consideramos esto una
 incidencia crtica.

 Si tienes alguna pregunta, visita el canal IRC #bitcoin-dev en Freenode.

Puedes descargar el software actualizado desde SourceForge:
 0.6rc
 [https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/]
 0.5.3.1 para Windows y 0.5.3 para Linux
 [https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.3/]

Hope this helps


On 3/19/12, Jean-Pierre Rupp <jpierre@xeno-genesis.com> wrote:


-- 
Jorge Timn


-------------------------------------
This meeting is to discuss the new OP_EVAL changes coming to bitcoin.

A good summary of the past discussion so far by justmoon can be found:
http://privatepaste.com/4088b049af

Hopefully this can become a weekly thing. For now this is to discuss and inform about the coming changes to bitcoin.

----------

Where: Freenode IRC #bitcoin-dev
When: 21:00 UTC (16:00 New York time) until 22:00*
What: OP_EVAL

Bitcoin is starting decentralising as any healthy free thinking community
should. Projects are thiving and the economy is growing. New ideas are
being realised and will edge out old models disruptively.

My hope is that we don't all become fractured. By having weekly regular
meetings, projects can harmonise in lock step. Concepts and algorithms can
be proposed and debated. You'd be surprised what having a scheduled regular
platform can achieve. A soap-box on an island in central waters.

For me, I don't have time to wade through IRC discussions, forum posts and
mailing lists. At least if the important things are discussed in one place
it makes bitcoin development and the system more accessible.

Before meeting:

- A wiki page is created for in advance of a weekly meeting.
- Announced on forums/mailing lists.
- Throughout the week talking points are added to the meeting page.

After:

- Log of discussion is posted online.
- I will type an accessible summary for the community at large on
http://bitcoinmedia.com/
- Next weekly meeting is scheduled.

Amir Taaki

*We can go over this hour, but this is to stop meetings dwindling off topic
into banal banter and stay focused.


-------------------------------------
On Sat, May 05, 2012 at 09:31:39AM +0100, Rebroad (sourceforge) wrote:

I think so, see my comment there.

-- 
Pieter


-------------------------------------
On Thu, Jun 14, 2012 at 10:37 AM, Peter Vessenes <peter@coinlab.com> wrote:

I like that idea.

A third argument that is an array of private keys (in the same format
as the dumpprivkey RPC call) should be easy to support, assuming the
semantics are:

+ If third argument given, do not require that the wallet be unlocked,
and only sign using the private key(s) given (ignore the bitcoind
wallet entirely).
+ Private keys would stay in bitcoind memory only for the duration of
the RPC call.

-- 
--
Gavin Andresen


-------------------------------------

Great, in that case Stefan is right and I'll delete that code when I
next work on the patch.


-------------------------------------
On Thu, Jun 14, 2012 at 7:52 AM, Mike Hearn <mike@plan99.net> wrote:

This is a fair point that sipa raised.

Consensus concluded that 'filterload' includes all necessary metadata
required to initialize a bloom filter.  That implies 'filterinit'
would only be needed for 'filteradd'.  If we don't think 'filteradd'
has a compelling use case, filterinit + filteradd can be dropped.


Yes, the format is something that must be hashed out (no pun
intended).  Need input from potential users about what information
they might need.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I support BIP 30.

I gave it a thought. The other ways of resolving this issue, all have various niggles. This is the best way.


________________________________
 From: Pieter Wuille <pieter.wuille@gmail.com>
To: Zooko Wilcox-O'Hearn <zooko@zooko.com> 
Cc: Bitcoin Dev <bitcoin-development@lists.sourceforge.net> 
Sent: Wednesday, February 29, 2012 4:47 PM
Subject: Re: [Bitcoin-development] Duplicate transactions vulnerability
 
On Tue, Feb 28, 2012 at 06:41:31PM -0700, Zooko Wilcox-O'Hearn wrote:

It's not exactly a secret anymore, as the patch also references it.
Russell O'Connor described the attack on his blog:
http://r6.ca/blog/20120206T005236Z.html

-- 
Pieter

------------------------------------------------------------------------------
Virtualization & Cloud Management Using Capacity Planning
Cloud computing makes use of virtualization - but cloud computing 
also focuses on allowing computing to be delivered as a service.
http://www.accelacomm.com/jaw/sfnl/114/51521223/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

- -----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 26/09/2012 13:49, Wladimir wrote:

Hi Wladimir,


excellent, that makes things much easier.


I think you might be misunderstanding a little. I am not trying to
replace the current system, I need to make sure that what I do will be
compatible with it (seamlessly so for the developer). I do not want this
to generate extra work for the development team.

However testing is a lot more than just bug reporting, dont get me
wrong bug reports are important, but so is running a testcase and that
testcase passing, especially if that testcase is linked to the proof
of a requirement. I am trying to develop a qa environment that is
conducive to testing and will allow the testers to shine in all their
glory :) and we need different tools and methodologies.

Git is too developer centric to be useful for organising testing. -
however there is a large amount of software that is compatible with
git, so the core development team only ever need to work with git.

The linking between a bug, the requirement, the fix, the retest, and
updating of regression testplan is vital. So is the ability to
organise testing campaigns and assigning tests, work units and test
relevant docs/scripts/ideas, etc.

I hope this clears things up a bit?

Cheers,

steve


- -----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQYwESAAoJEFvEB9dQFvtQ/GUH/jv2c5L0OcL/kHkX/z0Yqbl/
2IntPLdjXNKLuz0A7BMz7XfUyVmWlZrw44qxmi+Vyk5PKNBjYIidm763xHnTeJLN
ULQBckYexMvan9hAyYZUOt85IpesdNgqTIsqh8f49y4roHOy8GT4M/2fhzXpnsGg
G9d2m8jWGpj/kxl9qE7/WjVQC4APwBi/NiJsCrcHswgweN+zENc/Pot9YBLxAZu/
ACBUX/xFymRdaZN8P2LWBXuKx6E2WEcBdPCCWArX07wPiBlrashx9Gz6tiNzIiNq
x2c4ltLzRa45AmiDtQhwqyTprz/DbyeAYO1sIsfpUxDeu9e3xTb/Zd96jfKIWI0=
=iHI1
- -----END PGP SIGNATURE-----
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQYwGsAAoJEFvEB9dQFvtQxOsIAKgBBOKHNFtoV2cN+GVqzlip
yy0qiMvMTZKrraOhEw8QNNuOlB3LRchi+RDR/PvQkVfuwi/jHB2gUBzlapLoECBv
EH8pgT/MO281pXzARgRSVkRYqkb3ljhQz3mEQg9RhR9h5t9g2mL3Tvppt7249Bg8
oGXPj6xmMcrbClF5qDbwQUUDGJfOo4eti0jSVD3qp2NE7QpPVQwuN5buchpoKt3P
9aJnjeZdLmuAk2RPoDaLXUFc9unT8AcnW96juD0zoVA9wKvAa6/8IZQf0mzV4iZP
yiWGNOQtBZ+jyu2ixiEnvHqqG2ZmjtUVqWtjHkxYgrCyuuK2jOcTMNEWfn7SfKc=
=yP7N
-----END PGP SIGNATURE-----


-------------------------------------
On Wednesday, May 16, 2012 6:18:27 PM Jeff Garzik wrote:

That assumes you already have a connection to the peer in question.
As I understand it, the service bits are propagated as part of the address, 
so you can see at a glance which nodes you want to connect to for some 
special service. Passing a huge list along might be unwieldy (though it 
makes sense for protocol changes that don't add new services).


-------------------------------------
Devs,

I have decided to upgrade Armory's blockchain utilities, partly out of 
necessity due to a poor code decision I made before I even decided I was 
making a client.  In an effort to avoid such mistakes again, I want to 
do it "right" this time around, and realize that this is a good 
discussion for all the devs that will have to deal with this eventually...

The part I'm having difficulty with, is the idea that in a few years 
from now, it just may not be feasible to hold transactions 
file-/pointers/ in RAM, because even that would overwhelm standard RAM 
sizes.  Without any degree of blockchain compression, I see that the 
most general, scalable solution is probably a complicated one.

On the other hand, where this fails may be where we have already 
predicted that the network will have to split into "super-nodes" and 
"lite nodes."  In which case, this discussion is still a good one, but 
just directed more towards the super-nodes.  But, there may still be a 
point at which super-nodes don't have enough RAM to hold this data...

(1)  As for how small you can get the data:  my original idea was that 
the entire blockchain is stored on disk as blkXXXX.dat files.  I store 
all transactions as 10-byte "file-references."  10 bytes would be

     -- X in blkX.dat (2 bytes)
     -- Tx start byte (4 bytes)
     -- Tx size bytes (4 bytes)

The file-refs would be stored in a multimap indexed by the first 6 bytes 
of the tx-hash.  In this way, when I search the multimap, I potentially 
get a list of file-refs, and I might have to retrieve a couple of tx 
from disk before finding the right one, but it would be a good trade-off 
compared to storing all 32 bytes (that's assuming that multimap nodes 
don't have too much overhead).

But even with this, if there are 1,000,000,000 transactions in the 
blockchain, each node is probably 48 bytes  (16 bytes + map/container 
overhead), then you're talking about 48 GB to track all the data in 
RAM.  mmap() may help here, but I'm not sure it's the right solution

(2) What other ways are there, besides some kind of blockchain 
compression, to maintain a multi-terabyte blockchain, assuming that 
storing references to each tx would overwhelm available RAM?   Maybe 
that assumption isn't necessary, but I think it prepares for the worst.

Or maybe I'm too narrow in my focus.  How do other people envision this 
will be handled in the future.  I've heard so many vague notions of 
"well we could do /this/ or /that/, or it wouldn't be hard to do /that/" 
but I haven't heard any serious proposals for it.  And while I believe 
that blockchain compression will become ubiquitous in the future, not 
everyone believes that, and there will undoubtedly be users/devs that 
/want/ to maintain everything under all circumstances.

-Alan
-------------------------------------
I'm pleased to announce the release of version 0.6 of bitcoinj, the leading
Java implementation of Bitcoin. You can download the source from Google
Code, or use the release-0.6 branch from git. Our Nexus repository will be
updated soon.

This release focuses on improved compliance with the protocol, improved and
more scalable network handling, a more flexible send API, other misc API
improvements and of course, a large pile of bug fixes. You should upgrade
your software to use bitcoinj 0.6 as soon as possible, if only to benefit
from the fixes - the API changes are minimal so it should be easy.

In more detail:

   - Thanks to Jim Burton, the wallet now stores the depth and work done
   for all transactions, and coinbase transactions are now processed
   correctly. The ability to handle pubkey-only outputs was added, so these
   are now spendable. Migration from 0.5 wallets that don't store this is
   supported, but only for depth, by using
   WalletProtobufSerializer.setChainHeight().
   - Made some more APIs documented and public.
   - Improved block chain download handling.
   - Added compatibility with the broken URIs generated by blockchain.info,
   meaning that the iPhone app and Android apps can now read each others
   QRcodes.
   - Wallets can now auto-save themselves, taking the hassle of managing
   wallet persistence away from your app. See the javadocs for
   Wallet.autoSaveToFile() for information on this.
   - The network layer was rewritten on top of Netty to be more robust,
   more scalable and to remove flakyness in the unit tests. Thanks to Miron
   Cuperman for this work.
   - Thanks to Matt Corallo the ping/pong protocol is now supported. Also
   various protocol conformance issues and other misc bugs were resolved.
   - WalletTool now has a RAW_DUMP option that prints the raw protocol
   buffer form as text.
   - You can now explicitly set fees on a created transaction using the fee
   member of SendRequest. Please note that the correct fees for a
   transaction are still not auto-calculated or minimized. This will come in a
   future release.
   - Many bug fixes.

API changes:

   - TransactionConfidence.OVERRIDDEN_BY_DOUBLE_SPEND is now called DEAD
   - PeerGroup.broadcastTransaction now returns a Guava ListenableFuture (which
   is a subclass of Future, so it's compatible). The future completes when the
   transaction has been heard back from the network, instead of just being
   written out.
   - Wallet.sendCoins() now returns a SendResult that contains both the
   transaction, and the future returned by PeerGroup.broadcastTransaction(),
   so it will no longer block. As a result sendCoinsAsync() has been
   removed.
   - Various send methods on Wallet now take a SendRequest object that lets
   you customize the created transactions. The methods that let you explicitly
   set the change address are removed, you should set the changeAddress member
   of the SendRequest instead.
-------------------------------------
On Mon, Nov 26, 2012 at 9:16 PM, Walter Stanish <walter@stani.sh> wrote:

I see that draft-stanish-x-iso4217-a3 is not standards track, is there
a reason for this?

It also doesn't appear to address ~any of the the targeted items here.
Is there another draft I should be looking for which has more overlap
with the discussion here?


-------------------------------------
It can speed up the initial chain download. A newly created wallet will
have only new key-pairs, hence no incoming transactions (unless we have a
key collision, which is unlikely). So there is no need for a bootstrapping
node to download the chain with transactions. The chain itself can be
verified without the transactions. Later full blocks would be required to
detect usable inputs for future outgoing transactions. As long as you
verify the very last blocks in the chain you can be sure that all
preceeding blocks were also valid.

HTH,
Chris

On Mon, Jan 2, 2012 at 6:04 AM, Elden Tyrell <tyrell.elden@gmail.com> wrote:

-------------------------------------
On 02.08.2012 18:43, Jeff Garzik wrote:

Looks like much goodness in this version. Thanks for all this work.

Any chance that options to limit the size of blocks and prioritize paid
vs free txes could make it in?

By the way, by far the most common support request I have at my pool is
users withdrawing coins and not seeing it in their wallet because it's
not up-to-date with the block chain. Might be worth adding something in
the bitcoin-qt GUI to make it more obvious that users can't see new
transactions and why.


I just now updated the Norwegian translation on Transifex, if you'd like
to do another pull before the release. For some reason there were many
strings I had already translated that now had no translation and had to
be done again (even ones that had the same English text). Many languages
are now only about 50% translated.

Also there were new duplicated strings:

"Verify a message to ensure it was signed with a specified Bitcoin address"
"Sign a message to prove you own a Bitcoin address"
"Clear &All"

These two seem odd:
Use UPnP to map the listening port (default: 0)
Use UPnP to map the listening port (default: 1 when listening)

Regards,
Geir H. Hansen, bitminter.com


-------------------------------------
On 12/03/2012 10:02 AM, Gregory Maxwell wrote:


FYI, Armory uses exactly this logic to try to clean up dust outputs in
the user's transactions.  However, there's enough conditions on it, that
I don't know how often it triggers.  Recommendations are welcome for how
to improve it.

Right now, if the transaction has less than 5 inputs, there exists dust
UTXOs from addresses already included in the transaction, and those
UTXOs are sufficiently small in priority, then the Armory will add them
to the input side and increase the change accordingly.  Looking it just
made me realize I lost the last condition of making sure the tx already
has a change output -- don't want to turn a free tx into a fee-needed tx
just to do this.  (reorganized the code
<https://github.com/etotheipi/BitcoinArmory/blob/master/armoryengine.py#L5279>
recently, and must have fell through the cracks).

Perhaps it could be improved by cleaning up dust from *any* address by
default (not just ones already included in the tx), with the option for
the user to disable that behavior.  After all, anonymity was never a
core feature of the network -- I think it makes sense that the logic
would reduce anonymity by default in exchange for a cleaner network,
with a clear option to "opt-out" of that logic if user cares.  I think
most users don't actually care...

-Alan
-------------------------------------
On Thu, Sep 13, 2012 at 10:05 AM, Matthew Mitchell
<matthewmitchell@godofgod.co.uk> wrote:


Sorry, I'm still not seeing what the value is.  How is the tree level
useful to anyone?  If you did want to get only parts of the
transaction list, why not just ranges from the lowest level?


-------------------------------------
On Mon, Nov 26, 2012 at 4:26 PM, Mike Hearn <mike@plan99.net> wrote:

The only part that has an x509 cert associated is in the invoice message.

message Invoice {
//    repeated bytes x509chain = 1;
    optional string domainName =1;
    repeated Output outputs = 2;
    required uint64 time = 3;
    optional uint64 expires = 4;
    optional bool single_use = 5 [default = true];
    optional string memo = 6;
    optional string receiptURI = 7;
    optional bytes merchant_data = 8;
}

Removing that and adding a opaque string called domain name, or
identityName would be sufficient to move the conversation forward
without the x.509 baggage.

-rick


-------------------------------------
On Mon, Aug 13, 2012 at 5:57 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:



Fully agree with the changes, but I think there should be a small BIP, for
consistency, and to make it documented for other client developers.

Wladimir
-------------------------------------
On Mon, Aug 13, 2012 at 10:24 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

I'm not opposed to that logic.  But for cases where an introduction mechanism
will be needed... it would be awfully good to have one, and I do think that
there is harm in making people think that simple services negotiation will
actually work for their needs for cases where a separate p2p network is
needed.


-------------------------------------
I'm concerned about how the particular security model of electrum is
being described; or rather— not being described.  The electrum website
appears to have no security discussion beyond platitudes like "Secure:
Your private keys are not shared with the server. You do not have to
trust the server with your money.", "No scripts: Electrum does not
download any script at runtime. A compromised server cannot compromise
your client."

Claims like "You do not have to trust the server with your money" are
factually incorrect.

What I would expect is a proper discussion, like "Understanding the
bitcoinj security model":
http://code.google.com/p/bitcoinj/wiki/SecurityModel  (which I don't
agree with completely— as it makes some claims which are known to be
false— wrt detecting double spends, but it does give a reasonable
overview),  and avoidance of broad claims which will result in
misunderstandings that result in users engaging in riskier behaviors
which they could avoid if they better understood the security of the
software they're running.


-------------------------------------

I think the real thing we need full nodes for is "sockets" where by
socket I mean "resources needed to serve another node".

Last year we actually ran out of sockets and it took forever for new
nodes to connect because so many existing nodes were full. We don't
want to be in that situation again. So we need full nodes, nobody
disputes that.

The question is, if you have a node on your average desktop machine
that gets switched off at night, has a stupid virus scanner that
insists on checking every database write, has users who go from a bit
of light word processing to watching HD video and expect no stutters
or slowdowns - how valuable is such a node, really? Also has to be
weighed against the risk of eventual user frustration when they
discover Bitcoin is slowing their computer down and go around telling
their friends how much it sucks.

Ultraprune+LevelDB+other optimizations are great. They aren't game
changers for two reasons:

1) Eventually network traffic should increase to use up the additional
performance unlocked by optimizations

2) Users demand instant on not just at first start, but any time they
open their wallet. I don't think it ever makes sense for a regular end
user to have their wallet integrated with a full node because it means
if you get an email saying "oh hey I sent you the money" and you start
your wallet so you can see it/spend it, you still have to wait a while
until it catches up from whenever it was last quit. I've done this a
bunch of times and it really sucks to wait.

The only time it makes sense to have a wallet integrated with a full
node is if that node never shuts down, ie, it's a merchant node.

If a casual user has to be using an SPV wallet all the time no matter
what, then it's not a big leap to simply have both an SPV client and a
full node running in parallel for users who want to support the
network. And how do we recruit such users? Well I've got nothing
against light wallets noticing that the system seems to have high
uptime, external connectivity etc and putting a notice on the screen
asking users to take part. For Windows users you could have a
one-click install that sets up a background service (I think .NET
OneClick makes this possible), so getting a full node is totally easy
and transparent.

Going back to the Tor analogy, whilst I agree with Gregorys arguments
that they aren't quite the same, the Tor guys have wanted to
automatically opt users in to being relays for a while. But the
technical complexity of doing it well is really high. It's still on
their wishlist even though Tor is quite old. A good first base to
reach is simply having accurate recommendations. If users start
complaining that they were asked to run a full node but when they did,
performance suffered unacceptably, then we know we need better
heuristics before automatically opting users in.


-------------------------------------
On Wednesday, May 02, 2012 3:34:35 PM Gary Rowe wrote:

This is far less relevant than license...


Or bitcoind?


Dependent on centralized server, not any particular client


There are multiple Android clients. There is (or was) an OS selection to the 
left of the client choices...

On Wednesday, May 02, 2012 3:43:23 PM Alan Reiner wrote:

Pretty sure it means "not running continuously".


Would be awesome if it took after Spesmilo and managed bitcoind itself in the 
background...



-------------------------------------
I'd also like to be able to get detailed information of message format
errors for debugging other nodes that connect to bitcoind. For
instance, if a transaction is rejected because the signature is
invalid, I want to know this. If it's because the amount is out of
range or because the output couldn't be connected, I want to know
this, too. I especially want to know if it was because the transaction
is claiming an output that has already been claimed by another
transaction.

For now, I've had to resort to sticking tracers and stubs into
bitcoind. It would be really nice to not only be able to write an
error log but to also let the connecting node know what went wrong.
Obviously these types of messages should *not* be part of the bitcoin
protocol itself since it invites all kinds of attacks. But it would be
wonderful to have a side channel for this type of data, and it could
also be done using callbacks.

The callback mechanism could be configurable in a similar fashion to
the RPC in the bitcoin.conf file.

-Eric Lombrozo


-------------------------------------
On Tue, Jan 31, 2012 at 10:01:00AM +0000, Gary Rowe wrote:

For merchant purposes, I believe URI's containing a static pubkeyhash-address
are only a temporary solution until more elaborate solutions that deal with
all concerns appear (tagging transactions, feedback to the merchant, making
the receiver responsible for inclusion, certificates that a payment was
accepted, authentication, ...). I believe static addresses are too limited
for this purpose, and we shouldn't be trying to extend them with too many
features.

There have been discussions about more dynamic approaches (such as HTTP
communication to negotiate an address) here, and I've written my own
proposal as well (https://gist.github.com/1237788). The details are not
really relevant at this time, but these dynamic approaches seem a much
better way of dealing with what you're trying to add to the bitcoin URI
system now.

My 2 cents: keep bitcoin URI's simple for now.

-- 
Pieter




-------------------------------------
On Thursday, February 02, 2012 5:43:07 PM Michael Grnager wrote:

I hadn't even thought of this. Sounds like a pain :/

The problem I had was related to *using* static libraries; ie, boost.
I have libboost*.so, but libboost*.a


-------------------------------------
On Tue, Jun 19, 2012 at 10:33 AM, Alan Reiner <etotheipi@gmail.com> wrote:


Then use a 2-3-4 tree (aka self-balancing B-tree of order 4), which is a
generalization of RB-trees that doesn't allow for implementation choices in
balancing (assuming ordered insertion and deletion).

As gmaxwell points out, this is an trivially fixable 'problem'. Choose a
standard, mandate it, and write test cases.

If we were to use a raw trie structure, then we'd have all the above

No, a trie of any sort is dependent upon distribution of input data for
balancing. As Peter Todd points out, a malicious actor could construct
transaction or address hashes in such a way as to grow some segment of the
trie in an unbalanced fashion. It's not much of an attack, but in principle
exploitable under particular timing-sensitive circumstances.

Self-balancing search trees (KVL, RB, 2-3-4, whatever) don't suffer from
this problem.

Mark
-------------------------------------
Hello all,

pull #649 now also defines an import/export format for private keys
whose public key is compressed.

Rationale: even though a compressed and uncompressed public key share
the same actual 32-byte secret, the import/export format needs a
marker that states whether the corresponding compressed or
uncompressed public key should be used (since they have different
addresses).

Format:
* uncompressed: 0x80 + [32-byte secret] + [4 bytes of Hash() of
previous 33 bytes], base58 encoded
* compressed: 0x80 + [32-byte secret] + 0x01 + [4 bytes of Hash()
previous 34 bytes], base58 encoded

Any comments or suggestions regarding this format? Below I've included
3 cases to test implementations with.

Test cases:

case 1:
  * secret (hex):
1111111111111111111111111111111111111111111111111111111111111111
  * uncompressed:
    * secret (base58): 5HwoXVkHoRM8sL2KmNRS217n1g8mPPBomrY7yehCuXC1115WWsh
    * pubkey (hex):
044f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa385b6b1b8ead809ca67454d9683fcf2ba03456d6fe2c4abe2b07f0fbdbb2f1c1
    * address (base58): 1MsHWS1BnwMc3tLE8G35UXsS58fKipzB7a
  * compressed:
    * secret (base58): KwntMbt59tTsj8xqpqYqRRWufyjGunvhSyeMo3NTYpFYzZbXJ5Hp
    * pubkey (hex):
034f355bdcb7cc0af728ef3cceb9615d90684bb5b2ca5f859ab0f0b704075871aa
    * address (base58): 1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9

case 2:
  * secret (hex):
dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd
  * uncompressed:
    * secret (base58): 5KVzsHJiUxgvBBgtVS7qBTbbYZpwWM4WQNCCyNSiuFCJzYMxg8H
    * pubkey (hex):
04ed83704c95d829046f1ac27806211132102c34e9ac7ffa1b71110658e5b9d1bdedc416f5cefc1db0625cd0c75de8192d2b592d7e3b00bcfb4a0e860d880fd1fc
    * address (base58): 1JyMKvPHkrCQd8jQrqTR1rBsAd1VpRhTiE
  * compressed:
    * secret (base58): L4ezQvyC6QoBhxB4GVs9fAPhUKtbaXYUn8YTqoeXwbevQq4U92vN
    * pubkey (hex):
02ed83704c95d829046f1ac27806211132102c34e9ac7ffa1b71110658e5b9d1bd
    * address (base58): 1NKRhS7iYUGTaAfaR5z8BueAJesqaTyc4a

case 3:
  * secret (hex):
47f7616ea6f9b923076625b4488115de1ef1187f760e65f89eb6f4f7ff04b012
  * uncompressed:
    * secret (base58): 5JMys7YfK72cRVTrbwkq5paxU7vgkMypB55KyXEtN5uSnjV7K8Y
    * pubkey (hex):
042596957532fc37e40486b910802ff45eeaa924548c0e1c080ef804e523ec3ed3ed0a9004acf927666eee18b7f5e8ad72ff100a3bb710a577256fd7ec81eb1cb3
    * address (base58): 1PM35qz2uwCDzcUJtiqDSudAaaLrWRw41L
  * compressed:
    * secret (base58): KydbzBtk6uc7M6dXwEgTEH2sphZxSPbmDSz6kUUHi4eUpSQuhEbq
    * pubkey (hex):
032596957532fc37e40486b910802ff45eeaa924548c0e1c080ef804e523ec3ed3
    * address (base58): 19ck9VKC6KjGxR9LJg4DNMRc45qFrJguvV

-- 
Pieter


-------------------------------------
Sounds very nice. Congratulations with the release!

Any plans for porting over bitcoin-qt?

Wladimir
Op 1 feb. 2012 15:19 schreef "Michael Grønager" <gronager@ceptacle.com> het
volgende:

-------------------------------------
separate filterinit / filterload - so you can do a new filterload later 
on if your list changes, without the privacy implications of filteradd.

Simon


On Thu 14 Jun 2012 04:52:29 AM PDT, Mike Hearn wrote:


-------------------------------------
Hi!

Is this a valid script?

["1 0 1", "WITHIN NOT"]

The first value (1) is tested to make sure it is between the lower (0) and upper (1) value. This evaluates to true, placing on the stack a single byte of [01]. NOT then inverses this to a 0 byte false value of [].

What am I missing here?

Thanks


-------------------------------------
Hey everyone,

I was working on some custom protocol extensions for Bitcoin that I
wanted to experiment with and I noticed that in order to enable nodes to
announce these services the only mechanism the protocol currently
provides is to use one of the 64 bits of the services field. This is
obviously a resource that will run out quickly if we all just help
ourselves, so I set out to come up with a standardized way to announce
custom protocol extensions, without using up NODE_* flags.

Please kindly review my solution:

https://en.bitcoin.it/wiki/User:Justmoon/BIP_Draft:_Custom_Services

Thanks to Amir Taaki, Mike Hearn and Pieter Wuille who provided
invaluable feedback while writing the draft.

Note: Earlier drafts of this BIP contained a description of a mechanism
for peer exchange for these custom services. However, since that part of
the BIP was (1) just a recommendation and (2) rather complex, Amir and I
agreed to split it off into a separate BIP [1] that will be refined some
more and submitted later.

Cheers,

Stefan

[1]
https://en.bitcoin.it/wiki/User:Justmoon/BIP_Draft:_Custom_Service_Discovery


-------------------------------------
On Sunday, January 29, 2012 9:31:02 PM Pieter Wuille wrote:

As of yesterday, this is also part of my `next' and `next-test' branches.

Summary of latest next/next-test:

*** ACCEPTED (`next' branch)
	719 coinbaser					3dc0e2a
	755 explicit_p2sh				6728ecb
	787 sipa/addrman				70b8988
	786 sipa/checkkeys			c0e8c4d

*** NEEDS ACCEPT
	570 force_send (557)			9437c14
	568 rpc_keepalive				178f2c3	(threaded_rpc included)

*** NEEDS REVIEW
	457 origin-pull/457/head*	433b275	IPv6 JSON-RPC
	565 optimize_FastGetWork	4c1214f
	691 origin-pull/691/head	6192d6d	Temporarily disable "minimize to tray"

*** NEEDS SUPPORT
	780 checkhashverify			60649bd
	715 bugfix_client_name		fd6fc41
	559 accept_nonstdtxn		   7945399
	552 base58_liberal_parsing	e005327
	553 bugfix_qt_uri_amount_…	45d7c36
	562 optimize_ToHex			a781103

Luke


-------------------------------------
On Thu, Feb 2, 2012 at 12:12 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

It ended up taking almost exactly twice as long, FWIW.


-------------------------------------
If you are playing around with the current rawtx API, be careful using
SIGHASH_SINGLE:

When parsing a transaction input, which uses a SIGHASH_SINGLE signature,
and the given input's index is >= the total number of outputs in the
current transaction, bitcoind doesn't sign anything useful, it signs the
constant 1.

Thus, if anyone were to create such an invalid transaction, any future
outputs to the public key which created the signature would be
immediately steal-able by anyone.

The conclusion on how to fix the issue was to fix the rawtx API to block
such transactions instead of creating a hardfork-risk or further
complicating transaction verification.

Code (in script.cpp:SignatureHash, under SIGHASH_SINGLE):
        if (nOut >= txTmp.vout.size())
        {
            printf("ERROR: SignatureHash() : nOut=%d out of range\n", nOut);
            return 1;
        }

Matt



-------------------------------------
On Fri, Jun 15, 2012 at 4:59 PM, Peter Vessenes <peter@coinlab.com> wrote:


Splitting the UI into a seperate *process* is a long-term goal. The UI code
is structured so that all communication with the core happens through a
"bottleneck" (consisting of the model classes), so preparation has been
under way.

However, the current RPC calls don't suffice to implement a full-featured,
responsive UI. I'm not even sure JSON-RPC is a good fit for a UI<->core
protocol, as it doesn't support bidirectional communication (at least
without pretty ugly hacks).

But what exactly is the problem with having a GUI as part of the main
client project? I don't see how it would "speed up development" to split
the project. By far most of the users use the program through the UI so it
is one of the drivers for requirements on the core, and I'd think it is
pretty important to keep it a first-class citizen.

Wladimir
-------------------------------------
On Thu, Apr 12, 2012 at 3:19 PM, Alan Reiner <etotheipi@gmail.com> wrote:

Do you have a -specific- concern that you feel may be exploited?

Expiration already occurs at random, as nodes shut down and restart,
log on and log off the network.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Dear bitcoin-development,

One of the original reasons for the creation of this mailing list was because the bitcoin.org forum was filled with this type of noise and this list was to provide a medium for discussion of development topics.  This entire SOPA thing is off topic for this list.  Might as well argue about abortion, because you can pay an abortion doctor with bitcoins.. maybe.

Many of us subscribe because we're interested in the technical discussions.. not internet trolling.  Several people have already expressed that they don't care about this, so please discuss it somewhere more appropriate for this topic, like the bitcointalk forums.

Thanks,
Laszlo


On Jan 17, 2012, at 4:16 PM, James Burkle wrote:




-------------------------------------
This page really does matter to alternative clients. If you measure the click through statistics, then they are a significant portion of the 
traffic. By removing this page, you are directly stunting Bitcoin's 
growth.

The only thing that's changed between now and this morning is: 

- Addition of Bitcoin Wallet for Android
- Randomisation of entries

I actually got permission from everyone involved before making the page.If you want to remove the page, then we should see a vote by:

- laanwj
- gavin
- sipa
- jgarzik
- BlueMatt
- Diapolo
- luke-jr
- you
- jim from multibit
- gary rowe
- ThomasV
- me
- etotheipi
- Andreas Schildbach
- justmoon
- Mike Hearn
You're proposing to remove the page. You know, and I know and I know that you know that nobody visits the Wiki. Your proposal is not "move to Wiki" really but remove from bitcoin.org. Keep bitcoin.org for Bitcoin-Qt only which is against the stated goals of the rest of your team members (gavin, sipa, jgarzik).


Have you tried the new clients? I've tried all 4, and they are all well written.

Try the new version of Electrum, https://gitorious.org/electrum/electrum - it's more featureful and secure than Bitcoin-Qt what with deterministic wallets, brain-wallets, prioritising addresses, frozen addresses, offline transactions - none of which Bitcoin-Qt has.

MultiBit is also very good with QR integration and the ability for merchants to quickly set themselves up. It's full of guiding help text, and has this paradigm to allow people to work with keys.


Bitcoin Wallet for Android has one of the best bitcoin UIs I've seen and is extremely well thought out in how the user navigates through the software.

The Bitcoin network could function perfectly fine with Electrum nodes and 
miners. You would still have miners and we wouldn't have the problem now with huge blocks because miners would be economically incentivised to 
keep blocks small. But that's another discussion.

Technically speaking, the randomisation is fine now. It achieves its intended effect, as the page is regenerated daily.

This does not need to be a source of arguing. I see no problem with having this page be a neutral overview of the main clients (as we all agreed together in the beginning):
- Source must be public, and users must be able to run from source.
- Description should be non-spammy and neutral sounding. Cover the negative aspects.
Randomisation of the order simply makes that fairer. Alphabetical is not a good option (as others have suggested) because it can be gamed.

There is absolutely no reason to remove this page unless you think bitcoin.org is only for Bitcoin-Qt which is against the wishes of gavin, sipa, jgarzik, and the long-term stated goal of bitcoin.org as a neutral resource for the community.



----- Original Message -----
From: Gregory Maxwell <gmaxwell@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Monday, July 9, 2012 6:46 PM
Subject: Re: [Bitcoin-development] Random order for clients page

On Mon, Jul 9, 2012 at 12:09 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

JS randomization doesn't imply needing JS to view the page. It implies
needing JS to see it in random order. You could also combine it with
the server-side randomization if you care about non-js being non
random, though I don't think it matters.

As others have pointed out I don't generally think the randomization
is good in principle, but if its done it should at least achieve its
goals.


I'll let other people speak for themselves, but I did consult others
before reverting your last batch of changes.

More generally, we have pull requests in order to get some peer review
of changes. Everyone should use them except for changes which are
urgent or trivially safe. (Presumably everyone with access knows how
to tell if their changes are likely to be risky or controversial)


I'm strongly supportive diversity in the Bitcoin network, and some alt
client developers can speak to the positive prodding I've given them
towards becoming more complete software. If I've said anything that
suggests otherwise I'd love to be pointed to it in order to clarify my
position.

Unfortunately none of the primary alternatives are yet complete, the
network would be non-function if it consisted entirely of multibit or
electrum nodes (and as you've noted armory uses a local reference
client as its 'server'). The distinction between multiple kinds of
clients in terms of security and network health are subtle and can be
difficult to explain even to technical users and so until something
changes there the reference client needs to be the option we lead
with. People should us it unless their use-case doesn't match. When it
does they'll know it and they'll be looking. We don't need to make one
of those recommendations a primary option.

I like the proposals of moving this stuff to the Wiki as the wiki
already contains tons of questionable (and sometimes contradictory)
advice and so there is less expectation that placement there implies
any vetting.



-------------------------------------
On Mon, Jun 18, 2012 at 12:46:47AM +0200, Alberto Torres wrote:

I strongly disagree on that point. What you're proposing needs miner
support to work, and miners generally run either the satoshi client as a
daemon, or some other custom code. Implementing the idea in armory
doesn't give those miners a nice upgrade path.

That said, *using* the hash tree is something that can be implemented in
any client, but a lot of the code will be shared between calculating it
and using it anyway, so again implementing in the satoshi client makes
sense.


Lets suppose we're trying to make a tree consisting of real numbers:

    /\
   /  \
   *   \
  / \   \
 /   \   \
 *   *   *
/ \ / \ / \
1 2 3 4 5 6

If the numbers are evenly distributed, as will happen with hashes of
arbitrary data, any number will be at most log(n) steps away from the
head of the tree.

Suppose though some malicious actor adds the following numbers to that
tree: 3.001 3.002 3.003

    /\
   /  \
   *   \
  / \   \
 /   \   \
 *   *   *
/ \ / \ / \
1 2 * 4 5 6
   / \
   |  \
   *   *
  / \ / \
  0 1 2 3 <- (3.000 to 3.003)

Ooops, the tree suddenly became a lot higher, with an associated
decrease in retrieval performance and an increase in memory usage.

Of course the exact details depend on what rules there are for
constructing the tree, but essentially the attacker can either force the
a big increase in the depth of the tree, or a large number of vertexes
to be re-organizationed to create the tree, or both.

Now, to be exact, since the key of each vertex is a transaction hash,
this malicious actor will need to brute chosen prefix hash collisions,
but this is bitcoin: the whole system is about efficiently brute forcing
chosen prefix hash collisions. Besides, you would only need something
like k*n collisions to product an n increase in tree depth, with some
small k.


My solution was to simply state that vertexes that happened to cause the
tree to be unbalanced would be discarded, and set the depth of inbalance
such that this would be extremely unlikely to happen by accident. I'd
rather see someone come up with something better though.


Another naive option would be to hash each vertex key (the transaction
hash) with a nonce known only to the creator of that particular merkle
tree, but then the whole tree has to be recreatred from scratch each
time, which is worse than the problem... Interestingly in a
*non-distributed* system this idea is actually quite feasible feasible,
as the nonce could be kept secret.

-- 
'peter'[:-1]@petertodd.org
-------------------------------------
Luke-Jr - common subset of what operating systems ship is fine for me
as long as people do due diligence around mobile OS' here. It seems
easier to me to just grab a list from a popular browser, on the
grounds that SSL is mostly used by them so nobody is going to buy an
SSL cert rejected by IE/Firefox/Chrome/etc. But intersecting OS lists
is effectively the same.

For my own clients I'd just ship my own copy of the canonical CA certs
regardless, because integrating with each operating systems
proprietary crypto APIs is a lot of work vs just loading a pem file
into OpenSSL. If there are a lot of people who want to use the OS cert
management UIs then I guess that can be a point wallet clients compete
on.


But it would result in implementations that do not meet the requirements.

Yes, X.509 has problems. It's in the proposal because we can get the
effect we want (verifiable domain names in the UI) in about 50 lines
of code, today, with the id-verified keys people actually have already
bought.

As Gavin says, we can add optional fields later to extend the protocol
in a backwards compatible way.


-------------------------------------
On Wed, Apr 11, 2012 at 11:42 AM, Luke-Jr <luke@dashjr.org> wrote:

See pull #1081, which makes a few minor revisions along these lines.

Mike's original pull still has my ACK, FWIW, too.  Can pull either.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Grouping mempool transactions based on fees of the group seems
an unnecessary complexity; it makes it harder to predict if an isolated
transaction has enough "juice" to be included in the next Block.

Given your point about economic actors adapting to conditions, would it not
be simpler to use a individual "fee per byte" priority algorithm and let
transaction generators distribute their fees accordingly (and more
predictably)?

This simpler algorithm will prune arbitrary transactions sub-optimally, but
has the benefit of being more understandable and predictable from the point
of view of transaction generators.

On Fri, Jun 15, 2012 at 9:56 AM, Stefan Thomas <moon@justmoon.de> wrote:




-- 
Mike Koss
CTO, CoinLab
(425) 246-7701 (m)

A Bitcoin Primer <http://coinlab.com/a-bitcoin-primer.pdf> - What you need
to know about Bitcoins.
-------------------------------------
On Wed, Apr 11, 2012 at 2:39 PM, Christian Bodt <sirk390@gmail.com> wrote:

That seems like a perfectly reasonable protocol improvement to me.
Anybody else have an opinion?

-- 
--
Gavin Andresen


-------------------------------------
On Mon, Apr 2, 2012 at 6:32 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:


Yes, I think increasing with one is enough for now. Let's not get ahead of
ourselves :)

Wladimir
-------------------------------------
Well, it should be simple. libcoin separates all the stuff you would like to do from a gui from the actual code, so I think it could be done cleanly. I havn't looked much at qt though... But help would be appreciated ;)

/M

On 01/02/2012, at 16:02, Wladimir wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
I'll be in the #bitcoin-development IRC channel in two hours, for the
semi-regular Tuesday IRC meeting. Things that might be worth some
discussion:

+ The duplicate coinbase attack/fix, and strategy for rolling out sipa's
fix.

+ 0.6 release schedule

+ Is there anything we can do to attract a great Windows developer?  (we've
got issues piling up...)

+ Multisignature next-steps: who is working on what?

Am I forgetting anything?

-- 
--
Gavin Andresen
-------------------------------------
On Tue, Feb 28, 2012 at 17:48, Pieter Wuille <pieter.wuille@gmail.com> wrote:

After getting responses from Deepbit, bitcoin.cz (slush), MtRed, Bitlc
and BTCmine, it looks like march 15 is a reasonable deployment date
for the security update described in BIP 30.

I have created patches for:
* git master: https://github.com/sipa/bitcoin/tree/nooverwritetx
* v0.4.0: https://github.com/sipa/bitcoin/tree/nooverwritetx_v0.4.0
* v0.3.24: https://github.com/sipa/bitcoin/tree/nooverwritetx_v0.3.24
* v0.3.24+vinced:
https://github.com/sipa/bitcoin/tree/nooverwritetx_v0.3.24+vinced
* v0.3.19: https://github.com/sipa/bitcoin/tree/nooverwritetx_v0.3.19

I've asked pool operators to upgrade, and confirm when they have done
so. If you are a miner or pool operator, and have the ability to
upgrade, please do so as well.

Thanks,

-- 
Pieter


-------------------------------------
Howdy everyone.

This is my first post on this lits, so please allow me to introduce myself.
I'm Tony, 31, software engineer, brazilian.
More about myself here <http://tonylampada.blogspot.com.br/> and
here<http://dicasdolampada.wordpress.com/>
.

I'm reaching out to this list because I've built a free software
crowdfunding platform that you might find interesting/useful.

It's called FreedomSponsors - will you please take a look?
- http://www.freedomsponsors.org
- http://blog.freedomsponsors.org/

FS lets people place money bounties on issues of open source projects.
(like bitcoins issues listed at https://github.com/bitcoin/bitcoin/issues). If
more people have the same needs, they can "chip in" on that offer. Payments
are made directly to developer *after* the issue has been resolved (no
escrows involved).

Right now, the only supported payment option is Paypal, but I'm already
working on enabling the use of Bitcoin both as a currency and a payment
option.

So, if you like it, feel free to use it, and maybe even contribute to it
(which is *very* welcome) - it's open source on Github -
https://github.com/freedomsponsors.
If you have any feedback, I'm happy to hear about it.

Thanks!
Tony Lmpada
-------------------------------------
I spent some time changing the internal bitcoin code to use callback
hooks, but its far from complete (or even really usable from anything
other than the code in the satoshi client itself, it doesnt even have
any deregister methods!).  As it sits now, it is likely to get more
eyeballs and merged for 0.7.  If you need additional specific callbacks,
adding them would be cool, though I wouldn't recommend relying on the
blockstore API to remain even remotely stable for the foreseeable
future.

https://github.com/bitcoin/bitcoin/pull/771

Matt

On Wed, 2012-03-21 at 22:13 -0700, Eric Lombrozo wrote:



-------------------------------------
Bunk argument. This is an issue that affects bitcoin directly.

Wikipedia has far more need to remain neutral and apolitical than bitcoin ever does- you've read Satoshi's politically charged whitepaper or seen the genesis block quote.

http://en.wikipedia.org/wiki/Wikipedia:SOPA_initiative/Action

The Wikipedia community decided on a full and global blackout. Bitcoin should do the same in unison with the rest of the web- sites like Reddit, 4chan and Wikipedia.

It's funny / almost comical how you consign this to being just another issue or case of moral alarm. Sad.



----- Original Message -----
From: Jeff Garzik <jgarzik@exmulti.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Sunday, January 15, 2012 10:37 PM
Subject: Re: [Bitcoin-development] bitcoin.org SOPA/PIPA blackout

On Sun, Jan 15, 2012 at 5:09 PM, Amir Taaki <zgenjix@yahoo.com> wrote:


There are always issues that raise ire and moral outrage. I would
rather that bitcoin.org stay apolitical -- our users will appreciate
this in the long run.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com



-------------------------------------
X.509 has some problems we have recent experience with. I'd prefer to
leverage something like DANE which looks to help with assertions
around certificates and creates an option around the CAs and x.509
roots.

-rick


On Mon, Nov 26, 2012 at 2:37 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:


-------------------------------------
On Thu, Oct 11, 2012 at 12:51 PM, Wladimir <laanwj@gmail.com> wrote:

Oops, in my enthusiasm I completely forgot that 0.7.1 is still in rc, not final.

What I merged is:
- #1901 from laanwj/2012_10_remove_strlcpy
- #1900 from Diapolo/optionsmodel_getters
- #1913 from sipa/noi2p
- #1879 from sipa/fdatasync

I don't think any of them is problematic to have in rc2. If it is, we
need to make a branch for 0.7.x at eb49457 and consider master the
0.8.x branch.

Wladimir


-------------------------------------
On Monday, February 06, 2012 10:54:25 AM Luke-Jr wrote:

FWIW, at least MtGox was OK with the plan to move to non-blockchain-spam
0-confirmation via an extra signature. Why do you ignore this possibility, and 
merge stuff that will break it? Do you have an alternative solution to the 
problem of green addresses spamming the blockchain? As I noted in the pull 
request, stripping extra data has no negative impact on normal transactions, 
and clients creating these can be written to expect the txnid to change (or 
simply not care what the txnid is).


-------------------------------------
I have just uploaded a new application to libcoin: "coinexplorer"

It enables queries similar to that of blockexplorer.com, but locally on your own chain.

coinexplorer builds on a new library addition: coinStat, that is a collection of classes for gathering and querying the block chain for other information than the ones used directly by the Node.

coinexplorer uses the HTTP GET feature of the coinHTTP/Server class to enable a simple search webpage, so you can do block searches by either commandline:
	bitcoind search <Address>

or simply by pointing you browser at http://localhost:8332 

I apologize for the rudimentary interface, but I am not really a javascript/html5 savvy... So a more modern interface is left as an exercise for those who are.

You will find coinexplorer in the latest git:
	https://github.com/ceptacle/libcoin

Cheers,

Michael

Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
On Saturday, August 11, 2012 4:43:28 PM Geir Harald Hansen wrote:

Bitcoin-Qt even delays showing generation until 2 confirms.


The default depends on build options, so that should be correct.


-------------------------------------
...or should we be directing people to a (vetted) list of cloud services -
I think this has a significantly lower entry cost than any client. I know
the mybitcoin debacle has clouded (pun intended) people's views of these
providers, but blockchain.info (for example) really does seem quite well
engineered, and satisfies many of the features in particular a very low
cost of entry, cross platform support and what appears to be very good
security (e.g. two factor)

Will

On 4 December 2012 17:46, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
On Thu, May 24, 2012 at 1:13 PM, Joel Joonatan Kaartinen
<joel.kaartinen@gmail.com> wrote:

Work in this area is already progressing, though it is outside the
scope of this proposal regarding lazy miners and empty blocks.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Monday, January 30, 2012 1:50:03 PM Gary Rowe wrote:

It is not correct to imply that BIP 20 requires Tonal Bitcoin support.
In fact, the exact opposite is true; it states that even if one unit (eg, TBC) 
would be a more rational way to display a specified amount, clients should 
still interpret it in the way that is deemed to be most intuitive to the user 
(eg, BTC).


-------------------------------------
On Thu, Oct 25, 2012 at 12:56 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

Sorry for the rapid additional comment, but I should also have
mentioned that the in efficiency is at odds with the privacy argument
for the particular mechanism... if the filter is not set at least
somewhat too broadly then it will uniquely identify the user. The
inefficiency, however, argues for setting the filter as narrowly as
possible because there is much more bandwidth used for a wider filter
than would be otherwise.


-------------------------------------
Here are my 2 cents after using LevelDB as the default backend for
BitcoinJS for about a year.

LevelDB was written to power IndexedDB in Chrome which is a JavaScript
API. That means that LevelDB doesn't really give you a lot of options,
because they assume that on the C++ layer you don't know any more than
they do, because the actual application is on the JavaScript layer. For
example whereas BDB supports hashtables, b-trees, queues, etc., LevelDB
uses one database type, LSM trees which is an ordered data structure
that is pretty good at everything.

Another gotcha was the number of file descriptors, LevelDB defaults to
1000 per DB. We originally used multiple DBs, one for each of the
indices, but it was easy enough to combine everything into one table,
thereby solving the fd issue. (Lowering the file descriptor limit also
works of course, but if you lower it too much, LevelDB will start to
spend a lot of time opening and closing files, so I believe combining
your tables into one is the better option.)

Overall, LevelDB is a fantastic solution for desktop software that is
faced with multiple use cases that aren't known at compile time. It
isn't really designed for something like Bitcoin which doesn't need
ordered access, has relatively predictable characteristics and - at
least some of the time - runs on servers.

That said, it does seem to work well for the Bitcoin use case anyway.
Thanks to the LSM trees, It's very quick at doing bulk inserts and we
don't seem to need any of the bells and whistles that BDB offers. So I
can't think of a reason not to switch, just make sure you all understand
the deal, LevelDB unlike Tokyo/Kyoto Cabinet is *not* intended as a
competitor or replacement for BDB, it's something quite different.



On 6/19/2012 6:06 PM, Mike Hearn wrote:




-------------------------------------
On Mon, Sep 10, 2012 at 3:53 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:

As you know there is a hard protocol limit of 1MB.

If you're going to talk about doing that you are screwing with the
core economic promises of the system. (in particular, removing the cap
eliminates the only armwave we have for long term security).  But in
any case, removing it requires a complete and totally incompatible
hardfork, and at that point you can do whatever you want with the
protocol. Changing how blocks are fetched is almost incidental to the
number of other things that would be changed.  I don't think it makes
sense to design for that especially when something far simpler (as you
pointed out) is prudent for the design of bitcoin.


-------------------------------------
On Fri, Jul 6, 2012 at 9:49 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:


But those issues are solvable through other, non-backwards incompatible
means. For example, mandate that a <transaction hash, output index> refers
to the first such pair that is not already spent. No?

Mark
-------------------------------------
My thoughts:

The extension is simple. It's only really useful for the use-cases listed if the majority of nodes implement it. As I view the proposal, it is perfectly simple and uncomplicated. If it's implemented, then I suggest to just increment version and make it part of the protocol.

On the flipside it is another notch in complicating an already diffuse protocol, but it seems a rather benign offense in that regard compared to other changes (past and future).



----- Original Message -----
From: Pieter Wuille <pieter.wuille@gmail.com>
To: Jeff Garzik <jgarzik@exmulti.com>
Cc: Bitcoin Development <bitcoin-development@lists.sourceforge.net>
Sent: Thursday, August 16, 2012 6:56 PM
Subject: Re: [Bitcoin-development] BIP 35: add mempool message

On Thu, Aug 16, 2012 at 01:32:04PM -0400, Jeff Garzik wrote:

I like the idea of being able to query the memory pool of a node; the
implementation is straightforward, which is good. Maybe effectively using the
command can be added? I suppose it is interesting in general for nodes to
get a memory pool refill at startup anyway.


I'm not sure about this last. What is it good for? inv packets can always be
sent, even not in response to others, so it is not that this gives you an
acknowledgement the mempool is updated?


This seems safe, although it forces other full implementations that want to
expose protocol version 60002 (or later) to also implement this. What do they
think about this?

I would like to suggest to allocate an extra service bit for this. We still
have 63 left, and this is a well-defined and useful extra service that was
not yet provided by any earlier node. Doing that would also mean that
mempool-providing survices may be discovered before connecting to them, as
the service bits are carried around in addr messages. Any opinions about that?

-- 
Pieter

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
On Tue, Jun 26, 2012 at 7:01 PM, grarpamp <grarpamp@gmail.com> wrote:

Perhaps some argument to add blocks to the IsRoutable check is in
order?  Then people who use overlay networks that are actually
routable but which use otherwise private space can just add the
relevant blocks.


Note that while the hidden service support in bitcoin uses a
compatible IPv6 mapping with onioncat,  it is _not_ onioncat, does not
use onioncat, does not need onioncat, and wouldn't benefit from
onioncat.  The onioncat style advertisement is used because our
protocol already relays IPv6 addresses. The connections are regular
tor hidden service connections, not the more-risky and low performance
ip in tcp onioncat stuff.


-------------------------------------
On Sun, Jun 24, 2012 at 8:45 AM, Mike Hearn <mike@plan99.net> wrote:

Link?

I also proposed this on this list (see the response in the tree
datastructures thread) along with more elaboration on IRC. If multiple
people are coming up with it thats a good sign that it it might
actually be viable. :)

I was going for a slightly different angle and pointing out that the
proofs would mean that a node doing validation with TxOUT tree which
hasn't personally wittnessed the complete history of Bitcoin actually
has basically the same security— including resistance to miners
creating fake coin in the past— as a full node today because in order
to get away with a lie every single node must conspire: It's adequate
that only one honest node wittness the lie because once it has the
proof information is hard to suppress.

To save people from having to dig through the public IRC logs for what
I wrote there:

--- Day changed Thu Jun 21 2012
15:10 < gmaxwell> etotheipi_: amiller: an interesting point with all
this txout tree stuff is that if you join the network late and just
trust that the history is correct based on the headers, any other node
who has witnessed a rule violation in the past can prepare a small
message which you would take to be conclusive proof of a rule
violation and then ignore that chain.
15:11 < gmaxwell> e.g. if someone doublespends I just take the
conflicting transactions out and the segments connecting them to the
chain... and show them to you. And without trusting me you can now
ignore the entire child chain past that point.
15:13 < gmaxwell> This fits nicely with the Satoshi comment "It takes
advantage of the nature of information being easy to spread but hard
to stifle" ...  it would be safe to late-join a txout tree chain,
because if there is only a single other honest node in the world who
was around long enough to wittness the cheating, he could still tell
you and it would be as good as if you saw it yourself.
15:17 < gmaxwell> (this is akin to the provable doublespend alert
stuff we talked about before, but applied to blocks)


-------------------------------------
On Mon, Dec 3, 2012 at 2:50 PM, Andreas Petersson <andreas@petersson.at> wrote:

While thats a fine thing— and a feature that I'd personally use— its
not one that I expect to have a real measurable impact on the overall
network behavior.

For this kind of minutia especially, defaults are all powerful and
must be the best they can be. :)


-------------------------------------
These are interesting thoughts, karma for bitcoins essentially.

I would like CoinLab to publish a 'cost of subverting 1-n transactions with
90% probability' metric soon, and I think it would help everyone to
understand what that number is.

When we started out, you probably needed to wait 5 blocks for $10 or $20 of
bitcoin value transfer.

Now, I'd happily accept a $1k transaction with 1 confirmation.

More difficulty shortens the safe time we can transact large volumes in,
which is good for the network.

I'm not sure of the current implementation of replacement transactions, can
anyone on the core team speak to this? Can I replace transactions, or is
that part of the spec unimplemented or deprecated right now?

Peter


On Thu, Apr 26, 2012 at 8:49 AM, Peter Todd <pete@petertodd.org> wrote:



-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
Pieter's performance numbers are a bit conservative if anything—
profiles on ultraprune[1] show that the reference client's wasting of
a lot of time in redundant serialization and hashing operations is
the major time sink. Once thats cleared up it should be quite a
bit faster

[1] https://people.xiph.org/~greg/ultraprune_profile.png

On Fri, Jul 6, 2012 at 12:52 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

In particular,  if the BDB indexing in ultraprune is replaced with
a hash committed tree structure who's root is committed in the
blockchain you then have a txout commitment scheme.
Ultraprune is most of the messy structural work for that. The
rest is mostly storage differences.


-------------------------------------
Just to clarify, I'm not proposing anything to the protocol itself.  
Simply that some applications might benefit from users being to sign 
messages with existing Bitcoin identities, and what can we do to 
accommodate that (out of band)?  It's not a high priority, but I think 
it's potentially useful, and most codebases already have everything they 
need in place to implement it.


On 04/03/2012 04:04 PM, Peter Vessenes wrote:

-------------------------------------
Thanks for the summary!

On Sat, Mar 31, 2012 at 6:03 AM, Luke-Jr <luke@dashjr.org> wrote:


Yes, we have a lot of changes waiting already.



Agreed.



See my comments there; I'm all for optimizing the ToHex function, but I
prefer that he optimizes the current ToHex function not add yet another one
with an incompatible interface.

(we have the same problem with Error/Debug/"Log to console" functions, too
many of them and sometimes it's unclear what the difference is)



I also have some UI code changes ready, for example one to use notification
from the bitcoin core when the address book/transactions changed, instead
of a timer. Will submit pull requests soon.

Coderrr has rebased his Coin Control features (#415) to the latest version.

Agreed. It is very popular and should certainly be merged. And it has seen
quite some testing already. Though this will take some time to review, as
it is quite a large change.


IPv6 support would be nice, but I don't think a milestone of 0.7 is
realistic. Such a change to the network code will require extensive
testing. Who has access to IPv6 and can help testing?

Wladimir
-------------------------------------
Another concern is sourceforge being attacked and a backdoored client uploaded.
Most people don't check signatures and I seem to recall sourceforge having some
vulnerabilities stemming from their "your own website on sourceforge" feature.
It looks like Github takes security a little bit more seriously.
Probably the best is to ask for free hosting from a reputable security conscious
bitcoin enthusiast but that basically means Tux and he's already an SPOF in the
coineverse.

Thanks,
Caleb

On 10/20/2012 04:33 AM, Wladimir wrote:




-------------------------------------

Yes, that is essentially what BIP 30 did.

We want to do this also, partly for "belt and suspenders" security but
mostly for two reasons:

1. To test using block/transaction version numbers to smoothly roll
out changes. The next change we need to make might be prompted by some
crisis; better to learn any lessons now, when we have the luxury of
time to fix problems that might crop up.

2. We think we'll all appreciate the change in a year or three, when
the whole network has upgraded and we can start writing code that
assumes all new blocks past a certain checkpoint contain their height;
that should make it easier to do things like figure out whether or not
an orphan chain can possibly be part of the main chain.

-- 
--
Gavin Andresen


-------------------------------------
On Tue, Oct 9, 2012 at 7:12 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

The mention of testnet3 here reminds me to make a point:  Confirmation
bias is a common problem for software testing— people often over test
the success cases and under-test the failure cases.  This is certainly
the case in Bitcoin: For example, testnet3+the packaged tests test all
the branches inside the interior script evaluation engine _except_ the
rejection cases.

For us failure cases can be harder to package up (e.g. can't be placed
in testnet) but Matt's node-simulation based tester provides a good
example of how to create a data driven test set that tests both
failure cases and dynamic behavior (e.g. reorgs).

Testing of failure cases is absolutely critical for testing of
implementation compatibility: The existence of a difference in what
gets rejected in a widely deployed alternative node could result in an
utterly devastating network split.

Generally every test of something which must succeeded should be
matched by a test of something that must fail. Personally, I like to
test the boundary cases— e.g. if something has an allowed range of
[0-8], I'll test -1,0,8,9 at a minimum. Though reasoning trumps rules
of thumb.

Confirmation bias is another reason why it's important to have a more
diverse collection of testers than the core developers.  People who
work closely with the software have strong expectations of how the
software should work and are less likely to test crazy corner cases
because they "know" the outcome, sometimes erroneously.


To reinforce Jeff's list of different approaches: I've long found that
each mechanism of software testing has diminishing returns the more of
it you apply. So you're best off using as many different approaches a
little rather than spending all your resources going as deep as
possible with any one approach.

There are also some kind of testing which are synergistic: Almost all
testing is enhanced enormously by combining it with valgrind because
it substantially lowers the threshold of issue detection substantially
(e.g. detecting bogus memory accesses which are _currently_ causing a
crash for you but could). If I could only test one of "with valgrind"
or "without" I'd test with every time.  Sadly valgrind doesn't exist
on windows and it's rather slow. Dr. Memory
(http://code.google.com/p/drmemory/) may be an alternative on Windows,
and there is work to port ASAN to GCC so it may be possible to mingw
ASAN builds in not too long.

I've also found that any highly automatable testing (coded data
driven, unit, and fuzz testing) combines well with diverse
compilation, e.g. building on as many system types and architectures—
including production irrelevant ones— as possible in the hopes that
some system specific quark make a bug easier to detect.


-------------------------------------
This idea is from a Debian user [1].

What do you think of moving the > 2 GB db to $HOME/.cache/bitcoin and
leaving the wallet and other config files in $HOME/.bitcoin? This is
so backups can skip the .cache directory and the proposal follows the
freedesktop.org XDG Base Directory Specification [2]. Personal
info/settings stays in .bitcoin/ and everything that can be rebuilt
goes to .cache/bitcoin/ I know users can do a work around and set it
up themselves with symlinks, but interested in what you guys think.

Cheers,
Scott (Debian Developer but new to bitcoin)



[1] http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=660286
[2] http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html


-------------------------------------
On Thu, May 24, 2012 at 4:31 PM, Luke-Jr <luke@dashjr.org> wrote:

This is simply not true given current available data, i.e. the current
blockchain and ongoing not-spam transaction rate/pool.



According to your own numbers even, this is not true.  99% of the
network runs a wide variety of rules and versions.  Even with a
"critical" security announcement, the percentage of those running the
latest version is not large.



Miners are not the -only- ones that get a say in what is spam, and
what is not.  If miners are generating garbage, network users have the
right to veto that garbage.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Monday 03 December 2012 11:19:37 Michael Gronager wrote:


Ignoring the cost of storing these never-spent outputs; there is absolutely no 
reason we need to ensure that coins aren't lost.  Nor worry about those that 
are.

The total bitcoins produced is an entirely arbitrary number -- a function of 
the 210,000 halving rate and the initial block reward.  Satoshi could have 
picked anything for them and bitcoin would work exactly the same.

Lost coins never enter the economy ever again, and so supply is slightly lower 
than it would have been, making all the non-lost coins worth ever so slightly 
more.  Effectively: price adjustments will take care of lost coins.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Tuesday 27 November 2012 17:14:19 Mike Hearn wrote:


That's good; I've not done anything with protocol buffers, so wasn't aware it 
was that simple.


Sorry, I meant "obviously" in the sense that "obviously that's the other one 
that everyone will want".  The web-of-trust as a universal identity mechanism 
is, I agree, not useful.  However, as a localised, smaller-scale identity 
verification system it's used by every GnuPG user.  You become your own 
certificate authority.  For example, I've set up my whole family with GnuPG; 
I've set them up to trust me to authenticate (and I doubt any of them has ever 
added anyone else).  Then I take on the responsibility of signing all my 
family/friends keys and they don't need to worry about it.

There's no reason that a small group of companies wouldn't do exactly the same 
sort of thing.


Bear in mind, I was using that example as an example of a hash protected in a 
GPG envelope, not a GPG-signed invoice.  People who've already got their GPG 
system in place will appreciate being able to leverage it.


How can they put a hash of an invoice inside the invoice?  In my "hash mode" 
invoices, it would be a random number (or possibly specifying the hash 
algorithm) then the SignedInvoice would simply be the original invoice + hash.  
That hash would then be reported via some secure channel outside of bitcoin's 
domain.


I don't understand what the relevance of multi-factor is to invoices?  The 
payment is performed via normal bitcoin mechanisms isn't it -- multi-factor or 
not?  This invoice system has one primary job: to ensure that the target of 
the payment is who the payer thinks it is -- that's not affected by multi-
factor methods of protecting my wallet.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
Great to hear that.
-------------------------------------
On Thu, Oct 11, 2012 at 1:51 PM, Arklan Uth Oslin
<arklan.uthoslin@gmail.com> wrote:

As you like, but... bitcoin-devel is quite low traffic, so there is
not exactly an issue of crowding.  And a separate list means people
cannot chime in as easily.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

Well, yes, that is basically the implementation complexity argument :)
Engineering time isn't free.

I don't feel I understand the effort required to do some kind of
partial tree encoding. Having a kind of custom compression whereby
branches are represented as varint indexes into a dictionary, I can
feel how much work that involves and maybe I can make time over the
next few weeks to implement it. Has anyone got example code for
representing partial Merkle trees?


If you just want to waste bandwidth of nodes you can connect to nodes
and repeatedly download blocks, or fill the network with fake nodes
that spam random generated transactions to whoever connects. I don't
see how to avoid that  so it seems odd to worry about a much more
complicated attack.


-------------------------------------

I'm not sure I understand the rationale for this.  In the above
scenario the buyer has no way to determine whether the merchant still
has a copy of the transaction that they could broadcast in future.
Maybe there is simply a systems problem at the merchant which has
temporarily delayed the transaction broadcast. Or maybe a dishonest
merchant deliberately engineered this situation in an attempt to
mislead the buyer as to the status of their payment.

Either way, having the buyer think the coins have been returned to
their wallet - only to disappear from their wallet again at some later
time - would seriously damage user confidence in Bitcoin IMHO.

It seems to me that the first thing the buyer should do given the
protocol as it stands is simply resend the Payment message - if there
was a temporary problem then resending the payment message (with the
same signed transation) might resolve the sitution.

If after several retries the status of the transaction is still
undefined then it's really not clear what to do, but it seems
desireable to have the client take steps so that it can return to a
state of certainly about its wallet balance as quickly as possible.
Two things I can imagine that the buyer might want their client to do
at this point are:

 * broadcast the transaction itself, so they are sure the payment
   transaction will make it into the blockchain without any further
   action on their part, or

 * invalidate the transaction by immediately broadcasting a
   pay-to-self transaction that spends one or more of the same outputs
   that the payment transaction spends (and treat the funds as part of
   the unconfirmed balance until this pay-to-self transaction
   confirms).  This ensures the merchant can't subsequently use a
   transaction which the buyer thinks has failed

It seems to me it would be simpler and cleaner if the buyer just
always broadcasted the transaction on the p2p network, regardless of
whether the Invoice includes a receiptURI.  If a receiptURI is
included, the buyer's client would also include the transaction in the
Purchase message.  The merchant then tries to broadcast the
transaction as well (unless their bitcoind has already seen it, which
may well be the common case).  This approach seems to me to have fewer
nasty edge cases.s

roy



-------------------------------------
Hi Thiago

I had in mind using the JSON RPC 2.0 system.description standard command instead of help, but I got sidetracked implementing it. Will look into it asap. Thanks for noting!

/M

On 24/02/2012, at 03:17, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
https://lists.sourceforge.net/lists/listinfo/electrum-discuss



-------------------------------------
Hi team,

Given that sourceforge has shown to restrict access to a number of
countries at the request of the USA, would hosting of the compiled client
on https://github.com/bitcoin/bitcoin/downloads be an alternative that
would be considered?

It seems like a logical alternative to me that requires little effort as it
is already in use as the code repository.

Kind regards,

Kyle
-------------------------------------
How about a simple proof of work test? This one though does not ask for CPU
work but asks the miner for a random old transaction. If the miner really
stores the entire blockchain he will not have any problem answering to that
getdata request, whereas a botnet would have to ask someone else for it,
which could be detected if the response time deviates too much from what
has been previously measured (compare it against getdata for the block they
advertise). It's not perfect but it allows an estimate of whether it is a
chainless miner.

Regards,
Chris
--
Christian Decker



On Fri, May 25, 2012 at 3:17 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------

I am and I'm going to have to agree with Greg. Information about clients
is bound to be transient and controversial.

My relatively naive suggestion would be to move it to the Wiki. If it
can handle the controversies involved with the Trade page, it should
easily be able to handle the controversies involved with a Clients page
like this one. A link to that page could be added under Bitcoin Wiki on
Bitcoin.org.

On the subject of randomization, I think that's a bad idea. Randomness
does not equal fairness and more importantly it does not serve the
users, which should be the overriding concern. As a user I don't want to
be recommended a random client but the most sensible choice. As
alternative client implementors we should not be overly concerned about
Bitcoin.org recommending the wrong client, truly good clients will
benefit from word-of-mouth and eventually rise to the top. If you want a
"fair" ordering, then I'd order by number of downloads for downloadable
clients and Alexa rank for any hosted / online services if it were
decided that such should be listed at all.

On 7/9/2012 6:09 PM, Amir Taaki wrote:




-------------------------------------
On Sunday, June 17, 2012 11:04:42 PM grarpamp wrote:

No, that was a temporary branch of what became the stable 0.6.x branch.
GitHub/master is bleeding edge. For production, you usually want the stable 
branches/releases (which are on Gitorious).

The fix to -detachdb's position in -help was just merged to master, and should 
be backported sometime in the next few days.

Luke


-------------------------------------
Here is a BIP draft for improving the block relaying and validation so that it can be done in parallel and so that redundancy can be removed. This becomes more beneficial the larger the block sizes are.

https://en.bitcoin.it/wiki/User:MatthewLM/ImprovedBlockRelayingProposal

Matthew Mitchell
-------------------------------------
Script evaluation performance was what I was primarily concerned with.  I'm
fooling around with adding some new instruction types.
The tricky part is that to test how that effects performance, you need to
be able to intersperse transactions with the new instructions with existing
ones.  For accuracy, you'd like your simulated traffic to at least
approximate the real world traffic.


Also, is there any bench-marking / instrumentation in bitcoind ?

Ian
On Wed, Oct 3, 2012 at 1:43 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
This is a bad idea. The bitcoin protocol is (mostly) stateless. Stateless protocols are more secure.



________________________________
 From: Pieter Wuille <pieter.wuille@gmail.com>
To: Gavin Andresen <gavinandresen@gmail.com> 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Thursday, April 12, 2012 5:01 PM
Subject: Re: [Bitcoin-development] Adding request/reply id in messages
 
On Thu, Apr 12, 2012 at 11:41:05AM -0400, Gavin Andresen wrote:

If there is a reasonable use for it, I have no objections.

However: the bitcoin P2P protocol is not fully request-reply based, and trying to use
it that may be be less intuitive than how it looks. For example, doing a second
identical "getblocks" request will not result in more "inv" replies, as the client
prevents retransmits. This is not a large problem, but maybe such an extension
should also include an extra "denied" message, which is sent if the client is
unwilling to answer (and may also be used to report transactions that are not
accepted into the memory pool, for example).

-- 
Pieter

------------------------------------------------------------------------------
For Developers, A Lot Can Happen In A Second.
Boundary is the first to Know...and Tell You.
Monitor Your Applications in Ultra-Fine Resolution. Try it FREE!
http://p.sf.net/sfu/Boundary-d2dvs2
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
On Monday, November 26, 2012 11:02:14 PM Mike Hearn wrote:

I would prefer using the user-accepted certs at the operating system level...


-------------------------------------
On Thu, Feb 2, 2012 at 12:36 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

(and Gah: forgive the  autocompletion  of my fingers: I'm apparently
unable to type the word coin without prefacing it with bit)  *libcoin*
not libbitcoin.


-------------------------------------
On Monday, September 10, 2012 3:07:52 PM Matthew Mitchell wrote:

Most of the problem with block propagation lies in implementation, not 
protocol... Distributing missing transaction on an as-needed basis is a 
possible improvement at the protocol level, but there hasn't (AFAIK) been any 
research into whether the little benefit outweighs the cost yet. In any case, 
I don't see why 6 new messages are needed instead of simply adding a single 
new type to getinv?


-------------------------------------
I tried on another 11.10 machine with the normal boost 1.42 and things also worked as they should.

However, I noticed a difference between your cmake output and mine:


-- Found OpenSSL: /usr/lib/i386-linux-gnu/libssl.so;/usr/lib/i386-linux-gnu/libcrypto.so (found version "1..")

Are you sure that the openssl libraries/includes found are the correct ones ? cmake finds your openssl libraries at /usr/lib/ which most likely will make it think that the includes are at /usr/include. I can see that at least X11 stuff is in /usr/lib/x386-linux-gnu like my openssl.

Could there be an issue there ?

SHA256 would normally be found in openssl/sha.h but if that is somehow corrupt ?

Cheers,

M

PS: to get more debug output, please try a "make VERBOSE=1" That will show what g++ flags that are used, and might help us.

On 23/02/2012, at 18:31, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
On Tue, Dec 4, 2012 at 12:46 PM, Mike Hearn <mike@plan99.net> wrote:

I strongly believe that if community leads with client software which
is not a full _capable_ node (e.g. which can begin life as a SPV node
but at least eventually become full if the system resources permit)
then Bitcoin will fail, or at least fail to be anything but the
world's most inefficient centralized payment system.  Obviously SPV
nodes are excellent tools for getting bitcoin into less capable
systems, but they aren't a general replacement for the software the
participants in Bitcoin run.

— Because the properties promised by the system can not be upheld if
there is only a fairly small number of self selecting nodes enforcing
the rules. If we wanted a system where its security against theft,
denial of service, and non-inflation were governed by the consensus of
{mtgox,blockchain.info, deepbit, bitpay, slush, btcguild, bitminter}
we could have something infinitely more scalable by just using
something OT like with a simple O(N) consensus between these parties.
No disrespect intended to any of these services— but a system whos
rules were only enforced at the good graces of a small number of
interested parties is not what the users of bitcoin signed up for.

People obviously care about supporting the goals and security of a the
system they use but actions speak louder than words.  If a
non-validating node is promoted then we're telling people that it's
not important that many people run them.  If running a full node
requires using different software (with a different interface) or a
much more painful initialization than another promoted option then it
will be correctly perceived as costly. If people perceive it to be
both costly and not important then rational participants will not run
it. The result will be fragile to non-existent security, where
dishonest or exploitative parties benefit from running all the full
nodes until they start ripping people off and shift the equilibrium
just a little towards running costly nodes.

It sounds to me that you're insisting that you're asking people who
oppose degrading our recommendations to commit to a costly rushed
development timeline. I think this is a false choice.

There is no set timeline for the adoption of Bitcoin— man has survived
eons without Bitcoin just fine— and there are many practical reasons
why slow adoption is beneficial, including reducing the harm users
experience from growing pains.  By allowing things to mature at their
own pace we can preserve the principles that make the system valuable.

If the new user experience is sufficiently bad (and I agree it's bad,
esp with the current release versions of Bitcoin-Qt) then that should
justify more support of work that improves it without compromising the
system. If it's not bad enough to apply those resources, then it's not
bad enough to justify compromising it: as this sort of change is hard
to reverse.


-------------------------------------
On Sunday, January 29, 2012 12:10:41 AM Amir Taaki wrote:

2 compressed pubkeys are 33 bytes each. Add 1 bytes for the N (n-of-m), 1 byte 
for the address version, and finally the 4 byte checksum, you get a total of 
72 bytes. But these are *bytes* - to get an address, you also need to base58 
encode it: this yields a 99 character address.


-------------------------------------

Looks good to me.


-------------------------------------
And now to the list...

On Jul 27, 2012 6:21 AM, "grarpamp" <grarpamp@gmail.com> wrote:

I doubt the encryption is the problem. I have a much more recent machine
(i7 with 8 GiB RAM), and my blockchain is on a (userspace!) encrypted
filesystem. However, I do not notice any measurable slowdown from doing so.

You are however using a filesystem (ZFS) that is uses its own filesystem
caching implementation to reach some performance, and is known to be very
memory-hungry at that. Furthermore, I believe it is known to have
performance issues on 32-bit architectures. The bdb backend Bitcoin uses
does many I/O operations, and writes them synchronously to disk, killing
whatever caching your filesystem provides. For those who run a large
database on ZFS, I believe it is advised to put ZFS's intent log on a
separate SSD-backed device, to get fast synchronous writes.

That said, some improvememts may be coming. Mike has been working on
changing the backend from bdb to leveldb, which may (or may not) result in
a very different performance profile on your machine. Also, I've been
working on switching the bitcoin block verifier to use a different style
database layout ("ultraprune"), which is smaller, faster, and will support
pruning. A recent test on my own machine synced the blockchain up to the
latest checkpoint in 7 minutes (6 minutes when stored in RAM instead of
disk).

-- 
Pieter
-------------------------------------
On Wed, Feb 29, 2012 at 5:05 PM, Ben Reeves <support@pi.uk.com> wrote:

That can't happen until the coinbase matures, which takes 100 blocks.
And it won't mature because a majority of hashing power is rejecting
it, right?

-- 
--
Gavin Andresen


-------------------------------------
While writing the script engine for pynode, I ran a test to validate
my script tokenizer -- a python script which does nothing more than
split up scriptPubKey and scriptSig into component opcodes and data
elements.  No execution, just tokenization of the script's data
stream.

Scanning the entire blockchain, my script found over 8,000
tokenization failures, and 100% of those were in coinbase
transactions' scriptSig.  The scripts used to generate this can be
found at https://github.com/jgarzik/pynode

The following data dump are just the first few, and most recent few,
of the invalid scripts I found in the blockchain:

Scanning block #142312 000000000000046acff93b0e76cd10490551bf871ce9ac9fad62e67a0
7ff1d1e (1 tx)
   TX 50cfd3361f7162b3c0c00dacd3d0e4ddf61e8ec0c51bfa54c4ca0e61876810a9
      txin 0 parse failed
Scanning block #142357 0000000000000743c432f84ad688b7b60d1474ccd7baa3d762df0b3f5
1205712 (1 tx)
   TX 587da4d4870515e57efc27623aa92fae0b7aef5908162de57fef0bbe6382be73
      txin 0 parse failed
Scanning block #143014 00000000000007fe6ecd20a8c454cd43c78d912b499c46a1179e30f7c
ff002b3 (1 tx)
   TX 4c8f43c5115c5f29f3761176fa59cde2de2ad976efcbc5faae8ee79fa5dd6264
      txin 0 parse failed
...
Scanning block #190315 00000000000006a0bc3be527033c02d3bcfa72af2f4213c4b0feec923
9573342 (336 tx)
   TX f0ba80ce080eb49148b69c47d744bbb85e4e07e4e4d0273b402c0989d79c359c
      txin 0 parse failed
Scanning block #190321 00000000000001c3bacc869917cacdafb6e00c552ac294835107b574a
44a0362 (38 tx)
   TX 4c91f5ad0616df92165819902d0b117d9e68345f5fe964de6146f89838b9295e
      txin 0 parse failed
Scanning block #190331 00000000000000e3d3eaf93600684b085df7d58f84ef952c91e84eb4a
251d5d8 (128 tx)
   TX 5ee371d65e323934570566b1d92dceb8456e887814da8ef2a53971683bd11da4
      txin 0 parse failed

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On 05/03/2012 11:24 AM, Jorge Timn wrote:

I never measured exactly, but Bitcoin Wallet takes about an hour to
update its blockchain initially on good WLAN (lightweight approach,
headers only).

After that, Bitcoin Wallet is just as fast as any other client.

The advantage of that approach is that you are not dependent on any
server (like Spinner or Electrum). Essentially you're carrying the
blockchain in your pocket.

Cheers,

Andreas



-------------------------------------
On Thu, Jun 21, 2012 at 5:42 PM, Mike Koss <mike@coinlab.com> wrote:

No.

We're talking about commitments to the state of _unspent_ transactions
which would allow ~memoryless nodes to engage in full validation
without having to trust anything with the help of some untrusted
non-memoryless peers.  Also, talking about being able to securely
initialize new pruned nodes (not memoryless but reduced memory)
without exposing them to the old history of the chain. In both cases
this is possible without substantially degrading the full node
security model (rule violations prior to where they begin are only
undetectable with a conspiracy of the entire network).

But it requires a new data structure for managing these trees of
unspent transactions in a secure, scalable, and DOS resistant manner.
Fortunately there are lots of possibilities here.


Yes. Though this is obviously not an ultra short term thing.


-------------------------------------
On Sat, Dec 22, 2012 at 1:39 PM, Andreas Schildbach
<andreas@schildbach.de> wrote:

Yes.


Not so— but what you're actually seeing is that difficult change is
relative to the prior block's difficulty. E.g. if the penultimate
block in the difficulty cycle is under the special rule the difficulty
change will be relative to 1.

(I had intentionally avoided triggering that test case when adding the
timewarp attack to the testnet chain in case we had wanted to fix it
prior to testnet3's release— I guess I should have added it sooner in
order to catch the bitcoinj misbehavior!)


-------------------------------------
On Wednesday, February 01, 2012 11:20:22 AM Michael Grnager wrote:

Boost 1.46.1 is the latest stable on Gentoo.


Perhaps it would be easier to merge with the latest 0.4.x branch:
    git://gitorious.org/+bitcoin-stable-developers/bitcoin/bitcoind-stable.git


-------------------------------------
Would be fine for me, depends on the community, and it is one of those chunks that make many stall...

The reason for building on bitcoin/bitcoin directly is that this created a history of all changes, and this way I had a working version running each day while doing the refactoring - with my wallet at stake!

However, I think perhaps the bitcoin project should be split into a library, with a prototype client and the actual clients. This library facilitates this.

Cheers,

M

On 01/02/2012, at 16:09, slush wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Michael,

 I think it is time to your Libcoin to become the official Bitcoin...   ;-)

 Look: https://bitcointalk.org/index.php?topic=108987.msg1185827

 It is more or less the same idea, right?!

Best!
Thiago

On 16 July 2012 17:14, Martinx - $B%8%'!<%`%:(B <thiagocmartinsc@gmail.com> wrote:

-------------------------------------

I'm implementing a DHT, rather than storing the whole blockchain index
locally, a future version of BitcoinJS will store only a user defined
percentage (anywhere from 0-100%.) Any misses will be resolved by
querying the network.

Thanks to ultraprune, we no longer need a full index for verification.
And for all the other use cases like lightweight server queries and
block explorer queries a bit of latency is acceptable in exchange for
scalability and decentralization. This feature will give people to
option to run anywhere from a large BitcoinJS node (100% index) to a
small one (20% index) to a lightweight one (0% index.) All of them are
equally queryable, so if you're just trying out BitcoinJS you won't have
to download the block chain just to run the block explorer example. Only
when your block explorer's traffic grows will you need to contribute
some query services back to the network in order not to get rate-limited.



Pieter brought up this very point when he reviewed an earlier draft.
This prompted the creation of the second BIP I mentioned:

https://en.bitcoin.it/wiki/User:Justmoon/BIP_Draft:_Custom_Service_Discovery

The basic principle is quite simple - prefix the standard addr message
with a service-specific message to mark off service support. It's easy
to implement and very efficient (without compression it's 1.288 bits per
node, with compression it's quite possibly more efficient than the
services field.) Because this stuff is a bit more complex and because it
requires no changes to the Bitcoin protocol, Amir and I chose to split
it off into a separate BIP and I want to work on it a little more. But
if you are wondering how peer exchange might work for these custom
services, please do take a look at it.



When I designed the DHT, I did just that. Later I was working on a
concept for a decentralized pool and I noticed I was solving the same
problems again. And with all three services running a node might be
maintaining three separate TCP connections to the exact same peer.

So then I considered making the DHT network extensible, so that the
decentralized pool protocol could live in there. But, well if I'm doing
that, why not just make the regular Bitcoin protocol extensible and let
both extensions live in there.

For a custom service you DO need the following:

- service-specific DNS seeds
- service announcement (BIP: CS)
- service-specific messages (BIP: CS)
- service-specific peer exchange (BIP: CSD)

And those four things cover a lot of what Bitcoin does. But once you're
thinking about n custom services it starts to look easier to add
semantics for "some nodes support some things" in one network rather
than instantiating n networks.

On the opposite end of the spectrum there are very simple services.
Consider a WebSocket transport. Some nodes might offer
Bitcoin-over-WebSocket, for example to implement an SPV client in the
browser. But they don't connect to each other via WebSocket, since they
prefer plain TCP. So in this case you need peer exchange, but not much
else. You could create a new P2P network for the sole purpose of
exchanging peers, but again it seems much easier if there were ways to
do this on the Bitcoin network.

One final point: A major focus of this BIP is to make it easy to
canonicalize custom services if we choose to do so. The idea is that
custom services get to prove themselves in the wild - those that work
well may be added to the standard protocol. That's a good reason to 1)
encourage custom services to live in-band and 2) recommend compatibility
with Bitcoin's standard mechanisms (12 byte command names, 1 bit service
announcement, 1 bit peer exchange etc.)

On 8/13/2012 3:15 PM, Mike Hearn wrote:



-------------------------------------
Just wrote it in another mail, but I am quite certain it is the boost version - you need 1.48 (or 1.47).

/M

On 01/02/2012, at 17:15, Luke-Jr wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Forcing users to switch addresses per received payment to work around a bad fee system would be a braindead decision. You might love software and playing with web plugins, but not everyone does. Artists like Rap News can right now simply throw up an address and begin accepting donations. That's a hugely powerful and impactful selling point for Bitcoin.

I don't really see these problems as a concern. Stefan made an excellent post which touched on this, in that miners have an incentive to keep block sizes low so that their blocks propagate. The real problem here is not about block propagation but the user experience. The way I see it, Bitcoin is becoming more specialised over time and part of that process is abstraction. In the past we all used the Satoshi client for mining, merchant functions, validating blocks and personal uses. These are rapidly diverging, and managing the blockchain is not something that user clients should be doing.

Mike is right when he says the network only needs a few thousand nodes to function fairly. I am not worried about Bitcoin becoming corrupted because of it being a network "by bankers for bankers" because unlike the conventional finance industry, there are no artificial barriers to entry beyond the base cost. This network would always be competitive and strictly operate based on market dynamics.

Case in point: http://en.wikipedia.org/wiki/Coase_theorem

With strict property rights and zero (or low) transaction costs, the allocation of a system does not matter. The system will make efficient use of its resources. I don't see why a cabal would try to corrupt Bitcoin at expense to themselves when a new competitor can enter the market and undercut them. It's why we expect the ROI on mining to be 0 or negative.


I figured out that if you trust data from a blockchain service and only accept data with multiple confirms from each connected service, then you can trivially calculate the probability of being fed corrupt data (assuming a fixed chance per server). In this way, the model is a fault tolerant byzantine system. The chance of being manipulated falls expontentially as you add more servers. And these services can be made highly scalable if you see my BIP 33.

https://en.bitcoin.it/wiki/BIP_0033

________________________________
From: Mike Koss <mike@coinlab.com>
To: Stefan Thomas <moon@justmoon.de> 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Friday, June 15, 2012 7:37 PM
Subject: Re: [Bitcoin-development] Near-term scalability


Grouping mempool transactions based on fees of the group seems anunnecessarycomplexity; it makes it harder to predict if an isolated transaction has enough "juice" to be included in the next Block.

Given your point about economic actors adapting to conditions, would it not be simpler to use a individual "fee per byte" priority algorithm and let transaction generators distribute their fees accordingly (and more predictably)?

This simpler algorithm will prune arbitrary transactions sub-optimally, but has the benefit of being more understandable and predictable from the point of view of transaction generators.



On Fri, Jun 15, 2012 at 9:56 AM, Stefan Thomas <moon@justmoon.de> wrote:

Thanks Mike for the writeup - I'm very sad to have missed the discussion


-- 
Mike Koss
CTO, CoinLab
(425) 246-7701 (m)

A Bitcoin Primer- What you need to know about Bitcoins.

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------------------------------
For what it's worth I disagree with Gregory on nearly all these
points, so don't take it as some kind of consensus from the Bitcoin
community ;)

Matts change is reasonable but I think we all agree it has minimal
impact at the moment relative to other things, so something even more
complex than that seems like a non-starter. Bloom filtering is a lot
more important.


-------------------------------------
Very interesting for you to bring this up. I had a similar idea for a
totally different use case. Greg recently pointed out an interesting
dilemma saying that (significantly) larger blocks would lead to
centralization. So I've been working on a design for a decentralized
pool that can handle gigabyte sized blocks by splitting up the work
among its members.

At the moment P2Pool nodes all verify all transactions in all blocks.
But it seems feasible to create a system where miners who have over the
last 10000 blocks contributed to the pool's proof-of-work are allocated
a proportional piece of verification work with redundancy and
deterministic randomness that makes manipulation of the allocation
extremely difficult. Such a pool would be very unlikely to accept an
invalid block or transaction in practice.

However, with these block sizes obviously non miners are going to have
to be SPV, so even just a 0.0001% chance of an invalid block being
accepted has profound implications for the network. If a decentralized
pool like that had more than 50% of the hashing power and it accepted a
single invalid block, that tainted chain would be forever regarded as
valid by SPV clients. There needs to be some way to recover once an
invalid block has been accidentally accepted by an imperfect miner.

Based on that I also started to think about proofs of invalidity that
would circulate. Basically you would add a new network message that
would contain the proof that a specific signature and therefore the
whole block is invalid.

As long as the block's proof-of-work is valid and the block's parent is
one of the last n = 50000 blocks, the message is relayed (subject to a
cooldown, warnings would be less frequently relayed the older the
offending block is.)

The mechanism works in exactly the way Mike mentions: It allows even SPV
clients to punish any miner who is dishonest or negligent with their
verification work. That gives miners a good reason not to be dishonest
or negligent in the first place.


(Motivation:

Processing more transactions means that hashing is a smaller part of the
overall cost for miners. For example, paying for 50 BTC worth of hashing
per block costs 0.05 BTC per tx at 1000 tx/block, but only 0.0005 BTC at
100000 tx/block.

Number of transactions is a lever that lets us have lower fees and more
network security at the same time. Like Greg correctly pointed out, this
is not worth having if we have to sacrifice decentralization. But if we
don't, it becomes a no-brainer.

My IMTUO proposal [1] showed a way where miners don't need a copy of the
set of unspent outputs at all. This means the minimum storage
requirements per node no longer grow with the number of transactions.

However, the price for this was about five times greater bandwidth usage
per verified transaction. Since every miner still had to verify every
transaction it looked like bandwidth would become an even bigger problem
with IMTUO than storage would have been without. However, if a small
miner can do less than 100% verifications and still contribute, suddenly
IMTUO may become viable. That would accomplish the holy grail of Bitcoin
scalability where the network successfully runs on trust-atomic entities
all of which can choose to store only a small fraction of the block
chain, verify a small fraction of transactions and perform a small
fraction of the hashing.)


[1] https://en.bitcoin.it/wiki/User:Justmoon/IMTUO

On 6/24/2012 2:45 PM, Mike Hearn wrote:




-------------------------------------

Matts point that a branch-per-transaction may duplicate data is well
made, that said, I suspect a format that tries to fix this would be
much more complicated.

How about see this project as a three part change?

First step - add the mempool command and make nodes sync up their
mempools on startup.

Second step - if protocol version >= X, the "block" message consists
of a header + num transactions + vector<hash>  instead of the full
transactions themselves.

On receiving such a block, we go look to see which transactions we're
missing from the mempool and request them with getdata. Each time we
receive a tx message we check to see if it was one we were missing
from a block. Once all transactions in the block message are in
memory, we go ahead and assemble the block, then verify as per normal.
This should speed up block propagation. Miners have an incentive to
upgrade because it should reduce wasted work.

Third step - new message, getmerkletx takes a vector<hash> and returns
a merkletx message: "merkle branch missing the root + transaction data
itself" for each requested transaction. The filtering commands are
added, so the block message now only lists transaction hashes that
match the filter which can then be requested with getmerkletx.


-------------------------------------
I recently was dabbling with AskFor() and changing the time waited from 2
minutes to 10 seconds (I think perhaps this value may change in future
versions when "network tuning" is implemented).

I noticed that, when used with the -limitfreerelay option that is causes
significant increase in traffic between peers. This is because the tx gets
asked for (from all connected peers usually), but AlwaysHave never becomes
true as it's never stored, always rejected, so it effectively getdatas the
transaction from every single connected peer.

Would it perhaps be better to set up a memory pool for rejected txs and
blocks (perhaps keeping only the hash) so that these rejected items can
continue being ignored?

I hope these observations are ok - I consider myself at the "trying to
understand the code/protocol/algorithm" stage so might sometimes make false
assumptions of what the code intends to do.

Ed
-------------------------------------
Hi,

luke-jr withdrew BIP 16 and put forwards support for BIP 17. So now there's a consensus to move forwards.

However he submitted BIP 18 to me today. From looking it over, I'm not even sure the idea is tenable nor see the purpose when we are adopting BIP 17. Personally I'd rather not see a high turnover in protocol design when something works (now that we have viable multisig transactions) even compromising on the position of a perfect design.

https://en.bitcoin.it/wiki/BIP_0018

Usually for a BIP, someone submits it to me, I review to see whether the idea is technically sound (not making judgements on the validity), the community discusses the idea and I evaluate the support at the end to change the status. In general I try to accept all BIPs in the interests of fairness, rather than holding a vote or being the executioner.

"Once the champion has asked the Bitcoin community as to whether an idea has any chance of acceptance, a draft BIP should be presented tobitcoin-development@lists.sourceforge.net. This gives the author a chance to flesh out the draft BIP to make properly formatted, of high quality, and to address initial concerns about the proposal.
Following a discussion, the proposal should be sent to the Bitcoin-dev list with the draft BIP and the BIP editors <BIPs@Bitcoin.org>. This draft must be written in BIP style as described below, else it will be sent back without further regard until proper formatting rules are followed."

I don't think BIP 18 has followed this discussion before being accepted. Neither have many other BIPs as we're a small community, and so far we avoided this unneeded level of bureaucracy. However I think this is a good thing to do here.

Should BIP 18 be accepted into the repo or not?

"The BIP editor will not unreasonably deny a BIP. Reasons for denying BIP status include duplication of effort, being technically unsound, not providing proper motivation or addressing backwards compatibility, or not in keeping with the Bitcoin philosophy."

"For a BIP to be accepted it must meet certain minimum criteria. It must be a clear and complete description of the proposed enhancement. The enhancement must represent a net improvement. The proposed implementation, if applicable, must be solid and must not complicate the protocol unduly."

(quotes from BIP 1)


-------------------------------------
Thanks for getting this started.

With regards to the specific proposal, I don't believe it's the best option
and still plan to eventually implement the original design outlined more
than a year ago in this thread:

  https://bitcointalk.org/index.php?topic=7972.msg116285#msg116285

Namely that you use a new protocol command to set a Bloom filter on a
connection. Only transactions matching that filter will appear in relayed
inventory. Blocks that are requested will arrive as a header plus
transaction/merkle branch pairs. Clients are expected to maintain and track
the block chain as per usual, but instead of downloading the whole chain
and then dropping the irrelevant transactions, that filtering is done
server side. By strengthening or weakening the Bloom filters you can choose
your preferred point on the privacy/bandwidth-usage spectrum. It is a
fairly simple change to the Satoshi and BitcoinJ codebases but still allows
clients to gain confidence in their balance by examining the chain, and
this is true even in the presence of a hijacked internet connection (you
can't trust pending transactions that way, but you can still trust
confirmed transactions).

The filters would be applied to each data block in each script rather than
having a specific knowledge of addresses. In this way you can select for
things like multisig outputs or outputs which don't use addresses / pubkeys
to authenticate.

I could write a BIP for this alternative protocol if somebody else wants to
implement it. I was going to wait until I had time to do both BIP and
implementation, but I think some simple optimizations to BitcoinJ can keep
its performance good enough for the short term.
-------------------------------------
Hi all,

I'm working on a from scratch Java implementation. So far I got a 
modularized, unit tested implementation of the core modules (api, keys, 
blocks, chain, scripts, network protocol).

My dummy client however gets stuck on Block 140493, specifically at 
transaction hash: 
70f7c15c6f62139cc41afa858894650344eda9975b46656d893ee59df8914a3d

It seems the (signature) verification fails for this specific 
transaction (for the 1 input in it), which is rather odd since 
verification was successful for all the preceding blocks and inputs.

I double checked that the official (C++) client is indeed successful 
here. Oddly enough the bitcoinj implementation also seems to fail to 
verify this transaction, which seems to point in the direction of 
BouncyCastle (which we both use).

My question is, did anybody hit this issue before? If not, can someone 
doublecheck maybe that I'm not missing something trivial?

The data that should be signed (the signature hash):
b45c680f32f9364f5255cc15ef7cad879dbde9062d7fb8db0fe56e245823a78f

The signature (with '01' at the end for SIGHASH_ALL, remove this before 
you pass it to verification): 
304402206b5c3b1c86748dcf328b9f3a65e10085afcf5d1af5b40970d8ce3a9355e06b5b0220cdbdc23e6d3618e47056fccc60c5f73d1a542186705197e5791e97f0e6582a3201

The public key:
04f25ec495fa21ad14d69f45bf277129488cfb1a339aba1fed3c5099bb6d8e9716491a14050fbc0b2fed2963dc1e56264b3adf52a81b953222a2180d48b54d1e18

As said, this seems to work with openssl, but seems to fail with 
bouncycastle for some reason (version 140).

Thanks,
Robert.



-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 03/10/2012 03:02, Gregory Maxwell wrote:

that is not what i was getting at, nor what i meant at all.I am sorry
it came across this way. Im a bit drunk. (yeah that old excuse) I was
only trying to make an example of the quandary that exists, in what
happens to the current donations. There are far more deserving people
who have a claim on that coin rather than I.

I have stated on more than on occasion (written in public and verbal
with gavin) that I would be willing to work for free. But I would love
to be able to ditch the day job. (however i see that more as services
than mining/testing)

rereading what i wrote yeah, fair play i can see how you read my mail
like that. it wasnt meant to :/ i feel a bit of a turnip. the tone is
not what i meant. it does read pretty mercenary.


This is a different issue. But I see why you have raised it and I
would like to address it. I personally believe you should earn
bitcoins for writing testcases, executing testcases, passing or
failing test cases. in that order (failing a testcase normally
generates a new one therefore encouraging indepth and recorded
testing.). QA should not be judged based solely on bug reports - this
is unfair and will result in race to report bugs.  I have worked on a
few projects that have tried it.

This is one reason we need workflow and testcase software, so we can
measure and compensate people for their work.

As I have stated in previous emails I should have, but for various
excuses did not manage to run a single testcase for 0.7. but I did
setup a frame work, and I know some people did do some good work on
0.7 I believe these people should be compensated from the (limited)
funds the project received... something needs to happen with those coins.

I am sorry you find my emails abstract (and therefore meaningless?)

this is a really confusing time. i dont know if i am doing right from
wrong. I am trying to lead, without leading... i have always preferred
benevolent dictator. I know a number of bitcoin businesses that are
really keen to work with the project, but I have no authority, noone
seems to. Someone should be able to say, nice one, thanks for the
vm's. maybe use $200 worth of coin to get a technet licence, that
gives 10 installs of each ms OS. slipstreaming in the service packs
means you can have whatever era pc you want (and the vps providers
will allow various configuration of vm's...) then even if you do it by
hand you can still do 6 or 7 at once...

as for bug reports, give me 1 week from now (168hrs), lets see what i
can do. (priority, protocol, daemon, qt ref?) but still process is
more important...

I still think that writing and doing testcases should get more coin
than bug reports. but from what I have read, the big bounties will be
paid by the foundation. im not sure if that is true or where i read
it. (protocol level bugs)

it feels like I am wasting peoples time,and I should get back in my
box. so I will.

contact me off list if you want to have a look at the various workflow
stuff i have done.

cheers,

steve
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQa6pAAAoJEFvEB9dQFvtQ0H8H/jUjvzmsp61w1bmDnHR+KmF4
LNu7WwVLrTvrT8AHSNh3mClWvMM3muJJA7NMb2WthAgVe3jtrGimfreAlstDsObL
XNEcGvU6WN1YosH0MkN7hyDl8jnrDFoiH1P5qsMecuZIxwq7Z0vCOHEJ9DPmZilW
R+G8OmoGcpaeWs9VqXR6zR7Uyz69KaDAQpMRE1GTu3zQP9HSSolciy3ESeJRR9Sd
yO7EcCGdQot80rOG/VIZ0wkOmzGGm1thzYzayD6Zn2eW4Hw+ME1en9ksIbXJFpSv
IdgThEm7p5UuBo0jFkbX4Awrf9hfusZSEGWfhZqdASqqkSBnYqLmWF1sLprDRF8=
=Iv87
-----END PGP SIGNATURE-----


-------------------------------------
On Mon, Dec 3, 2012 at 10:00 AM, Mike Hearn <mike@plan99.net> wrote:

It's part of their messaging system. Every losing play results in a
new 1e-8 output being created.


-------------------------------------
I'd state it this way: a spec needs to be minimally complete

The subset implemented by bitcoin-qt allows description of *all* currently
desirable bitcoin transactions.

The rest of the spec is simply other ways to describe the same = redundancy

In case new transaction types are added, the spec obviously needs to be
extended. But not with a zillion ways to write "send XXX coins to YYY".

Anyway, that's my last word about it.

Wladimir

On Sat, Jan 28, 2012 at 3:12 AM, <bitcoin-list@bluematt.me> wrote:

-------------------------------------
Geir,

There were a lot of subtle changes to the English base messages such as
capitalization or punctuation, I know this is pretty annoying for
translators. It is a pity that there is no way to update all translations
when the English base message changes but not significantly enough to
trigger re-translation. I've looked but Transifex does not have that option.

Also there were new duplicated strings:

Duplicate strings are not a problem. Some strings are used multiple times
in the program, and thus appear multiple times in the translation. This is
because there are cases in which a string that is the same in English is
translated differently in another language based on the context.

At least Qt translator fills duplicates in automatically, with the option
to change them if desired. I'm not sure about Transifex but I've heard it's
the same there.



The default depends on compiler flags, hence the two messages. I suppose
the message could be split up, so that "Use UPnP to map the listening port"
is factored out.

Let's do this after 0.7.0 release though, otherwise all the translations
for those messages will be broken again. There should be no more message
changes before the release unless there is a very good reason.

Wladimir
-------------------------------------
Hi Alan,

I am using an approach similar to your proposal in a service I am developing. I have, however, chosen to sign using the following scheme:
1. take sha512 of document (=hash512)
2. take ripemd160 of hash512
3. create 512 bit data structure, where the first 352bits are '0', and the rest is the ripemd160 of our hash512
4. sign it with the key

This procedure prevents an evil site from fooling you to sign a transaction spending your own coins. So bottom like never sign a full sha512 with a key for any other purpose than a transaction. (The above could easily well have been implemented as just truncating the hash512 to 256 bits, feel free to propose the optimal scheme).

/M



On 04/04/2012, at 08:23, Wladimir wrote:





-------------------------------------

OK, I see. I guess that could be a reasonable fallback for the case
where you have a secure channel.


Yes, exactly. It's about paying who you think you're paying (when you
confirm on a second uncompromised device).


-------------------------------------
On Mon, Aug 13, 2012 at 3:41 AM, Stefan Thomas <moon@justmoon.de> wrote:

heh, this is not a new idea.  I even implemented a pull request for
service discovery myself, which simply consisted of querying the list
of supported commands:
https://github.com/bitcoin/bitcoin/pull/1471

On IRC, I proposed several alternatives including modifying 'version'
(which you did) and a new "getcaps" (get capabilities) command to be
added in protocol_version X.

gmaxwell seems continually unenthused, and made a valid point about
service advertisement:  these capabilities are not advertised with
CAddress, so how does one usefully discover and make use of them?
What are real world use cases, that cannot be solved with nService
bits?

My only response is a weak one:  inevitability.  It seems likely that
-somebody- will implement their own P2P commands for their own client
subset, even if only a simple "use 'getstatus' with strSubVer matching
/FooClient/"

Therefore, if it is inevitable, we might as well make some basic rules
about how to extended your P2P command set.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wed, Oct 10, 2012 at 8:40 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

Yes, I think this is a good idea. Getting ultraprune in should be a priority.

I've just pulled all the small stuff that was already ACKed for
post-0.7.1, so IMO the freeze can start.

Wladimir


-------------------------------------
Forward past automoderation...




The document (Tor.txt) assumes the bitcoin user has taken care of
that. So no bi-direction needed (I am not TorProject).


Seems it's used only within bitcoin code to distinguish which proxy
or native IPvN path to send bitcoin traffic to (or receive from).
It might be simpler than managing onions, i2p's and whatever else
throughout the code and the private bitcoin p2p mesh.

Though I don't suspect it will conflict [1] with anyone's use of
OnionCat, GarliCat, or Phantom... it would just feel odd configuring
bitcoin to use Tor or I2P proxy ports (or Phantom native) when you
could conceivably just dump the IPv6 traffic to the OS stack for
handling once you have the *Cat shims and Phantom set up. They do
have a point about about ocat as a shim for their purposes. And
Phantom is a special case in that it's all native IPv6 interface,
no proxy or shim needed or provided.

I will quote an additional note from bitcoin-devel...

"Note that while the hidden service support in bitcoin uses a
compatible IPv6 mapping with onioncat, it is _not_ onioncat, does not
use onioncat, does not need onioncat, and wouldn't benefit from
onioncat. The onioncat style advertisement is used because our
protocol already relays IPv6 addresses. The connections are regular
tor hidden service connections, not the more-risky and low performance
ip in tcp onioncat stuff."

FYI. There have been a dozen or so onion:8333 nodes and maybe some
on I2P long before this work. But I think could only be used as
-connect or -addnode seeds with some extra host setup. Never tried
it since -proxy was sufficient. Seems this is a simpler and full
solution.

[1] Well bitcoin wouldn't know to offload traffic to any of those
blocks, or a specific host on them, if you had them set up locally
via *Cat or Phantom... for bitcoin use. It would probably end up
half useful similar to the above FYI. But that would just affect
bitcoin, not whatever else you were running on them.


-------------------------------------
Odd, here I was thinking I checked that.  Just goes to show how useful
sources other than the rfc itself are... Anyway, Ill change it to a
hyphen.

Matt

On Tue, 2012-01-31 at 22:37 +0000, Gary Rowe wrote:





-------------------------------------
On 04.03.2012 02:04, Luke-Jr wrote:

If the client doesn't tell you which block change it saw last, you can't
avoid this problem completely.


I think long polling and reconnecting to LP is an HTTP-specific problem
anyway? So it may be best to go with an HTTP header. See below for an
idea for a capabilities reporting system, though, which would allow
putting this data into JSON.


I think "should" makes sense.


Reading through it again it is mostly clear except for one thing, how to
submit "share/merkle" style. It doesn't say exactly how to submit this data.

It says merkle tree, but a merkle branch should suffice. Also, I believe
the coinbase must always be the first transaction of a block? So we
won't need the transaction's index in the merkle tree (it's always index
zero). This would then be just an array of sha256 hashes making up the
merkle branch for the coinbase.

I'd prefer if block header, coinbase tx and merkle branch were submitted
in 3 pieces. When merged mining and submitting a block generating proof
to the aux backend you put an auxiliary proof of work between the block
header and transactions. So the header and transactions are not
necessarily adjacent. Also, there's no merkle branch in a regular
bitcoin block.


Let's add an optional "servercapabilities" key on the server side, the
value being a space-delimited list of what's supported by the server. If
that list contains "clientcapabilities" then the client may, instead of
sending an empty request, send an object where one of the keys is
"clientcapabilities", and the value is a space-delimited list of extensions.

Those names are a bit long, maybe "caps" is better.

Ok, this is not entirely clean. For the first request the client won't
know what the server supports. For subsequent requests I guess always
assume the last caps the server reported.


Yes, you can end up getting half a nonce range from an upstream server,
and not being able to make use of it because your downstream clients
don't support it.

A single GPU can make full use of the noncerange if you allow the
timestamp to slip a few seconds into the past. I believe most miners do
that today.

Also worth including are the "hostlist" and "switchto" getwork
extensions. I think those can fit right into the JSON response, to keep
with being transport-agnostic, but otherwise look like they do for getwork.

Regards,
Geir H. Hansen


-------------------------------------
2012/4/15 Jorge Timn <timon.elviejo@gmail.com>:

No, not changing the protocol.

Further, adding a field to TX would imply the client needed to rewrite
the TX for each retransmit, changing the hash.  Not good at all.


Typically no, because 99.9% of TX's make it throughout the network in
seconds.  But yes it is possible, just like it is possible today to
receive a TX at various times.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I'm a big proponent of a testing project.

I think if one could self organize that Gavin and team wanted to bless we
could put up some BTC as bounties or funding. We won't have our heads
around the foundation budget for a few more weeks, but self-organization is
often slower than budgeting. :)

This is just my opinion, but I would like very, very much to move the
current specification into unit tests so that anyone could validate their
alternate bitcoin implementation. This is a lot of work, some of which has
been done, much of which hasn't.

So, my two cents, plus an offer to bring it up at our next budgeting
meeting.

Peter


On Mon, Oct 1, 2012 at 7:28 AM, steve <steve@mistfpga.net> wrote:




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
On Sat, Jan 14, 2012 at 08:19:29AM -0700, Roger Pack wrote:

This sounds like an easy improvement. Anyone interested in implementing
such a minimal "first-use wizard" ?


Please do.


I believe posting to the forum is restricted to certain boards for newbies.

-- 
PIeter


-------------------------------------
period, where making

Spot on, in 2005 when I lived in (among other places) Sudan, Sourceforge
would block certain downloads (but not the project site).  That said it
was trivial to bypass the restrictions then.




-------------------------------------
On Mon, Jan 16, 2012 at 11:37 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

Agreed :)

For those that believe one particularly noisy country in the North America
region with a policy called SOPA or PIPA directly affects Bitcoin - can you
point out precisely where it does so?
-------------------------------------
https://github.com/bitcoin/bitcoin/pull/748/files

I'm reading a diff of a now defunct OP_EVAL proposal with the current pay to script hash one.

It might be better for code review if the old pull is reverted and then this one re-requested. That will make it easier to see the real changes.



-------------------------------------
Hey,

Only a small thing - I think the first check in that function should be an assert. There is a problem if that function is called a coinbase tx.



-------------------------------------
JS randomisation is bad. People shouldn't need JS to view a webpage.

Only you have a problem with this page. I don't see why Bitcoin-Qt needs to be first either when it dominates the front page. It is perfectly fine as it is.

You are not a developer of any alternative clients, and this is a webpage for Bitcoin clients. I have made a change to remove a source of disputes, and make the process more fair and equal. Your suggestion to remove the clients page is your bias towards thinking that there should be only one Bitcoin client that everyone uses (the one which you contribute towards).

If you want to suggest removing the clients page, then fine, lets also remove all reference to Bitcoin-Qt from the front-page and turn it into a http://bittorrent.org/ style website.

Fact is that the other clients are rapidly becoming stable and mature, and the ecosystem is diversifying. The argument that the other clients were not up to scratch held maybe a few months ago, but not now.



----- Original Message -----
From: Gregory Maxwell <gmaxwell@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Monday, July 9, 2012 5:04 PM
Subject: Re: [Bitcoin-development] Random order for clients page

On Mon, Jul 9, 2012 at 11:54 AM, Amir Taaki <zgenjix@yahoo.com> wrote:

If you had authored this as a pull request rather than making the
change unilaterally I would have recommended leaving it so the
reference client was always first. I also would have suggested that it
use JS randomization instead of jekyll in order to get more even
coverage, though I think thats a more minor point.

Some people were concerned when this page was created that it would
just be a source of useless disputes. I think its becoming clear that
this is the case. I think the cost of dealing with this page is
starting to exceed the benefit it provides and we should probably
consider removing it.



-------------------------------------
On Thu, Nov 08, 2012 at 10:19:05AM +0100, Mike Hearn wrote:

Right now, there seem to be little problems with allocation and viability of
proposed BIPs, with hardly any reviewing/formal allocation being done in
practice. In the past there have been collisions though, and there also have
been nonsensical proposals. I'm in favor of some moderate form of process,
but if the process becomes a burden more than a help, there is clearly a
problem.

It seems there is also little attractiveness to writing BIPs. If many proposals
do not result in useful discussion, there is little incentive to write one
except for those proposals that absolutely need to (p2p protocol, block
validity rules, ...). That's a pity in my opinion - I'd like to see non-core
proposals related to Bitcoin being discussed more often as well.


Agree, I think Bloom filtering should make it into 0.8 - it's a critical
step to make SPV clients more useful for end users.

Regarding ultraprune, there are a few TODOs left:
* Auto-migrate old data (depends on -reindex, for which there is a pullreq)
* UTXO set consistency checks at startup (-checklevel)

-- 
Pieter


-------------------------------------
Escrow/multisig is complicated enough to wait for another day. But
certainly having a payment protocol is an important step towards it
On 6 Dec 2012 07:32, "Andreas Petersson" <andreas@petersson.at> wrote:

-------------------------------------
Hi,

is there any status update from Deepbit? Why he still does not support
anything...

slush

On Tue, Mar 6, 2012 at 4:46 PM, Luke-Jr <luke@dashjr.org> wrote:


-------------------------------------
I'm pleased to announce the release of BitCoinJ 0.5, the library that
powers Android Wallet, SatoshiDice, Bitcoin Status, the server side part of
BCCAPI and much more.

This release focusses on bug fixes, making the build more standard and
completing the transition to the protobuf wallet format. It also includes
the first preview of the native API, allowing you to access bitcoinj from
C++/Objective-C++ using a straightforward, intuitive mapping from the Java
API. Much easier than JNI and no JVM is required, just the libgcj support
library. Examples of a native Cocoa app for OS X and a command line hello
world app are included. Because it's not fully finished/documented yet,
this work is available on a branch rather than in the main release.

We now have a Google+ page where we'll post announcements and developer
tips/ideas: https://plus.google.com/102614914114364947458

New in this release:

   - Address.getParameters() and Address.getParametersFromAddress() let you
   figure out for what network the address is for (test, production, etc).
   BitcoinURI no longer requires a NetworkParameters for the same reason.
   - Updated to latest bouncy castle version, remove the need for the
   Android artifact by using the SpongyCastle build
   - Receives pending transactions much faster than before
   - Update to the testnet2 rules
   - Wallets now store the current chain head
   - wallet-tool can now create and broadcast transactions from the command
   line
   - Wallets will now be auto-migrated to protobuf format if they were
   previously serialized Java objects
   - Now uses the standard Maven directory layout
   - Many important bugfixes

I'd like to thank Jim Burton, Miron Cuperman, Andreas Schildbach and Gary
Young for their contributions to this release.

You can get it from the download page on www.bitcoinj.org
-------------------------------------
I switched the transaction database to use the Google LevelDB library,
which is a refactored out part of BigTable.

Here are my results. All tests are done on this hard disk:

  http://wdc.custhelp.com/app/answers/detail/a_id/1409/~/specifications-for-the-500-gb-caviar-blue-and-caviar-se16-serial-ata-drive

which has an average 8.9msec seek time. It is a 6 core Ubuntu machine.

I used -loadblock on a chain with with 185127 blocks in it, so it has
lots of SatoshiDice traffic.

8.9 ms (average) seek time

real	96m6.836s
user	49m55.220s
sys	2m29.850s

Throughput usually 4-5MB/sec according to iotop, pauses of 8-10
seconds for “Flushing wallet ...”. 611mb of blkindex.dat

Throughput, 12-17mb/sec
real	42m51.508s
user	11m52.700s
sys	2m36.590s

Disabling EC verification halves running time.

(I ran the wrong time command here, hence the different format)
3184.73user 181.02system 51:20.81elapsed 109%CPU (0avgtext+0avgdata
1220096maxresident)k
1104inputs+125851776outputs (293569major+37436202minor)pagefaults 0swaps

So, 50 minutes. Throughput often in range of 20-30mb/sec. 397MB of data files.

real	50m52.740s
user	53m38.870s
sys	3m4.990s

424mb of data files

No change.

real	50m53.054s
user	53m26.910s
sys	3m10.720s

No change. The reason is, signature checking is the bottleneck not IO.

real	12m58.998s
user	11m42.330s
sys	2m5.670s

12 minutes vs 42 minutes for BDB on the same benchmark.


Conclusion: LevelDB is a clear win, taking a sync in the absence of
network delays from 95 minutes to 50, at which point signature
checking becomes the bottleneck. It is nearly 4x as fast when
signature checks are not done (ie, when receiving a block containing
only mempool transactions you already verified).


-------------------------------------
On Mon, Dec 17, 2012 at 6:23 AM, Melvin Carvalho
<melvincarvalho@gmail.com>wrote:

The decision has already been made.

-- 
--
Gavin Andresen
-------------------------------------
Hi guys.

So, as I mentioned on the bitcointalk.org forums thread about the
foundation, I want to get involved in the QA side of bitcoin
development. I've done functional testing in the video game industry for
years. I've read all the messages in this thread, but I'm left unclear how
I can most effectively and quickly being helping out. Could I get a bit of
a directional nudge?

Arklan

----------
As long as there is light, the darkness holds no fear. And yet, even in the
deepest black, there is life. - Arklan Uth Oslin

I want to leave this world the same way I came into it: backwards and on
fire. - Arklan Uth Oslin



On Sat, Sep 29, 2012 at 12:26 PM, steve <steve@mistfpga.net> wrote:

-------------------------------------
Hello all,

I've implemented a new block/transaction validation system for the 
reference client, called "ultraprune".

Traditionally, pruning for bitcoin is considered to be the ability to 
delete full transactions from storage once all their outputs are spent, 
and they are buried deeply enough in the chain. That is not what this 
is about.

Given that almost all operations performed on the blockchain do not 
require full previous transactions, but only their unspent outputs, it 
seemed wasteful to use the fully indexed blockchain for everything. 
Instead, we keep a database with only the unspent transaction outputs. 
After some effort to write custom compact serializations for these, I 
could reduce the storage required for such a dataset to less than 70 
MB. This is kept in a BDB database file (coins.dat), and with indexing 
and overhead, and takes around 130 MB.

Now, this is not enough. You cannot have a full node wit just these 
outputs. In particular, it cannot undo block connections, cannot rescan 
for wallet transactions, and cannot serve the chain to other nodes. 
These are, however, quite infrequent operations. To compensate, we keep 
non-indexed but entire blocks (just each block in a separate file, for 
now), plus "undo" information for connected blocks around in addition 
to coins.dat. We also need a block index with metadata about all stored 
blocks, which takes around 40 MB for now (though that could easily be 
reduced too). Note that this means we lose the ability to find an 
actual transaction in the chain from a txid, but this is not necessary 
for normal operation. Such an index could be re-added later, if 
necessary.

Once you have this, the step to pruning is easily made: just delete 
block files and undo information for old blocks. This isn't implemented 
for now, but there shouldn't be a problem. It simply means you cannot 
rescan/reorg/server those old blocks, but once those are deep enough 
(say a few thousand blocks), we can tolerate that.

So, in summary, it allows one to run a full node (now) with:
* 130 MB coins.dat
* 40 MB chain.dat
* the size of the retained blocks
  * + +-12% of that for undo information.

Oh, it's also faster. I benchmarked a full import of the blockchain 
(187800 blocks) on my laptop (2.2GHz i7, 8 GiB RAM, 640 GB spinning 
harddisk) in 22 minutes. That was from a local disk, and not from 
network (which has extra overhead, and is limited by bandwidth 
constraints).

If people want to experiment with it, see my "ultraprune" branch on 
github: https://github.com/sipa/bitcoin/tree/ultraprune

Note that this is experimental, and has some disadvantages:

* you cannot find a (full) transaction from just its txid. 
* if you have transactions that depend on unconfirmed transactions, 
  those will not get rebroadcasted
* only block download and reorganization are somewhat tested; use at 
  your own risk
* less consistency checks are possible on the database, and even fewer 
  are implemented

Also note that this is not directly related to the recent pruning 
proposals that use an alt chain with an index of unspent coins (and 
addresses), merged mined with the main chain. This could be a step 
towards such a system, however.

-- 
Pieter


-------------------------------------
On Tue, Dec 4, 2012 at 10:06 PM, Mike Koss <mike@coinlab.com> wrote:

As Pieter pointed out recently— it's not (realistically) possible to
blindly iterate through strings.  This means your proposal loses the
backup recoverablity property which is part the point of a
deterministic wallet:  If you have a backup prior to a new string name
being established you must also have a reliable backup of the string
as well.

Of course, if you're backing up the strings then you can also backup a
map equating the hdwallet indexes to your strings, and in the event of
a catastrophic loss where you are only left with the original ultimate
root you lose no coins (only metadata) with the BIP32 scheme. If,
instead, we have your scheme and the backup of strings is incomplete
then some or all assigned coin may be lost forever.

Your extended hierarchy of multiplers also makes me uncomfortable.
BIP32 uses a HMAC in its construction to obtain strongly unstructured
points.


-------------------------------------
On Wed, Sep 26, 2012 at 8:53 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:

Jenkins is excellent at cycling through tests,  while additional
external tools may bring some value they're not required.  It's also
essential to automate all tests that we really care are run— with our
small active development group and volunteer contributors the only
tests we can count on being run are the automated ones. Automated
tests included with the software— or at least the source— are also the
only way to have a good chance of catching gnarly platform
interactions.

I think more than talking about testing I think we need is actual
testing. Code coverage from the current tests (e.g. bitcoin-test and a
testnet sync) is very unimpressive, and while coverage isn't some
magical silver bullet and does not, by itself, mean the tests are good
flaws in uncovered code can't be detected by the tests.  We also lack
simple testing cycle documentation for people interested in testing
manually to walk through, etc. I think all the meta discussion is not
very useful until we actually have more substance to put into it.
Otherwise I fear we're just building an airport by painting stripes
and waiting for the planes to land...

If someone wants to help and would like a list of some of the testing
I think would be useful, ping me off-list and I can blast some
suggestions. But I assume that anyone who actually wants to work on
this isn't short of ideas, and at this point "work on what interests
you, report what interesting thing you accomplish or discover" is
probably a perfectly fine level of coordination.


-------------------------------------

Yeah. I am still unsure that this really holds. Bitcoin moves fast,
but even so, unless there are a few more SatoshiDice-like events and
the way people use transactions changes dramatically we're a long way
from gigabyte sized blocks.  And once we get there, technology will
probably have improved to the point where it doesn't seem like a big
deal anymore.

Of course we have debated this many times already. Maybe again at the
next meetup :-)


-------------------------------------
I've started a discussion on BIP 16/17 support moving forward
(including trying to improve the testing process) here:
https://bitcointalk.org/index.php?topic=61922.0

(please reply there so the discussion stays mostly in one place)

--
--
Gavin Andresen


-------------------------------------
A bloom filter seems like an interesting idea. However this proposal is concerned mainly with the initialisation stage, whereas this bloom filter is for pushed blocks.

This proposal still updates new transactions and blocks in the same way, and it's not inconceivable to later use a bloom filter to make that part more efficient (although it's questionable if pushing this server side would be a good idea as it would now need to track an additional client state).

________________________________
From: Mike Hearn <mike@plan99.net>
To: Amir Taaki <zgenjix@yahoo.com> 
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net> 
Sent: Wednesday, May 16, 2012 5:46 PM
Subject: Re: [Bitcoin-development] BIP 33 - Stratized Nodes


Thanks for getting this started.

With regards to the specific proposal, I don't believe it's the best option and still plan to eventually implement the original design outlined more than a year ago in this thread:

https://bitcointalk.org/index.php?topic=7972.msg116285#msg116285

Namely that you use a new protocol command to set a Bloom filter on a connection. Only transactions matching that filter will appear in relayed inventory. Blocks that are requested will arrive as a header plus transaction/merkle branch pairs. Clients are expected to maintain and track the block chain as per usual, but instead of downloading the whole chain and then dropping the irrelevant transactions, that filtering is done server side. By strengthening or weakening the Bloom filters you can choose your preferred point on the privacy/bandwidth-usage spectrum. It is a fairly simple change to the Satoshi and BitcoinJ codebases but still allows clients to gain confidence in their balance by examining the chain, and this is true even in the presence of a hijacked internet connection (you can't trust pending transactions that way, but you can still trust confirmed transactions).

The filters would be applied to each data block in each script rather than having a specific knowledge of addresses. In this way you can select for things like multisig outputs or outputs which don't use addresses / pubkeys to authenticate.

I could write a BIP for this alternative protocol if somebody else wants to implement it. I was going to wait until I had time to do both BIP and implementation, but I think some simple optimizations to BitcoinJ can keep its performance good enough for the short term.


-------------------------------------
Hi Martinx,

Another note:

boost 1.42 and openssl 1.0 has a conflict (you will see it when you try to compile coinHTTP with that specific combination: sslv2 has been removed from openssl, but boost still references it.)

You should do a :

sudo apt-get upgrade libboost-dev-all

to get the 1.46.1 library

/M


On 23/02/2012, at 18:31, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
I think there may be an ideal order of ops bug around rescan,
wallet upgrades/import and last block markers.

I dropped an old wallet in a current blockchain.

First ran - in rescan mode.
It said old walletver.
Then rescanned whole chain.
AddToWallet some blockhash, blocks out of range, invalid/nonwallet txid's,
which were already in there as legit ones in the old logs.

Second run in plain mode.
New wallet ver logged.
Rescanned  the last 20k blocks or so,
which might have been the marker last time the old wallet was used.

Third and later runs... duplicates the second.

Never did say 'upgrading wallet' as it sometimes does.

Running detach=1 always.

Why scan the last 20k every time? Shouldn't have to if
whole chain was scanned. And certainly no more than
once if not.

Also...
Dumping the run params (bitcoin.conf, cmdline) to the log would be good.

And not automatically truncate the log when big but just append or roll it.


-------------------------------------
I was baffled by this exact script, too. :)

Big props to Gavin for adding those data-driven test cases. I can't
overstate how useful they are.

Is there interest to port more tests (P2SH, checksig, checkmultisig,
block verification, maybe even DoS rules) into data-driven format? It
might be something that I'd like to help with if pull requests in that
direction are welcome.

On 7/29/2012 6:42 PM, Amir Taaki wrote:



-------------------------------------
I would guess that you are running the blockchain download through the tor-proxy - that would give you the times you mention. Further, encrypting your disk (aes stuff) will not help you much either, and encrypting a the storage of a public blockchain seems to me a bit odd ?

I get a full blockchain from scratch in 45 minutes on my laptop, but, I still agree with Gregory that scalability improvements are needed, but the problem is far from critical in the sense outlined here.

/M 


On 23/07/2012, at 09:35, Gregory Maxwell wrote:




-------------------------------------

I hope that someone else here would chime in on the issue raised in the 
thread, about using a tree-structure that has multiple valid 
configurations for the same set of unspent-TxOuts.  If you use any 
binary tree, you must replay the entire history of insertions and 
deletions in the correct order to get the tree structure and correct 
root.  Along those lines, using something like a red-black tree, while 
theoretically well-known, could be subject to implementation errors.  
One implementation of a red-black tree may do the rebalancing 
differently, and still work for it's intended purpose in the majority of 
applications where it doesn't matter.  One app developer updates their 
RB tree code which updated the RB-tree optimizations/rebalancing, and 
now a significant portion of the network can't agree on the correct 
root.  Not only would that be disruptive, it would be a disaster to 
track down.

If we were to use a raw trie structure, then we'd have all the above 
issues solved:  a trie has the same configuration no matter how elements 
are inserted or deleted, and accesses to elements in the tree are 
constant time -- O(1).  There is no such thing as an unbalanced trie.  
But overall space-efficiency is an issue.

A PATRICIA tree/trie would be ideal, in my mind, as it also has a 
completely deterministic structure, and is an order-of-magnitude more 
space-efficient.  Insert, delete and query times are still O(1).    
However, it is not a trivial implementation.  I have occasionally looked 
for implementations, but not found any that were satisfactory.

So, I don't have a good all-around solution, within my own stated 
constraints. But perhaps I'm being too demanding of this solution.

-Alan



On 06/19/2012 12:46 PM, Andrew Miller wrote:



-------------------------------------
I am trying to post on the bitcoin forums (bitcointalk.org), but I am only able to reply and post on some of the regional forums?!?!? On the bitcoin dev and alternative client forums I have no post / reply button...

I don't consider myself an IT illiterate, and I have even tried to create a new user to see if that would help, but no luck....

Can any of you please share with me the secret on how to post there ???

In the expectation of a embarrassingly simple answer...

Michael




-------------------------------------
I agree with Alan.

I too am happy to see my client listed on bitcoin.org, and I don't mind Bitcoin-Qt being listed first. I have no problem with a "czar" approach if it can solve conflicts.

I believe that it is useful to keep the 'clients' page on bitcoin.org, because it contributes to clarifying the difference between the Bitcoin client and Bitcoin as a protocol/network/ecosystem. It shows that Bitcoin is much more than its original implementation. It is a sign of health.

Thomas



-------- Original-Nachricht --------



-------------------------------------
	849 gavin/testnetmining
	852 Fix #846. Allow negative options in bitcoin.conf
	719 coinbaser
^^ next ^^
	834 sje/BackupWallet
	570 force_send
	806 sipa/threadid
	816 sipa/lameversion
^^ 037497c ^^
	854 laanwj/2012_02_qtipc
	841 sipa/getalltransactions
	787 sipa/addrman
	823 sipa/nodupcon
	829 sipa/multilocal
	568 rpc_keepalive
	565 optimize_FastGetWork
	837 sje/ShowImmatureBalance
	838 laanwj/201202_guiaddsuffix
	853 laanwj/2012_02_altminimizetray
	855 sje/ToggleHide
^^ 4b7e5f5 ^^
	780 checkhashverify
	715 bugfix_client_name
	559 accept_nonstdtxn
	552 base58_liberal_parsing
	553 bugfix_qt_uri_amount_parser
	562 optimize_ToHex
^^ next-test ^^


-------------------------------------
On Thu, Nov 29, 2012 at 06:31:24PM +0100, Mike Hearn wrote:

[snip]

All good reasons, thanks for the explanation.

Though I still like my idea of a ValidatePurchase message that allows
a buyer to ask a merchant "would you accept this payment?" without
actually supplying a signed transaction.  Make it optional if you care
about minimising the number of round trips, e.g. for fast NFC
payments.

Having such a message reduces the extent to which you need to trust
the merchant not to spend a transaction that they've rejected.  (And
in the non-Internet connected case this is particularly useful since
the client won't have the ability to broadcast a pay-to-self
transaction.)

roy




-------------------------------------
On Sun, 2012-07-29 at 20:52 -0400, Gavin Andresen wrote:

I wrote a simple block chain tester (that is capable of forking,
checking invalid blocks, etc) as a part of the bitcoinj test suite.  Its
more targeted at testing bitcoinj directly and keeping the bitcoinj test
suite light weight, so if it were to be more generic some tweaks could
be done (not requiring tweaking the minimum difficulty/genesis block
hash/etc would be first).  It doesn't have that many test cases yet, but
it is capable of sanity-testing reorgs/etc.  Its mostly the first two
commits listed at
http://code.google.com/r/bluemattme-bitcoinj/source/list?name=fullverif

Matt



-------------------------------------
Sorry for the duplication Amir, I meant to send this to everyone:

BitTorrent might be an example to look to here. It's a peer-to-peer network
that has undergone many significant protocol upgrades over the years while
maintaining compatibility. More recent clients have had the ability to
expose the capabilities of connected peers and modify behavior accordingly,
and overall it has worked very well.

Capability-based systems do work, and provide an excellent means of trying
out new algorithms, adding new features for upgraded clients, and when
necessary reverting protocol changes (by depreciating or removing
extensions).

The problem with OpenGL was and continues to be that the two superpowers of
that industry develop and maintain competing proposals for similar
functionality, which are thrust upon developers which must support both if
they want access to the latest and greatest features, until such time that
the ARB arbitrarily choses one to standardize upon (in the process creating
yet another extension of the form ARB_* that may be different and must be
explicitly supported by developers).

I think the BitTorrent example shows that a loosely organized, open-source
community *can* maintain a capability-based extension system without
falling into capability-hell.

Mark

On Sun, Jun 17, 2012 at 9:30 AM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
On Fri, Jun 15, 2012 at 04:58:55PM -0400, grarpamp wrote:

Use -detachdb if you want to detach the blockchain database files from the
database environment at exit. This was turned off by default in 0.6.0 to
speed up the shutdown process very significantly, and few people have a need
to manually fiddle with their blockchain database files.

-- 
Pieter


-------------------------------------

It's usually the right thing to do to be open to future backward-compatible
changes, but I don't know of any such standard, as it equally makes future
non-backward-compatible changes impossible.

Whatever will be defined in the BIP is the standard in this case.



Which is exactly what I want to avoid by defining this up-front.

A versioning scheme can avoid this. Any BIP that breaks backwards
compatibility (for example, adds a multiple-send type or specific
restriction) should increase the version number. A client rejects URLs with
a version number higher than what it knows about.

That's the simplest way to handle it, and enough IMO.

Wladimir
-------------------------------------
Mike,

You make an excellent point.  Neither of these proposals impact the 
protocol itself.  I hadn't considered that.  But I think it's a 
critically important problem to solve (signature blocks, not so much, 
but it could piggy back on the same solution).    So the mailing list is 
a good place to discuss this, but it maybe it shouldn't be labeled as a 
BIP.  I'll leave that up to the others (arguably, the URI scheme is not 
a protocol change, either, but was still a BIP).

There is all this fanfare around P2SH and how multi-sig is the solution 
to all these security problems, but how the hell do you use it?  I 
believe that BIP 10 (or successor) is *critical//*to the success of 
multi-sig, because the greatest barrier to using multi-sig will be the 
ability to actually execute them in less than 14 steps.  And if every 
client implements it differently, there's even less chance it will be 
used (assuming the userbase reaches any level of client diversity).

I think we need to supply a solution to this existing problem before 
everyone starts solving it on their own and fragmenting the market.  No 
one has to use the solution we come up with -- but I believe it's a 
problem for which most developers will take any solution that is easy to 
exchange, size-efficient and promised to be interoperable (if for no 
other reason than the Satoshi client uses it).

-Alan



On 04/03/2012 07:37 PM, Mike Koss wrote:

-------------------------------------
On Mon, Jul 9, 2012 at 2:18 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

Yes, because I reverted eight commits to it by you because they were
clearly controversial, including the proprietary clients section and
blockchain.info.

You went on to add the randomization, again without a pull request
and, as seen here, its somewhat controversial.


Luke originally authored the multiple clients page. It sounded like it
could be useful and I made some recommendations for it too.  I'm
concerned that it's not working out that well. Thus "we should
probably consider".  Perhaps that came off as too strong.  If I really
pushing for that I'd submit it as a pull request. (and everyone,
including the people you listed, could comment)

I think the fact that we can just remove it if we can't agree on it is
a useful point to the discussion.  For the site to be a neutral
resource it should be conservatively operated and if sometimes being
neutral, safe, and conservative gets in the way of being complete then
we should choose those other things over completeness. There are a
great many other resources available, bitcoin.org will never contain
all the relevant knowledge.


Crazy. I have considerable evidence to the contrary, in fact. The wiki
is widely used and promoted as the primary community memory.

I certainly didn't agree with that suggestion because I thought it
wouldn't get seen. I found it agreeable because it would reflect the
lower degree of consensus we apparently have about listing the page.


I've used multibit, armory, and electrum (though not for some time). I
shed painted the electrum determinstic wallet stuff pretty extensively
when it was first created, and I think the wordlist seed stuff was my
suggestion.


I'd like to invite you to point your electrum client against a server
I operate.  I will then happily agree with you that it is more secure:
because the bitcoin I rob from you will soothe my pain at the loss of
this "debate".  Sound like a deal?

I think you're exaggerating the features there, and simultaneously
underplaying the fact that clients doesn't actually participate in the
bitcoin protocol, don't provide the security promises of bitcoin, and
basically leave us with a centralized system (if thats all we had).
It's a worthwhile part of the ecosystem, I agree.


There has been QR integration in bitcoin-qt for some time. ::shrugs::
I don't really understand why you're arguing features here: Yes the
other clients are great things. I never said they weren't.  They are
not, however, complete alternatives to the reference client yet.


Please stop putting words in my mouth. I certainly don't think that.


-------------------------------------
Whats the best way to get performance numbers for modifications to bitcoin
? Profiling it while running on testnet might work, but that would take a
rather long time to get data.
Is there anyway to speed this up  if we only needed to
provide  relative performance between tests. (in a sense a fast performance
regression test).

At least in theory, one possibility would be to replay real
bitcoin transactions  to a test-net-in-a-box network (of maybe a few nodes)
that has the real blockchain history loaded into it but then operates at a
far reduced hash difficulty in order facilitate running quickly.

Are there existing techniques/scripts for  some kind of perf testing with
traffic that at least approximates real world traffic ?
The test infrastructure  that ships with bitcoin does not appear to provide
this.

Thanks,
Ian

-------------------------------------
On Saturday, June 16, 2012 11:39:00 PM Gregory Maxwell wrote:
wrote:

I'm willing to make Eligius reject these as well, if someone provides a patch 
that doesn't depend on IsStandard being enforced...

Same goes for rejecting OP_NOP<n> - I can't see any legitimate reason we'd 
want these on mainnet right now.

Luke


-------------------------------------
I had to hit the sack last night as it was 2am CET, but I'd like to
sum up the discussion we had on IRC about scalability and SatoshiDice
in particular.

I think we all agreed on the following:

- Having senders/buyers pay no fees is psychologically desirable even
though we all understand that eventually, somebody, somewhere will be
paying fees to use Bitcoin

- In the ideal world Bitcoin would scale perfectly and there would be
no need for there to be some "winners" and some "losers" when it comes
to confirmation time.

There was discussion of some one-off changes to address the current
situation, namely de-ranking transactions that re-use addresses. Gavin
and myself were not keen on this idea, primarily because it just
avoids the real problem and Bitcoin already has a good way to
prioritize transactions via the fees mechanism itself. The real issue
is that SatoshiDice does indeed pay fees and generates a lot of
transactions, pushing more traditional traffic out due to artificial
throttles.

The following set of proposals were discussed:

(1) Change the mining code to group transactions together with their
mempool dependencies and then calculate all fees as a group. A tx with
a fee of 1 BTC that depends on 5 txns with zero fees would result in
all 6 transactions being considered to have a fee of 1BTC and
therefore become prioritized for inclusion. This allows a transition
to "receiver pays" model for fees. There are many advantages. One is
that it actually makes sense ... it's always the receiver who wants
confirmations because it's the receiver that fears double spends.
Senders never do. What's more, whilst Bitcoin is designed to operate
on a zero-trust model in the real world trust often exists and it can
be used to optimize by passing groups of transactions around with
their dependencies, until that group passes a trust boundary and gets
broadcast with a send-to-self tx to add fees. Another advantage is it
simplifies usage for end users who primarily buy rather than sell,
because it avoids the need to guess at fees, one of the most
problematic parts of Bitcoins design now.

The disadvantages are that it can result in extra transactions that
exist only for adding fees, and it requires a more modern payment
protocol than the direct-IP protocol Satoshi designed.

It would help address the current situation by avoiding angry users
who want to buy things, but don't know what fee to set and so their
transactions get stuck.

(2) SatoshiDice should use the same fee algorithms as Bitcoin-Qt to
avoid paying excessive fees and queue-jumping. Guess that's on my
plate.

(3) Scalability improvements seem like a no brainer to everyone, it's
just a case of how complicated they are.

(4) Making the block size limit float is better than picking a new
arbitrary threshold.

On the forums Matt stated that block chain pruning was a no-go because
"it makes bitcoin more centralized". I think we've thrashed this one
out sufficiently well by now that there should be a united opinion on
it. There are technical ways to implement it such that there is no
change of trust requirements. All the other issues (finding archival
nodes, etc) can be again addressed with sufficient programming.

For the case of huge blocks slowing down end user syncing and wasting
their resources, SPV clients like MultiBit and Android Wallet already
exist and will get better with time. If Jeff implements the bloom
filtering p2p commands I'll make bitcoinj use them and that'll knock
out excessive bandwidth usage and parse overheads from end users who
are on these clients. At some point Bitcoin-Qt can have a dual mode,
but who knows when that'll get implemented.

Does that all sound reasonable?


-------------------------------------
Hi,

Can we pull this? It's been there for almost 20 days now.


https://github.com/bitcoin/bitcoin.org/pull/32

My comment:
"As a first step, this should probably be pulled right away and then 
any improvements can be made after. Lets get the ball rolling rather 
than debating the colour of the bike-shed!
http://hackerspaces.org/wiki/The_Bikeshed_Anti-Pattern

Although I agree with Mike Hearn - far better would be a grid of 4 
columns and X rows. Each box has a linkable title, a picture and then 
850 word blurb from the project. I mean where would libbitcoin fit in 
here? I'd want to say the design philosophy behind it and that there's 
Python bindings - a circular peg that doesn't fit in the square boxes of this table. Although whatever, that's not important. I'm just happy to 
see MultiBit, Electrum and Armory get exposure."

Anyone that wants to see what it looks like can add this to their hosts file:

176.31.24.241 bitcoin.org

Then navigate to http://bitcoin.org



-------------------------------------
On Tuesday, March 13, 2012 2:06:38 PM Mike Hearn wrote:

Not really an objection per se, but what's wrong with TCP keepalives?


-------------------------------------

Fair enough then, let's take that out.
-------------------------------------
On Wed, May 16, 2012 at 12:46 PM, Mike Hearn <mike@plan99.net> wrote:

Makes sense.

In an idealized model of a client as a set of private keys, they will
want to (a) notice new activity on these keys, (b) notice increased
confidence on existing transactions with those keys [confirmations],
and (c) be able to submit to the network new transactions.  Your
proposal covers those bases, I believe.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Thu, Aug 16, 2012 at 05:05:58PM -0400, Jeff Garzik wrote:

I disagree. Returning an empty "inv" is a very strange way of replying
"empty mempool". Bitcoin P2P is not a request-response protocol, and
"inv" messages are sent where there are inventory items to send. The
reaction to a request (for example "getblocks") can be nothing, or one
or more "inv" messages if necessary. Special casing an empty "inv" to
mean empty mempool is trying to hack a request-response system on top
of the asynchronous system.

If there is need for confirming the transmission of the mempool is
complete, the proposal to use a MSG_MEMTX sounds good to me. No client
will ever receive such an inv without requesting the mempool, and
implementing handling MSG_MEMTX is trivial.

-- 
Pieter


-------------------------------------
On Wed, Sep 26, 2012 at 12:06 PM, Mark Friedenbach <mark@monetize.io> wrote:

As a goal or general principle, this is agreeable.

But slavish attention to this will only get ignored.  There is finite
developer resources, and regression tests for certain types of bugs,
like prickly P2P network interaction bugs or RPC API bugs, could
potentially involve many days or weeks of coding, to sufficiently
simulate the environment.  The ability to easily, automatically and
programmatically reproduce certain classes of bugs is simply out of
reach right now, and nobody is going to shut down development to fix
that problem.

We should move towards this direction, yes, but bitcoin test cases are
not always going to be as easy as writing (say) a compiler testcase.

We can always use the help of a few good QA coders:  simulating a P2P
environment and checking the RPC API are two examples of very
complicated problems that -can- be automated for testing... with a lot
of work.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On 05/03/2012 06:28 AM, Alan Reiner wrote:


Bitcoin Wallet for Android currently ignores both fields. At least
temporarly displaying the transaction message is on my short-term todo list.




-------------------------------------
On Tuesday, November 06, 2012 7:56:23 PM slush wrote:

Perhaps the problem lies in misunderstanding of the BIP process, then, rather 
than awareness of it. BIP isn't just "write a document"; that's just the first 
step. The main thing is that it gets peer review, changed to meet the 
community's needs, and when done should result in a common standard suitable 
to the needs of the whole community. Whatever the reason, there was a failure 
of key members of the community to participate in the GBT BIP process and 
ensure it addressed their needs/wants; identifying and addressing that is 
something that would improve the BIP process.

get_transactions is a step in the right direction, and I don't think anyone 
expects Stratum to reach the same level as GBT overnight considering it took 
months for GBT (though I have no doubt now that the GBT discussions have taken 
place, that some dedicated individual could probably combine the two if they 
dedicated a few days to it). My comments, however, were not intended to bash 
stratum or mere complain about the past (it can't be changed), but an attempt 
to learn from the past and figure out how we can improve things the next time 
around.

Luke



-------------------------------------
----- Forwarded message from Pieter Wuille <pieter.wuille@gmail.com> -----

Date: Sun, 10 Jun 2012 01:10:54 +0200
From: Pieter Wuille <pieter.wuille@gmail.com>
To: bitcoin-development@lists.sourceforge.net
Subject: getmemorypool
User-Agent: Mutt/1.5.20 (2009-06-14)

Hello everyone,

Luke's getmemorypool/BIP22 pull request has been open for a long time, and didn't receive too much discussion.

I think that having a stable and flexible API for negotiating block generation is important to be standardized. The fact that it allows moving block generation to specialized programs is a step in the right direction. However, it seems to me that too few people (myself included) understand all the details of BIP22 (or don't care enough) to judge their necessity. I gave up trying to follow all design decisions some time ago, and as it seems I'm not alone, nobody liked merging support for it in the Satoshi client. This is a pity, and I hope the situation can be improved soon.

I'm sorry for being this late with these comments, but I think it's essential that the standard is not more complex than necessary (making it as easy as possible to write either servers or clients for it), and perhaps even more important, that its purpose and intended use cases are clear.

  1) a miner requests a block template
  2) builds/modifies a block based on this, and optionally uses propose to check whether the server is willing to accept it before doing work
  3) submits when valid proof-of-work is found
I'd like to see this process described in the BIP at least, it too me way too long to extract this.

Regarding the block template: is there a particular reason for sending the full transactions (serialized in hex) both in templates and submissions? The server will always need to have access to the transaction database anyway, and clients will (afaics) rarely care about the actual transactions. My suggestion would be to just transfer txids - if the client is interested in the actual transactions, we have the gettransaction RPC call already. This seems to be captured by the several "submit/*" and "share/*" variations, but making it optional seems way more complex than just limiting the API to that way of working.

That's another thing that bothers me in the standard: too many optional features. In particular, I understand the usefulness of having some flexibility in what miner clients are allowed to modify, but I'm unconvinced we need 10 individually selectable variations. In particular: 
* coinbase outputs: can we just add a list of required coinbase outputs (amount + scriptPubKey) to the template? If no generation+fee amount remains, nothing can be added.
* coinbase input: put the required part in the template; miners can always add whatever they like. Is there any known use case where a server would not allow a client to add stuff to the coinbase?
* noncerange limiting: if coinbase input variation is not limited, there is certainly no reason to limit nonceranges. This adds unnecessary complexity to clients, in my option.
* time/*: put a minimum and maximum timestamp in the template (i believe those are already there anyway). Anything in between is valid.
* transactions/add: what is the use case?
* transactions/remove: i'd just standarize on having all transactions be removable (perhaps except those marked 'required').
* prevblock: one getmemorypool per new block shouldn't be a problem imho, so do a longpoll instead of having the client able to modify prevblock themselves.

One more thing that I do not like is often several ways for specifying the same behaviour. For example, txrequires specifies that the first N transactions are mandatory, a 'required' field in the transaction list itself specifies that that transaction is mandatory, and the lack of transactions as variation means that they must not be touched at all. Pick one way that is flexible enough, and discard the others.

In summary, I'd like to see the standard simplified. I have no problem merging code that makes getmemorypool compliant to a standard that is agreed upon, but like to understand it first. 

In my opinion - but I'm certainly open to discussion here - the standard could be simplified to:
* getblocktemplate: create a new block template, and return it. The result contains:
  * bits, previousblockhash, version: as to be used in block
  * curtime, maxtimeoff, maxtimeoff: client chooses a timestamp between (curtime - local_time_at_receipt + local_time), decreased by mintimeoff and increased maxtimeoff
  * expires, sigoplimit, sizelimit: unchanged
  * subsidy: amount generated (5000000000 for now)
  * coinbaseaux: what generated coinbase's scriptSig must start with
  * coinbaseoutputs: list of objects, each specifying a required coinbase output. Each has fields:
    * amount: sent amount
    * scriptPubKey: hex serialized of the output script
  * transactions: list of object, each specifying a suggested transaction (except for the coinbase) in the generated block. Each has fields:
    * txid: transaction id
    * depends: list of dependencies (txids of earlier objects in this same transactions list).
    * fee: fee generated by this transaction, which increases the max output of the coinbase.
    * required: if present, transaction may not be dropped.
* submitblocktemplate: submit an object containing a hex serialized block header, hex serialized coinbase transaction, and a list of txids. Returns true or string describing the problem. Proof of work is checked last, so that error is only returned if there is no other problem with the suggested block (this allows it to replace both propose and submit).

Are there important use cases I'm missing?

-- 
Pieter


-------------------------------------
Hello,

Even though I'm not a dev, I can't agree more, and would like to know if 
they are expected steps being taken, some fixes coming, or whatever?

Thank you all for your hard work.
Raphael

On 07/23/2012 12:37 AM, grarpamp wrote:



-------------------------------------
Actually I was looking at a screenshot someone sent me because I couldn't
seem to access it even after changing the hosts file (I assumed it was
recent, but I guess not).  It just looked like the regular Bitcoin page
(despite doing a ping on the command line and seeing the expected IP).  Was
there a specific link to click on?    Am I blind?

Is there a process we should use to submit how we think our program should
be represented on the clients page?

-Alan


On Mon, Apr 30, 2012 at 2:31 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
Thanks!

"required 5 posts and 4 hours"

Well, that is not so easy if you cannot post ;) I will apply for whitelisting - strange policy though...

/M

On 19/02/2012, at 17:42, Harald Schilly wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
On 17 December 2012 03:18, Jeff Garzik <jgarzik@exmulti.com> wrote:


Apologies if I am a bit late to the thread.  I bumped into someone that
suggested I take a look at it.  Will try and catch up!

You raise a good point.

Is there no good canonicalization algorithm / library for JSON?

I think that provided that each JSON object has an identifier,
canonicalization of JSON is not that hard.

Then when you hash or sign the canonical form they can be compared reliably.


-------------------------------------
Just copied your bitcoin.conf file to my system and the server connects just fine to RPC on 10332
and I get using curl:

MacGronager:bin gronager$ curl --data-binary '{"jsonrpc": "2.0", "id":"curltest", "method": "getblockcount", "params": [] }' -H 'Content-Type: application/json' http://127.0.0.1:10332
{"jsonrpc":"2.0","result":168299,"error":null,"id":"curltest"}

Didn't do a retest on linux, but I am quite certain that it works there well as I had it running for weeks on port 9332 on amazon.

However, the "port" parameter will not work


and as you can see it connects to 8333 - that for the bitcoin protocol.

I havn't implemented "port" (have a look at the possible options in bitcoind.cpp). It was not on the official help list in bitcoind 0.4.0 (see init.cpp or do a bitcoin/bitcoind -help). But, I can implement it over the weekend if your need it.

I also tested the bitcoind --rpcport=10332 and it worked too using the commandline - both running as server and client.

/M



Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Normally I would consider it an error of the parsing script of blockchain (seen that before), however, this seems genuine enough.

the second transaction is the most amusing - it has an output script which is:
OP_HASH256 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f OP_EQUAL

The hash is the most famous bitcoin hash... - so if you can come up with something that, when hashed with sha256 yields the genesisblock hash you can claim one BTC ;)

It is actually very easy to do (!), however, it is a game only for miners, as non_standard transactions are not relayed between standard clients. So now a miner can have a go creating a transaction redeeming this 1BTC.

Perhaps, Eligius creating that block, might be playing a little christmas game :)

Cheers,

Michael

On 12/12/2012, at 23:09, Eric Lombrozo <elombrozo@gmail.com> wrote:


Michael Grnager
Jens Juels Gade 33
2100 Copenhagen E
DENMARK
Mobile: +45 31 45 14 01
E-mail: gronager@mac.com





-------------------------------------
This discussion sounds to be veering slightly off track.  I think we should
be focusing on how we will ease the transition for new users to get on the
network and use it.  Talking about the necessity and costs of running full
nodes in the future is important, but irrelevant here:  unless we don't
want users who aren't willing to run full nodes, we need to accommodate
users who want to simply "use" the network, not necessarily "support" it.  *I'm
making an assumption here that we want new users whether they use a full
node or not*.  Greg's point looks like it's veering towards "we don't want
to grow the network unless we're going to get more full nodes out of it."
  I'm of the opinion, like Mike Hearn, that the number of full nodes needed
for a healthy network is *not* O(N) in the number of users of the network.
 I expect it to be something more like O(sqrt(N))... or perhaps there's
even an upper limit above which the network gets no benefit, even if all 7
billion humans were using it.  (the bottleneck would be size of blocks and
CPU processing power at that point, not a shortage of full nodes).  Would
we rather have a system that is "full-node-or-nothing" and drive away users
that won't support the network, or accommodate those users with various
gradations of participation?

I believe my proposal for an address-based meta-chain (or something like
it) is *exactly* what is needed in the long run.  It could almost obsolete
this entire discussion.  However, as Greg pointed out there is a long,
treacherous path between the theory I presented, and a working&robust
implementation that can serve as the backbone for future SPV nodes.  I have
every intention to help pioneer that when Armory has other major features
completed (such as multi-sig), but it's not something that we can even
consider in the near- or medium-term as a solution to rely on.  I'd be
surprised if any such solution existed in the next 6-12 months.

I think it is very much in everyone's interest here to encourage new users
to start "using" Bitcoin, even if they don't "support" it.  As long as
there is a convenient channel for interested users to get more information
about the system, the benefits of spending the effort to run a full node,
and the features available in more-advanced clients that they might benefit
from, then I'm not personally concerned about a shortage of full nodes, and
we should carry forward with the idea of promoting SPV nodes for the
really-new users.

-Alan




On Tue, Dec 4, 2012 at 4:41 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------
Spec updated: https://gist.github.com/4120476

Notable changes are:

+ Removed SignedReceipt

+ Replaced Invoice.x509chain with a "pki_type" and "pki_data" to make
using other identity systems cleaner.

+ Added a "Why not an existing electronic invoice standard?" section
to the design notes

-- 
--
Gavin Andresen


-------------------------------------
On Monday, July 23, 2012 12:41:15 AM Gavin Andresen wrote:

Any reason CBlockIndex couldn't cache the coinbase version?


That sounds workable.


I was thinking more of the end-game of changing the rule to simply "if 
version==2, require the height in coinbase" after the point of no return is 
met without any infringement.


-------------------------------------
Just my two cents -- I'm against removing the overview page or moving it to
the wiki. I think other open source clients deserve a mention on the
bitcoin.org page.

Many new people are looking for a good Android client, for example. Rather
than randomly searching on Google or the app store, it's much safer to
follow the link from bitcoin.org. Others are looking for a light clients
because they think the Satoshi one is too heavy.

Again, rather than following random links on a search engine or wiki (not
all users have the common sense required for this) it may be better if they
follow links "audited" (or at least discussed) by this community. I agree
with Jim here.

The reference client is already first in that it can be downloaded directly
from the main page of bitcoin.org. That should stay that way for the
considerable future, as it's the most proven.  The position in the alt
clients list is less important. That said, I'm not a big fan of randomized
order because it's confusing. Come back to the page and it's different.
Some other neutral ordering is probably possible.

Wladimir

On Tue, Jul 10, 2012 at 5:05 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------
On Thu, Dec 6, 2012 at 12:55 PM, Mike Hearn <mike@plan99.net> wrote:



OK. I want to keep the signature field required, though, so how about:

signature: digital signature over a protocol buffer serialized variation of
the SignedPaymentRequest message where signature is a zero-byte array and
fields are serialized in numerical order (all current protocol buffer
implementations serialize fields in numerical order), using the public key
in pki_data.

-- 
--
Gavin Andresen
-------------------------------------
Actually now I'm thinking- I reckon it is so that your transaction gets accepted by the network when it is sent out. At around 20 confirmations, you can be sure that the rest of the network also has 100 confirmations off the original mined block.

Otherwise at 100 confirms, you may have a chain ahead of everyone else or there might be a temporary network partition (islanding) that causes another fork to get built up, then when they rejoin, not everyone has 100 confirms...


________________________________
 From: Amir Taaki <zgenjix@yahoo.com>
To: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net> 
Sent: Friday, January 27, 2012 4:33 PM
Subject: GetBlocksToMaturity
 

Why add 20 to COINBASE_MATURITY there?

The underlying protocol accepts spent transactions at 100 (COINBASE_MATURITY) so this seems more like a measure to put people off spending until 120 confirms. If you are determined enough to hack your client, you can still spend before 120 but after 100.

Why is this?

Did Satoshi overestimate how many competing races there would be between mined blocks?
-------------------------------------
On Fri, Jun 15, 2012 at 11:43 AM, Simon Barber <simon@superduper.net> wrote:

filterload loads a whole new bloom filter from scratch, in one atomic
operation.  Params set, table sized, data input into table.  A
separate filterinit does not make sense for filterload.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------


Yeah well it's up to the people who are making this stuff to decide :)


On Tue, Jan 31, 2012 at 3:27 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

BIP 20 really has no support among implementations such as Bitcoin-Qt, Electrum, MultiBit or Bitcoin-JS. As the most active and visible user facing GUI projects (all with some form of URI Scheme), their opinion carries the most weight. To a lesser degree Bitcoin-Qt has the large majority of users too (although that's a line of reasoning I'd discourage).
-------------------------------------
On 13 Sep 2012, at 09:42, Mike Hearn <mike@plan99.net> wrote:


Sure other things may be done before this, I was seeing this as a change somewhere down the line but not urgent.

@Gregory


Yes, my proposal allows you to do this. You skip out transactions your already have. My proposal is simply better than others because it takes full advantage of the merkle tree structure with minor additions that are simple to implement. How hard is it to get the hashes at a particular level of a merkle tree? Not hard at all. How hard is it to place a selection of transactions from a block into a message Not hard at all. Implementation of the protocol requirements would be a piece of cake. The harder bit would be to create an algorithm to determine the best level of segmentation but this is not required to comply with the protocol.


The motivation to incentivise miners and maintain stronger security? The difficulty only has to be high enough to prevent a cartel of malicious miners taking control of the network, something that is potentially a problem today with the large mining pools. Remember that the more transactions there are the more fees there can be for miners to collect. The more people that are using bitcoin, the greater bitcoins will be worth. A bigger network should be good for miners when relying on fees.


If it's so controversial that it creates a split making two separated currencies then I'd see it turning out like the format wars (VHS vs Betamax and Blu-ray vs HD-DVD). Eventually people will move towards one or the other since it's better for people to have universalised agreement on a system.

-------------------------------------
I'm firmly against a *blackout* - it would harm users' trust in Bitcoin 
since people looking to download the client or to get information about 
Bitcoin may end up in the wrong place. I constantly have to delete 
YouTube spam advertising this or that "miracle GPU miner" or "secure 
Bitcoin client", which of course are all just the same trojan.

As for making a statement or putting up a banner - that's ok with me.

On 1/17/2012 7:15 AM, Gregory Maxwell wrote:



-------------------------------------
On Wednesday, May 02, 2012 12:21:13 PM grarpamp wrote:

Try "Reply to All"


-------------------------------------
On 04/03/2012 02:46 PM, Gavin Andresen wrote:
I'm glossing over details because I actually have no experience dealing 
with character encodings,  or the implementation specifics of existing 
solutions (PGP or S/MIME).   That's why I'm emailing this list: I want 
to figure this stuff out, and at the same time try to converge on 
something that is efficient and can be interoperable between Armory and 
the Satoshi client (wallets, signature collection, sig blocks).

I don't go into these things solely to reinvent stuff.  My primary 
motivation for both ideas I have pitched so far (BIP 0010 and the sig 
blocks) is the versatility.  I like the encoding-independent, visual 
compactness of PGP ASCII-armored text blocks, but I don't like their 
opaqueness.  PGP vs my signature blocks basically look the same to a 
casual user, but even a moderately-knowledgeable user can appreciate the 
human-readable components of it.  You can visually identify if 
signatures are missing from sig-collection packet, or see that you 
signed with the wrong address without having to load an external program.

But that isn't a critical requirement, it's just my personal 
preference.  I'm fine with existing systems if it sidesteps a lot of 
problems and there's easy interface to it.    But, I don't want to have 
another BSDDB-wallet situation where we end up with 10x more capability 
than we need, and pay for it with 10x the complexity (at least in this 
case, using PGP is an existing crypto/security-sensitive technology).  I 
have made "simplicity" one of my goals in Armory.

Alternatively, we could change the discussion to a requirements 
discussion, to first figure out what we need in order to address 
multi-signature collection, etc.  Then evaluate competing ideas based on 
their qualities relative to the requirements.





-------------------------------------

On 13 Sep 2012, at 16:51, Gregory Maxwell <gmaxwell@gmail.com> wrote:


A merkle tree root is found by hashing the two children together and those children are found the same way until you get to the greatest level down the tree. This means you can validate children as being correct as long as they hash together to form the root. This means you do not need all the transaction hashes to validate segments of the block, you only need the root hashes for all the segments you want. Let's say there are 8 transactions and you want to verify 4 segments (2 transactions each), The merkle tree looks like this (Might not work depending on the font):

Level 0:               *
                      / \
                     /   \
                    /     \
                   /       \
                  /         \
                 /           \
                /             \
Level 1:       *               *
              / \             / \
             /   \           /   \
            /     \         /     \
Level 2:   *       *       *       *
          / \     / \     / \     / \
Level 3: *   *   *   *   *   *   *   *

When you look at any non-leaf node you can see a separate merkle tree where the root can be found exactly the same as any other merkle tree. In this example you want four segments, so you ask for level 2. Now imagine a tree without level 3, you can validate the root with level 2. In fact you can validate that the root exists for any level. So you first check that the level 2 hashes do indeed calculate to the root. Once this is done you can now use these hashes to validate the segments. When you receive a segment, you check that segment against the segment's root. So you've validated the segment transactions for the segment root and the segment root was validated for the entire tree's root. You validate the segments for each segment root and this way you know all the transactions are valid for the four segments and thus are valid for the entire tree. This way you have downloaded 4 hashes instead of 8. 

Downloading the transactions hashes are therefore not necessary only the level for the segment roots. You might for instance want to divide the block into two segments in which case you ask for level 1 and download 2 hashes.

I hope that made sense.

And yes the merkle tree is particularly useful for validating a single transaction exists in a block as that saves a large proportion of the data required. The redundant data removed in the proposal here is smaller as a proportion of the total data (Because most of the data is the actual transactions themselves), so you might argue it's not worth it but it's simple to implement.
-------------------------------------

That page was old, it stated that pending transactions aren't provided
to the app which hasn't been true for a long time.

I've rewritten and extended it. You may still not like what it says ;)
but it should at least be more thorough now. It also links to the ETH
paper.

Re: Electrum. In fairness the electrum page is designed for end users
and the bitcoinj page is designed for app developers. As far as I
know, there are no bitcoinj based clients that try to explain
transaction confidence to end users.

I don't think it's worth worrying about this too much right now. In
future the software end users and merchants use will diverge
significantly. At that time it'll be easier to tailor the
documentation to each user demographic. And I think Electrum type
services will go away once we do more optimizations like bloom
filtering and better peer selection logic, as the speed of SPV clients
will be comparable to Electrum/BCCAPI type clients but without the
need for a specific server operator.


-------------------------------------
On Monday 26 November 2012 22:37:31 Gavin Andresen wrote:


Personally, I'd like to see fewer implicit ties to X509.  With X509 as one 
option.  For example, I'd much prefer to see a doorway to the future left open 
like this:

    message Invoice {
        repeated bytes issuerIdentityType;
        repeated bytes issuerIdentityBytes;

or similar, instead of "x509chain".

In particular two additional identification types:

 - GnuPG (obviously)
 - Hash based

The hash-based system would be there as a method of leveraging an existing 
trusted connection, without needing to get into the nitty-gritty of 
certificates.  For example, I am paying for something on a web site; I 
presumably already have a secure connection that I trust to that site.  That 
site can issue me an invoice (which is to be sent to the bitcoin client) _and_ 
a hash of the certificate on the same page.

I trust that hash because I received it over a secure connection from a 
trusted source.  When my bitcoin client pops up with the received invoice, it 
shows me the hash of the invoice, and I can be sure that it is from the web 
site I thought it was from.

Imagine I'm a (very) small business, I have two or three customers.  I want to 
email one of my customers an invoice.  I don't want to have to get an X509 
certificate, and I don't necessarily know how.  However, I can ring my 
customer up and say "I've generated an invoice with my bitcoin client, it is 
hashed A7DE-521X-9977.  Write that down and confirm it when you get my 
invoice".  Alternatively, I might attach a file called
invoice-A7DE-521X-9977.bitinv to a signed GnuPG email.  The receipient can 
easily confirm I sent it because the filename must match the contents and 
GnuPG protects against tampering.




Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Monday, November 26, 2012 11:16:03 PM Mike Hearn wrote:

That's expected behaviour - except it's mainly be manipulated by *users*, not 
viruses (which can just as easily manipulate whatever custom cert store we 
use). If I don't trust Joe's certs, I don't want Bitcoin overriding that no 
matter who Joe is or what connections he has.


Browsers with this bug are not relevant IMO.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Peter,

Thank you for your in depth, forthright and professional response. You
have answered my questions.  And you have cleared up a lot of
confusion I had in my mind. (and I read ditto as i dont know) I
appreciate the extra information. :)

This is a top post and there is nothing inline so i snipped it.

cheers,

steve

On 03/10/2012 06:03, Peter Vessenes wrote:
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQbGKXAAoJEFvEB9dQFvtQ5QcIAJR0RlkjUb5Xm09eo7wjV2QV
IYXbyOBx6bZWox0wxmbygpPL23grEKxlehavf18Q1S6VjdtFs75K5GV83FZb9KPk
YeB0hz5ht48Ig7uQ3zu7MBCaNerTst+6fQ/k5Uu6l2WKCVwk18WykGrnXMnSTbpM
qONQCc4HQhOm7sgEsJD9KNp73eGZt/BG0hQAa8zLh2rHA0to8TER9nRUUx+mH0uf
Cj58EXKVz5WI5+G31M/4v4UgRRv3Z7efaVbczrvhvv6DZfVkCpuD6t0kt2ZlcFCn
oO1sKD05/VtC7DZxQvPEvvkikOp8onmue0xCJBvDpG269Xr55qNqGM039Yjy80c=
=1NTS
-----END PGP SIGNATURE-----


-------------------------------------
On Mon, Dec 3, 2012 at 10:17 AM, Alan Reiner <etotheipi@gmail.com> wrote:

Yea, the obvious case would look for exact matches—  but because sane
software pays change to fresh addresses I expect this to trigger an
unfortunately infrequent amount of time.

Why do you bother with the 5 input limit?  The way I'd handle this in
the reference client is as a pure post-processing step. E.g. take any
w/ change transaction formed and try adding small inputs in a greedy
fashion until the next would change the fees. Do you see a reason not
to do this?

A next step up in infrequency is to use input taint tracking
information to gather up coins from all inputs which are already
crosslinked.  In the reference client, which doesn't avoid
crosslinking, this would likely be quite effective but I worry about
having an O(N^2)-ish algorithm as part of coin selection. And so I
think it would require maintaining in the wallet the cross link
history for each address rather than building it on the fly. This
seems like a lot of changes for a relatively modest optimization.

Another possibility would be to not apply the privacy rule to very
small inputs or to addresses which have only ever received a very
small sum total. But I don't know how to define very small in a robust
way, and I think that the privacy behavior of the software being
"inconsistent" from the users perspective would be somewhat
unfortunate.  Perhaps a setting for the value considered very small
for this purpose which defaults to the relay MINFEE?   (And also
include larger outputs when they're address matches).

The the problem with this is this:  Say I have an address 1GMaxwellFOO
 that everyone knows belongs to me. Someone who wants to identify all
my transactions sends me a constant spray of 1e-8 inputs to
1GMaxwellFOO.  If the address association is ignored (even for only
very small inputs) then all my transactions become rapidly
identifiable.    Privacy, of at least a basic form, is an important
element of the system, if it's not preserved than bitcoin is inferior
to traditional value transfer systems in an additional way.

(And FWIW, I've seen self-appointed sluths on IRC trying to catch
trouble makers by paying tiny amounts to their extortion addresses;
with the incorrect expectation that it would taint their other
transactions. So even when it doesn't usually work people have tried
using this to attack people)


-------------------------------------
FWIW, all this argumenting is why my original suggestion for a Clients list 
focussed on objective information in alphabetical order.


-------------------------------------
BIP16: 37% support vs 4% oppose
BIP17:  4% support vs 0% oppose


-------------------------------------
OK, pull request seems good.

FYI we lost money on last year's conference, and are hoping to break even this year. The only people to make profit will be nefario and anyone else we give a share in it (people who help realise it). Otherwise money made goes towards next year's conference and paying for things to make a better conference (like Gavin wanted to attend but couldn't afford a ticket). It is not a commercial event, and I've been pushing to keep the sponsorship and community parts highly separated. Like I really do not wish to sell a speaker slot, but if I have to (to pay the bills) then it will be obvious due to scheduling and disclaimers that speakers are sponsors.



----- Original Message -----
From: Luke-Jr <luke@dashjr.org>
To: bitcoin-development@lists.sourceforge.net
Cc: Jeff Garzik <jgarzik@exmulti.com>; Amir Taaki <zgenjix@yahoo.com>
Sent: Tuesday, July 17, 2012 2:09 AM
Subject: Re: [Bitcoin-development] bitcoin.org - remove hackathon

On Monday, July 16, 2012 11:47:02 PM Jeff Garzik wrote:

IMO, bitcoin.org is more community-focussed anyway.
How often do devs use the site, compared to GitHub etc?

Someone else made a pullreq for Bitcoin Magazine; I suggest(ed) that
for-profit organizations should be asked to pitch in some way or another.
Who should organize that, I don't know. If Bitcoin Consultancy/Amir is behind 
the conference, I suggest their/his development contributions should be 
sufficient in that respect.


I concur, this should be discussed in a pullreq.



-------------------------------------
I think that the "send to private address" field will require more effort
to implement than the simpler "expires" and "message" fields and should be
deferred to a later BIP. There is a pressing need for expires and the only
point of contention I see is the inclusion of a dual representation (block
or timestamp).

Personally, I feel that simple is best and while a block number represents
Bitcoin's pulse, there is no guarantee that a block will be discovered at
any particular moment. From a merchant perspective the main point of the
expires field is to limit risk against currency movement (immediate cash
out) or inventory movement (time limited offer). I have difficulty seeing a
good use case that would need a block. People have been co-ordinating
events based on a UTC timestamp for decades and I think we should stick
with it.

Regarding the "version" field I again think it adds unnecessary complexity.
Pretty much everything that is needed within the Bitcoin URI scheme can be
encoded with suitable optional fields (as query params) making the whole
structure forward compatible. Having a version field seems redundant.

Finally, the URI signing mechanism. Apologies for the earlier
misunderstanding, I was reading from a limited description and it didn't
make the purpose clear. I've since used
https://bitcointalk.org/index.php?topic=58534.msg689190#msg689190 as my
reference which is a lot clearer. I think it's a good idea, and I'll
definitely support it in my MulitBit Merchant project, but it currently
seems to need more work so I think should be deferred into a dedicated BIP.

On 31 January 2012 08:35, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------


Git repos are backed by strong hashes. Each commit could be a single
block dump, perhaps into a file hierarchy. Trusted entities, pools, etc
could sign at a checkpoint/height. Blockchain tools
would need made that can take the blk* and export single blocks and
process/export up to a certain block and quit. Everyone would do a
comparison and sign a commit hash. Everyone else git pulls. Having
the block toolset is a key prequisite to any sort of distribution. They don't
exist now :( Maybe the two bitcoin compatible library projects out there
will implement them :) Torrents are also strongly hashed and could be
signed as well.

Making the blockchain tools would be the most important thing to start.


If that means not validating the chain, then it's as above. I'm not sure if it's
right to not care about the history if only making new transactions with a new
key post install time and then only validating new transactions as they come
in. Will have a look.


-------------------------------------
On Sun, Feb 19, 2012 at 5:45 PM, Michael Grønager <gronager@ceptacle.com>wrote:


It was instated in times that the forums were much more busy. There were a
lot of new people that trolled the forum with questions immediately, which
were answered throughout the forum already. This policy forces people to
hang around the newbie forums a bit before being able to post to the "full"
forum. I'm not sure it's really needed anymore -- anyway, it used to be
much more strict and you'll have no problems getting whitelisted.

Wladimir
-------------------------------------
I'd emailed steve last week to try and get a look at the test cases and
such he worked up, but I've not heard from him. Other then that, I'll grab
the RC tonight and go through it.

Arklan

----------
As long as there is light, the darkness holds no fear. And yet, even in the
deepest black, there is life. - Arklan Uth Oslin

I want to leave this world the same way I came into it: backwards and on
fire. - Arklan Uth Oslin



On Thu, Oct 11, 2012 at 9:59 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
On Thu, Nov 8, 2012 at 10:19 AM, Mike Hearn <mike@plan99.net> wrote:



Well I think regularly scheduled IRC meetings are a good idea, as for some
smaller decisions quick brainstorming tends to work better than long e-mail
threads.

But indeed big and important decisions should be posted on the mailing list
too.



Agreed in that we don't need a "number allocation king". But some rules for
the numbering can be good to keep sanity. What about very simply "everyone
that wants to create a BIP picks the next available number and reserves
that page on the Wiki?".



I'm not sure about a full feature freeze. I agree it could be wise not do
any more changes of the scale of ultraprune before 0.9, to give some
stability to fix the kinks in the current version.

Wladimir
-------------------------------------
Hi everyone,

I wish to submit the following draft BIP for discussion and possible
formal BIP review.

https://en.bitcoin.it/wiki/BIP_M_of_2_DRAFT

It is a proposed alternative to BIP 16 ("/P2SH/").

Thank you,
Ben Reeves


-------------------------------------
It sounds OK as long as you exclude nLockTimed transactions.

That said, if you broadcast a transaction that does not meet the fee
rules, you should be able to notice that it wasn't accepted by your
peers immediately. Today it's painful because the protocol isn't very
chatty - in bitcoinj I plan to do this by announcing to half the
connected peers and waiting to see if the transaction comes back on
the other half. Getting a response from a peer that the TX was dropped
for reasons {x,y,z} is a better design but needs another protocol
change.

So having transactions expire would address the case where somebody
broadcasts a transaction that successfully propagates across the
network, but then isn't actually accepted by miners for some reason.
For instance due to a change in the default fee schedules. That risk
can be mitigated somewhat by being careful about such changes (timed
phase ins set multiple months out so people have time to upgrade,
alerts announcing it, etc).

I'm not sure we should be encouraging users to attach fees to
transactions though. Even if you can replace a transaction after a
couple of days, the user experience of trying to get the fee "right"
is atrocious. I don't think any sensible merchant will actually be
willing to put their customers through this nonsense. If somebody
broadcasts a transaction that successfully propagates across a big
chunk of the network but then gets stuck due to lacking sufficient
fees, the best fix is for the merchant to broadcast another
transaction that spends the first and increases the fees on it that
way. After this happens a few times, if I was a merchant I'd be
tempted to just ask buyers to submit the TX to me directly and I'll
handle keeping up with what miners currently charge and attaching
fees. I don't want my customers to have to think about this and have
trades spuriously fail when they forget.

That design requires a minor change to how fees are calculated inside
the memory pool, to include fees on un-included dependencies. But that
seems fairly uncontroversial to me. It's best for users, merchants and
miners to not leave chains of transactions in limbo when together
their fees add up to the minimum required amount.


-------------------------------------

It was a private conversation for some reason.


Ah OK. I wasn't paying much attention to those threads.


-------------------------------------
On 2012 June 26 Tuesday, Pieter Wuille wrote:


Yuck.  Can't we pinch a few of the addr.services bits to store an address 
family?  AF_INET, AF_INET6, AF_CUSTOM_TOR, and leave space for a few more 
would be, say, four bits out of 64 mostly unused.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Mon, Nov 26, 2012 at 05:37:31PM -0500, Gavin Andresen wrote:

I'm not sure this is actually as much of an advantage as you'd expect. I
looked into Google Protocol buffers a while back for a timestamping
project and unfortunately there are many ways in which the actual binary
encoding of a message can differ even if the meaning of the message is
the same, just like JSON.

First of all while the order in which fields are encoded *should* be
written sequentially, parsers are also required to accept the fields in
any order. There is also a repeated fields feature where the
fields can either be serialized as one packed key-list pair, or multiple
key-value(s) pairs; in the latter case the payloads are concatenated.

The general case of how to handle a duplicated field that isn't supposed
to be repeated seems to be undefined in the standard. Yet at the same
time the standard mentions creating messages by concatenating two
messages together. Presumably parsers treat that case as an error, but I
wouldn't be surprised if that isn't always true.

Implementations differ as well. The current Java and C++ implementations
write unknown fields in arbitrary order after the sequentially-ordered
known fields, while on the other hand the Python implementation simply
drops unknown fields entirely. As far as I know no implementation
preserves order for unknown fields.

Finally, while not a Protocol Buffers specific problem, UTF8 encoded
text isn't guaranteed to survive a UTF8-UTFx-UTF8 round trip.  Multiple
code point sequences can be semanticly identical so you can expect some
software to convert one to the other. Similarly lots of languages
internally store unicode strings by converting to something like UTF16.
One solution is to use one of the normalization forms such as NFKD - an
idempotent transformation - although I wouldn't be surprised if
normalization itself is complex enough that implementation bugs exist,
not to mention the fact that the normalization forms have undergone
different versions.

I think the best way(1) to handle (most) the above by simply treating the
binary message as immutable and never re-serializing a deserialized
message, but if you're willing to do that just using JSON isn't
unreasonable either.


1) Of course I went off an created Yet Another Binary Serialization for
my project, but I'm young and foolish...

-- 
'peter'[:-1]@petertodd.org
-------------------------------------

I meant for anyone who wanted to distribute the dataset as a project.


Rather than use dated/modified packages, I compiled current versions
of all component sources manually.


True. Used them all before, happy with BSD for now. Just knowing
what the general setup is on those zippy systems should suffice.
ie: blindly fishing for such a zippy system to compare through various
install tests doesn't sound too appealing. It's different than benchmarking.

Datapoint: The system below is not zippy.


Am I correct in guessing that, given a certain height, the data
in blkindex and blk0001 should be the same across instances?

# file blk*
blk0001.dat:             data
blkindex.dat:            Berkeley DB (Btree, version 9, native byte-order)

Pursuant to comparison, what is the format of blk0001.dat?


I'm not running Linux with asynchronous data and metadata
turned on by default if that's what you mean :) ZFS, disk crypto,
standard drive write cache. Looking at it, I'm largely buried in
that crypto at 8MB/sec or so.


Hmm, I compiled everything with the defaults. Will go back and
look at bdb options. I don't think there was anything interesting
there. I'd bet a lot is tied to the fs and cpu.
Single core p4@1.8 512k/2g isn't much up against ZFS+disk crypto.

It seems to take its time and roll up all but the last database file (of
a hundred or more) on receiving sigterm. Is it supposed to roll
and delete the last log too? Can I safely delete everything but
the blk* files? (wallet excepted of course :)

Currently, in KiB...

running:
853716  database
747881  blk0001.dat
290601  blkindex.dat
4361    addr.dat
137     __db.005
137     __db.004
137     __db.003
137     __db.002
41      __db.006
25      __db.001

sigterm:
750569  blk0001.dat
291497  blkindex.dat
8465    database/log.0000000nnn
4361    addr.dat

database/log.0000000133: Berkeley DB (Log, version 16, native byte-order)


-------------------------------------
Seems ... acceptable from first glance.

Though I propose an ammendent to either

(1)

make the script: OP_NOP1 HASH160 <push-20-byte-hash> EQUAL to make it 
extremely easy to see from the first byte that this is verly likely to be 
a special transaction (or more accurately if the first byte isn't 
OP_NOP1 then you immediately know it isn't a special script and can even 
disregard the token).

or

(2)

If you are feel like spending another byte make the script:
OP_NOP1 <push-special-script-version-number> <special-script>

and assign 1 to this special script, making this case:

OP_NOP1 OP_1 HASH160 <push-20-byte-hash> EQUAL

On Mon, 2 Jan 2012, Gavin Andresen wrote:


-- 
Russell O'Connor                                      <http://r6.ca/>
``All talk about `theft,''' the general counsel of the American Graphophone
Company wrote, ``is the merest claptrap, for there exists no property in
ideas musical, literary or artistic, except as defined by statute.''


-------------------------------------
I think the strong verification would go well if you add it along with an
optimization that avoids rechecking transactions that have already been
verified as valid. Any transactions it doesn't have to verify are from the
pool, of course :)

On Thu, May 24, 2012 at 7:33 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
Why add 20 to COINBASE_MATURITY there?

The underlying protocol accepts spent transactions at 100 (COINBASE_MATURITY) so this seems more like a measure to put people off spending until 120 confirms. If you are determined enough to hack your client, you can still spend before 120 but after 100.

Why is this?

Did Satoshi overestimate how many competing races there would be between mined blocks?
-------------------------------------
On Fri, Feb 3, 2012 at 9:22 AM, Michael Grnager <gronager@ceptacle.com> wrote:

I think that tag's in
https://gitorious.org/+bitcoin-stable-developers/bitcoin/bitcoind-stable
- a certain amount of developer politics seems to be involved, and
v0.5.2 may not have been pushed to the official github repository.


-------------------------------------
Full conversation starts here:
  http://bitcoinstats.com/irc/bitcoin-dev/logs/2012/02/14/5#l2892558

Summary of what was discussed/decided; please correct anything I get wrong:

1. BIP 16 support is at about 34% of hashing power, so we'll continue
to ask big pools and miners to upgrade and will re-evaluate support on
March 1'st, with a potential switchover date if there is enough
support of March 15'th.

2. On February 20'th the protocol changes to include checksums on the
initial version messages. version includes an 'addrFrom' field with
your IP address, and there are (unconfirmed) reports of NAT routers
changing the contents of packets to modify the inside-the-NAT IP
address to the outside-the-NAT address. If you've got a router that
does that, then the version message checksum will be wrong and you'll
be unable to connect.

Two things are being done to address this:

+ A patch that puts the outside-the-NAT IP address in addrFrom. That's
a good idea in any case, exposing interior IP addresses was a mistake.
There will be either a 0.5.3 or 0.5.2.1 release available for anybody
affected.

+ An alert will be sent next Friday on the main network directing
people to a to-be-created bitcoin.org/feb20 web page explaining the
issue.

3. The third issue was how to deal with potential chain-splitting
attacks involving duplicate coinbase transactions. The general
consensus is that in the long-term requiring that the first four bytes
of every coinbase be the block height is the best solution, but
looking for and 'discouraging' just blocks that have duplicate
coinbases is a reasonable short-term solution.

There's still some research and thinking to be done on this issue (see
the IRC discussion for details), but I expect that the final version
of bitcoin-qt/bitcoind version 0.6 will be putting the block height
into coinbases that it creates.


-- 
--
Gavin Andresen


-------------------------------------
On 25/07/2012 10:45, Michael Grnager wrote:

They can be, it depends on how they are set up.  For reference, these
VM's used to test network stacks and file format bugs.  They do this
via debug tracing, trace into, not over.  They then dump this data in
files and it can keep up with a core2 duo laptop for file io. however
I moved to using an in ram database (4gb chunks, that then get dumped
over the network port to a db on a seperate machine)

I am not sure I have the skills to instrament this into bitcoind


I will test that when I get back :)


will do, thanks for the response. :)

Live Security Virtual Conference
------------------------------------------------------------------------------




-------------------------------------
Mark,

That's a great development. Virtualbox has less requirements with regard to
specific CPU flags, KVM is really slow without hw virtualization whereas
Virtualbox is usable on older CPUs.

It also means I can do gitian builds together with other running virtualbox
instances. KVM and Virtualbox don't play along well.

Wladimir

On Fri, Jul 13, 2012 at 10:41 PM, Mark Friedenbach <mark@monetize.io> wrote:

-------------------------------------
On Thu, Nov 8, 2012 at 4:19 AM, Mike Hearn <mike@plan99.net> wrote:

I agree on getting the bloom filtering stuff in for 0.8, though I
don't think it'll need any marketing at all— ultraprune speaks for
itself. :P
I'm also concerned about overselling it for miners and merchants when
the ultraprune stuff is such a major change.

Since the current changes will just need a lot of testing and soaking
time which is pretty much independent of RPC and GUI changes it might
be unfortunate to feature freeze those things and then have a long
delay just on QA for the other stuff.  I do think we need to talk
about what we think we need to o to get what we have now ready for
release.


-------------------------------------
I agree we need a payment protocol, but instead of thinking of all of the
things we might possibly want I would like to solve a few boring problems
that we have right now.

Absolutely critical:

+ Bitcoin addresses by themselves are insecure against man-in-the-middle
attacks. We need a payment protocol so if you get a donation link for
"Bitcoin Foundation" in an email message and click on it you can be
reasonably certain that your coins will actually go to the Foundation and
not some hacker at your ISP that modified the email message.

+ After sending payment I should have a receipt that proves I followed the
payee's instructions, so if the payee says they never received the funds I
can prove that it wasn't my fault.

+ Protocol for gathering signatures from multiple devices
(extension/variation of the basic payment protocol, I think).

Not absolutely necessary, but I think v1 should have it anyway:

+ Where-to-send-refund information included with payments, so
overpayments/refunds can be handled efficiently and displayed intelligently
in the customer's wallet.


Everything else I think can wait.

-- 
--
Gavin Andresen
-------------------------------------
On 01/28/2012 02:45 AM, Luke-Jr wrote:


Bitcoin Wallet for Android implements only parts of this spec:

The hexadecimal notations (x) and exponent notations (X) feel horribly
redundant to me and are thus not implemented.

"label" and "message" parameters are not implemented right now, but will
probably be in a later version.

"send" is also not implemented.

Cheers,

Andreas



-------------------------------------

Of the three currently published proposals, all are essentially IANA
registry proposals.

We are currently working with IETF staff, with open offers of support
from multiple well funded commercial bodies, to transition these
proposals through to IANA management.

It appears that the Independent Stream Editor path will be used to
transition these through to IANA, at which time the proposals
themselves will be converted to Informational status.

(As far as I understand right now, Within the IETF, Standards Track
has special meaning and entails relatively large degrees of
bureaucracy that are not within the current contributors' resources.
It is also worth pointing out that many popular protocols implemented
on the majority of systems (IIRC, such as IMAP) never reach formal
standardization for this reason. It should be noted that in these
cases, this does not make the protocols any less attractive as
potential components for system implementation.)


As outlined in the previous post:
  - Internet Financial EXchange (IFEX). A proposal under development
that facilitates the negotiation of financial transactions between
internet-based financial endpoints. (The area we would love your
input) http://www.ifex-project.org/our-proposals/ifex

As well as the information linked to above, significant but not
particularly well grounded discussions have occurred regarding the
IFEX-based paradigm for settlement versus some other proposed
paradigms, in particular Ripple (as it appeared some months ago),
which can be read here:
https://groups.google.com/forum/?fromgroups#!topic/rippleusers/v4bEBZZVEsA[1-25]

Kind regards and with the hopes of combining our efforts as a joint
proposal that can benefit other currencies/commodities and settlement
systems as well as Bitcoin,
Walter Stanish
Skype:walter.stanish


-------------------------------------
I've had some push-back on the names of the proposed messages-- e.g.
"Invoice" in the accounting world means "I've already given you a
product or service, here is what you owe, payment terms, what forms of
payment are accepted, etc."

I think there might also be confusion about why we're defining our own
Invoice when there are at least three or four other existing standard
for electronic invoices.

So unless there is strong objection I'm going to change the names of
the messages:

Invoice -->  PaymentRequest
Payment : ok as-is
Receipt --> PaymentACK  (payment acknowledgement)

On Tue, Dec 4, 2012 at 12:06 PM, Mike Hearn <mike@plan99.net> wrote:

BIP 0001 says:  "If in doubt, split your BIP into several well-focussed ones."

I think it makes sense to keep the URI extension separate from the
binary message format.


Ok.

-- 
--
Gavin Andresen


-------------------------------------
Hi Michael,

 Thank you for your attention!

 Now, I'm trying to start libcoin's bitcoind using high ports but, it
always try to listen at 8332, no matter what I "say"...

 Look:

$ cat .bitcoin/bitcoin.conf
server=1
daemon=1
rpcuser=libcoin
rpcpassword=LibCoin13
rpcport=10332
port=10333

 But:

/usr/local/bin/bitcoind
Error: Address already in use

terminate called after throwing an instance of 'DbException'
  what():  DbEnv::close: Invalid argument
Aborted

 When I "strace it", I can see:

...
bind(12, {sa_family=AF_INET, sin_port=htons(8333),
sin_addr=inet_addr("0.0.0.0")}, 16) = -1 EADDRINUSE (Address already in use)
...

 I already tried:

/usr/local/bin/bitcoind --rpcport 10332
/usr/local/bin/bitcoind --rpcport=10332

 Without success...

Thanks again!
Thiago

2012/2/24 Michael Grønager <gronager@ceptacle.com>

-------------------------------------
On Tue, 2012-03-13 at 14:45 -0400, Luke-Jr wrote:
It wont tell you if the node itself is overloaded (not just the OS'
network stack).

Looks good to me.

Matt



-------------------------------------
Jim, perfect idea with some logo indicating wallet compatibility! This
should cover BIP32 + some mnemonic algorithm for easy transferring of
wallets across various clients.

Btw I asked ThomasV for making BIP from his mnemonic algorithm and he
agreed, so I believe some proposal will be here pretty soon.

slush

On Tue, Dec 4, 2012 at 7:56 PM, Jim <jim618@fastmail.co.uk> wrote:
-------------------------------------
Flights booked. Mike Hearn and I will be there. :)

On 6/22/2012 1:03 AM, Amir Taaki wrote:




-------------------------------------
On Sunday, January 29, 2012 6:02:30 PM Matt Corallo wrote:

No, that never had a consensus.


As everyone can observe from your bitcointalk links, you didn't begin trolling 
until months after the URI Scheme was Finalized (in January 2011).


-------------------------------------
Bitcoin version 0.7.0 release candidate 1 binaries are now available
for download at:
  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.0/test/

Please use the issue tracker at
https://github.com/bitcoin/bitcoin/issues to report bugs.

Notable changes:

Qt GUI
------
* Add UI RPC console / debug window
* Re-Enable URI handling on Windows, add safety checks and tray-notifications
* Add 2 labels to the overviewpage that display Wallet and Transaction
status (obsolete or current)
* Extend the optionsdialog (e.g. language selection) and re-work it to
a tabbed UI
* Merge sign/verify message into a single window with tabbed UI
* Improve error reporting at startup
* Fine-grained UI updates for a much smoother UI during block downloads
* Reorganize tray icon menu into more logical order
* Persistently poll for balance change when number of blocks changed
* Much better translations
* Added 'immature balance' display on the overview page
* (Windows only): enable ASLR and DEP for bitcoin-qt.exe
* (Windows only): add meta-data to bitcoin-qt.exe (e.g. description)

Bitcoin Improvement Proposals implemented
-----------------------------------------
BIP 22 - 'getblocktemplate', 'submitblock' RPCs

JSON-RPC API
------------
* Internal HTTP server is now thread-per-connection, rather than
  a single-threaded queue that would stall on network I/O.
* Internal HTTP server supports HTTP/1.1, pipelined requests and
  connection keep-alive.
* Support JSON-RPC 2.0 batches, to encapsulate multiple JSON-RPC requests
  within a single HTTP request.
* IPv6 support
* Added raw transaction API.  See https://gist.github.com/2839617
* Added 'getrawmempool', to list contents of TX memory pool
* Added 'getpeerinfo', to list data about each connected network peer
* Added 'listaddressgroupings' for better coin control
* Rework gettransaction, getblock calls. 'gettransaction' responds for
  non-wallet TXs now.
* Remove deprecated RPC 'getblocknumber'
* New blockchain checkpoint at block 193,000
* listtransactions output now displays "smart" times for transactions,
  and 'blocktime' and 'timereceived' fields were added


P2P networking
--------------
* IPv6 support
* Tor hidden service support
* Attempts to fix "stuck blockchain download" problems
* Replace BDB database "addr.dat" with internally-managed "peers.dat"
  file containing peer address data.
* Lower default send buffer from 10MB to 1MB
* proxy: SOCKS5 by default
* Support connecting by hostnames passed to proxy (-proxydns)
* Add -seednode connections, and use this for -dnsseed + -proxydns
* Added -externalip and -discover
* Add -onlynet to connect only to a given network (IPv4, IPv6, or Tor)
* Separate listening sockets, -bind=<addr>


Internal codebase
-----------------
* Additional unit tests
* Compile warning fixes


Miscellaneous
-------------
* Reopen debug.log upon SIGHUP
* Bash programmable completion for bitcoind(1)
* On supported OS's, each thread is given a useful name

Thanks to everybody who contributed to this release:
=======================================

Chris Moore
Christian von Roques
David Joel Schwartz
Douglas Huff
Fordy
Gavin Andresen
Giel van Schijndel
Gregory Maxwell
Jeff Garzik
Luke Dashjr
Matt Corallo
Michael Ford
Michael Hendricks
Peter Todd
Philip Kaufmann
Pieter Wuille
R E Broadley
Ricardo M. Correia
Rune K. Svendsen
Scott Ellis
Stephane Glondu
Wladimir J. van der Laan
cardpuncher
coderrr
fanquake
grimd34th
sje397
xanatos


-------------------------------------

You are going to want to include the block of the Phatom project as well:
https://code.google.com/p/phantom/
fd00:2522:3493::/48

And the one for 'garlicat' for I2P, which might be more complex due
to I2P's addressing:
fd60:db4d:ddb5::/48

Note that while these blocks are not expected to be routable, that
people may in fact have interfaces, routing tables and packet filters
on their machines configured with up to all three of those networks
for the purposes therein.


-------------------------------------
This discussion about ordering is absolutely retarded. Once the list fills up, then it won't matter. For now I'm deciding the ordering with Bitcoin-Qt first and the others ordered however. That was nobody can try to game the system (it remains unexploitable).

If there are no objections, then I am going to merge this branch. The forum thread is divulging into a mess all over the place, and this conversation can go on forever discussing the silly fine details:

http://hackerspaces.org/wiki/The_Bikeshed_Anti-PatternProblem:
You suggest creating something new for your hackerspace, like a 
bikeshed.  But now all anyone will discuss is its colour. No bikeshed 
will be built.

Armory & MultiBit, are you OK with that description? I will check with ThomasV about Electrum.


________________________________
From: Gary Rowe <g.rowe@froot.co.uk>
To: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net> 
Sent: Wednesday, May 2, 2012 8:34 PM
Subject: Re: [Bitcoin-development] new bitcoin.org clients page


How about keeping it simple?

Bitcoin-Qt
* Requires the entire blockchain
* Standalone client
* Designed for continuous operation
* Available for Windows, Mac, Linux with installer
* Developed in C
* Website: https://bitcoin.org

MultiBit
* Requires a reduced blockchain
* Standalone client
* Designed for occasional use
* Available for Windows, Mac, Linux with installer
* Developed in Java 
* Website: http://multibit.org

Armory
* Requires the entire blockchain
* Dependent client of Bitcoin-Qt
* Designed for occasional use
* Available for Windows (64-bit only), Mac, Linux (self-build)
* Developed in Python
* Website: http://bitcoinarmory.com/

Electrum
* Requires no blockchain
* Dependent client of Bitcoin-Qt (on server)
* Designed for occasional use
* Available for Windows, Linux (self-build)
* Developed in Python
* Website: http://ecdsa.org/electrum/

Bitcoin Wallet (Android client)
* Requires a reduced blockchain
* Standalone client
* Designed for occasional use on mobile
* Available for Android only
* Developed in Java
* Website: https://play.google.com/store/apps/details?id=de.schildbach.wallet&hl=en


On 2 May 2012 20:25, Amir Taaki <zgenjix@yahoo.com> wrote:

This is like the most annoying thing about email. Often with group emails, we'll be having a conversation then someone will click reply instead of group reply and the convo will go on for a while. Eventually I'll realise the persons are missing and add them back in.

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------------------------------
On 01/31/2012 07:22 PM, Matt Corallo wrote:


Is the ':' sign actually allowed in URL parameter names
(unescaped/unencoded)? If not, I'd propose an unrestricted char instead,
maybe '_'.




-------------------------------------
On Friday, May 25, 2012 12:51:09 AM Jeff Garzik wrote:

Block times are not accurate enough for that.


-------------------------------------

OK, I haven't tried a full block chain sync for a while. If it's only a
couple of hours that's great. Let's change that.
-------------------------------------

Just to be clear, I think this solution is a hack and don't support it
because it's yet another change of network rules. Some random people
will get whacked because of a heuristic "rule of thumb".

If it's implemented, SD could/would switch to fresh addresses and
nothing would have been achieved except making an already complex
system more complex.

I disagree with the notion that you need "less important than free".
If you care about the confirmation time of a transaction that was sent
to you and you need space in a limited resource, you can pay for it.
It's an auction like any other. Besides, the idea that transactions
are free today is just a psychological trick befitting governments but
not us - transactions are funded by aggressive hyperinflation. I would
never describe Bitcoin as a free system and I suggest nobody else does
either.

If grouped fee calculations are implemented, we can keep the nice
property that the person who cares about double spending risk pays the
fees, and if you assume most transactions are hub-and-spoke from
buyers to merchants, rather than a pure p2p graph, in practice it'll
work out to seeming free most of the time even if seen globally it
doesn't make much difference.


I'm not sure why. If you want to audit everything from scratch, after
checking the code you could just blow away the included files and then
"-connect=archive.bitcoin.org" or something like that. After
rebuilding the chain from scratch, check the databases for consistency
with the included data.

It reduces the number of nodes with full copies of the block chain,
yes, but as long as there's at least one copy of the old data in an
accessible location new nodes can still bootstrap just fine.

I'm sure we can find organizations willing to host full chains for
people who want to rebuild their databases from scratch, given how
cheap disk space is.


Yes, but old nodes probably have a copy of the chain already, so it
wouldn't affect them. New blocks would still be fully distributed,
right?

The only case where it'd cause issues is if you install a fresh copy
of a very old node. Not a common occurrence, and those nodes will have
to wait until they find an archival node announcing itself. Those
nodes could be made to announce more frequently than normal, if need
be.


-------------------------------------
Jim,

Most of those issues don't have to do with the SPV versus non-SPV problem.

First person doesn't understand what Bitcoin is supposed to do (he's
confusing mining and running a node). An information problem that could be
solved by explaining what is going on.

Another one seems to have a problem with DEP. That's probably an issue with
his OS configuration.

The third one is confused about the fees. Again, an information problem.

Only the fourth one is concerned with synchronization. The other ones could
happen with any client, as they're either based on misconceptions about
bitcoin as a whole or computer problems.

This doesn't in any way make switching to another, reduced security model
client preferable. Let's first try to improve the Bitcoin experience with
full security model, and if that somehow turns out to be impossible it's
always possible to recommend some other client based on the 'user type'.

I don't agree that this point is now. Anyway, security and stability of the
network is of utmost importance to do anything in the future, better to
grow organically than explode.

Many initiatives are underway to improve the Satoshi client (for example to
have Bitcoin-Qt behave as SPV client during initial block download, and as
full node after that), but as usual in open source development, many of us
are doing this basically for fun in our free time it does not always go as
fast as users would like.

I wish there was a straightforward solution for that, yeah pooling together
our development on one or two clients instead of a zillion different ones
could help, but everyone has more fun working on their own client that's
just how things go :)

Wladimir

On Wed, Dec 5, 2012 at 6:38 AM, Jim Nguyen <jimmy.winn@gmail.com> wrote:

-------------------------------------
On Sun, Oct 14, 2012 at 6:09 PM, Christian Decker
<decker.christian@gmail.com> wrote:

The only restrictions I'm aware of are the EAR restrictions on the
export of cryptography.

These are generally not applicable to us for two reasons. One is that
we only use cryptography for authentication, which is explicitly
exempted:
http://www.bis.doc.gov/encryption/question2.htm

The other is that since Bernstein vs US
(http://en.wikipedia.org/wiki/Bernstein_v._United_States) there has
been absolutely no enforcement attempts against open source projects
as the precedent creating holding there makes it clear that these
regulations cannot inhibit the publication of source code.

Perhaps someone could make a little noise about binaries, but it would
be pure pretext: Especially since with the deterministic build process
we use anyone can produce bit-identical binaries (thus allowing builds
by untrusted third partities to be just as trustworthy as the official
ones).


This made me laugh. It's hard to find places with better effective law
for most online and internet things.  Many places copy the US's
statutes (either cargo culting, or as part of treaty compliance) but
do so without also copying our legislative history which is
/generally/ highly protective.  For example, Australia has copied the
US munitions regulations exactly, but has no analog of Bernstein v. US
to limit the government's power.

Unfortunately sourceforce was rather vague about what regulations they
believe they're enforcing:
http://sourceforge.net/blog/clarifying-sourceforgenets-denial-of-site-access-for-certain-persons-in-accordance-with-us-law/

So unless someone has already done it, I'll get in touch with the EFF
and find out if they're aware of any particular precautions we should
take here.


-------------------------------------
Hi Amir,

I am fine with the MultiBit description (+ subsequent suggestions like taking the language text out).

Looking forward to seeing it on the bitcoin.org site.

Jim

jim618@fastmail.co.uk

-------------------------------------
On Sat, Jun 2, 2012 at 7:52 PM, Luke-Jr <luke@dashjr.org> wrote:
This attack has an obvious signature: getting outworked on the same
block as the pool was trying to verify, and always by the same person.
So the goal is to prevent the attacker double-dipping by submitting
cycles to the pool, which if he
found a correct answer he could submit himself. I don't see how this
does that: if he finds a valid
block he finds a valid block. Only if the operator has a secret is
this prevented.
This further delays the finalization of a transaction. That's not a good thing.



--
"Those who would give up Essential Liberty to purchase a little
Temporary Safety deserve neither  Liberty nor Safety."
-- Benjamin Franklin


-- 
"Those who would give up Essential Liberty to purchase a little
Temporary Safety deserve neither  Liberty nor Safety."
-- Benjamin Franklin


-------------------------------------
All,

With the flurry of discussion about blockchain compression, I thought it 
was time to put forward my final, most-advanced idea, into a single, 
well-thought-out, *illustrated*, forum post.     Please check it out: 
https://bitcointalk.org/index.php?topic=88208.0

This is a huge undertaking, but it has some pretty huge benefits.  And 
it's actually feasible because it can be implemented without disrupting 
the main network.  I'm sure there's lots of issues with it, but I'm 
putting it out there to see how it might be improved and actually executed.

----
*Summary:

*/Use a special tree data structure to organize all unspent-TxOuts on 
the network, and use the root of this tree to communicate its 
"signature" between nodes.  The leaves of this tree actually correspond 
to addresses/scripts, and the data at the leaf is actually a root of the 
unspent-TxOut list for that address/script.  To maintain security of the 
tree signatures, it will be included in the header of an alternate 
blockchain, which will be secured by merged mining.

This provides the same compression as the simpler unspent-TxOut merkle 
tree, but also gives nodes a way to download just the unspent-TxOut list 
for each address in their wallet, and verify that list directly against 
the blockheaders.  Therefore, even lightweight nodes can get full 
address information, from any untrusted peer, and with only a tiny 
amount of downloaded data (a few kB). /*
*----

Alright, tear it up!
-Alan

-------------------------------------
On Wed, Apr 11, 2012 at 2:39 PM, Christian Bodt <sirk390@gmail.com> wrote:

If the peer is misbehaving, then disconnect.  Your protocol change
does not offer any clear benefits in this area, as these sorts of
attacks/misbehaviors/bugs are still just as possible, and just as
damaging (or not).

Just disconnect the strange peer!



Stateless protocols have a lot of value.  They are easiest to
implement, and easier to prove correct.  Existing clients like
ArtForz' half-a-node, variants of which are deployed all over the
place in bitcoin-land, rely on the stateless-ness to one degree or
another.

Stateful protocols, too, have their problems as well.  One must add
code to help remain "synchronized" between local and remote states,
which your suggested change only hints at.  NFSv4 and RPC have a long
history of dealing with stateful-ness issues.  Obviously bitcoin P2P
is nowhere near as complex, but the history of NFS development offers
several lessons applicable to your proposed change.

Overall, IMO your listed reasons for needing this major change
(stateless->stateful) do not really justify the change.  Handling
initial block download can be accomplished in a number of ways, and
peer(s) may crash or return odd results.  You must handle these cases
properly, regardless of the presence of req/reply id's.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Tue, Jan 31, 2012 at 11:50 AM, Andy Parkins <andyparkins@gmail.com> wrote:

I think you've been deceived by people who have some interest in
promoting this as some sort of big controversy, or perhaps just
confused by the general level of noise.

The differences between BIP16/BIP17 are technically obscure, everyone
who is well versed in the issue (with the potential exception of
Luke). There is broad consensus among the involved technically minded
parties over just about all of it.

Luke has been maintaining an opinion tracker page:
https://en.bitcoin.it/wiki/P2SH_Votes

reflecting the views of core developers and people who've been
technically involved enough to have an informed opinion.


There is always a different color that the shed could be painted.
Expecting absolute consensus on the _best_ way forward is an
unreasonable standard, especially if you're going to invite the
opinions of many people.

Depending on how you count we have considered a good two dozen options
in this space—  Starting with the OP_CAT key combinations many months
back, and including many variants of the current ideas. The BIPs only
represent the "final" surviving ideas.

In particular, BIP16 was the isolated consensus path forward that came
out of the discussions about the concerns that BIP12 was too
computationally powerful— I don't think I can identify any particular
person as the author of the BIP16 idea.  At the the time BIP16 became
a BIP only Luke was actively objecting to it.

Though his hard work and tireless (...unstoppable dogmatic) promotion
he's managed to build a workable alternative, and it now has some
support other than himself.  This, however, doesn't constitute a
material schism.


As always, asbestos underwear is required.


It does not, in fact— Yes, it requires a client update to make use of
the new functionality, but old nodes will happily continue to validate
things.  It's hard to express how critical this is distinctly.
Bitcoin is, predominantly, a zero-trust system. Nodes don't trust that
things were done right, the validate them for themselves.

A breaking change of the kind you suggest is not something that would
be considered lightly, and this is certainly not justified for this.


If we ever were to scrap the system, I think we very much would do
something like what you describe here... and as much has been
documented:

https://en.bitcoin.it/wiki/Hardfork_Wishlist
(see "Elimination of output scripts")

But, to be clear, this stuff is pretty much fantasy. I'm doubtful that
it will ever happen, doubtful that we can get the kind of development
resources required to pull off a true breaking change in a way that
people would actually trust upgrading to— at least not before a time
that the system is simply too big to make that kind of change.


-------------------------------------


No. The main idea is to protect the consumer against a malicious seller pretending that he has not been paid. Please read the forum.


The bitcoin address that is used to sign URIs will establish the online reputation of the merchant. If a merchant has received a payment and pretends not to have received it, the signed URI will prove him wrong. 

In principle it would be possible to use HTTPS signatures for that purpose, but this is not really the way HTTPS is supposed to work, and it has disadvantages:
- HTTPS is not always available; there are other communication channels.
- A website, even a single page, may contain URIs posted by various merchants; we need to distinguish the identity of the merchant from the identity of the website.
- with signed URIs, a Bitcoin client can easily keep track of the signatures for all the payments it made. if we used the HTTPS signature of the webpage as receipts, then users would need to save them manually. To my knowledge, nobody does that.




yes, that too. see my proposal here: https://bitcointalk.org/index.php?topic=60828.0;topicseen

-- 
Empfehlen Sie GMX DSL Ihren Freunden und Bekannten und wir
belohnen Sie mit bis zu 50,- Euro! https://freundschaftswerbung.gmx.de


-------------------------------------
On Mon, Oct 8, 2012 at 7:52 AM, Mike Hearn <mike@plan99.net> wrote:

Electrum also has a daemon for merchants. Considering the dislike of
Java that exist reflexively in much of the non-java community and the
greater ease of deployment and the integration of type-2 split key
management,  I wouldn't be surprised if it became quite popular
quickly especially if the status quo of failing to disclose and
discuss the security limitations of the client continues.

What I've found is that even fairly sophisticated bitcoin participants
are actually unaware of the security implications— not just of thin
clients architecturally but of electrum specifically.  I think even
you may find my findings of the latter a bit surprising.

Generally for thin clients— a lying server can make clients think
they've received confirmed payments they haven't, and unless the
client is constructed to be a bit less thin a lying server can lie
about input values and cause think clients to spend large values to
fees. Servers can also monitor clients and deanonymize them and
selectively deny service to particular clients or transactions. Thin
clients must trust their servers to be available, and to not perform
these attacks. Users can use tools like tor to reduce the privacy
attacks, but doing so inhibits having a trust relationship to protect
against the other attacks. And none of these attacks leave
cryptographic proof of their existence, so a victim can't convince the
public of a server's treachery. Us experts know about these risks, but
I don't think the general users do.

But thats not the limit of it—  It seems some people believe Electrum
does majority quorum between servers, complicating attacks arising
from the fact that today users virtually never have a reason to trust
their server operators.  This isn't true— it connect to one at a time.
(And sibyl attacks would make that pretty weak protection even if it
did that, as someone could use a a botnet to run tens of thousands of
'servers' (really proxies)).

Beyond that the protocol between the clients and servers is
unauthenticated cleartext JSON in TCP.  So any network advisory with
access to the network near the server has the same power to attack as
the server operator... and one near the client has the same power to
attack as the sum of all the server operators.  A passive attacker
near the client has full deanonymization power.

But I don't even know if any of these limitations matter much—  The
electrum client instantly displays unconfirmed transactions and allows
users to spend them.  The default user interface gives _no_ indication
that the payment is unconfirmed. There is a "pro" mode, that shows
'processing' for unconfirmed transactions... but it looks as final as
it ever will be once it gets a single confirm. Only the most cautious
and well informed users would open the pro interface and right click
and select details to see the count— and even then there is no
guidance on what numbers are good (beyond '1').  So I suspect people
can probably rob typical electrum users (including electrum running
merchants) without actually using any of the above.

When a thin client is willing to provide arbitrary features like
showing unconfirmed payments and simplified UI without regard to
security it removes the functional advantage of running more secure
software like SPV and various degrees of full node... the only
motivation is security, and it's not much of a motivation when the
risks aren't even disclosed.

...and I haven't even gotten into delving into what kind of attacks
are possible due to deeper implementation specifics.

But I do share your view that people will migrate to stronger client
models in the future— but I don't agree that it will be due to those
clients improving (though they will improve), it will be because
people will know that they provide better security and will choose
them for that reason.

My only question is will they know this because we as a community and
the authors of the thin clients provided clear explanations and
appropriate caution, or will it be because they're getting robbed
blind, producing a bunch of bad press for thin clients in particular
and Bitcoin generally?


-------------------------------------
On Wednesday, September 26, 2012 11:41:13 AM Daniel F wrote:

The front page already has wiki links. Adding a direct link to a developer 
resources page there would probably make sense.


-------------------------------------
Spec updated: https://gist.github.com/4120476

Changes are:

Version numbers:  a couple of people asked privately about adding
version numbers to the messages. In general, Protocol Buffers don't
need version numbers if later versions add only optional fields.

And best-practice is to know what version of something you're
expecting BEFORE you start parsing that something.

So, if a bitcoin client is getting Invoice messages via email or from
a web server, the version will be specified as part of the MIME type;
for example:
   Content-Type: application/x-bitcoin-invoice; version=1
The version= syntax is part of the MIME standard.

Following that best-practice of knowing what you're parsing before you
parse it, I added an invoice_version field to the SignedInvoice
message. It is now:

message SignedInvoice {
    required bytes pki_data = 1;
    required string pki_type = 2 [default = "x509"];
    required bytes serialized_invoice = 3;
    required uint32 invoice_version = 4 [default = 1];
    required bytes signature = 5;
}


Handling of receiptURI errors:

Following discussion here, I changed the spec to say:

"Clients may handle errors communicating with the receiptURI server
however they like, but should assume that if they cannot communicate
at all with the server then the Payment should either be retried later
or immediately rejected."

and under Receipt added:

"The Bitcoin client must be prepared to handle the case of an evil
merchant that returns accepted=false but broadcasts the transactions
anyway."


I also added a TODO "Test Vectors" section with base64-encoded
examples of everything.

-- 
--
Gavin Andresen


-------------------------------------
I actually implemented parts of the header+ v<tx> stuff in a branch with
my bloom filter stuff, you can see it here:
https://github.com/TheBlueMatt/bitcoin/commits/bloom%2Brelayblock
Its pretty stupid and would be pretty easy to DoS/get it stuck/etc, but
in theory it works.  I don't see much reason why we'd need anything
significantly more complicated, but maybe there is a use-case I'm
missing?

Matt

On Mon, 2012-09-10 at 11:14 -0400, Gregory Maxwell wrote:



-------------------------------------
i can happily start testing this this weekend. however i'm not 100% sure
how to get a copy. i looked around github, but wasn't sure which was the
proper project. could i get a link and a simple "do this, this and this"?
thanks.

i feel like a newb. ugh.

Arklan

----------
As long as there is light, the darkness holds no fear. And yet, even in the
deepest black, there is life. - Arklan Uth Oslin

I want to leave this world the same way I came into it: backwards and on
fire. - Arklan Uth Oslin



On Sat, Oct 20, 2012 at 4:33 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:

-------------------------------------

You are so funny sometimes. xD

On 3/14/2012 4:07 PM, Amir Taaki wrote:



-------------------------------------
Oh, like I did 3 hours ago?  Gah!  I replied directly to grarpamp by
accident.  Sorry if this seems out of place now...

I'm all for sorting the clients by "ease of use".  We want the smoothest
first experience greeting users new to Bitcoin.  I have grand plans of
defaulting Armory to a standard user mode that is standalone, easy to use,
etc.  But until then, Armory will remain an a power-users thing, and I'd
prefer not to have Bitcoin n00bs emailing me for support before they know
what Bitcoin-Qt is, or, more likely, installing Armory alone and then
walking away when nothing works.

As someone else mentioned previously, the advanced stuff will generally be
found by advanced users.  I think it should still receive exposure through
these means, but not on the top/first row.

I personally think the page should say something like "New to Bitcoin?
Start experiencing Bitcoin with My Phone <menu of phone options>, or My
Desktop <menu of desktop options>"  Put the top 3 on each and either a
button for "More Options", or a short list of other options without
screenshots, and just descriptions with links.  Ideally, it would be sorted
by popularity, because that's probably the most important metric that ties
together all features into a single number, but we don't have good stats on
that.  For now, we settle this by putting Bitcoin-Qt up front, and sort
everything else by how easy it is for users to get started and perceived
popularity and disagreements can be settled by semi-regular rotation.

For now, I don't think ordering is super important.  No one here is
threatening lawsuits for improper placement, and the rotation will be good
to keep the main Bitcoin page looking less stagnant, and slowly exposing
repeat visitors to the variety of options available.

--Alan




On Wed, May 2, 2012 at 3:25 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
+gary


Well, I suggest taking it up with Thomas directly. A thread here won't do much.


I'm hoping that MultiBit Merchant will provide something similar based
on bcj, ie, you don't have to actually be a Java developer to use it,
it can just talk to your app via POSTs and GETs.

WRT deterministic wallets, yes, right now that's indeed a competitive
advantage of Electrum. So much code to write, so little time.


Yes indeed. This also gives [hacked] server operators a way to steal
money from users without private keys, they can get clients to create
some very high fee transactions and then provide them directly to a
miner who promises to cut them in (or they can mine themselves, of
course).


I thought it used SSL. Maybe I'm thinking of BCCAPI which is a similar approach.


I think communicating transaction confidence to users is something of
an open UI design problem right now. I agree that hiding it entirely
seems suboptimal, but in reality explaining what the risks are for a
given number confirmations is difficult. Given the lack of actually
reported double-spends against unconfirmed transactions, I can
understand this choice, even if I wouldn't recommend it.


Well, I pushed for English-text explanations of clients on bitcoin.org
rather than a feature matrix, for this kind of reason :) Unfortunately
the current texts are too small to really give a detailed explanation
of the security models involved. It may be worth adding one-liners
that link to a page explaining different security models (full, SPV,
superlight).

One thing I'm really hoping we can find and get agreement on is
somebody clueful and trustworthy to work on the bitcoin.org website.
Bitcoin, the project, needs a stronger voice than it currently has,
partly to speak about such issues. For instance, an FAQ that isn't on
the wiki would be good. And a simple "Welcome to Bitcoin" flow on the
bitcoin.org website that guides people to appropriate clients, teaches
them the security basics, etc, would be excellent.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 01/10/2012 17:52, Peter Vessenes wrote:

I am very happy to hear this, however, your actual words are slightly
evasive. I do not expect you to be up to speed on this. Gavin started
a project called 'the bitcoin testing project' This project solicited
donations, about 80 coins last time I checked.  However these 80 odd
coins were donated to 'the bitcoin testing project' This would seem to
be an official bitcoin (both protocol and client) testing project.  I
signed up to work on this, and organise as much as i could of this.
for various reasons I did not manage to do the testing I wanted to on
0.7 i over committed myself.

Are the donations solicited for the 'bitcoin testing project) funds
going to be given to 'the foundation'?

Does the foundation support 'the bitcoin testing project'? does the
foundation have any involvement with 'the bitcoin testing project'?


Im ready to go, more or less.  Please check out the links in my
previous emails. I have over 400 testcases (8 platforms * 50 release
tests) - Also I am not sure what you mean by bless, I take it that is
a euphemism for pay?

I have tried my hardest to get bettermeans to work, but it doesnt.  It
does show quite a lot of work that I have done though. If you were to
say to me, 'steve, by monday we need end to end, requirements based
testing' It would be done. (I have already spent over 4 months on
this)  Leaderless leadership is something I am having a hard time
with, bettermeans is excellent at this.  But I have found very little
in regards to voting and polling that integrates with the project in
an effortless way like bettermeans.

I understand that the budget from the foundation is something that
needs to be worked on and organised.  I offer my services in this area
(qa only).  I would be happy to submit my cv and refs for this, if
required.

I am now feeling frustrated and useless.  has my last 4 months of work
been for nothing? it feels like it.  I know I bang on about processes
but they are sorted, you can only attract talent like Arklan if he has
a process to follow. i feel like a broken record.

tl;dr version
1 - Will donations to the 'bitcoin testing project' as started by
gavin going to be given to the foundation?
2 - Is the work bill hees and myself going to be binned?
3 - I feel like I have the knowledge and drive to push this, but I
cant do it on my own.
4 - Is bill or I entitled to any of the cash raised for 'the bitcoin
testing project'
5 - Do I have to join the foundation to have a say in how the project
(testing) is done?
6 - sorry for being so mercenary, but am I going to receive any coin
for work I have done?
7 - It really probably is the time for a bitcoin-test list to appear.
 Is there anything I can do to make this happen?


have a look at the stuff in bettermeans.  I personally think we can go
a step further and publish guidelines (similar to RFC's and all the
tests that we would do against a ref client)

But I dont want to waste any more time on stuff that is going to be
ignored, life is short.


I accept that offer. and I really appreciate it.  I have some more
questions I would like you to ask in regards to QA. (Gavin and I
skyped about this a while ago and we didnt really come to a
resolution, weworked out the problems though ;) )

I have an exceptionally detailed qa process (based off the game
certification process) - but I have gone on about this at length in
previous messages.

I thank you for your email and your involvement with this, but do you
think we are closer to getting stuff tested? call my bluff... Not one
person has asked for login details to my proposals - and i even have a
bugzilla version now.

I need to sleep.  sorry if i rambled.

nite nite,

steve

How fast is your code?
_______________________________________________
-
------------------------------------------------------------------------------
Got visibility?

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQa5GXAAoJEFvEB9dQFvtQUR4H/3o0aOyvF6u4Wi5UUxMtGWXD
Bduuag9jNY/GACFshYs365wWqJcK96GXc/svOx0l/TTv10tw9BboaMpKY2x9gWri
7DJ+mym1AorgHBlZUgZJy3kQrb5yUCR7MiYU0O28QAqK5aVoklBa6cGQJqQVRa2j
vm9UrKCOeMbHiNMjagLP3s1tcQxYJUwm8hEuALWjyqsDQ+Rk7j2ndBnfonJLTCDc
rIy6HhmfAGSCaXFzhH35Ydfl2hV6ASaUHtBSKke3bB/oJ/bA5XspmPPhCkjum4Lo
4b28i4/O8BTisAsr8N3FYQ17dmD2fu8/gmQt1Rl9MBfWBHPJ9YVIIittk+WhcI0=
=nER6
-----END PGP SIGNATURE-----


-------------------------------------
Hi,

I'm opening the call for papers. It's about time to move forwards with this already. Sorry for the delays.

Email proposals to genjix@bitcoin2012.com

Speaker list: https://sites.google.com/a/bitcoin2012.com/homepage/speakers


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi All,

After the failure to get any real testing done for the 0.7 release (all
of which is my fault) I have decided to rejig things.

I am heavily into test driven development, and I have a strong
background in requirements management, and automation.

I want to leave bettermeans behind, maybe we might be able to keep the
voting aspect of it, and link it into mantis.

So, what I have been doing over the past few weeks is developing a
rudimentary requirements set, basic requirement tracking, tests to
prove/stress the requirements.

The next most important thing is to get release/acceptance tests done -
these primarily focus on new stuff doesnt break old (ie lose a wallet,
etc) and needs no special requirements.

To this end I have installed various opensource applications (mantis,
salomeTMF, bugzilla, etc) and am currently evaluating the best workflow
process.

This was a much longer post, but decided against it. :)

So, what I want to know is who wants to be a part helping me out with
all this? I am finalising the workflow flow diagrams and they should be
ready for inspection soon.

Anyone interested in helping out/reviewing processes? even if it is just
some encouragement, it is all greatly appreciated.

Drop me an email if you want access to the current setup and help me
review the different software for the bitcoin workflow process.

cheers,

steve

- -- 
my PGP public key is at pgp.mit.edu id: 0x5016FB50
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQYfjMAAoJEFvEB9dQFvtQSmsH/R/FEdOQRB7ncTnHhaP8woLu
nIiGX2DgLOWLOF9launSuTCrtVm2G56B9Dgl/BqScFxeuJGbzje7+kp7LgjtA3uy
kS9DUZ1zhUfhslGP0UpVJJGX6Yfk8GbQ4nUcuL1VTv6nSZXWP2EvLMDPpRgKwyi5
z1FiyBg2A3Kg3Er+VmHPmpI0zZAGB5ytaenUp4xXGhL7Nk66i5X0twVr51xlEm0L
zKCDXHzWTvNNlT7TzMjIxShJ/EcgCI1r6tVD3T+2e9QeVm0QNw3xeNUkMxKn+ul8
d1v1OxJbHD1CsNqW+XgVvFE2SJReizaHNOFwrqcpVCp7bABnWAB5eyTzB9B9IX8=
=di5x
-----END PGP SIGNATURE-----


-------------------------------------
Although I can only speak for my involvement with MultiBit, the idea of a
randomised client page seems wrong to me, for the reasons given by Alan
earlier.

Equally, in order to further the idea that Bitcoin is more than the
reference client, it is appropriate that other clients are acknowledged and
promoted. Bitcoin.org has by far the most traffic and by directing people
to other clients that may be more suitable to their needs the user
experience is improved considerably. After all, not everyone wants a 2.5Gb+
download before starting out on their Bitcoin adventure.

If the reference client was the best of all possible worlds then there
would be no need for the alternative clients.

On 9 July 2012 20:14, Alan Reiner <etotheipi@gmail.com> wrote:

-------------------------------------
On Wed, May 16, 2012 at 2:29 PM, Luke-Jr <luke@dashjr.org> wrote:

If the peer list becomes too, um, stratified maybe that's a Big Hint
that said clients should be using another network entirely, and not
overloading bitcoin's P2P network for wholly unrelated tasks.  The
bitcoin P2P network is not a general message transit network.

Another argument against the proposal, IOW, if you ask me....

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hello everyone,

I've just merged my "ultraprune" branch into mainline (including
Mike's LevelDB work). This is a very significant change, and all
testing is certainly welcome. As a result of this, many pull requests
probably don't apply cleanly anymore. If you need help rebasing them
on the new structure, ask me.

The idea behind ultraprune is to use an ultra-pruned copy (only
unspent transaction outputs in a custom compact format) of the block
chain for validation (as opposed to a transaction index into the block
chain). It still keeps all blocks around for serving them to other
nodes, for rescanning, and for reorganisations. As such, it is still a
full node. So, despite the name, it does not implement any actual
pruning yet, though pruning would be trivial to implement now. This
would have profound effects on the network though, so may still need
some discussion first.

A small summary of the changes:
 * Instead of blk000?.dat, we have blocks/blk000??.dat files of max
128 MiB, pre-allocated per 16 MiB
 * Instead of a Berklely DB blkindex.dat, we have a LevelDB directory
blktree/. This only contains a block index, no transaction index.
 * A new LevelDB directory coins/, which contains data about the
current unspent transaction output set.
 * New files blocks/rev000??.dat contain undo data for blocks
(necessary for reorganisation).
 * More information is kept about blocks and block files, so
facilitate pruning in the future, and to prepare for a headers-first
mode.
 * Two new RPC calls are added: gettxout and gettxoutsetinfo.

The most noticeable change should be performance: LevelDB deals much
better with slow I/O than BDB does, and the working set size for
validation is an order of magnitude smaller. In the longer run, I
think it is an evolution towards separation between validation nodes
and archive nodes, which is needed in my opinion.

-- 
Pieter


-------------------------------------
Short comments:

* What if the SignedReceipt is not received AND the transactions IS posted on the p2p. Then you have payed for the goods, but you don't have a receipt. This could happen both from malice or system failures.
** Suggestion - sign the invoice with the key to which to send the transaction, the proof of payment, equivalent to a signed receipt is then in the blockchain.

This scheme would work both with or without x509, if you want to include x509, the message in the invoice could simply be signed by the x509 certificate as well.

PRO: Any user can send signed invoices, not only those with a x509 cert.
PRO: No limbo situation with no SignedReceipt
CON: This disables the use of anything but payment to key/address incl multisig etc.

However, the wast majority of use will anyway be payment to key/address.

Support of general pay to script could be supported through the payment scheme proposed earlier by Mike: No non-fee payments are accepted, except in a group - i.e. it is up to the merchant to generate the final transaction incl the fees, and that one could be to a general script. This also keeps the support of pay to general script needed for a client to a minimum.

Cheers,

Michael




-------------------------------------
Your approach won't work-- OP_ADD is limited to 4-byte operands.  Changing
that would require a "hard" blockchain split / entire-network-upgrade.

I wish to submit the following draft BIP for discussion and possible

-- 
--
Gavin Andresen
-------------------------------------
On Tue, Jun 19, 2012 at 1:33 PM, Alan Reiner <etotheipi@gmail.com> wrote:

This is why good comprehensive tests and a well specified algorithim
are important. The tree update algorithm would be normative in that
scheme. Worrying that implementers might get it wrong would be like
worrying that they'd get SHA256 wrong.


Provable libJudy trees. Oh boy.


-------------------------------------
On Wednesday, February 01, 2012 10:58:28 AM Michael Grnager wrote:

I didn't see anything useful in ccmake. Boost is in the standard locations 
(/usr/include/boost/ and /usr/lib/libboost*


Gentoo


-------------------------------------
There are tons of scenarios, some discussed here on this list previously,
which would benefit from out of band messages and notes.

This is small, but an interesting tidbit from BTC Foundation payments;
roughly 3-5% of our initial members double-spent. WOW, that's terrible.

I presume that's because they use web wallets without double-click
prevention. But, seriously! A tiny UI issue that's a big deal in an
irrevocable payment system.


On Tue, Oct 2, 2012 at 10:43 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:

I'm trying but can't think of a lightweight solution to this off the top of
my head. Not that that proves much.


+ Protocol for gathering signatures from multiple devices
comes into clarity for me just how innovative and incredibly awesome this
would be for financial controls for companies. Imagine the bookkeeper
inputting payments, and the owner (or 2 of 3 owners) approving them. I can
even imagine large member groups having 2/3 or majority spend rules.

When we talk about stuff like this, I come back around to thinking there
should be many different GUIs -- this use case is more business-y, it's
stuff like this that I always think about the bitcoin testing project
helping provide -- a standard backend that a bookkeeping GUI could go on
top of..




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
On Wed, 2012-11-21 at 16:15 +0100, Pieter Wuille wrote:
Meh, sure, whatever...I dont really think the seed values matter
significantly (Murmur3 isnt that bad of a hash function...) (and the
original algorithm wont result in a significant bit difference between
the seeds in many cases).
I think there is some consensus here, and I have no problem doing it
this way (in large part, filteradd should not be used at all).
I'm not sure here, if you are sending a filter just to use filteradd to
add things to it manually, you are doing something very, very, very
wrong... Though we could certainly do some kind of compressed bloom
filter encoding to allow for small filter loads (loading the few things
you need to filteradd right away) where you anticipate adding
significantly more filter elements down the road (can anyone even come
up with a case where you anticipate doing this?), the filter is small
enough (max 36kB) that I see little benefit for the large increase in
complexity (or is this another repeat of the merkle branch discussion?)

Matt



-------------------------------------
On Mon, Jul 9, 2012 at 12:09 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

JS randomization doesn't imply needing JS to view the page. It implies
needing JS to see it in random order.  You could also combine it with
the server-side randomization if you care about non-js being non
random, though I don't think it matters.

As others have pointed out I don't generally think the randomization
is good in principle, but if its done it should at least achieve its
goals.


I'll let other people speak for themselves, but I did consult others
before reverting your last batch of changes.

More generally, we have pull requests in order to get some peer review
of changes.  Everyone should use them except for changes which are
urgent or trivially safe.  (Presumably everyone with access knows how
to tell if their changes are likely to be risky or controversial)


I'm strongly supportive diversity in the Bitcoin network, and some alt
client developers can speak to the positive prodding I've given them
towards becoming more complete software. If I've said anything that
suggests otherwise I'd love to be pointed to it in order to clarify my
position.

Unfortunately none of the primary alternatives are yet complete, the
network would be non-function if it consisted entirely of multibit or
electrum nodes (and as you've noted armory uses a local reference
client as its 'server').  The distinction between multiple kinds of
clients in terms of security and network health are subtle and can be
difficult to explain even to technical users and so until something
changes there the reference client needs to be the option we lead
with. People should us it unless their use-case doesn't match. When it
does they'll know it and they'll be looking. We don't need to make one
of those recommendations a primary option.

I like the proposals of moving this stuff to the Wiki as the wiki
already contains tons of questionable (and sometimes contradictory)
advice and so there is less expectation that placement there implies
any vetting.


-------------------------------------
Sounds interesting, however, even after a couple of days, I cannot see how you maintain protection against double spend using OP_CHECKEXPSIG. It is not until you redeem the OP_CHECKEXPSIG transaction that you reveal which former transactions that was involved?

I guess I am missing a point here?

/M




 
On 02/03/2012, at 20:57, Watson Ladd wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Are there any plans to eventually force TLS (SSL) for bitcoin.org and
its downloads?

- Jay


-------------------------------------
I've been thinking about the requirements for a payment protocol
lately. It seems we have consensus that we need one of these. Pieter
has a gist on the topic here: https://gist.github.com/1237788

IMHO we'll want to move away from "send X BTC to address Y" and more
towards "upload to me transactions that send X BTC to outputs
A,B....F,G". In this context by output I mean the obvious
interpretation of script+value.

The reasons are privacy and security. Privacy: you don't want people
to find out if you have an unexpectedly large balance (from the block
chain). Example worst case scenarios

- in a hypothetical Bitcoin-using country, as most people receive
income exactly once a month from their employer, you could potentially
find out other peoples salaries. Drama ensues.

- business partners could find out their counterparty has an
unexpectedly good financial position, messing up negotiations

Security:

- some of the outputs could be in a hot wallet, others in cold
wallets, helping you maintain correct balances between them in real
time

- the outputs can be multi-sig scripts

Wallets would then craft a series of transactions to try and somewhat
balance the size of inputs vs outputs. Because they are separate
transactions and all the keys are fresh, there's no way to link them
together into a single payment, especially not if they're broadcast in
random order with some jitter.

The upside of this is better privacy. The downside is obviously more
transactions and therefore more overhead. In theory the sum of tx
outputs would end up converging to a reasonable "coin size" for the
recipients, eg, businesses might be happy to receive a lot of money in
a single output, individuals less, children or very poor people maybe
much less.

Let's call payment requests invoices. Here is a brainstorm on other
features that may be desirable. I'm not suggesting they're all in v1,
just that we think about them a bit to ensure we don't paint ourselves
into a corner.

- Optional list of {signature, certificate} pairs. SSL certs can be
embedded into the payment request file itself so they can be checked
instantly for wallets that want to show a verified identity, but you
can also provide other certificates issued outside the regular SSL CA
system. For example maybe MtGox issues you a "trusted vendor"
certificate. Maybe the better business bureau issues you a cert, etc.

- Optional expiry time (from sipas gist) so outputs that were never
sent to can be recycled

- Upload target (URI), where to send the created transactions

- Optional message and branding image/icon that a wallet can display
to make the transaction history a bit prettier

- Opaque token that the wallet is supposed to copy into the payment.
The merchant can use to link invoice with payment. It's technically
redundant, the output set would identify the invoice too, as could a
token in the upload target URL, but it may be simpler for some
merchant implementations

- Ability to specify payment amount[s] in terms of other currencies.
If the amount is specified statically it can just be recorded in the
wallet for informational purposes. If there's a URL provided also, it
is an endpoint where quotes can be obtained. This allows merchants to
make long-lived invoices which are protected against FX volatility.
Downside: complicates wallets. Upsides: invoices can be kept around
for longer.

- Web/human-usable URL for the order so users can, eg, send messages
to the merchant specific to an order, post a review of the merchant,
etc

- Support for setting up 2-of-3 dispute mediation. Invoices should be
able to name a list of acceptable mediators and the wallet software
can intersect this with a list of mediators acceptable to the user, to
find one that works best. The whole mechanism by which merchants and
users agree on mediators isn't designed yet but we can at least think
about it now. It may be there's a simple design everyone agrees on
already.

- Support for requesting recurring payments. Eg, I should be able to
provide N sets of M outputs, one set for each payment with a payment
schedule. Wallets can then ensure they run at the appropriate times to
keep up the subscription.

- Suggested tip/service charge. Wallet would give a simple UI to
adjust this up/down by X percentage points

- Request to sign inputs with SIGHASH_ANYONECANPAY, allowing the
payment to be a pledge for an assurance contract

- Ability to specify minimum confirmation level of coins that will be
spent. Some merchants may be OK with you immediately re-spending
unconfirmed coins. Other merchants will care more and might want you
to take on the burden of getting your transactions into the chain.


On the payment upload side:

- An optional signature under a stable user key that lets users
optionally link their payments across merchants. In this way a user
can build cross-market reputation which may help them in future, by
relaxing confirmation requirements or reducing the chance of being
asked to enter dispute mediation. Needs more thought.

- Optionally, an invoice for a refund if the merchant chooses to
refund the money in the absence of dispute mediation.

- A list of Bitcoin transactions that make payments to the outputs
requested in the invoice

- The opaque token provided in the invoice



Re: format. I would (surprise) strongly suggest protocol buffers over
JSON. I cannot think of any justification for using JSON (for
anything) but especially not for data structures that mostly contain
binary data like hashes or keys. Protobufs are easier to work with in
code, have a more efficient encoding, can be printed/parsed from ASCII
if you need to (eg for debugging purposes) and have fewer sharp edges
than JSON does.


-------------------------------------

So what's the actual difference in format? Is there any at all, or
it's just the first number that's different?


-------------------------------------
On Tue, Apr 3, 2012 at 8:55 PM, Luke-Jr <luke@dashjr.org> wrote:


Or we could take a step back, further into "don't reinvent the wheel"
territory. Why not simply make use of PGP(/EC) to sign and verify messages?
It has many advantages, like an already existing web-of-trust and keyserver
infrastructure.

I still feel like this is sign message stuff is dragging the kitchen sink
into Bitcoin. It's fine for logging into a website, what you use it for,
but anything that approaches signing email (such as S/MIME implementations
and handling different character encodings) is going too far IMO.

Wladimir
-------------------------------------
Assuming 50% of hashing power adopts BIP30 but the actual client
install base is relatively low the patch will likely result in a
"hard" blockchain split if someone takes advantage.

A malicious miner can produce a duplicate coinbase which the majority
of clients will accept but the majority of hashing power won't.
Spending the coinbase output after disconnection will cause the
blockchain to fork. All none BIP30 clients on the short blockchain
will be vulnerable to transaction reversal of 6 confirmations or more.

It is a relatively inexpensive attack to perform (costing the attacker
only one valid block ~$240) and could be quite disruptive. I think
this should be patched in DisconnectBlock() (if it hasn't already?)
before any protocol change - maybe a new mapByCoinbase multimap is
needed.

Thank You,
Ben Reeves
www.blockchain.info

On Tue, Feb 28, 2012 at 4:48 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:


-------------------------------------
On Wednesday, May 16, 2012 6:38:28 PM Jeff Garzik wrote:

No, I meant the inverse. If only a small minority of nodes are stratified, 
the clients need some way to figure out which ones, without connecting to 
every node.


-------------------------------------
On 5 December 2012 19:43, Gary Rowe <g.rowe@froot.co.uk> wrote:



Hybrid SPV sounds like a good idea to me. Allows it to work out-of-the-box,
then slowly gets up-to-speed with the full network - working low priority,
or even not at all, if it detects a slow system or network link.
Another idea is always distributing the client with a checkpoint that is
only days old, then starting by pulling in more recent blocks, so it can
transact. Following that, it will pull in progressively older blocks as
time permits.
-------------------------------------
Steve,


Currently github is the authoritative place to report issues. When
someone reports a bug on the mailing list, IRC or forum, they are
generally asked to make a github issue (or, someone else makes the
issue for them). Failed tests are generally also reported on github,
by the pull tester.

We currently have 232 issues, mostly classified into categories such
as "Bug", "Improvement", "GUI", "Wallet", and so on.

Also it's easy to refer to github issues in commits with #123, with
automatic linking.

I'm not sure it is worth the effort to move to another system
(especially if you need a another login etc...). But I'm probably
misunderstanding what you're trying to do.

Wladimir


-------------------------------------
BIP 20 really has no support among implementations such as Bitcoin-Qt, Electrum, MultiBit or Bitcoin-JS. As the most active and visible user facing GUI projects (all with some form of URI Scheme), their opinion carries the most weight. To a lesser degree Bitcoin-Qt has the large majority of users too (although that's a line of reasoning I'd discourage).

Normally we should probably Reject BIP 21 and re-submit a new standard (for history's sake), but as a) BIP 21 is largely a copy paste of BIP 20 sans some sections b) it is still a draft, probably the best thing here is if you all agree on something to run it by BlueMatt and then we'll make it the new BIP 21.

I can see a consensus forming on most parts. Just the send private key is contentious, and there's the topic of adding a time to expire field for merchants (this is a very good idea IMO).

Also BIP 20 is problematic because it is incompatible with about every standard on the web. All the HTML, URI and everything uses decimal numbers alone. I see no reason for breaking with tradition. Note that everytime I have to write Color or Vectorize (as a British speaker) in my code, I die a little inside. But it's convention and American English = International English. Also it would be cool if all code used a *real* international language (like Esperanto) but the world ain't perfect! We live in a decimal-counting English-speaking Windows-using God-worshipping world!

(no offense todecimal-counting English-speaking Windows-using God-worshipping world- I do half those things too :)


-------------------------------------
On Fri, Jun 15, 2012 at 10:55 PM, grarpamp <grarpamp@gmail.com> wrote:



This has nothing to do with priority and "user interrupts", but with the
locks on the wallet and client. Every RPC command takes both locks, and
releases them only when finished.

Shutting down also requires both locks, so the operations will be
serialized.

This protects the database and critical data structures. Sure, there might
be some cases in which the locks are not necessary, or read/write locks
could be used instead to improve concurrency, but this has to be approached
really carefully.

Wladimir
-------------------------------------
RE: signature blocks and BIP 10:

We should avoid reinventing the wheel, if we can. I think we should
extend existing standards whenever possible.

So: could we encode signature blocks or BIP-10 transactions using
S/MIME ?  Or is there a more appropriate "sign a message" standard we
could/should use?

You're glossing over little details like what character encoding is
used for the message, but I'd rather leverage all the work already
done by the IETF to nail down all those little details rather then
re-discover them and come up with our own solutions.

-- 
--
Gavin Andresen


-------------------------------------
Hi Gregory,

I played with the database sync as well to get further speedups, but in the latest version I could only get about 1% extra from this. 

In the Satoshi client there is a bunch of sleeps and mutexes (put in there with great generosity)  for making threads run smoother and to avoid deadlock I guess.

The big change in speed came from moving from the threading based setup to the async based setup, so I think these are the culprit. Further, as I also write somewhere in the wiki. I can measure that 50% of the time is consumed in verify, so there is not much left to optimize now. Actually, Berkeley DB does a quite decent job in caching reads so not even a cache should help.

Cheers,

M

On 01/02/2012, at 15:59, Gregory Maxwell wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Jeff elaborated the problems very well, but I just want to add this:

Your change is essentially relying (trusting) the server to track a piece of information (your state). Anytime you start depending on another node in some way, it is opening yourself up to be exploited. Nodes should be doing their owning state maintainance, not relying on external parties.


I am very much against the change. As someone who has implemented the complete bitcoin protocol, I had no problems implementing the blockchain download. In fact, I dislike that nodes have to store the last inventory they sent as part of a getblocks in order to trigger the next round. It's be better if there was no state whatsoever.

________________________________
From: Jeff Garzik <jgarzik@exmulti.com>
To: sirk390@gmail.com 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Thursday, April 12, 2012 6:12 PM
Subject: Re: [Bitcoin-development] Adding request/reply id in messages

On Wed, Apr 11, 2012 at 2:39 PM, Christian Bodt <sirk390@gmail.com> wrote:

If the peer is misbehaving, then disconnect. Your protocol change
does not offer any clear benefits in this area, as these sorts of
attacks/misbehaviors/bugs are still just as possible, and just as
damaging (or not).

Just disconnect the strange peer!



Stateless protocols have a lot of value. They are easiest to
implement, and easier to prove correct. Existing clients like
ArtForz' half-a-node, variants of which are deployed all over the
place in bitcoin-land, rely on the stateless-ness to one degree or
another.

Stateful protocols, too, have their problems as well. One must add
code to help remain "synchronized" between local and remote states,
which your suggested change only hints at. NFSv4 and RPC have a long
history of dealing with stateful-ness issues. Obviously bitcoin P2P
is nowhere near as complex, but the history of NFS development offers
several lessons applicable to your proposed change.

Overall, IMO your listed reasons for needing this major change
(stateless->stateful) do not really justify the change. Handling
initial block download can be accomplished in a number of ways, and
peer(s) may crash or return odd results. You must handle these cases
properly, regardless of the presence of req/reply id's.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com

------------------------------------------------------------------------------
For Developers, A Lot Can Happen In A Second.
Boundary is the first to Know...and Tell You.
Monitor Your Applications in Ultra-Fine Resolution. Try it FREE!
http://p.sf.net/sfu/Boundary-d2dvs2
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------------------------------
TCP keep-alives aren't reliably implemented.

I've got reports that sometimes we struggle to keep connection to the
network on mobile, eg, because we roam into an area with poor
connectivity but not poor enough for the network stack to drop access
entirely. Being able to quickly check if the connection is really
there with some kind of bounded, app layer deadline is probably useful
and besides, it's cheap.


-------------------------------------
On Tue, Jan 31, 2012 at 9:33 AM, slush <slush@centrum.cz> wrote:

Mixed bag of worms there, even ignoring what people have already
implemented— if you make it use satoshis people who are working with
things at COIN scale are inevitably going to end up multiplying
numbers stored as radix-2 floating point to get satoshis and then are
going to be confused when it comes out "wrong".

Using decimal numbers at least lets them treat the values as strings
and avoid arithmetic that will end up confusing them.


-------------------------------------
On Tue, Feb 28, 2012 at 06:41:31PM -0700, Zooko Wilcox-O'Hearn wrote:

It's not exactly a secret anymore, as the patch also references it.
Russell O'Connor described the attack on his blog:
http://r6.ca/blog/20120206T005236Z.html

-- 
Pieter


-------------------------------------
On Monday, November 26, 2012 11:32:46 PM Gregory Maxwell wrote:

This effectively centralizes Bitcoin (at least in the eyes of many) and even 
if each competing client had their own list, you'd be back to the original 
"problem" of not being sure your CA is on all lists.


How is this whitelist any different from the list of CAs included by default 
with every OS?


-------------------------------------
On 01/31/2012 11:22 AM, Wladimir wrote:


IMHO its standard that unknown URL parameters are simply ignored. I
think we should not change this principle.


In this case, you'd need to refuse *all* parameters you don't know
about. In consequence, all extensions would break older clients.



-------------------------------------
On Fri, Apr 13, 2012 at 6:04 AM, Mike Hearn <mike@plan99.net> wrote:

ACK, agreed


Correct.  As mentioned, this change should impact few TXs on the
existing network.

It's mostly about getting everyone to collectively agree that
transactions should expire, if they don't make it into a block.
(excl. nLockTime stuff)  A minor technical step, but also a useful
policy step.


Yes -- I think there is near-universal agreement on this user experience point.


So, to be specific... a A->B chain of transactions, that collectively
meet the network's fee requirements?  It seems quite reasonable to
accept that, sure.  ACK on concept.  A chain of length 2 seems like it
would be most common, and limiting total chain length (to 10? 100?)
for any one chain in the memory pool seems prudent.

As to the larger issue of fees...  I will readily admit I have no good ideas.

The user's experience is pretty poor:  while it might make economic
sense, from the network's standpoint, to charge for the service of
verifying and storing a transaction, the user has limited means to
determine an ideal fee.  There are also other valid economic models
(receiver pays fee) out there that may successfully sustain the
network.

Ideally the fee, if any, is market based and negotiated.  The current
method is loose-consensus, mainly aimed at (a) combating dust spam or
(b) ensuring it becomes increasingly more expensive to fill a block,
up to the current 1MB maximum.  I think almost everyone agrees the
current fee system is an ugly, warty hack.  Problem is... like
democracy, no matter how ugly it is, people have trouble finding a
better system :)

Furthermore, many of these ideas -- like sending TX's directly to the
merchant -- involve far more direct payee<->payer communication on the
part of the wallet client than is currently envisioned by the bitcoin
P2P network design, which is broadcast-oriented.  So, it remains an
open question whether we want the base bitcoin layer to even worry
about real-time fee negotiation and direct TX transmission.

It is possible that an instant-payments layer evolves on top of the
base bitcoin block chain layer, with bitcoin transactions evolving
largely into settlements between instant-payment intermediaries large
and small.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I meant sent twice, a.

No double-spends that I'm aware of. Sorry for the loose verbiage!

Peter

On Tue, Oct 2, 2012 at 11:07 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
On Saturday, March 03, 2012 8:44:45 AM Stefan Thomas wrote:

Please do comment on the content, in the original thread if you prefer:

Message-Id: <201202281706.22650.luke@dashjr.org>
Subject: [Bitcoin-development] getmemorypool BIP process
Date: Tue, 28 Feb 2012 17:06:20 -0500


-------------------------------------
We split IRC among all those channels to handle the load when there were 60k clients.. the ideal thing would be some kind of dynamic sizing, and this applies to the number of outbound connections and transaction relaying logic too.. the same values that work for 1k clients don't work as well for 50k.  It is difficult to get this kind of thing tuned correctly, especially with the added complexity of potentially malicious nodes.

I think the observed isolation problems, with or without IRC, are simply due to there not being many bitcoin nodes leaving/joining the network.  The ones that are stable are happy with their 8 connections or whatever they're set to, and they're just relaying.  There are only about 5k clients on IRC now.. it would probably work to go back to the single channel model as (at least from the IRC point of view) the usage is declining not growing.  Maybe people are just turning off IRC though.  IRC works well with many channels having a few clients each, not with one channel having many clients.  We considered probing bitcoin clients to see if they're listening and favoring those clients in the WHO response, kind of like the DNS booters, but nobody got around to doing it.

Still, I think it's good to have a bunch of different ways to bootstrap in case one or the other is broken/poisoned.

Laszlo



On Jan 31, 2012, at 2:57 AM, Gregory Maxwell wrote:




-------------------------------------
It was implemented in the waylaying client with the merge of Bitcoin-Qt for drag and drop, and just recently for system URI handling in https://github.com/bitcoin/bitcoin/commit/70f55355e29c8e45b607e782c5d76609d23cc858. However the version on the wiki armed as BIP 20 has a ton of extraneous crap in it's number encoding which is not implemented in Bitcoin-Qt since it was explicitly voted against at the time the spec was being discussed. If that stuff were removed, I would agree that it is final.

Luke-Jr <luke@dashjr.org> wrote:

On Friday, January 27, 2012 5:51:04 PM Amir Taaki wrote:

It's been Final (even according to BIP 1 standards) since late January 2011. 
The only change recently is assigning it a BIP number for formality.


Once P2SH is deployed, it will probably make good sense to revisit the URI 
Scheme for revision, and eventually move BIP 20 to Replaced/Superceded status.

_____________________________________________

Try before you buy = See our experts in action!
The most comprehensive online learning library for Microsoft developers
is just $99.99! Visual Studio, SharePoint, SQL - plus HTML5, CSS3, MVC3,
Metro Style Apps, more. Free future releases when you subscribe now!
http://p.sf.net/sfu/learndevnow-dev2
_____________________________________________

Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------------------------------
Joseph is quite accommodating and doesn't want to hurt the network.
That said "asking him to stop" seems like the worst possible solution
possible. His site is quite reasonable.

I think if I fix bitcoinj to have smarter fee code he might stop
attaching a small fee to every TX, but I'm not sure.

On Sat, Jun 16, 2012 at 6:33 AM, Amir Taaki <zgenjix@yahoo.com> wrote:


-------------------------------------
OK thanks. I just went and made those sections then saw your posts.

Anyway we have a section for proprietary clients now. Please tell me if anything looks disagreeable, http://bitcoin.org/clients.html

One thing I'm going to do is randomise the positioning order within sections upon refresh.



----- Original Message -----
From: "mats@henricson.se" <mats@henricson.se>
To: bitcoin-development@lists.sourceforge.net
Cc: 
Sent: Monday, July 9, 2012 11:19 AM
Subject: Re: [Bitcoin-development] Bitcoin Wallet for Android

Sources are available here:

http://code.google.com/p/bitcoin-wallet/

Mats

Quoting Amir Taaki <zgenjix@yahoo.com>:




------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
Internet censorship *is* a threat to bitcoin, if we don't stand up for our
rights now we deserve anything that is coming. There will be no "long run".

On Mon, Jan 16, 2012 at 2:19 AM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

A potential security vulnerability has been discovered in the Windows
version of Bitcoin-Qt. If you are running Bitcoin-Qt versions 0.5
through 0.6 on Windows you should shut it down and upgrade to either
version 0.5.3.1 or 0.6rc4 NOW.

The command-line bitcoin daemon (bitcoind), Mac and Linux versions of
Bitcoin-Qt, and versions prior to 0.5 are not affected.

Due to the nature of the vulnerability, we believe it would be very
difficult for an attacker to do anything more than crash the
Bitcoin-Qt process. However, because there is a possibility of such a
crash causing remote code execution we consider this a critical issue.

Binaries are available at SourceForge:
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.3/

If you have questions, feel free to drop by the #bitcoin-dev channel
on FreeNode IRC.

- --
Gavin Andresen
Gregory Maxwell
Matt Corallo
Nils Schneider
Wladimir J. van der Laan
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (Darwin)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAk9j12IACgkQdYgkL74406iIyQCfbxFTO3yD4Q2bHDjPlDuJn3Mj
9GAAn3mV+ggo+5q1Ujd0A5zwpFYojkE2
=g1Ad
-----END PGP SIGNATURE-----


-------------------------------------
This is great, thanks!

A few remarks:

If you have to update the filter after every block, IBD will require a
round-trip after every single block download instead of doing bulk
requests with getblocks. That sounds like it'd kill any performance
gains won by the feature. There needs to be a way to do bulk getblocks
on hundreds/thousands of blocks at a time and then have the data
stream in. Perhaps the server node can update the filter for you, as
the rules are deterministic?

As you know the remote end will request the transactions given their
hashes anyway, why not save the bandwidth for the hashes and the
network round-trip by just providing the transactions immediately in
the block? I was imagining something like:

// A CMerkleTx without the redundant block hash
class CLiteMerkleTx : public CTransaction {
  std::vector<uint256> vBranch;
  int nIndex;
}

class CMerkleBlock {
    int nVersion;
    uint256 hashPrevBlock;
    uint256 hashMerkleRoot;
    unsigned int nTime;
    unsigned int nBits;
    unsigned int nNonce;

    std::vector<CLiteMerkleTx> vMatchedTxns;
}


-------------------------------------
On Wednesday, May 02, 2012 9:22:42 AM Mike Hearn wrote:

This is just wrong. While Bitcoin-Qt is by far the best client, it is 
Wladimir's, not Satoshi's.


Isn't this down to only a few hours now?


I don't see this as relevant. Every client has been partly funded by 
donations, anyway.


-------------------------------------

Don't know what you're using since you've not stated it.


Extra cores help with disk, crypto, net, etc...


I've spent about two weeks crunching about the last month's
worth of new blocks.


The config is reproducible, and not believed to be uncommon.


Mostly disk and crypto.
Shall everyone instead run in bitrot and no-privacy mode?
What do we do when we've got 10k trans a day coming in?
50k? 100k, 1M? When the chain gets 1M, 50M, 500M, 1B long?

Forget my swamped box, these numbers are coming to others.


I'd bet some people using 'tmpfs' probably have it unknowingly
[fall]backed to swap instead of core.

Bitcoin already takes up 3GiB of disk, how many have that much
free RAM? How many have 30GiB, 300GiB?


Yes, I left out that bit of platform so here are the remaining
bits... db4830, boost149, vm.kmem_size=650000000


I'm not bashing anything or anybody, just detailing a stock config
that is underwater. Anybody wishing to verify can get the hardware
from their junk pile and the software from freebsd.org. I'll certainly
be looking at both it and different setups too. If anyone's using
say Linux/BSD, BTRFS/ZFS, crypto, on i386/amd64, they could
chime in with their times too.

Disk is the cheapest, easiest thing for Joe to get. Think about
indexing and checkpointing into said disk. I don't know what
bitcoin's doing, but if it's verifying every transaction back to
the root, that would seem a bit ridiculous.

Joe probably won't be happy buying TiB's for bitcoind, so after that's
filled (assuming there's CPU to do it), the trust model has to change.
These scales are coming...


-------------------------------------
Bitcoin version 0.7.0 is now available for download at:
  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.0/

We recommend that everybody running prior versions of bitcoind/Bitcoin-Qt
upgrade to this release.

Please report bugs using the issue tracker at github:
  https://github.com/bitcoin/bitcoin/issues

Project source code is hosted at github; you can get
source-only tarballs/zipballs directly from there:
  https://github.com/bitcoin/bitcoin/tarball/v0.7.0  # .tar.gz
  https://github.com/bitcoin/bitcoin/zipball/v0.7.0  # .zip

Ubuntu Linux users can use the "Personal Package Archive" (PPA)
maintained by Matt Corallo to automatically keep
bitcoin up-to-date.  Just type
  sudo apt-add-repository ppa:bitcoin/bitcoin
in your terminal, then install the bitcoin-qt package:
  sudo apt-get install bitcoin-qt


How to Upgrade
--------------

If you are running an older version, shut it down. Wait
until it has completely shut down (which might take a few minutes for older
versions), then run the installer (on Windows) or just copy over
/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).

If you were running on Linux with a version that might have been compiled
with a different version of Berkeley DB (for example, if you were using the
PPA and are switching to the binary release), then run the old version again
with the -detachdb argument and shut it down; if you do not, then the new
version will not be able to read the database files and will exit with an error.

Incompatible Changes
--------------------
* Replaced the 'getmemorypool' RPC command with 'getblocktemplate/submitblock'
  and 'getrawmempool' commands.
* Remove deprecated RPC 'getblocknumber'

Bitcoin Improvement Proposals implemented
-----------------------------------------
BIP 22 - 'getblocktemplate', 'submitblock' RPCs
BIP 34 - block version 2, height in coinbase
BIP 35 - 'mempool' message, extended 'getdata' message behavior


Core bitcoin handling and blockchain database
---------------------------------------------
* Reduced CPU usage, by eliminating some redundant hash calculations
* Cache signature verifications, to eliminate redundant signature checks
* Transactions with zero-value outputs are considered non-standard
* Mining: when creating new blocks, sort 'paid' area by fee-per-kb
* Database: better validation of on-disk stored data
* Database: minor optimizations and reliability improvements
* -loadblock=FILE will import an external block file
* Additional DoS (denial-of-service) prevention measures
* New blockchain checkpoint at block 193,000


JSON-RPC API
------------
* Internal HTTP server is now thread-per-connection, rather than
  a single-threaded queue that would stall on network I/O.
* Internal HTTP server supports HTTP/1.1, pipelined requests and
  connection keep-alive.
* Support JSON-RPC 2.0 batches, to encapsulate multiple JSON-RPC requests
  within a single HTTP request.
* IPv6 support
* Added raw transaction API.  See https://gist.github.com/2839617
* Added 'getrawmempool', to list contents of TX memory pool
* Added 'getpeerinfo', to list data about each connected network peer
* Added 'listaddressgroupings' for better coin control
* Rework gettransaction, getblock calls. 'gettransaction' responds for
  non-wallet TXs now.
* Remove deprecated RPC 'getblocknumber'
* Remove superceded RPC 'getmemorypool' (see BIP 22, above)
* listtransactions output now displays "smart" times for transactions,
  and 'blocktime' and 'timereceived' fields were added


P2P networking
--------------
* IPv6 support
* Tor hidden service support (see doc/Tor.txt)
* Attempts to fix "stuck blockchain download" problems
* Replace BDB database "addr.dat" with internally-managed "peers.dat"
  file containing peer address data.
* Lower default send buffer from 10MB to 1MB
* proxy: SOCKS5 by default
* Support connecting by hostnames passed to proxy
* Add -seednode connections, and use this instead of DNS seeds when proxied
* Added -externalip and -discover
* Add -onlynet to connect only to a given network (IPv4, IPv6, or Tor)
* Separate listening sockets, -bind=<addr>


Qt GUI
------
* Add UI RPC console / debug window
* Re-Enable URI handling on Windows, add safety checks and tray-notifications
* Harmonize the use of ellipsis ("...") to be used in menus, but not on buttons
* Add 2 labels to the overviewpage that display Wallet and Transaction
status (obsolete or current)
* Extend the optionsdialog (e.g. language selection) and re-work it to
a tabbed UI
* Merge sign/verify message into a single window with tabbed UI
* Ensure a changed bitcoin unit immediately updates all GUI elements
that use units
* Update QR Code dialog
* Improve error reporting at startup
* Fine-grained UI updates for a much smoother UI during block downloads
* Remove autocorrection of 0/i in addresses in UI
* Reorganize tray icon menu into more logical order
* Persistently poll for balance change when number of blocks changed
* Much better translations
* Override progress bar design on platforms with segmented progress
bars to assist with readability
* Added 'immature balance' display on the overview page
* (Windows only): enable ASLR and DEP for bitcoin-qt.exe
* (Windows only): add meta-data to bitcoin-qt.exe (e.g. description)

Internal codebase
-----------------
* Additional unit tests
* Compile warning fixes


Miscellaneous
-------------
* Reopen debug.log upon SIGHUP
* Bash programmable completion for bitcoind(1)
* On supported OS's, each thread is given a useful name

------------------------------

Thanks to everybody who contributed to this release:

Chris Moore
Christian von Roques
David Joel Schwartz
Douglas Huff
Fordy
Gavin Andresen
Giel van Schijndel
Gregory Maxwell
Jeff Garzik
Luke Dashjr
Matt Corallo
Michael Ford
Michael Hendricks
Peter Todd
Philip Kaufmann
Pieter Wuille
R E Broadley
Ricardo M. Correia
Rune K. Svendsen
Scott Ellis
Stephane Glondu
Wladimir J. van der Laan
cardpuncher
coderrr
fanquake
grimd34th
sje397
xanatos

Thanks to Sergio Lerner for reporting denial-of-service
vulnerabilities fixed in this release.


-------------------------------------
On Thu, Mar 01, 2012 at 01:09:02PM +0000, Ben Reeves wrote:

I don't understand this.


Just disallowing duplicate coinbases is possible, but it requires keeping a
set of all coinbases transaction around until infinity. That's not really a problem,
but it can be avoided. One very reasonable proposed solution is adding the block
height to the coinbase. However, as coinbases are used for all kinds of things
already, this is harder to roll out network-wide. Hence, first this "emergency"
solution that already prevents (afaik) all practical attacks, and in a later step
forcing unique coinbases, so that transactions can be assumed to be unique
identifiable by their hash again.

-- 
Pieter


-------------------------------------
On Sun, Feb 19, 2012 at 17:38, Michael Gronager <gronager@ceptacle.com> wrote:

you probably need to be whitelisted, but i'm not sure.
https://bitcointalk.org/index.php?topic=15911.0

h


-------------------------------------
I too support BIP21 over BIP20. However, I do not understand the "Sending money via private key" feature; in which situation would such a URI be useful?

Also, I posted a proposal in the forum, to extend the URI syntax with signatures. The goal would be to provide a proof of identity of the recipient; genjix told me that it would be more appropriate to post that here.

My proposal is described here: http://ecdsa.org/bitcoin_URIs.html

My original forum post is here: https://bitcointalk.org/index.php?topic=58534.msg689190#msg689190

-- 
Empfehlen Sie GMX DSL Ihren Freunden und Bekannten und wir
belohnen Sie mit bis zu 50,- Euro! https://freundschaftswerbung.gmx.de


-------------------------------------
(Also posted on the forum: https://bitcointalk.org/index.php?topic=128900.0)

The amount of "dust" in the block chain is getting large and it is growing all the time. Currently 11% of unspent tx outputs (UTXO) are of 1Satoshi (0.00000001BTC), 32% is less than 0.0001BTC and 60% is less than 0.001BTC. (Thanks to Jan for digging out these numbers!)

This means that a huge part of the block chain is used for essentially nothing - e.g. the sum of the 11% is worth roughly 2 US cents !

The main source for these 1 Satoshi payouts is Sahtoshi Dice. And nothing wrong with that, however, we should work on ensuring that too many too small payments will not kill the size of the blockchain in the end - further, they are essentially too small to be included in other transaction as the added fee will often make it more expensive to remove them. Hence, there is no incentive to get rid of them.

I have an idea for a possible mitigation of this problem - introduction of demurrage - not as in it normal meaning as a percentage over time (see:http://en.wikipedia.org/wiki/Demurrage_(currency) btw, this has also been tried in freicoin), but as a mean to recycle pennies over time. The proposal is simple - UTXOs age out if not re-transacted - the smaller the coin the faster the aging:
1-99 Satoshi: lives for 210 blocks
100-9999 Satoshi: lives for 2100 blocks
10000-999999 Satoshi: lives for 21000 blocks
1000000-99999999 Satoshi: lives for 210000 blocks

Only amounts above 1BTC lives forever - (or we could even impose aging on those too..)

The aged coins are simply included in the block mining reward, creating another incentive for miners. Further, if we include all coins in this recycle scheme coins will never be lost forever. 

This scheme will impose some lifetimes also on e.g. colored coins (hence you need to use a certain amount to borrow space on the blockchain for the time needed, or simply transact them).

If you like this I would be happy to write it into a BIP.

Thoughts ?

-------------------------------------
I mentioned this somewhere a while ago.
It is enough of a sysadmin problem to warrant a feature ticket.
Open one on github for it.
XDGBDS is not canon. So don't hardcode said paths.
All paths should be specifiable in bitcoin the config file, whose
location should itself be specifiable on the command line.


-------------------------------------
Thanks for the patch and the detective work!

Enabling dynamic libs was on my TODO, but on the Redmond_OS_not_to_be_mentioned you need to :
* prepend class definitions with __declspec(dllexport) when you compile the dll
* prepend class definitions with __declspec(dllimport) when you use the dll
I just love the way they spoil their developers...

I have the framework to automate this with CMake from a former project, but I havn't tested it for libcoin yet, hence the static build. And well, iOS also has this fetich for static libs.

I also recall another issue with dll's: If you define a global variable it is shared between all executables using this dll. I have still a handful of globals to clean out, namely those related to logging - I will do so, but it has not yet been a top priority. 

So, feel free to use dynamic libs on unix'es, but on windows it is .libs for a little while longer.

Will fix the Qt stuff in CMake - thanks!

Cheers,

Michael


On 02/02/2012, at 17:30, Luke-Jr wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------

That's true. Though if you prune up to the last checkpoint, orphans
before that point can be safely thrown away.

I wonder if swapping out bdb for LevelDB might make sense at some
point. I'm not sure how deterministic that is either though :)


-------------------------------------
On Monday, January 16, 2012 7:46:39 PM Alan Reiner wrote:

Sorry, Bitcoin is not about the same thing to everyone. For me, Bitcoin is 
about one thing: providing a monetary system for the Tonal number system. 
Otherwise, it would be merely an interesting project I have no real concern 
with. To assume everyone has the same interests is a sure-fire way to prevent 
widescale adoption. If you want Bitcoin to succeed, don't try to impose a 
single purpose/"about" on everyone using it (which a "blackout" would do).


Bitcoin is an innovative new currency. How is a bill on internet censorship 
(which is badly needed, even if not in the form of SOPA/PIPA) directly 
relevant? I don't think it is.



-------------------------------------
Supporting DNSSEC/DANE in the future when they are widely deployed is a great idea.

Note that the x509chain field is 'repeated', and any repeated field may have zero entries. So I would suggest supporting other PKI systems in the future by adding optional new fields (for maximum compatibility or security merchants might want to include both a x509chain AND 

--
Gavin Andresen



-------------------------------------
On Fri, Dec 21, 2012 at 3:53 AM, Eric Lombrozo <elombrozo@gmail.com> wrote:

How about a rpc like "usewallet <foo> <normal RPC>"  that simply
generalizes all the rpcs?

And instead of explicitly deactivating rpcs that don't make sense,
simply have them return an error.  Or, for example,  sendtoaddress on
a watching wallet should actually return an unsigned raw transaction
and a wallet specific message that tells you where to find the private
key.

I think it's desirable to not break compatibility but for this kind of
feature compatibility should not get in the way of doing it right.


-------------------------------------
I suppose I mean that I don't understand how to reverse that into a URL
when one is presented only with a block, or perhaps a coinbase in a
transaction.

Best,

Peter

On Tue, May 29, 2012 at 11:34 AM, Luke-Jr <luke@dashjr.org> wrote:




-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
Didn't even know that they were proprietary software bitcoin clients.
Should people trust them? Should the web promote them?
After all, you can't know what they do. What if one of them contains a
back door or something?
I would say it's better not risk to apologize later.



On 7/9/12, Andreas Schildbach <andreas@schildbach.de> wrote:


-- 
Jorge Timn


-------------------------------------
Took me a while, but finally got it working.

Entries on the clients page are randomly ordered when the page is generated.

https://github.com/bitcoin/bitcoin.org/commit/6850fc8c83494d6ec415ea9d36fb98366373cc03

We should regenerate the page every 2 days. This gives fair exposure to all the clients listed.



-------------------------------------
Hi Thiago,

Forgot to comment on the two latter:


401 = permission denied - you need to setup username / password either on the commandline or in the bicoin.conf file to access those commands...

See in the bitcoind.cpp file for commands that you can use with and without auth...

Those that contains an "auth" requires auth:

       server.registerMethod(method_ptr(new GetBalance(wallet)), auth);

As opposed to:

       server.registerMethod(method_ptr(new GetInfo(node))); 

auth is defined by:

       Auth auth(rpc_user, rpc_pass); // if rpc_user and rpc_pass are not set, all authenticated methods becomes disallowed.

so you just experience the case explained in the comment ;) I admit that the output could be more readable, though!

/M





-------------------------------------

Perhaps not worry about removing it too much. As above, if blocking
or other issues arise, people will be hosting manual lists and nodes
on hidden sites... Tor/I2P/etc. The nodes are already there.
For that matter, since the nodes are talking once seeded, why not
deploy a DHT and be done. All you'd need is one friendly node and
the list comes in and maintains itself through node expiry rules.
Your node publishes its hello for others to discover, etc.
IRC, DNS, etc would go away in favor of autonomy. It wouldn't
be any more resistant. But if people wanted that, some form of
signatures from the hidden nodes would do... if you trusted them.
Booting and running is easy, trust isn't (ask the Tor/I2P people).


-------------------------------------

As you presumably already know, the reference client doesn't attempt
to parallelise most operations at all. Chain download is entirely
single threaded.


-------------------------------------
On 04/26/2012 01:30 PM, Peter Todd wrote:

Went on a scavenger hunt with Gavin a couple weeks concerning tx 
replacement.  The conclusion was that if,
(1) Transaction has lock-time in the future  AND
(2) Transaction has non-maximum sequence number

Then the transaction will both propagate and be accepted into nodes' 
memory pools, but will not go into any block until locktime expires.  If 
the lock-time is in the past OR sequence number on all TxIns is 
0xffffffff, then it will be immediately valid and included in the 
blockchain.

But the actual "replacement" mechanism is disabled.  Therefore, the 
nodes accept the tx as if it's replaceable, but don't allow it to be 
replaced.  This means that it is effectively replaceable *once*, but 
only if you inject a final transaction into the blockchain.   You can't 
broadcast a final version of the same tx, because it will conflict with 
the non-final one sitting in all the other nodes' memory pools.  You 
need a miner to agree to remove the non-final tx from their memory pool 
and specifically include your replacement.

-Alan


-------------------------------------
Bitcoin already keeps track of which nodes have seen what to avoid
redundant inv announcements.

I think if you are approaching most transactions in a block matching the
filter then you would just request full blocks and do all the filtering
client side
On Oct 24, 2012 8:54 PM, "Gavin Andresen" <gavinandresen@gmail.com> wrote:

-------------------------------------

Unfortunately it appears to be just as dead as the one
on sourceforge.


Well there's a couple things I see...

1) Yes, IMO, a real mailing list for users needs to exist.
Among the prior reasons... lists tend to house a more
technical crowd than forums which are magnets for
initiates.
2) There was originally one client. Now there are many,
all adherant to the same bitcoin spec. So while:
 bitcoin-development@lists.sourceforge.net
represents the dev community for the original client,
it may not, or won't be, for any other client.
And as:
 bitcoin-list@lists.sourceforge.net
was for, and is administratively tied to, the original client...
it may not be the place, or a welcome one, to hold talk of all
the adherant clients.
3) The sourceforge list browsing interface is ridiculously
lame and overweight, and it doesn't appear to be setting
a '^Reply-to: ' header which is bad. Googlegroups would
be an ok site I suppose. And a pure MailMan interface would
be even better and more customarily accepted.

So for the user list, I'd suggest:
1) Search a bit to make sure there's not already a busy list
out there somewhere. Check the list aggregator sites
like markmail, gmane, etc too.
2) Charter it as bitcoin protocol, client agnostic.
3) Find an impartial administrative and robust home for the list
with browsable, searchable and hopefully downloadable archives.
4) Make the announcement to other known client lists/forums.
5) Close any relevant old lists.
6) Promote via similar announcement from time to time.


http://groups.google.com/group/bitcoin-discussion/about
Description: A place for discussion related to bitcoin.

Is this sufficient charter to go with? Is the creator/maintainer
known impartial? What happens to ongoing list operations when
said people vanish? It is presumed googlegroups itself is robust.


-------------------------------------
I submitted a pull request yesterday that implements low-level "raw"
transaction, and am looking for feedback on the API and help with
trying to test/break it.

Design doc:  https://gist.github.com/2839617
Pull request: https://github.com/bitcoin/bitcoin/pull/1456
Test plan: https://secure.bettermeans.com/projects/4180/wiki/Raw_Transaction_RPC_Test_Plan

Playing around with this API on the command line I'm pretty happy with
the level of abstraction and the way it interacts with existing RPC
commands; for example, "createrawtx" is just like "sendmany" in the
way outputs are specified.

The signrawtx method is the key new method; it takes a raw
transaction, signs as many inputs as it can, and returns the same raw
transaction with signatures. Typical usage would be:

Funds are sitting in a multisignature transaction output, and it is
time to gather signatures and spend them.

Assumption: you know the multisignature transaction's [txid,
outputNumber, amount].

Create a raw transaction to spend, using createrawtx.
Use signrawtx to add your signatures (after unlocking the wallet, if necessary).
Give the transaction to the other person(s) to sign.
You or they submit the transaction to the network using sendrawtx.
I don't imagine anybody but very-early-adopters or ultra-geeks will do
this by calling these RPC methods at a command-line. They are really
intended for people writing services on top of bitcoind. The service
should be careful to include an appropriate transaction fee, or the
sendrawtx method is likely to fail.

I've been asked a couple of times: why doesn't signrawtx handle the
BIP 0010 (https://en.bitcoin.it/wiki/BIP_0010) transaction format?

I considered parsing/writing BIP 10 format for raw transactions, but
decided that reading/writing BIP 10 format should happen at a higher
level and not in the low-level RPC calls. So 'raw transactions' are
simply hex-encoded into JSON strings, and encoding/decoding them is
just a couple of lines of already-written-and-debugged code.

------

Here is the help output and example use for all the new RPC calls:

listunspent [minconf=1] [maxconf=999999]
Returns array of unspent transaction outputs
with between minconf and maxconf (inclusive) confirmations.
Returns an array of 4-element arrays, each of which is:
[transaction id, output, amount, confirmations]

E.g:  listunspent 1 2
Returns:
[
    [
        "2881b33a8c0bbdb45b0a65b36aa6611a05201e316ea3ad718762d48ef9588fb3",
        0,
        40.00000000,
        2
    ],
    [
        "894a0fc535c7b49f434ceb633d8555ea24c8f9775144efb42da85b853280bcd7",
        0,
        50.00000000,
        1
    ]
]

getrawtx <txid>
Returns hexadecimal-encoded, serialized transaction data
for <txid>. Returns an error if <txid> is unknown.

E.g.: getrawtx fce46ea2448820f7bb8091b5f5e3fd75b7b267e60b9a22af88a9eeabfb084233
Returns:
01000000016d40da062b6a0edcaf643b6e25b943baf103941589d287e39d6f425d84ae8b1c000000004847304402203fb648ff8381d8961e66ef61ab88afe52826a5179b8a7312742c8d93785ca56302204240ea12de1211fffab49686f13ca0e78011d1985765be6e6aa8e747852f897d01ffffffff0100f2052a0100000017a914f96e358e80e8b3660256b211a23ce3377d2f9cb18700000000


createrawtx [["txid",n],...] {address:amount,...}
Create a transaction spending given inputs
(array of (hex transaction id, output number) pairs),
sending to given address(es).
Returns the same information as gettransaction, plus an
extra "rawtx" key with the hex-encoded transaction.
Note that the transaction's inputs are not signed, and
it is not stored in the wallet or transmitted to the network.

E.g.: createrawtx '[
["fce46ea2448820f7bb8091b5f5e3fd75b7b267e60b9a22af88a9eeabfb084233",0]
]' '{"mqYmZSQQuAWNQcdwBrDwmtTXg2TLNz748L":50}'
Returns:
{
    "version" : 1,
    "locktime" : 0,
    "size" : 85,
    "vin" : [
        {
            "prevout" : {
                "hash" :
"fce46ea2448820f7bb8091b5f5e3fd75b7b267e60b9a22af88a9eeabfb084233",
                "n" : 0
            },
            "scriptSig" : "",
            "sequence" : 4294967295
        }
    ],
    "vout" : [
        {
            "value" : 50.00000000,
            "scriptPubKey" : "OP_DUP OP_HASH160
6e0920fc26383dc7e6101bc417cf87169d0cedbd OP_EQUALVERIFY OP_CHECKSIG"
        }
    ],
    "rawtx" : "0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc0000000000ffffffff0100f2052a010000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd88ac00000000"
}

signrawtx <hex string> [<prevtx1>,<prevtx2>...]
Sign inputs for raw transaction (serialized, hex-encoded).
Second argument is an array of raw previous transactions that
this transaction depends on but are not yet in the blockchain.
Returns json object with keys:
  rawtx : raw transaction with signature(s) (hex-encoded string)
  complete : 1 if transaction has a complete set of signature (0 if not)

E.g.: signrawtx
"0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc0000000000ffffffff0100f2052a010000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd88ac00000000"
'["01000000016d40da062b6a0edcaf643b6e25b943baf103941589d287e39d6f425d84ae8b1c000000004847304402203fb648ff8381d8961e66ef61ab88afe52826a5179b8a7312742c8d93785ca56302204240ea12de1211fffab49686f13ca0e78011d1985765be6e6aa8e747852f897d01ffffffff0100f2052a0100000017a914f96e358e80e8b3660256b211a23ce3377d2f9cb18700000000"]'
Returns:
{
    "rawtx" : "0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc000000009100473044022007f3ba1b8bdc156f2340ef1222eb287c3f5481a8078a8dad43aa09fd289ba19002201cc72e97406d546dc918159978dc78aee8215a6418375956665ee44e6eacc1150147522102894ca6e7a6483d0f8fa6110c77c431035e8d462e3a932255d9dda65e8fada55c2103c556ef01e89a07ee9ba61581658fa007bf442232daed8b465c47c278550d3dab52aeffffffff0100f2052a010000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd88ac00000000",
    "complete" : false
}

sendrawtx <hex string>
Submits raw transaction (serialized, hex-encoded) to local node and network.
E.g.: sendrawtx
0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc000000009100473044022007f3ba1b8bdc156f2340ef1222eb287c3f5481a8078a8dad43aa09fd289ba19002201cc72e97406d546dc918159978dc78aee8215a6418375956665ee44e6eacc1150147522102894ca6e7a6483d0f8fa6110c77c431035e8d462e3a932255d9dda65e8fada55c2103c556ef01e89a07ee9ba61581658fa007bf442232daed8b465c47c278550d3dab52aeffffffff0100f2052a010000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd88ac00000000
Returns:
error: {"code":-22,"message":"TX rejected"}

(Rejected because it doesn't have all required signatures, if it was
accepted it would return the transaction id)

-- 
--
Gavin Andresen


-------------------------------------
It would be nice if Bitcoin was engineered this way from the start. The amount of workarounds, special cases and code bloat to deal with the fact that txs are non-unique was a massive headache for me.




________________________________
From: Mark Friedenbach <mark@monetize.io>
To: Jeff Garzik <jgarzik@exmulti.com> 
Cc: Bitcoin Development <bitcoin-development@lists.sourceforge.net> 
Sent: Friday, July 6, 2012 6:56 PM
Subject: Re: [Bitcoin-development] BIP 34: Block v2, Height in Coinbase


On Fri, Jul 6, 2012 at 9:49 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

On Fri, Jul 6, 2012 at 12:45 PM, Peter Vessenes <peter@coinlab.com> wrote:

But those issues are solvable through other, non-backwards incompatible means. For example, mandate that a <transaction hash, output index> refers to the first such pair that is not already spent. No?

Mark
------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------------------------------

Ultra-lightweight clients like Electrum or smart cards have a
fundamentally different security model to SPV clients, which mean they
cannot connect directly to the P2P network no matter what commands or
db indexes are added.

This seems to be a common point of confusion. Andreas brought up
something similar in a chat yesterday.

To connect to the P2P network, you MUST understand how to walk the
block chain and handle re-orgs. This is not optional. The reason is
that you are connected to random arbitrary nodes who can and maybe
will lie to you. The block chain is a self-proving data structure, a
node cannot lie about it or make you believe garbage unless they can
outrun the rest of the miners combined.

If all you're doing is asking a remote node to tell you about what
coins are available, that node can simply say "guess what, you're a
millionaire!" and you have no way to discover it's wrong. This can be
dangerous in the case where you think you've received a payment but
actually did not, eg, because your internet connection got tampered
with in some way. SPV clients have the same issue for zero-confirmed
transactions, but once you see confirmations at high speeds you can be
pretty sure the network accepted the transaction. For clients that
don't understand the block chain confirmations don't have any meaning.

That's why Electrum requires a trusted server and connects to it via SSL.


It doesn't matter. CPU wise Bloom filtering of blocks is very cheap
and can be trivially parallelised in the unlikely event it's
necessary. The expensive part of serving a Bloom filtered chain to an
SPV client is simply moving the disk head into the right position and
waiting for the platter to rotate. Blocks are stored sequentially and
modern hard disks transfer data once positioned at gigabit speeds so
requesting 1 or 2000 blocks is not significantly different.


-------------------------------------
Meh, probably harmless, but...

As best I can tell, OP_RESERVED does absolutely nothing (a NOP).

CScript::IsPushOnly(...) counts this as a push operation.



-------------------------------------
Are we just talking about pruning the spent transactions from an old block?
 We already have a data structure that allows us to replace any un-needed
transaction by just it's hash - and possibly a whole sub-tree if we get
lucky in that the un-needed transaction all fall within a common node of
the merkle tree.

If a lite client only cares to retain a single transaction in a block (the
most common case) - it will only need O(log2(T)) merkle hashes plus the
transaction it cares about.

Does it really make sense to adopt a more complex data-structure than the
merkle tree for inclusing in the bticoin protocol?  And we're not talking
about blocks with millions of transactions in them - I don't understand the
relevance of Order statistics for random access to a transaction given its
block.

On Tue, Jun 19, 2012 at 11:30 AM, Alan Reiner <etotheipi@gmail.com> wrote:



-- 
Mike Koss
CTO, CoinLab
(425) 246-7701 (m)

A Bitcoin Primer <http://coinlab.com/a-bitcoin-primer.pdf> - What you need
to know about Bitcoins.
-------------------------------------
On 9/23/12, Jeff Garzik <jgarzik@exmulti.com> wrote:

I don't understand. Can the chain enforce this number?
Why can't clients delete all those transactions right now?

On 9/23/12, Gregory Maxwell <gmaxwell@gmail.com> wrote:

Why clients store transactions that don't obey the current rules of
the chain at all?


-------------------------------------
I would like to chime on on the user experience of the SPV client (in
particular MultiBit).

Without exception, everyone that I have introduced Bitcoin (which is a lot
of people) have expected an "instant-on" experience. It has to clobber
PayPal and credit cards or people won't give it a second look, let alone a
second chance. SPV clients deliver on that expectation.

Once the user has the great initial "wow!" moment then their interest in
Bitcoin is reinforced and they tend to explore further, particularly into
the economic theory behind it. Many decide to install the full node out of
a sense of community contribution to the security of the network.

Having a hybrid mode of SPV first then full node second should be something
that a user has control over - it is their computing resources we are using
after all and Bitcoin should not be perceived as a drain.


On 5 December 2012 07:50, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------
It seems to me the whole idea of segmenting blocks would add very little
(to nothing) with any sane block size.  Sure, if a block were to be
10GB, it may make sense.  However, even in that case, it would be easier
to relay a list of tx hashes (which may be a bit expensive) and txes
separately instead of using a notion of block segments.  That said, I
don't see blocks ever being that large and if they do become that large,
as only a few full nodes will remain, upgrading their protocol would be
(relatively) easy.  I would instead encourage focus on decreasing block
relay times for the current network and as blocks approach 10MB (so that
they can approach 10MB).

Matt

On Mon, 2012-09-10 at 20:34 +0100, Matthew Mitchell wrote:




-------------------------------------
I'm sure that there are many but my Google Search-Fu is not strong enough
to build a query to identify how widespread they are.

Maybe once we have sufficient evidence to support the suspicion we should
post to the main developer forum asking for a cleanup. After all, a Bitcoin
URI starting bitcoin://<address> doesn't actually make much sense because
there is no hierarchy in Bitcoin - it's flat with only an address being a
mandatory element.

I don't want to be all anal about this, but looking at RFC 3986 #10 (
http://tools.ietf.org/html/rfc3986#page-10) it's pretty clear that
introducing a false hierarchy is breaking the specification since it
presumes the existence of a relative URI.

On 16 July 2012 10:02, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------
On Fri, 2012-06-15 at 15:23 +0200, Mike Hearn wrote:
IMHO it already is.  A node requests a filter using filterinit by
specifying the false positive rate it wants and a guessed number of
items.  The node which will have to hold that filter then responds with
the closest filter to what the SPV node requested that it is willing to
provide.  If the SPV node responds with a filterload command, it has
accepted the offer, otherwise it will simply disconnect and find a
better full node.  
I'd much rather have an overloaded node respond with 50% fp rate filters
as an option if there aren't many full nodes available than simply
disconnect SPV clients.
At least thats my thinking, but you may be right that it is too heavy
for too little gain.



-------------------------------------
On Wednesday, August 22, 2012 2:25:20 AM Forrest Voight wrote:

From the mining perspective, the unpatched install might not be simply wedged: 
it will also follow a competing smaller blockchain. An attacker could have 
used this exploit against a number of large miners (say about 40% or so) and 
exchanges to pull off any number of double-spend attacks until the miners 
noticed they had been forked and fixed their bitcoind. That is, the attacker 
could easily hijack as much of the miners has he wanted for his own purposes 
including phony 6+ confirmation transactions. On a more subtle level, the 
attacker could target certain blocks they wanted orphans by performing this 
attack on a majority of miners with the "tip" block he wanted orphaned.

This vulnerability is also the reason why Eloipool (the software behind 
Eligius, EclipseMC, TripleMining, and other pools) has attempted to produce 
blocks with only transaction counts that are powers of two; such blocks cannot 
be used for an attack even against vulnerable clients.

Luke


-------------------------------------
Running a concurrent Mantis tracker would be confusing and fragment the
development pathway. We have an issue tracker; it's on github.

What's being talked about here are two separate things. Jenkins is a
continuous integration system. It can be configured to run the suite of
unit tests, regression tests, and any kind of automated functional tests
for every commit on github and every pull request.

Github is our issue tracker. Github, and only github, is where new issues
should be reported (unless it's security related, in which case an email
should be sent to the core devs directly).

Certainly developers should be responsible for making sure that regression
tests for bugs they fix make it either into the unit tests or Matt's
functional test repository. QA should hold them accountable for that
(re-opening tickets for bugs that have been fixed but without regression
tests).

The other thing we're talking about is coordinated release testing--getting
release candidates in the hands of actual users and making sure that issues
are reported. This is something that can't be automated as the point really
is to pick up on things that the testing suite missed. You sound more
qualified than me for coming up with a process, but in the end discovered
issues should be reported to github, the final repository of issues that
hold up Gavin from doing a release.

Just my 0.002BTC
Mark

On Wed, Sep 26, 2012 at 6:22 AM, steve <steve@mistfpga.net> wrote:
-------------------------------------
On Monday, July 16, 2012 11:47:02 PM Jeff Garzik wrote:

IMO, bitcoin.org is more community-focussed anyway.
How often do devs use the site, compared to GitHub etc?

Someone else made a pullreq for Bitcoin Magazine; I suggest(ed) that
for-profit organizations should be asked to pitch in some way or another.
Who should organize that, I don't know. If Bitcoin Consultancy/Amir is behind 
the conference, I suggest their/his development contributions should be 
sufficient in that respect.


I concur, this should be discussed in a pullreq.


-------------------------------------

If I mine a duplicate coinbase of an old block (whether spent or not)
if that block is then invalidated DisconnectBlock() will erase both
the coinbase of the new block and of the old block. This leaves the
blockchain is in an inconsistent state because with the coinbase
missing the old block will no longer pass CheckBlock().

When affected clients are restarted LoadBlockIndex() will try and
verify all blocks in the main chain, failing at the block with the
missing coinbase.

1) If an attacker was to do this with an early block it would force
all affected clients to redownload the majority of the blockchain.
2) If the attacker was able to do this on a block after the March 1st
deadline (future block A). If they mined a fake copy of block A (block
B) with the same coinbase but a different hash clients who received
block B before block A will refuse to accept block A because of the
unspent duplicate coinbase in block B. The attacker can then fork the
chain at this point despite the real chain being longer.

I am just think out load here so I could be wrong, but maybe it would
be better to go for the full block height fix now?

On Thu, Mar 1, 2012 at 2:27 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:


-------------------------------------
On Monday, June 18, 2012 3:27:52 AM grarpamp wrote:

Workflow is all new development takes place in master during release windows. 
Eventually, those windows close and master is cleaned up and bugfix'd for the 
next 0.x release. Occasionally, when 0.N.0 has some problem before the next 
release window opens, Gavin will use it to roll a 0.N.1 (and recently even a 
0.N.2 and 0.N.2.2). Once the release window for the next 0.N version opens,
I import the (last bugfix-only commit after the final 0.N.M release made in 
master) into the stable repository as the 0.N.x branch, and begin applying 
backports. When there's significant backports, I'll tag another 0.N.M from the 
branch and possibly release Windows binaries. Usually this happens around the 
same time as master becomes the next 0.N.0 release.


I guess I've been neglecting to update the stable repo with releases tagged in 
master. It should be fixed now.

Luke


-------------------------------------
I like the concept except that it only works if every node connected to the
miner enforces the rule (if it works).  Once any one of the nodes forwards
the block,  other nodes see it coming from a node that can pass the
challenge.

I don't think any solution based on node queries will succeed,  especially
if it requires spontaneous super-majority-of-nodes acceptance.  I think
it's gotta be based on the block itself and each nodes' own info.

If you could spontaneously get all miners to agree not to build off of
anti-social blocks (however that is defined) ,  it would have a chance of
making a difference,  but individual miners would have an advantage
building off the antisocial block because they only need to produce one to
create the longest chain (and collect reward) while the miners following
the rules need two blocks.

--Sent from my overpriced smartphone
On May 25, 2012 3:48 AM, "Christian Decker" <decker.christian@gmail.com>
wrote:

-------------------------------------
A follow up on my mail from the other day (got it send from the wrong email address...)

I now exit the ipc thread at startup by inserting:

void ipcThread(void* parg)
{
   ipcShutdown();
   return;

Bitcoin-Qt is now running nicely using around 0.9% CPU. So it seems like the culprit was indeed line 31:

if(mq->timed_receive(&strBuf, sizeof(strBuf), nSize, nPriority, d))

Others, who have seen similar issues ?

Cheers,

M 

On 21/02/2012, at 21:33, Michael Grnager wrote:




-------------------------------------
Hi Alberto,

Your thread was part of the inspiration for the idea that I proposed.  
But as I read it more, I see that I originally misunderstood it 
(mistaking it for a simpler unspent-TxOut tree idea).  Even after 
reading it, I'm not entirely clear how your proposal would work, but I 
see that you proposed something very similar.  I just want to clarify 
that there are two, major orthogonal pieces to both proposals:

(1) The method for creating unspent-TxOut-tree roots/fingerprints for 
verification
(2) Using an alternate blockchain to maintain and distribute those 
fingerprints

There are multiple ways to do both of those.  You proposed a different 
tree structure (which I haven't entirely figured out, yet), and putting 
those "fingerprints" in the main chain header.

In my proposal, (2) is to avoid inducing a blockchain fork, or even 
changing the protocol at all.  By using a separate blockchain, it can be 
done non-disruptively, and could even be thrown out and re-worked if we 
were to find an issue with it later.  The availability of merged mining 
makes it possible to get [almost] the same security as changing the 
protocol, but without the disruption of hard-forking.  (I expect that if 
there's not too much computational overhead and the software is already 
written, most miners would sign on)

I'll read into your page a little more.  I don't want to take credit 
away from you, since you clearly had a comparable idea developed long 
before me :)

-Alan


On 06/17/2012 06:46 PM, Alberto Torres wrote:



-------------------------------------
Sounds great.
Does it support merged mining?
Also, I'm a bit skeptic about it being chain agnostic. I want to
implement a chain with demurrage and I think I'll need to also change
coinWallet and not only create an implementation of the interface
Chain.
Anyway, this will make the task much easier. Thank you.
Until I have the time to code it, there's a little bounty (7.3 btc)
for this in case you're interested.


-------------------------------------
On Saturday, March 03, 2012 6:51:34 PM Geir Harald Hansen wrote:

How would you suggest addressing this? I presume if a share solves blocks on 
multiple chains, you just longpoll once when that's successful?


Hmm, the problem is that adding any parameters to getmemorypool itself breaks 
compatibility with bitcoind 0.5, and using HTTP headers makes it HTTP-specific 
again. Any ideas?


Good catch. Should this be required (since it might be necessary for future 
Bitcoin blocks), or just "should" for compatibility?


What is unclear about this?


Doing this safely needs some way for clients to communicate capabilities to 
the server, which has the problem of passing parameters to getmemorypool.


There is no mining hardware to date that exhausts even half the nonce space, 
so I'd really prefer to see this as a required feature on the miner side. On 
the other hand, it's merely an extension for getwork, so I can see the problem 
so long as we're using getwork proxies.

Luke


-------------------------------------
Just run a query over the entire blockchain, looking at script opcode
use. I counted the number of times each opcode was used, in total:
https://gist.github.com/3180470

(data in full)
OP_0 104
OP_1 27
OP_2 12
OP_2OVER 182
OP_2SWAP 182
OP_3 16
OP_4 1
OP_CHECKMULTISIG 22
OP_CHECKSIG 12188693
OP_CODESEPARATOR 14
OP_DEPTH 182
OP_DROP 19
OP_DUP 11699991
OP_EQUAL 88
OP_EQUALVERIFY 11699985
OP_HASH160 11700067
OP_IF 182
OP_IFDUP 182
OP_MIN 4
OP_NOP1 1
OP_NOP2 15
OP_NOP 5
OP_PUSHDATA1 18
OP_PUSHDATA2 4
OP_PUSHDATA 32350369
OP_SHA256 2
OP_VERIFY 182


-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Given a testbed: Pentium 4 1.8GHz single core, 2GB ram, FreeBSD 8,
disk is geli aes-128 + zfs sha-256, bitcoin 0.6.3, Tor proxy,
An estimate is made that by the end of the year bitcoin will
completely overrun the capabilities of this reasonable class of
machines.
It already takes a month to build a new blockchain, let alone keep up
with new incoming blocks.
Yes, it also has workstation duties, yet even if those were removed,
it would probably choke by mid 2013.

It would appear bitcoin has some *serious* scalability hurdles coming
down the road.
Most certainly if the user expects to independantly build, manage, and
trust their own blockchain.


-------------------------------------
On Thu, Apr 26, 2012 at 10:11:51AM -0700, Peter Vessenes wrote:

There's gotta be a lot of subtlies there. For instance, if I just want
to double-spend, the easiest approach would be to first buy a whole
bunch of VPS's, each with different /16's for their IP address to defeat
that anti-sybil measure. Then figure out what is the set of nodes
closest to my target - easier for an active target that makes a lot of
transactions.

Then it's just a matter of giving them my transaction, and immediately
flooding the network faster with my nodes than their single node. It's
not block-replacement, but it would be effective against people who
accept 0-confirmations. (although as Gavin has pointed out elsewhere, in
the future miners may be very happy to replace transactions for more
fees in that kind of circumstance)

Of course, this whole trusted identities business could be equally used
for the bitcoin flood network as a whole to prevent sybil's, and perhaps
even get guarantees of behavior like "My node respects nLockTime and
won't ignore it for a higher-fee transaction replacement"


Yup, especially when a human is in the loop.


My understanding is it's completely disabled.

-- 
http://petertodd.org 'peter'[:-1]@petertodd.org
-------------------------------------
URL: https://github.com/bitcoin/bitcoin/pull/2100

1) Create COIN_DUST constant, to represent the dust spam limit used.

2) Decrease COIN_DUST to 0.001 BTC

Rationale: With the increase in bitcoin value (US$13.67 as of this
writing), it seems reasonable to reduce the value level of which we
consider "dust spam."

3) Update TX miner and relay fee defaults to 0.001 / 0.0005 BTC respectively

Rationale: Reflects growth of dust spam in unspent transaction output dataset.

Review of impact:
a) Definition of COIN_DUST reduced from 0.01 to 0.001.
b) Miners who mine with this code will require a fee >= 0.001 to
include TX's with outputs <= COIN_DUST
c) Normal clients will require a fee >= 0.0005 to relay TX's with
outputs <= COIN_DUST

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Thu, Nov 29, 2012 at 06:31:24PM +0100, Mike Hearn wrote:

[snip]

All good reasons, thanks for the explanation.

Though I still like my idea of a ValidatePurchase message that allows
a buyer to ask a merchant "would you accept this payment?" without
actually supplying a signed transaction.  Make it optional if you care
about minimising the number of round trips, e.g. for fast NFC
payments.

Having such a message reduces the extent to which you need to trust
the merchant not to spend a transaction that they've rejected.  (And
in the non-Internet connected case this is particularly useful since
the client won't have the ability to broadcast a pay-to-self
transaction.)

roy




-------------------------------------

There are lots of successful binary protocols: TCP, IP, PNG, JPEG,
MP3, DNS, SSH, SSL, the Bitcoin protocol itself. What's more some
other protocols that are text based have suffered serious problems due
to that choice. Witness the absurd design of SMTP that means you can't
start a paragraph with the word From because that's a new-message
marker! Or the fact that file attachments grow by 33% when you send
them. Or the various exploits that can exist in web servers thanks to
header splitting attacks.

Trying to represent something binary as text doesn't make any sense.
If you look at these data structures they consist of keys, signatures,
hashes, certificates and other fundamentally binary things. You'd just
end up base64 encoding everything anyway, at which point all you've
done is design an inefficient binary protocol that masquerades as
text. The disadvantages of both with the advantages of neither.

Protocol buffers have a text form that you can print to and parse
from, if you so wish, though I only normally see people use that
support for debug prints and sometimes because they want to load
hand-written config files directly into protobuf generated objects.


-------------------------------------
On Mon, Jul 9, 2012 at 12:04 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

Agreed, and this would be why I support revert -- pull requests are
for anything non-trivial.  This practice of pull requests clearly
should be followed in the case of controversial changes.


Agreed.
-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I have added a simplified fall back class to the boost::asio::signal_set. This should enable compilation on platforms with less than bleeding edge versions of Boost. Most notably most of the currently deployed Linux'es that use Boost 1.42.

I also updated the root CMakeLists.txt to only require 1.42. It works for me, but I also recognize the fact that committers machines has some intrinsic magic that just makes things work, hiding actual errors for the them ;)

Please test and feed back.

Cheers,

Michael


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Hi bitcoin-development,

blockchain.info generates non-BIP-compliant URIs in its QRcodes, as
does its iPhone app. They are of the form bitcoin://address not
bitcoin:address.

I asked Ben to fix this (social networks don't parse QRcodes after
all), but after explaining that social networks don't parse URLs
without :// in them, he stopped responding to my emails. So I've gone
ahead and added support for reading these types of URLs to bitcoinj,
in the interests of "just works" interoperability.

This mail is just a heads up in case anyone else wants to do the same
thing. Hopefully at some point, Ben will stop generating such QRcodes
and we can remove these hacks and get back to BIP compliance.


-------------------------------------
On Sunday, March 18, 2012 10:04:27 AM Amir Taaki wrote:

You might find my 0.4.x backport helpful:
    https://github.com/luke-jr/bitcoin/commit/bip16_0.4.x
Be aware, this still needs auditing (nobody else has looked it over), but I 
believe should cover only the minimal changes required to get P2SH validation 
(though not the "standard" rule changes to accept them into blocks).


-------------------------------------
On Fri, Jul 6, 2012 at 4:02 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

It's important to note that bip 30 doesn't prevent duplication, it
just prevents the identified really evil outcome of the duplication.

There was discussion on doing the height _before_ that, but the
realization that the rewrites were a real vulnerability made it urgent
and rolling out the height will require time while the bip30 change
could be deployed more quickly.


-------------------------------------
I've been testing how the Bitcoin-Qt GUI deals with multisignature transactions.

The good news is it seems to display them just fine; even my
insanely-messy test wallets look reasonable.

It does not support sending multisig/BIP16 transactions, which is
definitely a feature for the main network (we don't want users sending
them until they will get relayed, get mined, AND will be fully
verified by a large super-majority of miners).

But... to encourage more testing it might make sense to enable sending
multisig transactions in the GUI if (fTestNet).

So I see two possible paths:

1) Leave the GUI as-is; require multisig testing to use the RPC interface.
 Note: the RPC call that make multisig sends possible
(addmultisigaddress) is disabled for the main network for the 0.6
release.
 Don't start rolling out GUI support until the next (0.7?) release cycle.

2) Start implementing multisig support in the GUI during the 0.6
release process, enabled only for test network. This could be as
simple as allowing the 35-character BIP16 multisig addresses in the
'send' dialog, to as complicated as adding/extending dialogs that let
you create multisig addresses to add to your address book.

Advantage of (1) is it should mean 0.6 gets to final release faster.

Advantage of (2) is it should mean more testing of multisig, and fewer
bug reports of "I added a multisig address via RPC but I can't send to
it using the GUI"

My opinion: I think it is worth allowing send-to-multisig-address via
the GUI (should be a very simple change to the address validation
logic).  But creating multisig addresses via the GUI should wait until
the next release.

-- 
--
Gavin Andresen


-------------------------------------
I had hope the Testing Project would be self-organizing, with somebody
taking on the QA lead role and figuring out the hard questions like:

+ How to do fundraising?
+ If/when bitcoins are available, how to decide who gets rewarded for what?
+ If somebody wants to help, how do they start?

Steve jumped in and started creating a gazillion tests cases, which is
great, but creating test cases isn't the hard part. Creating a
"community" of testing that gets things done is the hard part that I,
frankly, don't have time to do.

I hoped that the BetterMeans platform would help, but it sounds like
it was more of a hindrance than a help.  Ok:  live and learn.  Failed
experiment, lets move on...

So, RE: moving on:  I'd like to tag a 0.7.1rc1 release in the next few
days (I'll start another thread about that). How about a very
short-term goal of getting these QA deliverables:

1. A process for QA testers to sanity-test release builds, and
sign-off as "Tested/problems found" or "Tested/OK"
2. Some place online I can look to see if all of our supported
platforms have been tested before promoting a release candidate to
"final release"



PS: Thanks to Peter for responding to the "what's the relationship
between the Foundation and the Testing Project" (executive summary: no
relationship right now).

-- 
--
Gavin Andresen


-------------------------------------
I've been playing with the tools in db 4.8.30, and bitcoin stable...
My blockchain is up to date. Bitcoin is not running.

#  strings database/*
This will at times yield the addresses in your wallet.
So it's not exactly in compliance with 'only your wallet file matters'.

Bitcoin always leaves behind at least one "database/log.nnn" file.
Shouldn't it roll and delete it on exit like it does the other state files?
Particularly after a simple "we're able to do nothing but local
operations" invocation
like: bitcoind -proxy=127.0.0.1:9050 -keypool=0 -connect=127.0.0.1
-nodnsseed -noirc

Similarly, the ".lock" file is never deleted.
Shouldn't it be upon exit?

Vacuuming addr, blkindex, and wallet with "db_dump | db_load" will save
significant space. I do not yet know how to view or validate blk0001.dat.

When left with junk, I've been removing everything except:
addr.dat - node addresses
bitcoin.conf - config
blk0001.dat - blocks
blkindex.dat - index to blocks
wallet.dat - wallet


-------------------------------------

D'oh!  correct url for the pretty graph:
  http://blockchain.info/P2SH

-- 
--
Gavin Andresen


-------------------------------------
On Tuesday, February 07, 2012 10:04:36 AM Luke-Jr wrote:

gmaxwell explained to me why this is no longer needed on IRC.
I withdraw my objection.


-------------------------------------
Dear Bitcoiners,

I have been following some of the debate on the various BIP suggestions for enabling e.g. multisignature transactions. ( First a little rant - it seems like the discussion takes place in at least 5 different forums plus the IRC, this is so annoying. Please keep the discussion at one place and refer to this for people asking questions other places - including me, now... ).

I have some issues with BIP-16, it is mainly the lines 265-269 in the reference implementation (https://github.com/gavinandresen/bitcoin-git/blob/pay_to_script_hash/src/base58.h): 

PUBKEY_ADDRESS = 0,
SCRIPT_ADDRESS = 5,
PUBKEY_ADDRESS_TEST = 111,
SCRIPT_ADDRESS_TEST = 196,

The purpose of the networkID is broken by this, as it ties additional information into an address as a hack. In the BIP-12 implementation I argued that this notification on address level is not needed, and should not be introduced, I am still of the same opinion. The bitcoin code has enough of globals and cross references inside the code s it is today, lets not add another one...

If we want more information in a bitcoin address we could just as well cannibalize it from the checksum - today it is 4 bytes (1 to 4mia) it could be 2 or 3 bytes (1 to 65k or 16M) and that would not break the current meaning of the network ID. This would have the same effect - that you could not mistake two different addresses and create a non-redeemable transaction.

The BIP-17 seems a step forward, but I also agree with Gavins note on one on the forums, that it behaves differently in input and output scripts. So it obviously need some further work too.

Cheers,

Michael

-------------------------------------
On Sun, Jun 17, 2012 at 02:39:28PM -0400, Alan Reiner wrote:

How are you going to prevent people from delibrately unbalancing the
tree with addresses with chosen hashes?

One idea that comes to mind, which unfortunately would make for a
pseudo-network rule, is to simply say that any *new* address whose hash
happens to be deeper in the tree than, say, 10*log(n), indicating it was
probably chosen to be unbalanced, gets discarded. The "new address" part
of the rule would be required, or else you could use the rule to get
other people's addresses discarded.

Having said that, such a rule just means that anyone playing games will
find they can't spend *their* money, and only with pruning clients.
Unrelated people will not be effected. The coins can also always be
spent with a non-pruning client to an acceptable address, which can
later re-spend on a pruning client.


It also comes to mind is that with the popularity of firstbits it may be
a good idea to use a comparison function that works last bit first...


It's merkles all the way down...

-- 
'peter'[:-1]@petertodd.org
-------------------------------------

No, the point of using X509 certs is to get a verified identity (a
domain name) on the receipt, this is needed for multi-factor
authentication. You can't do that without some kind of third party
asserting to an identity.


-------------------------------------

PUBKEY_ADDRESS_TEST is/was supposed to change (the logic for it being 111
was "eleven is Gavin's favorite number"), but I have higher priority things
to do than make all the necessary code changes to upgrade testnet wallets
(unfortunately the address:account mappings in the wallet store the address
base58-encoded) and the testnet faucet and get theymos to change the
blockexplorer.com/testnet site to change the version number and publicize
the change so anybody else who has created testnet infrastructure changes.

If you'd like to spearhead that effort, be my guest, but it is not as
trivial as just changing the definition.

Luke can explain why SCRIPT_ADDRESS_TEST is 196, my memory is fuzzy about
that (it always decodes to the same digit in base58 maye?)

-- 
--
Gavin Andresen
-------------------------------------
On Tue, Oct 2, 2012 at 9:15 PM, steve <steve@mistfpga.net> wrote:

Perhaps a bit bluntly here— but since you seem to be rather boldly
insisting on getting paid:

With all of this testing where can I find the issues you've uncovered?
 Searching on your name/email in the issue tracker reports nothing,
likewise I can't find anything in my email (beyond abstract discussion
of testing).


-------------------------------------
On Tue, Oct 2, 2012 at 6:44 PM, Mike Hearn <mike@plan99.net> wrote:

SSL itself (as opposed to using the certs as you suggest) is not
non-reputablable, so it's not enough for the below concerns


To their prospective customer base.  "I can prove to the public that
you ripped me off" is protective, even if there isn't formal direct
remedy available.


-------------------------------------
On Sun, Sep 23, 2012 at 4:30 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

Right, this disconnect is why simple scalar measures of mempool size
aren't terribly informative.

There are bursts of weird transactions (e.g. someone was flooding zero
value txn a few weeks ago; before that there were some enormous series
of double-spend induced orphans), and other sustained loads that quite
a few miners are intentionally excluding.


Sounds good— my only concern is that nodes will repeat their own
transactions but not the unconfirmed parents. So being more aggressive
can turn otherwise valid transactions into orphans.

Would there be value in an archive-mempool which is only checked when
you receive an orphan transaction?

I would point out that you can't _KNOW_ a txn will disappear. Someone
else could happily reannounce it. (I know you know this; but it's good
to be clear on that point when we talk about it!)


-------------------------------------
Created a forum thread "Bitcoin cookbook", to collect real world, step
by step examples of some of the more advanced uses of bitcoin:
https://bitcointalk.org/index.php?topic=118126.0

If you have a recipe to contribute, create a new thread, then mention
your thread in the cookbook.

Maybe some of this will migrate to the wiki, but the wiki itself tends
to be a poor place for discussion and questions.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
There's an interesting post here about block propagation times:

https://bitcointalk.org/index.php?topic=88302.msg975343#msg975343

Looks like the regular network is reliably 0-60 seconds behind p2pool
in propagating new blocks.

So optimizing IO load (and after that, threading tx verification)
seems like an important win. Lukes preview functionality would also be
useful.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Michael,

On 23/07/2012 10:00, Michael Grnager wrote:
Hang on a sec, in 45 minutes you can download the entire chain from
the genesis block?

I have been doing extensive testing in this area and would love to
know what is special about your setup (I have never had the entire
chain in under 12 hours, infact it is normally closerto 24.) I have an
extensive setup of test machines, everything from e4300 to phenom2x6
to i5's.

as an example on an amd e-450 with 4gb ram, and approx 3gb/s internet
connection it took 2 hours to sync the last 5 days.

Maybe i am missing something important...

Any additional information that you could provide to help me with
testing would be really appreciated.

cheers,

steve

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQEcBAEBAgAGBQJQDXO4AAoJEFvEB9dQFvtQxdcH/ieqQkyDCg8mKeOa6CqsWaS6
fhoeny3Ke2b/CsvhYmsThCvntN9volIqR2CTn5tkHiVwG9OmlxyHZcNpN0ZTHhK5
lsfLap/Y0QpiysXpV4Bu7Z4Hwp9jnhOP74TshT305r2pX6EGXPQ0CrlHqlIry/X/
vNcunUclliou+KjL7EHcY50GH5wDpqJAjlNyF97Lj9YiPrAC9vahGwWdxkbCYtG+
KUuWGBKMMdHuMAgcQh7nI9q0WT3k/gzRQtuC2kf+v0wvQhaGlTVkku4uanhpuw4p
99blRF3/SfWimGuQgsm6wT3Y7dk+z8MFHLb6XGPxmgV9+gF+TWNczfU3GRzfcXw=
=CQkI
-----END PGP SIGNATURE-----


-------------------------------------
Hi,

not sure if you already noticed, but I and my friends are actively working
on bitcoin hardware wallet. This should be pocket size device with
something like 256kB flash and 80 MHz CPU, talking with the computer over
USB. User will prepare transaction on the machine, send it to the device,
device shows target address on the display and user confirms it by pressing
the button.

We're trying to make bitcoin payments safe even on hacked computer. For
this reason we're also implementing SPV so device don't need to trust
computer with any kind of information. The biggest existing problem is that
user cannot be sure that the address displayed on computer screen is
correct and he's confirming valid address.

I don't have any solution for this problem yet. I just appreciate an
activity in payment protocol area, because it can (with some care) solve
this problem and my appeal si to keep all this simple. I'd be very happy
with simple payment protocol which can be implemented even on devices like
I'm working on, so device with few widely used certificates stored in the
memory will be able to display origin of the invoice and confirm its
validity.

slush


On Thu, Nov 29, 2012 at 1:30 AM, Watson Ladd <wbl@uchicago.edu> wrote:

-------------------------------------

Thanks very much, I think that helps me/others. I did not realize
there were release windows in master and thought it more as the
typical full time dev slush. That also explains the presence of all
the release tags in github repo. And even, in a divergent way, the
presence of github/0.6.2 as path to gitorius/0.6.x. And I agree
with the (last bugfix after release) -> import/maintain model, it
would be similar in solo repo.


Yes, that has helped! Now git'ers can easily compare the release
tags to stable 'x' branches on gitorious. I don't know how to do
that across repos yet, save manuel diff of checkouts from each,
which would have been required prior to this update you made.

Also, these declarations of defunctness help sort out too.

# git branch -vv -a
"This stable branch is no longer maintained."


Ok, so for my works I will now track github/master (edge) and
gitorious/0.bigN(eg: 6).x (stable) against gitorious/bigTagRelease
(latest public). Thanks guys, and Luke :)

I hope other with similar questions find this thread. Apology for
subverting its subject somehows.


-------------------------------------
I pushed a fix for this.


-------------------------------------

Here is a simpler solution. (most of this message repeats the content
of my reply to the forum)

Suppose we were talking about a binary search tree, rather than a
Merkle tree. It's important to balance a binary search tree, so that
the worst-case maximum length from the root to a leaf is bounded by
O(log N). AVL trees were the original algorithm to do this, Red-Black
trees are also popular, and there are many similar methods. All
involve storing some form of 'balancing metadata' at each node. In a
RedBlack tree, this is a single bit (red or black). Every operation on
these trees, including search, inserting, deleting, and rebalancing,
requires a worst-case effort of O(log N).

Any (acyclic) recursive data structure can be Merkle-ized, simply by
adding a hash of the child node alongside each link/pointer. This way,
you can verify the data for each node very naturally, as you traverse
the structure.

In fact, as long as a lite-client knows the O(1) root hash, the rest
of the storage burden can be delegated to an untrusted helper server.
Suppose a lite-client wants to insert and rebalance its tree. This
requires accessing at most O(log N) nodes. The client can request only
the data relevant to these nodes, and it knows the hash for each chunk
of data in advance of accessing it. After computing the updated root
hash, the client can even discard the data it processed.

This technique has been well discussed in the academic literature,
e.g. [1,2], although since I am not aware of any existing
implementation, I made my own, intended as an explanatory aid:
https://github.com/amiller/redblackmerkle/blob/master/redblack.py


[1] Certificate Revocation and Update
    Naor and Nissim. 1998
    http://static.usenix.org/publications/library/proceedings/sec98/full_papers/nissim/nissim.pdf

[2] A General Model for Authenticated Data Structures
    Martel, Nuckolls, Devanbu, Michael Gertz, Kwong, Stubblebine. 2004
    http://truthsayer.cs.ucdavis.edu/algorithmica.pdf

--
Andrew Miller


-------------------------------------

BitcoinJS will implement it, it's a useful feature and there is no
reason not to support it.

Two comments from my end:

- This is just a thought, but I wouldn't mind using a new inv_type for
this, e.g. MSG_MEMTX. I could conceivably see a future where broadcast
and relay txs are stored in a very fast local cache whereas the general
mempool is stored in a slower data structure. By being able to
distinguish incoming getdata requests I can save a few milliseconds by
querying the right storage right away. Might also help with things like
telling apart broadcast/relayed transactions from the response to a
mempool request for purposes like DoS scoring etc.

Not a big deal by any means, but I also don't see a downside to it.
inv_types are not a scarce resource, we have four billion of them available.

For now clients would just treat MSG_TX and MSG_MEMTX interchangeably.

- If a node doesn't have anything in it's mempool it sends back an empty
inv message. This is either ambiguous (if other things also send empty
inv messages in the future) or arbitrary (why should an empty inv be
associated with a mempool request of all things.) Instead why not
respond with an inv message that contains a single element of type
MSG_MEMTX and hash 0. That would a very direct way to indicate that this
response is associated with a mempool request.


I'm not married to either suggestion, just trying to add my perspective.
One thing you notice when reimplementing Bitcoin is that Bitcoin's
protocol leaves out a lot of information not for space reasons, but
because the reference client's implementation doesn't happen to need it.
Sometimes however this locks other clients into doing things the same
way. If we can make the protocol a bit richer, especially if this
doesn't cost any extra bytes, then we should consider it as it might
help some implementation down the road make a neat optimization.


On 8/16/2012 7:56 PM, Pieter Wuille wrote:



-------------------------------------
Hello all,

while OpenSSL's silent support for compressed public keys allowed us to
enable them in a fully backward-compatible way, it seems OpenSSL supports yet
another (and non-standard, and apparently useless) encoding for public keys.

As these are supported by (almost all?) fully validating clients on the
network, I believe alternative implementations should be willing to handle
them as well. No hybrid keys are used in the main chain, but I did test them
in testnet3, and they work as expected.

In total, the following encodings exist:
* 0x00: point at infinity; not a valid public key
* 0x02 [32-byte X coord]: compressed format for even Y coords
* 0x03 [32-byte X coord]: compressed format for odd Y coords
* 0x04 [32-byte X coord] [32-byte Y coord]: uncompressed format
* 0x06 [32-byte X coord] [32-byte Y coord]: hybrid format for even Y coords
* 0x07 [32-byte X coord] [32-byte Y coord]: hybrid format for odd Y coords

Handling them is trivial: if you see a public key starting with a 0x06 or
0x07, use it as if there was a 0x04 instead.

I suppose we could decide to forbid these after a certain date/block height,
and try to get sufficient mining power to enforce that before that date.
Any opinions? Forbidding it certainly makes alternative implementation
slightly easier in the future, but I'm not sure the hassle of a network
rule change is worth it.

-- 
Pieter


-------------------------------------
Agreed, you need to consider DoS attacks.  I have that in my mind under
security and not performance. I'd imagine the test methodology would be
completely different since you no longer are attempting to simulate real
world traffic.


Ian

On Thu, Oct 4, 2012 at 5:55 AM, Joel Joonatan Kaartinen <
joel.kaartinen@gmail.com> wrote:

-------------------------------------
On Sat, May 12, 2012 at 3:42 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

Since yesterday, my DNS seeder (running at seed.bitcoin.sipa.be) also
crawls the IPv6 network, and returns corresponding AAAA records.
Hopefully this helps IPv6 nodes to find eachother.

--
Pieter


-------------------------------------
Hi Eric,

What hooks are you looking for in particular ?

libcoin supports registration of listeners for new blocks and new transactions. These are e.g. used for connecting the Wallet to the Node.

Cheers,

M


On 22/03/2012, at 06:39, bitcoin-list@bluematt.me wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Michael,

 Since libcoin is "chain agnostic", I was wondering if the project can be
used like this:

 When I install it with "make install", I would like to have something like
this:

 Regular file: /usr/local/bin/libcoincore # or whatever you like

 Symlink -> Regular file

 /usr/local/bit/bitcoind ->  /usr/local/bin/libcoincore  # bitcoind is a
symlink to libcoincore

 /usr/local/bit/litecoind ->  /usr/local/bin/libcoincore  # litecoind is a
symlink to libcoincore

 /usr/local/bit/devcoind ->  /usr/local/bin/libcoincore  # devcoind is a
symlink to libcoincore

 /usr/local/bit/namecoind ->  /usr/local/bin/libcoincore  # devcoind is a
symlink to libcoincore

 ...and so on...

 So, libcoincore will interpret the ARGV[0] and, for each string, it will
initiate the appropriate internal functions...

 I don't know if Libcoin already does something like that... I'm not a
developer/code reader... Just a small nerd with big ideas...  ^_^

Thanks!
Thiago

2012/2/28 Michael Grønager <gronager@ceptacle.com>

-------------------------------------

Why not combine these two?


Need to specify the format of how these arrive. It means that when a
new block is found instead of inv<->getdata<->block we'd see something
like  inv<->getdata<->merkleblock where a "merkleblock" structure is a
header + list of transactions + list of merkle branches linking them
to the root. I think CMerkleTx already knows how to serialize this,
but it redundantly includes the block hash which would not be
necessary for a merkleblock message.


-------------------------------------
I like that idea. I'm close to having something working along those lines. Hopefully I'll be able to push something by tonight.




-------------------------------------
Hi Michael!

 I would like to ask you one thing:

 1- Release a new version of Libcoin closest as possible with mainline
Bitcoin.

 I mean, do not add any extra code to it and also, do not change any stdout
/ stderr messages.

 How much do you think that this will cost?

 For the extra code: I'll need to run the "blockchain side" as Linux user
called "blockchain" and, each of my regular Linux user will have its own
wallet.dat file (without the blockchain).

Thanks!
Thiago
-------------------------------------
On Tue, Dec 4, 2012 at 9:23 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

I would like to note that BIP32 and this new proposal have a missing
feature: being able to spend
a coin sent to an address generated by this scheme implies being able
to spend any coin generated
by this scheme.

The easiest deterministic wallet construction is simply to use a
stream cipher to generate random
bytes used as the private keys in a wallet. Hierarchical constructions
do not seem to me to add more,
other then distinguishing transactions by sending to unique addresses,
which could be done by other means.


I read BIP32. And while the multipliers at each level are
unstructured, the ones in the next level are products
of the ones before i.e. we have a multiplication tree with random
looking branches.
Note that the order of the basepoint is prime or a small cofactor
times a prime, so this isn't an issue (usually:
the cofactor could be annoying).

--
"Those who would give up Essential Liberty to purchase a little
Temporary Safety deserve neither  Liberty nor Safety."
-- Benjamin Franklin


-------------------------------------
I agree that it would be nice if the protocol stayed stateless.

I also think we should try and keep in our heads the aggregate
bitcoin-universe cost of implementing any protocol change; even a very
small change, something that truly only takes one hour of time from each
bitcoin node client developer to implement, test and bugfix (hah!) Has a
cost in the (tens?) of thousands of USD added up across those who need to
understand, implement, discuss, etc.

Peter

On Thu, Apr 12, 2012 at 10:24 AM, Amir Taaki <zgenjix@yahoo.com> wrote:




-- 

Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
-------------------------------------
I had previously commented on this.
My references to wallet ver were really to nFileVersion.
And I've since been able to make that, and the
real walletversion become current.

However it is still doing this every invocation...
 Rescanning last 14xxx blocks (from block 170xxx)...
Which seems unneeded more than 1x. I cannot yet explain.

So I expect to avoid all by send the balance from old
wallets to new wallet soon instead.

The old wallets were ver 10500.


-------------------------------------
On Fri, Oct 26, 2012 at 04:01:58PM +0200, Mike Hearn wrote:

I've implemented code for efficient representation of partial merkle
trees: see https://github.com/sipa/bitcoin/commits/partialmerkle

The encoding/decoding algorithm uses a depth-first traversal of the tree, at
each node outputting whether anything relevant is beneath, and if not, storing
its hash and not descending into the children.

Furthermore, thanks to some properties of the tree, some hard upper bounds on
the size of the serialized structures are guaranteed. See the comments in the
code for details.

Unit tests are included to verify that
1) encoding and decoding a subset of transactions is an identity
2) the calculated merkle root matches the merkle root calculated by the existing merkle algorithm in the source code
3) the calculated merkle root actually depends on all hashes in the data structure.
4) serialization/deserialization is an identity
5) bounds on the size of the serialization are respected

Hope it is clear enough to port to other languages.

-- 
Pieter


-------------------------------------

Pieter

Most of you might already know this, but I'm strongly in favor of doing
this as soon as possible.

-- 
--
Gavin Andresen
-------------------------------------
On Monday, June 04, 2012 1:43:42 AM Peter Vessenes wrote:

That depends on the pool's reward scheme. Some complicated forms are capable 
of getting "bonus" earnings out of the pool. Under all systems, the attacker 
at least gains the "hurt the pool" benefit. Given the frequency of DDoS 
attacks on pools, it is clear there are people who will even pay for attacks 
that provide no other benefit than harming pools. Under all systems, the 
attacker doesn't lose out in any significant way.


If we wait until there's real pain, it will be a painful fork. If we plan it 
1-2 years out, people have time to upgrade on their own before it breaks.


With this attack, attackers can hurt the pool's "luck factor" *and* spend the 
bitcoins they earn to bribe users away.


-------------------------------------
Stefan went and finished off this work by bringing it up on Windows,
so now there's a pull req for it:

  https://github.com/bitcoin/bitcoin/pull/1619


-------------------------------------
Hi,

I would like to discuss the following bitcoin protocol improvement proposal:

         Adding request/reply id in all messages (in the message header,
based on what was done for the "checksum" field)

The original reason is that I found it very hard to implement robust
blockchain downloading as we are missing context information:
The download protocol relies on the other peer sending one (or more) "inv"
reponse(s) to "getblocks" and sending the "hashContinue".
But if the other peer doesn't send a response to getblock, send a partial
response to getblocks, mixes it with some unrelated blocks inventories
or doesn't send the "hashContinue" it is very hard to detect and handle
(e.g. ban the peer and switch to another).  This could cause some DoS
attacks by misbehaving peers.
The problems are that 1/ we don't know how many "inv" messages to wait for
after "getblocks" and 2/ we don't know how to distinguish between result of
"getblocks" and spontaneous "inv" notifications.
The same is true for  "addr" messages (it is both a notification and reply)
but this is less of a problem as a lack of response to getaddr
doesn't constitute a DoS.

The idea would be to add a new "requestid" field in messages and define the
following:
      - verack sends back the requestid given in version.
      - inv sends back the requestid given in getblocks or a special value
in case of a notification.
      - addr sends back the requestid given in getaddr or a special value
in case of a notification.
      - tx sends back the requestid  given in getdata.
      - block sends back the requestid given in getdata
      - headers sends back the requestid given in getheaders.
      - reply sends back the requestid given in checkorder/submitorder.
      - pong sends back the requestid given in ping.

With the following rules:
       - getblocks always results in a single"inv" reply (0-500 elements
allowed).
       - getdata still result in multiple 'tx' or 'block' 's (as currently).

This is inspired by the common request/reply pattern (the id is sometimes
called "correlation id").
This would permit better asynchronous messaging (multiple request of the
same type in parallel. This could be useful for
getblocks/getdata/getheaders and future messages).

Historic note: It seems similar to the existing mechanism of
"CRequestTracker, hashReply & PushRequest" in the current bitcoin source
code except requestId  would only be a 32bits instead of the 256bits
of hashReply .

I have implemented a prototype here: https://github.com/sirk390/bitcoin/
This could allow to remove "hashContinue" in a second step like this:
https://github.com/sirk390/bitcoin/tree/better_block_download

I'm discussing it now as I read the PONG BIP and saw some similar nonce
field added.
I was not sure if this nonce field would still be required if we had
request/reply ids .

What do you think?

Best Regards,
Christian Bodt, France
Note: I am working on a python implementation of bitcoin.
See https://github.com/sirk390/coinpy
-------------------------------------
Test post.
-------------------------------------
On Fri, Jun 15, 2012 at 9:43 AM, Mike Hearn <mike@plan99.net> wrote:

Here's the "mempool" implementation:
https://github.com/bitcoin/bitcoin/pull/1470

SPV nodes would definitely want to sync up their mempool upon startup.
 As for full nodes... I like the organic growth and random nature of
the mempools.  On the fence, WRT full node mempool sync at startup.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sat, Mar 31, 2012 at 01:16:56PM +0200, Michael Grnager wrote:

Thanks for that - without a license change it would not be possible to merge anything.


Yes, I like its design and refactorings a lot, but at the same time it's very large change to accept at once. In particular, I'm not entirely convinced yet about its thread-safety. For example, acceptblock is a public method, but it seems (i may be missing something) to grab no lock at all until setBestBlock or reorganize is called. Is it impossible to call acceptBlock twice simultaneously? One may start with a bestblockindex value that gets modified a split second later by a simultaneous call. It may be the case that there are indeed no possibilities for this to happen because of things I'm missing, but although I'm a big fan of well-encapsulated locks and the use of reader-writer locks, it's hard to verify whether you use them enough. My suggestion would be: make each publicly accessible method of BlockChain grab either a reader lock (if it's a const function) or an upgradable lock, and take a writer lock in each method that actually performs changes.


Not sure what you mean: the serialized combination of the 32-bit IPv4 address and 12 bytes padding in CAddress are exactly a bsd socket library in6_addr in network byte order. In 0.6.0, CAddress derives from CNetAddr, which encapsulates these 16 bytes.

-- 
Pieter



-------------------------------------
On Thu, 24 May 2012 12:33:12 -0400, Jeff Garzik wrote:

If miners wanted to continue mining empty blocks without bothering to 
monitor the Tx pool they would just switch to stuffing the empty blocks 
with a dummy transaction of their own to get round your new rules. They 
could also spam them to the p2p network so that they end up in the 
mempool if that were necessary. This would probably still be slightly 
easier than 'doing it properly'.

Once the block reward halves in a few months time then receiving 
transaction fees will probably become more important to the miner's 
profit and loss calculations and they'll spend the extra time to 
implement proper transaction processing. I suspect if we do nothing this 
particular issue will go away. Perhaps it could be helped along by 
publishing some example code to make it easier for them.

The ability to refuse transactions seems like an important part of the 
game theory of transaction pricing. Miners are supposed to be able to 
jack up transaction costs by declining to process no fee or too low fee 
(in their opinion) transactions.. the counter balance is that they are 
losing money by doing that and leaving more on the table for the next 
miner to score a block.

I expect that in the future there will be other instances when people 
complain that the miners are being 'unfair' and that the rules should be 
changed in some way to lower transaction fees (ie: increase block size).

If block sizes are increased ever larger and miners aren't allowed to 
refuse to process transactions it will get rid of the financial 
motivation for mining and less mining will happen. We should be very 
careful when making these kinds of changes.

Setting percentage quotas of stuff in the mempool sounds dangerous.. 
miners that hear about a block from a rival miner soon enough could 
possibly DOS the mempool on the rest of the network to get the block 
rejected. I think it should be legitimate not to publish a transaction 
to the p2p network at all.. in the future there will probably be lots of 
networks other than the p2p network.. right now we have the IPv6 network 
and the IPv4 network.. in the future there could be many other protocols 
and perhaps not all transactions will make it back to the old legacy 
ipv4 p2p network or into the mempool of bitcoin nodes on that network.. 
but they should still be able to get into the block chain.

Rob


-------------------------------------


Yes, the current prototype implementation modifies that. "getblocks" always
results in one "inv" with [0-500] elements.
It also removes the filtering on previously transmitted block invs.
see patch:
https://github.com/sirk390/bitcoin/commit/17a27e3d56efa107697b53c193364a33951f1dd1
-------------------------------------
Right now we're seeing cases where block propagation is sometimes
taking minutes.
This doesn't cause much of a problem for general Bitcoin users but for
miners its problematic because it potentially increases the risk for
orphaning.

There are probably many contributing factors which can be improved
here but one of the most obvious is that nodes fully validate blocks
before relaying them. The validation is IO intensive and can currently
take a minute alone on sufficiently slow nodes with sufficiently large
blocks and larger blocks require more data to be transmitted.  Because
this slowness is proportional to the size of the block this risks
creating mismatched incentives where miners are better off not mining
(many) transactions in order to maximize their income.

The validation speed can and should be improved but there is at least
one short term improvement that can be made at the protocol level:
Make it possible to relay blocks to other nodes before fully
validating them.

This can be reasonable secure because basic validation (such as the
difficulty, previous block identity, and timestamps) can be done first
so an attacker would need to burn enormous amounts of computing power
just to make very modest trouble with it... and it's a change which
would be beneficial even after any other performance improvements were
made.

Luke has been working on a patch for this:

https://github.com/luke-jr/bitcoin/commit/0ce6f590dc2b9cbb46ceecd7320220f55d814bca

One aspect of it that I wanted to see more comments on was the use of
a new message for the preview-blocks instead of just announcing them
like normal. The reason for this is two-fold: To prevent existing full
nodes from blacklisting nodes sending a bad preview block due to the
existing misbehavior checks, otherwise an attacker could burn one
block to partition the network,  and also so that SPV nodes which
aren't able to fully validate the block themselves can opt-out or at
least know that the data is not yet validated by the peer.

I don't see any better way to address this but I thought other people
might have comments.


-------------------------------------
A freshly deployed client on an old p4 has been idly crunching away
at building and verifying the initial chain for about a week now. It
should be done in a day or two. This seems rather untenable for
new users. Have any groups published proposals for distributing
a weekly precomputed bootstrap chain?
rsync? db_dump > git > db_load?
There is also 50% or more compression available in the index
and chain.
Of some known future issues... raw transaction rate, the eventual pay
(or extort?, depending on how megapools pan out) to process mining
environment, and scaling the client count itself... this one appears to
be already present.


-------------------------------------
We just implemented our own mining tool, soup-to-nuts, and I would say that
the likely motivation for what I presume are botnet owners is just economic.

It's a lot more work to make sure your merkleing and keeping up-to-date are
happening than it is to just get an 80 byte header from a central server,
and re-calc a single transaction merkle client-side.

Not to mention the extra work to keep track of what version of
getmemorypool output you're receiving work for in a broadly distributed
pool.

For what it's worth, we did this extra engineering work since we care about
Bitcoin, but if I just wanted to pull value out of the ecosystem, we would
have skipped it.

The only solutions to this are economic solutions -- making such 'cheater'
blocks less valuable, or increasing the value of the transactions.

Also note that botnet operators likely care, in the end, about fiat
currency, so going to 25 btc per block in what I think of as transaction
fee subsidies won't necessarily impact this -- it's a matter of what
happens to exchange rates vs generation rates that will matter.

I think we also have to moderate this consideration against the rights (and
arguable benefits) of someone wanting to build an express-delivery mining
service, one that will provide provably faster certification for those
adding a transaction fee of, say, 1 btc.

My own experience now in the MMO world is that we have to carefully
understand how we deal with griefers who control massive resources (compute
or gold-farmers). It may not be a winning battle to choose a solution which
harms the rest of the network in exchange for harming the griefers.

This is definitely out of the box, but one solution might be to change the
difficulty calculations to just ignore 1tx blocks; that would minimize
impact on others to a great extent, and would let someone set up an express
block service if they chose. I guess we'd have to settle on whether or not
such blocks counted towards the issuance countdown as well. Or, we could
allow only 1/10 generation fees on such blocks.

Peter


On Fri, May 25, 2012 at 9:44 AM, Alan Reiner <etotheipi@gmail.com> wrote:



-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
I'd like to garner consensus on whether anyone else thinks it desirable to
have a flag option for bitcoin to punish blocks for not including
transactions. I notice there are already pro-miner options, such as the
restricting the relaying of free transactions, and so including an option
to restrict relaying of blocks from "stingy" miners to balance against the
current bias, so that the default bitcoin client can be run as much
pro-miner as pro-non-miner.

On Monday, May 28, 2012, rebroad@gmail.com wrote:

-------------------------------------
Not yet, its up to genjix (Amir) to do that.  See
https://github.com/genjix/bips/pull/2

Matt

On Thu, 2012-02-02 at 17:07 +0000, Gary Rowe wrote:




-------------------------------------
ok, also what is the reasoning behind serialising points using a compressed format before going into the hash function? I'm looking at the sec1-v2.pdf and the compression format is a little confusing.

I think the octet string for X is 32 bytes (using q = curve.order) and secp256k1 is a prime field so we follow step 2.2.1


________________________________
From: Pieter Wuille <pieter.wuille@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com> 
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net> 
Sent: Monday, December 3, 2012 2:54 PM
Subject: Re: [Bitcoin-development] BIP 32 HD wallets, accounts should be labels not numbers




On Mon, Dec 3, 2012 at 2:49 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

Can this be amended? I think it makes much more sense to allow people to input labels not numbers at this level.

There is no way to iterate over all strings. The intention is that a wallet application can detect a new account that becomes in use (e.g. during disaster recovery), so the accounts get assigned incrementing numbers.

I wouldn't mind adding the ability to do "non-standard derivations" using arbitrary strings, if this recoverability property is not desired.

--
Pieter


-------------------------------------
On Mon, Jul 30, 2012 at 4:26 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

It actually took place on this list:
http://sourceforge.net/mailarchive/forum.php?thread_name=20120612105038.GA29784%40vps7135.xlshosting.net&forum_name=bitcoin-development

It just took some IRC prodding to get Luke to move in the direction of
breaking it up to get the optional parts that Pieter objected to out
of the spec.

Perhaps other people missed it too... so discussing it more sounds
fine if anyone objects.


-------------------------------------
On Monday, February 20, 2012 6:17:01 AM Michael Grnager wrote:

If you must. However, BIP 13 has been pretty much undisputed, and only held 
back by BIP 16/17 so far...


Where do you see this? It has always been "version" as far as I am aware, and 
we discussed formalizing the details of the bits in it a few months back.
In any case, it was certainly originally intended as "version" as can be 
observed in Satoshi's reference implementation.


-------------------------------------
On 3 December 2012 20:35, Mike Koss <mike@coinlab.com> wrote:


Binary formats can be challenging to deal with and convert to other
formats.  The experiences in the PKI world of ASN.1 have not been great, in
terms of interop.  It tends to create islands and silos.  This is probably
one of the reasons why X.509 and GPG are fragmented and why we dont really
have a widely deployed web of trust on the net.  Another reason is simply
lack of developer resources to make tools.  In that respect I think JSON
offers significant advantages, though I am interested in the security
issues raised.


-------------------------------------
I agree on your architectural considerations - and with libcoin you can have several wallets in the same application ( and several RPC servers for that matter). And ... they all use the same Node / blockchain.

You will also find the RPC server in libcoin blistering fast compared to the Satoshi client. (It was actually what got me to write libcoin in the first place...). The Satoshi client HTTP server executes all rpc commands in its own thread, but to do so, it needs to stop the thread of the Node, even though the command executed is just a query (i.e. not a SendTo), you hence have two threads blocking each other and when they wait, you wait... In libcoin all the query methods access the blockChain as a const object and they can hence safely query it without intervening the work of the Node thread. The exception are the SendTo methods that first query if a transaction can take place, then pushes it to the work-queue of the Node thread and again exits immediately. The actual execution then follows once the Node has finished its current tasks (e.g. validating a block).

I have attached the code for a very simple one node, two wallet, libcoin client below (~30 lines), and I have added it to the libcoin source as an example (example name: extrawallets).

Once running, you can access your extra wallet using the RPC interface:
./extrawallet extragetbalance
And youy normal wallet by:
./extrawallet getbalance

I'll leave the generalization to an n-wallet gui application to the reader ;)

Cheers,

Michael

....

// The derived classes below are only to get other class names (using the auto rpc name feature)
// I will put adding a "setName" method to the Method class on the todo. 
class ExtraGetBalance : public GetBalance {
public:
   ExtraGetBalance(Wallet& wallet) : GetBalance(wallet) {}
};
class ExtraSendToAddress : public GetBalance {
public:
   ExtraSendToAddress(Wallet& wallet) : GetBalance(wallet) {}
};

int main(int argc, char* argv[])
{    
   logfile = CDB::dataDir(bitcoin.dataDirSuffix()) + "/debug.log";

   Node node; // deafult chain is bitcoin

   Wallet wallet(node, "wallet.dat"); // add the wallet
   Wallet extra_wallet(node, "extra_wallet.dat"); // add the extra wallet

   thread nodeThread(&Node::run, &node); // run this as a background thread

   Server server;

   // Register Server methods.
   server.registerMethod(method_ptr(new Stop(server)));

   // Register Node methods.
   server.registerMethod(method_ptr(new GetBlockCount(node)));
   server.registerMethod(method_ptr(new GetConnectionCount(node)));
   server.registerMethod(method_ptr(new GetDifficulty(node)));
   server.registerMethod(method_ptr(new GetInfo(node)));

   // Register Wallet methods. - note that we don't have any auth, so anyone (on localhost) can read your balance!
   server.registerMethod(method_ptr(new GetBalance(wallet)));
   server.registerMethod(method_ptr(new SendToAddress(wallet)), Auth("username","password"));
   server.registerMethod(method_ptr(new ExtraGetBalance(wallet)));
   server.registerMethod(method_ptr(new ExtraSendToAddress(wallet)), Auth("username","password"));
   server.run();

   node.shutdown();
   nodeThread.join();
}


On 02/02/2012, at 00:50, grarpamp wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
On Tue, Feb 28, 2012 at 17:48, Pieter Wuille <pieter.wuille@gmail.com> wrote:

After some private discussion, Ben Reeves pointed out two potential
small weaknesses in the proposed patch, which seem viable to me.

First: disconnecting the same coinbase transaction twice would fail,
as EraseTxIndex will not find anything the second time. This is
extremely hard to pull off, as it requires reverting a chain of at
least 120 blocks long. Still, the fix is very easy imho: allow
EraseTxIndex to fail.

Second: assume the following order of events: block with coinbase A is
created, 120 blocks later, A:0 is spent in transaction B. Then, a dupe
of A is created, and another 120 blocks are waited. At this point, A:0
and B:0 are still spendable. Now a block is created with two
transactions: first C which spends B:0, followed by a dupe of B. This
dupe is accepted, as its former instance is completely spent now.
However, if this last block is disconnected again, B:0 is not
spendable anymore, causing a risk for chain split. Ben suggested
moving the check for dupes up, turning the new network rule into:

  Blocks are not allowed to contain transactions whose hash matches
that of an earlier transaction in the same chain, unless that
transaction was already completely spent before said block.

I've updated the patch, and will update the BIP soon.

What do you all think? Can we still move forward with deploying this?

-- 
Pieter


-------------------------------------
On Wednesday, February 01, 2012 9:18:32 AM Michael Grnager wrote:

Looks interesting. However, it doesn't configure for me:
    http://paste.pocoo.org/show/544135/

I noticed it's forked from bitcoind 0.4.x. Do you plan to merge up to 0.5.x?

Luke


-------------------------------------
On Mon, Dec 3, 2012 at 7:24 AM, Michael Gronager <gronager@ceptacle.com> wrote:

Pieter already commented on this, but it's so important it must be
said twice because everyone developing software for Bitcoin must
understand and internalize it:

Bitcoin is not a democracy, it's certainly not a democracy of miners.
Every full node independently and autonomously validates the rules of
the system without the influence of other participants.
Unfortunately, there is no universally consistent way to evaluate the
temporal ordering of transactions independently known— and none likely
to ever exist— and a digital currency requires ordering to resolve
double spends. Because of this Bitcoin must compromise the autonomy of
its validation slightly: It uses a computational majority to determine
transaction ordering. But only ordering!

This is essential because if all the rules were subject to the whim of
a computing majority the system would be far less trustworthy.  The
economic incentives which keep the mining participants honest depend
on the value of defection being as limited as possible.

So, no— you can't achieve by what you want with miners. Any miner
which applied your rules would instantly stop mining from the
perspective of Bitcoin users. As a miner myself, I welcome my
competition adopting your proposal :P.  You're looking for a hard fork
of the system.  Such a change must be supported by ~all users, and so
it must be something which has near universal consensus that it is
essential.  I think it's not essential— though I agree that better
UTXO set  size management would have been a useful component if it had
been in the origin economic promise of the system—  and I already know
that some participants take a principled position that views changes
to the mere spendability of outputs as _theft_.

Your proposal is also more economically hazardous than necessary: By
paying unmoved coins to miners you create a substantial incentive for
miners to delay processing transactions in the hopes that they expire
first.  There is also some risk that the return of large coins from
the past after the currency has substantially deflated would be
extremely economically disruptive.

As far as your concern— as opposed to the mechanism— I share it.  But
it's important to note that the source of most of the problem
transactions is a single source, and a rather unusual one that defies
the normal anti-spamming economic incentives by attracting mentally
ill people to subsidize pay for the bloating transactions, which are
already penalized.  I believe this specific issue can be adequately
addressed primarily through a three fold process:

(1) Make client software aggressive about sweeping up dust inputs:
"Any time a transaction is created that has change keep adding in
extra inputs— smallest to largest— until an additional one would
increase the cost of the transaction by 0.0001 BTC or more"  — the
only major complication is doing this without concurrently harming
privacy which is why it's not done yet in the reference client.

(2) Change the default relay and mining rules to further penalize
transactions with very small outputs.  Making sure that its
practically possible to create inexpensive transactions right now is
very important for the long term success of the system while the small
size of the system makes it unattractive to use, but I don't believe
that applies for dust outputs.

(3) Change the default relay and mining rules to further incentive
reductions in the UTXO set size.  This would make the actions of (1)
save the participants funds instead of just being an altruistic
behavior that most do because its a default.

It might also be useful for client software to incorporate a "destroy
wallet" button for people with wallets that only have dust remaining
to send the private keys off to something of community benefit (e.g.
bitcoin foundation, the faucet, or the developers of that that client)
for recovery so that they don't perpetually bloat the UTXO set.

I expect that these actions would substantially address your concerns,
and even if they do not I believe that they would be the most basic
prerequisites for any kind of argument that something more drastic
(especially something that some would could consider theft!) is
essential.


-------------------------------------

On 13 Sep 2012, at 16:16, Gregory Maxwell <gmaxwell@gmail.com> wrote:


Obtaining a particular tree level allows you to verify segments without needing to download all the transaction hashes first. You only need one hash per segment. For instance if you want to divide the block into 8 segments you specify level 3 and download 8 hashes. You could download all transaction hashes if you wanted and it would still work, it just requires more data transfer for the hashes. This was the reason why merkle trees were used in bitcoin, to avoid requiring all hashes to verify data.



-------------------------------------
There is consensus that we need to do a 0.7.1 release to fix the
"click on a bitcoin: URI and nothing happens" bug on Windows.

I would really like to fix the "I upgraded from a binary running an
incompatible version of BDB and now I get a DB_RUNRECOVERY error on
startup" problem, too, and I've got a pull request that fixes half of
that problem (plus a bunch of other "my wallet is broken" cases):

"Handle corrupt wallets gracefully" :
https://github.com/bitcoin/bitcoin/pull/1895

This pull request:

"Add -reindex, to perform in-place reindexing of blockchain data
files" : https://github.com/bitcoin/bitcoin/pull/1870

... could be the basis for fixing the other half of the problem (if
blkindex.dat is bad, delete it and re-create it from the blk000?.dat
files).

Are there any other very-high-priority pull requests that should go
into a 0.7.1 release?

I'd like to pull:

"P2P: Do not request blocks from peers with fewer blocks than us" :
https://github.com/bitcoin/bitcoin/pull/1834
"In listaddressgroupings push down the IsMine check to run on each
input." : https://github.com/bitcoin/bitcoin/pull/1872

... and these which could be considered fixes to the new raw transactions API:

"Add redeemScript to raw transactions API"  :
https://github.com/bitcoin/bitcoin/pull/1818
"Add new RPC "lockunspent", to prevent spending of selected outputs" :
https://github.com/bitcoin/bitcoin/pull/1861

--
--
Gavin Andresen


-------------------------------------
Yes, I measure mainnet confirmation times on a regular basis.
http://bitcoinstats.org/post/tx-confirmation-times-June2012.png

Before fairly recently, fee-paying transactions never took anywhere close to
this long to be confirmed. 

Jonathan Warren
(Bitcointalk: Atheros)

-----Original Message-----
From: Jeff Garzik [mailto:jgarzik@exmulti.com] 
Sent: Friday, June 15, 2012 1:17 PM
To: bitcoin-development@lists.sourceforge.net
Subject: [Bitcoin-development] SatoshiDice and Near-term scalability

Hard-fork requires a very high level of community buy-in, because it shuts
out older clients who will simply refuse to consider >1MB blocks valid.

Anything approaching that level of change would need some good, hard data
indicating that SatoshiDice was shutting out the majority of other traffic.
Does anyone measure mainnet "normal tx" confirmation times on a regular
basis?  Any other hard data?




-------------------------------------
Jeff asked for a BIP for the pong message, so here it is:

https://en.bitcoin.it/wiki/BIP_0031


-------------------------------------
On Thu, May 24, 2012 at 8:45 PM, Luke-Jr <luke@dashjr.org> wrote:

Look at the time since last block, and correlate with the number of
non-spam TX's in the memory pool at the time.  It is obvious which
ones are quick blocks (<60 seconds since last block, no big deal) and
which ones are the lazy miners (> 120 seconds since last block).

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Monday, July 30, 2012 8:26:12 PM Amir Taaki wrote:

Note that the Pooled Mining parts have already been moved to:
	https://en.bitcoin.it/wiki/BIP_GMPPM

It just needs a number assigned (as the last part).


-------------------------------------
On Sun, Jul 29, 2012 at 1:35 PM, Stefan Thomas <moon@justmoon.de> wrote:

+1  they are a useful, cross-platform test tool.

pynode will be making use of them shortly.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hi all,

Luke Dashjr is telling me that BIP 20 was accepted as Final a year ago (before the BIP process existed).

https://en.bitcoin.it/wiki/Bitcoin_Improvement_Proposals


I respectfully disagree. I find it nonsensical to have a BIP to have been accepted before the BIP process existed. My feeling is that a BIP needs to go through the proper formalised motions in public before becoming accepted.

The URI Scheme did not go through these motions. I did not know it was even accepted, and at least 2 implementations have objected to the standard as is. This is problematic because a standard is meant to be consensus building not enforcement from above.

Ergo I am going to say:

NO BIP EXISTED BEFORE THE BIP PROCESS.

NEW BIPS ARE ALWAYS DRAFT STATUS.

BIPS CHANGE STATUS AS SPECIFIED IN BIP 0001

Luke claims I do not have the ability to specify those conditions above.

If there are any objections then please tell me. I did not get to observe the process for BIP 20, therefore I am not accepting it. Anybody is welcome to submit a competing BIP to Luke's BIP 20 (as has happened with BIP 16 and 17).



-------------------------------------
oh, bitcoin...

Thanks justmoon :D



----- Original Message -----
From: Stefan Thomas <moon@justmoon.de>
To: bitcoin-development@lists.sourceforge.net
Cc: 
Sent: Sunday, July 29, 2012 1:33 PM
Subject: Re: [Bitcoin-development] script tests - invalid script in script_valid.json?

OP_WITHIN is lower-bound-inclusive, but upper bound exclusive, so 1 0 1 WITHIN is false.


bool fValue = (bn2 <= bn1 && bn1 < bn3);

https://github.com/bitcoin/bitcoin/blob/master/src/script.cpp#L854

On 7/29/2012 6:31 PM, Amir Taaki wrote:


------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
NOTE: I've been piecing this together for about a week now, and intended to 
update it when 0.6.0 final was released, but with the timing of it, I just 
won't get the time to update for a while, so here is my last draft...

It seems to me, there is potentially enough ready to merge into 0.7 to start 
the RC process right away if someone wants to... except that the first merge 
will probably require rebasing everything else ;)

My first recommendation is to merge Matt's CBlockStore (#771). It's mostly a 
major code cleanup, but it still needs a lot of post-merge testing. The sooner 
it gets in the master branch, the more testing of unexpected cases that it 
will get before final. Also, Matt's been working hard to keep rebasing it 
throughout the 0.6 merge window, which is very difficult since it conflicts 
with pretty much every other change. As one of the parties responsible for 
those other changes, I vote to get the big conflict over with and rebase all 
the simpler stuff afterward.

Next up are some changes already ACK'd for 0.7: Hearn's "pong" message (#932) 
and Wladimir's Visual C++ 2010 fixes (#949). getmemorypool BIP standardization 
(#936) is also ACK'd, but it might be good to wait until later in the merge 
window considering its low impact and high potential for change as the BIP 
gets closer to Accepted status.

For similar reasons as CBlockStore, I feel multithreaded JSON-RPC with keep-
alive support (#568) should be merged sooner rather than later. It's long 
overdue for bitcoind having had a lot of testing, and pretty much required for 
any sort of high-volume bitcoind usage (such as solo mining). Some other 
optimizations by Joel such as the optimized ToHex function (#562) and 
FastGetWork (#565) have also had plenty of testing; all combined, these 
optimizations more than double the performance of JSON-RPC.
Details: https://github.com/bitcoin/bitcoin/pull/565#issuecomment-3269334

Pieter's getalltransactions (#841) and my getblock_full (#886) provide what is 
needed to completely replace Jeff's old dumpblock call with bitcoind's new 
getblock. He also put together a -loadblock option (#883) which has proven 
quite handy for development, and -walletupgrade (#974) seems like a good idea.

Under the hood, Chris has some neat refactoring of the coin selection 
algorithm (#905, #898), and I haven't had any problems using it in next-test 
for a few weeks now. Michael has contributed a patch to get the standard 
reopen-log-files-on-SIGHUP (#917). Matt noticed the protocol documentation on 
the wiki and BitcoinJ both expect the 'getheaders' message to return at most 
only 2000 headers, so recommends we enforce that in the core (#951). Philip 
has a trivial flip to the backslashes in debug.log for Windows (#971). Some 
p2pool miners put up a bounty for a JSON-RPC call to customize fee 
requirements (#989) that would help make Bitcoin more decentralized.

Scott has a pull request for Bitcoin-Qt to behave more like other close-to-
systray applications by toggling the hide/show action (#855). He's also 
contributed a patch to show miners' immature balances on the overview screen 
(#837; it leaves only a blank space for non-miners). Nils, on the other hand, 
has been working with a UI designer to totally remodel Bitcoin-Qt.

Coderrr has rebased his Coin Control features (#415) to the latest version. 
These seem to be popular, so should probably be merged as soon as it's had 
proper review.

Finally, I don't know the status of Pieter's IPv6 support, but I hope it will 
be ready for 0.7. Right now all I see submitted for this is support for 
multiple local IPs (#829) though.

I'd like to see Coinbaser (#719) finally get merged, but since it seems nobody 
is using bitcoind for mining anymore, I guess there isn't a real need. I don't 
plan to rebase this anymore unless someone gives it a "I'll merge it" sign.

Luke


-------------------------------------
I generally agree with Greg.   I don't see anything he's said or done as
anti-alt-client.

As an alt-client developer, I'm happy to see my client on the main page,
but I'm also happy if that "clients" page is simply an acknowledgement that
there's more to the Bitcoin world than just the Bitcoin-Qt client, and a
link of where to find more information (i.e. the wiki).  I would still *
prefer* to have the page the way it is, because I think alt clients should
be more accessible and word will spread better where it is now -- but I
also recognize the inherent difficulty of gaining any kind of consensus of
how it should be organized, what goes on the list, etc, and no matter how
you do it, someone will complain about it being unfair or not right.

We either have to have a "czar" who is trusted to make responsible
decisions, and complaints of being unfair or recommendations for
improvements can go through that person, but ultimately it is that person
who makes the call.  Or we just move it to another page that is less
strictly controlled and where these things matter less.  Trying to gain
consensus among an amalgamation of developers all with competing priorities
and "products" is a terrible way to try to agree on stuff.

-Alan




On Mon, Jul 9, 2012 at 1:46 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------
Having closely read the BIP20 proposal, I can see your point. As I see it,
BIP 20 vs BIP 21 is about standardising on a representation of the "amount"
field. BIP 20 proposes that "amount" can contain alternative
representations, clearly defined, whereas BIP 21 requires the use of a
single representation in decimal notation.

In my view, BIP 21 still wins since it reduces complexity for the end
client both at the human and machine level.

On 30 January 2012 18:56, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
Hello all,

as some may be aware, OpenSSL accepts several encodings for the same
public key or the same signature. It even accepts encodings that fail
to conform to the SEC and DER specification by which they are defined.
As it perfectly capable of parsing every standard-compliant encoding,
this is not a problem on itself. However, as near every full Bitcoin
node in existence uses OpenSSL, they will accept such non-standard
encodings in transactions, and even let them into blocks.

In order to make the Bitcoin network rules more well-defined, I'd like
to propose strict rules about what is acceptable, and which do not
depend on OpenSSL's implementation. This would make it easier for
alternative full node implementations, and prevent "malleability
attacks".

For that, I've submitted a pull request some time ago (see
https://github.com/bitcoin/bitcoin/pull/1742). The specific rules are
these:
 * For public keys (SEC compressed or uncompressed EC points)
   * First byte is either 0x02, 0x03 or 0x04
   * If the first byte is 0x02 or 0x03, exactly 32 bytes follow
   * If the first byte is 0x04, exactly 64 bytes follow
 * For signatures (DER encoded integer pairs)
   * Format is 0x30 <total len> 0x02 <len R> <R> 0x02 <len S> <S> <hashtype>
   * R and S are MSB encoded integers, which encode a non-negative
integer without excessive zero bytes in front. This implies they do
not start with a 0x00 unless the next byte has its highest bit set
(>=0x80) or are 0, in which case exactly one 0x00 is required. Their
length is thus between 1 and 33 bytes.
   * <hashtype> is a single byte that is either 0x01, 0x02, 0x03,
0x81, 0x82 or 0x83.

All these are rules that are followed by almost all clients already
(including Armory and Bitcoin-js, which until recently didn't).

Sergio Lerner recently discovered that one can take the
secp256k1-field-size complement of the S value in the signature
without invalidating it. The easiest solution to prevent this, would
be to require that the lowest bit of the S value is always even (as
taking the complement changes this). This would require some
coordination, as no client currently enforces this, but it is easy to
implement.

The reason malleability can be a problem, is that a malicious relayer
can modify transactions in-transit without invalidating them. This
will not cause any loss of coins, but a lot of wallet software
wouldn't deal gracefully with a modified version of their transactions
that gets accepted in a block.

What do you think about these rules? If people want these rules,
nothing would happen for now - just start try to find software that
doesn't produce complying data. In a second step, these could be
enabled as check similar to IsStandard() - making it hard for them to
get into blocks, but still be accepted when they aren't standard.
Finally, when no significant amount of non-standard transactions are
seen anymore, we can write a BIP and start enforcing this as a network
rule.

-- 
Pieter


-------------------------------------

I think that's OK. However, you should only be getting the version you
expect because when you request an invoice, your client should be
telling the merchant what protocol version you implement.

Does it make sense to have this spec not include the details of
bootstrapping? It's not complicated - we extend the URI spec in a
backwards compatible way:

   bitcoin:1AbCdEfG?value=10.0&label=Pay%20for%20Foo&invoice=https://merchant.com/inv/aB425az

When a compatible client sees the invoice param, it ignores the rest
of the URI and downloads the URL
https://merchant.com/inv/aB425az?ver=1.0

A server on merchant.com sees that the client expects a version 1.0
invoice and vends it. If ver=2.0 or whatever, it knows it can use 2.0
features. If extensions are supported, add new query params.

We should define a simple mechanism for extending the protocol now, so
people who want to make proprietary extensions don't conflict. The
simplest is to just say, if you want to add new fields to an Invoice
message, please update a wiki page with the tag numbers you're going
to use, and start from number X. Protobufs have a simple way to
formalize this in the language:

   https://developers.google.com/protocol-buffers/docs/proto#extensions

message Invoice {
  extensions 1000 to max;
}

The point of this is to allow you to define new parts of the messages
in separate .proto files. It's only a minor convenience but it means
if you want to use, say, two extensions that weren't yet folded into
the main spec, you can more easily do so without having to do a manual
merge of the message definitions together.

For instance, if you wanted to extend the protocol to support
specification of recurring billing, you could make a file called
recurring-invoices.proto containing:

message Recurrences {
  required uint32 every_seconds = 1;
  optional uint32 start_time = 2;
}

extend Invoice {
  optional Recurrences recurrences = 1005;
}

then you update the wiki page to claim tag number 1005 and apps can
easily use your new features. If/when the feature gets standardized
via a BIP, the core .proto definition can be extended to include these
messages and the extensions can go away.


-------------------------------------
It seems to me that the internet as a whole has got this one covered. I say
this as someone who thinks that BitCoin needs to choose its battles and
craft its reputation extremely carefully; this isn't the most important
fight for BitCoin, nor the most deadly.

I do think SOPA and PIPA could impact bitcoin, what if, for instance,
copyrighted material made its way into the blockchain?

Already the DMCA would make it hard for someone publishing blocks online to
do anything but cease under a DMCA request. SOPA, at least, would go
farther and allow the US to cut all access to 'offending' sites elsewhere
in the world.

At any rate, I don't think these bills are 'aimed at' BitCoin, and the
companies with the most stake are taking the threat quite seriously.
-------------------------------------
On Mon, Feb 6, 2012 at 5:27 PM, Wladimir <laanwj@gmail.com> wrote:

Should do (unless BIP 16 broke something). In fact both the GUI and
RPC commands use CBitcoinAddress and IsValid to validate addresses in
that way.


Again, should do, and it's used by the RPC commands for sending
Bitcoins as well. Really there's not a lot that needs to be changed.
I'm pretty sure even the change in MaxAddressLength is only necessary
to send coins to multisig addresses on testnet, sending them on
mainnet should just work.


-------------------------------------
On Mon, Dec 3, 2012 at 12:19 PM, Michael Gronager <gronager@ceptacle.com>wrote:


I've noticed this too, and it is a concern indeed.



If this were a proposal at the time Bitcoin was created, I would definitely
be in favor, but I feel we can't just change such a policy right now - it's
not what people signed up for when they started using the system. I also
see no way to implement this without a hard fork, which would require
planning at least 1-2 years in advance (imho). By that time, the economic
landscape of Bitcoin may be vastly different, and either dust spam will
have killed it, or we will have found another solution already.

Personally, I think the best solution is to change the mining policy to
prioritize (and perhaps favor for free relay/inclusion) transactions that
reduce the number of UTXO's.

-- 
Pieter
-------------------------------------
Hi Aidan,

Thanks, and the number is still 140700 - do we have a policy / logic on adding new checkpoints ? It seems to me that the number could easily be bumped to 160000 by now ?

Cheers,

Michael
 
On 03/02/2012, at 10:52, Aidan Thornton wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
I'm a little unclear on which repo is which and
for what intended uses. And other than #1,
their descriptions on the hubs are minimal.
I'm not the best with git, but getting there.
Are these the right way to think of them?
And that #1 and #3 are what most builders
and hacks should be tracking?

#1
https://github.com/bitcoin/bitcoin.git

The current development tree. As such, HEAD/master/origin
may at times not be exactly reliable/usable.

#2
https://git.gitorious.org/bitcoin/bitcoind.git

A copy of some chunk of #1 that then died
off around v0.4.0. Purposed similar to #3?

#3
https://git.gitorious.org/bitcoin/bitcoind-stable.git

Another copy of #1. For development along stable
branches and making release cuts from same?
Releases get pulled back to #1 for keeping?
The HEAD/master/origin should be reliable.

Why is this functoin not a part of #1?

Thanks.


-------------------------------------
I changed the description of the message parameter to be a bit more
descriptive, however, I dont want to change the name of the parameter
because some clients have already implemented that and I really prefer
to make as minor of changes as possible to this BIP even if it is
officially only a Draft.  

Matt

On Sat, 2012-02-04 at 16:03 +0000, Gary Rowe wrote:




-------------------------------------

Probably because their listing is even more useless than any of the
proposals that were presented here. Thank goodness it didn't end up
like that. Their table doesn't even attempt to list features or
differentiating aspects of each client.

I think the XMPP guys have pretty much given up on directly marketing
the system to end users.


Fortunately reasonable clients don't appear/disappear/change that often.


I think by "users" you mean, geeks who understand wiki syntax. Because
that's what it'll end up trending towards. I don't believe a wiki
would reflect the needs of your average person. It's still better to
have these arguments here and try to find a user-focussed consensus
than hope one will converge from a wiki.


Inability to agree on columns isn't why the page looks like that. I
know because I'm the one who argued for the current design.

It looks like that because feature matrices aren't especially helpful
for newbies to make a decision, especially when the "features" in
question were often things like how they handled the block chain or
which protocol standards they support, ie, things only of interest to
developers.

It's much easier to communicate the differences to people with a short
piece of text, and maybe if there is no obvious way to explain why
you'd want to use a given client, that's a good sign it's not worth
listing there. Otherwise you end up like xmpp.org.


It's true that bitcoin.org needs to be conservative. That said, I'd
like there to be sections for them too, actually. I agree that risk
isn't purely about how it's implemented and that whilst we might like
to push particular ideologies around protocols or code licensing, that
isn't especially relevant to end users who have different priorities.
Track record counts for a lot as well.


-------------------------------------
On Monday, June 04, 2012 8:49:48 PM Mike Koss wrote:

With decentralized pools, the attacker does have access to the block, and can 
potentially submit it to the Bitcoin network directly bypassing the pool if it 
benefits them to do so.


Because of the above, there is a possibility an attacker can make a profit.


There are other modes of detection, but nobody has bothered to implement them 
since attackers can easily do a simple workaround in an arms race.


With my proposal, miners can find shares, but won't know if it's a valid block 
until the subsequent block is also found (that subsequent block might not end 
up being a real block in the big picture).


This only works for centralized pools, which are contrary to the health of the 
Bitcoin network. Decentralized pools cannot have a secret.


-------------------------------------

Yeah, that sounds reasonable. I mean, I can't see why pruning would
not be deterministic. So if you download a binary that contains a
pre-indexed and pruned chain up to block 180,000 or whatever, you
should be able to blow away the data files and run with
"-syncto=180000 -prune", then check the hashes of the newly created
files vs what you downloaded.

Unless BDB has some weird behaviour in it, that shouldn't require any
additional effort, and anyone could set up a cron job to verify the
downloads match what is expected.

Even if a more complex scheme is used whereby commitments are in the
block chain, somebody still has to verify the binaries match the
source. If that isn't true, the software could do anything and you'd
never know.


-------------------------------------
On Sun, Jun 17, 2012 at 5:35 PM, grarpamp <grarpamp@gmail.com> wrote:

The latter is Luke's backports of security and stability fixes to
otherwise unmaintained old versions.


-------------------------------------
On Tue, Dec 4, 2012 at 10:36 PM, Watson Ladd <wbl@uchicago.edu> wrote:

If you have the the full extended secret there then you can spend
along the chain— but just the plain ecdsa secret by itself is not
enough to spend anything but that address itself.

Or have I misunderstood you here?


Sadly that construction has no ability to separate address generation
from spending— an important element for merchant applications.  Not
just for their own own distinguishing of transactions but because the
use of fresh addresses is essential to the limited privacy properties
of the Bitcoin system.

I called that a type-1 deterministic wallet in some old forum post
where I wrote about the different derivation schemes as opposed to the
point combining type-2 construction. The hope in BIP32 was that we
could get away just using a single one.


-------------------------------------
Very interesting. Do you have any plans to push your refactored code into
Bitcoin upstream for future releases someday?

slush

On Wed, Feb 1, 2012 at 3:18 PM, Michael Grnager <gronager@ceptacle.com>wrote:

-------------------------------------
On Mon, Jan 30, 2012 at 7:05 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

The randomness prevents finely crafted attacks since an attacker can't
predict which bucket his address ends up in.  I don't think it helps
against brute force attacks though.  If 60% of the network's nodes are
controlled by an evil botnet, 60% of the nodes we pull out of the
address manager point to the attacker.  If a client has 8 connections
to the network, a Sybil attack would succeed 1.7% of the time.  At
current network size, 60% of listening nodes is 2,800; only 2-5% of a
decent botnet.

Nodes that accept incoming connections are far less vulnerable, since
the probability of success decreases exponentially with the number of
connections.  95% botnet control with 125 connections has 10^-6 chance
of success.

Perhaps we could add a command-line option for increasing the maximum
number of outbound connections.  That way, nodes unable to accept
incoming connections can easily decrease their susceptibility to Sybil
attack.


I think it should be disabled by default one release after the new
address manager is released.  That way, we're not changing too many
parts of the bootstrapping process at once.

As an aside, I can't help but wonder whether ISPs blocking IRC traffic
filters some botnets out of the IRC bootstrapping channels; keeping
them more "pure".

-- 
Michael


-------------------------------------
On Thu, Nov 29, 2012 at 12:07 PM, Roy Badami <roy@gnomon.org.uk> wrote:

Mike Hearn has experimented with in-person payments using
bluetooth/NFC on a phone, where the merchant has full Internet
connectivity but the phone might only be able to connect to the
merchant via a Bluetooth/NFC paymentURI.

I think I agree with you, though: if the device DOES have
bitcoin-p2p-network-connectivity, then expecting the client to
broadcast the transaction might be cleaner.

However, if a connection to the paymentURI is made and the transaction
data has been sent, clients have to deal with the case where the
merchant also broadcasts the transaction, no matter what the spec says
and even if the merchant sends an "accepted : false" response.


-- 
--
Gavin Andresen


-------------------------------------
On Tue, Dec 4, 2012 at 5:44 PM, Alan Reiner <etotheipi@gmail.com> wrote:

No…

There is no fundamental completion between taking what actions we can
to maximize the decentralization of the network and making the
software maximally friendly and painless to get started with and use.
It's possible— not even deep rocket science— to create software that
accommodates both.

And because of this, I don't think it's acceptable to promote
solutions which may endanger the decentralization that makes the
system worthwhile in the first place.  If the current experience is so
poor that you'd even consider talking about promoting directions which
reduce its robustness then thats evidence that it would be worth
finding more resources to make the experience better without doing
anything the that reduces the model, even if you've got an argument
that maybe we can get away with it.  If there isn't interest in
putting in more resources to make these improvements then maybe the
issue isn't as bad as we think it is?


Absolutely— and yet that has nothing to do with promoting software to
users which only consumes without directly contributing and which
doesn't even have the capability to do so even if the user wants to
(or much less, is indifferent).


-------------------------------------
On 17 January 2012 00:30, Amir Taaki <zgenjix@yahoo.com> wrote:

I would like to voice my support to Amir here. It is a solidarity
gesture and from my point of view it would be great if bitcoin related
websites join the Blackout. In my view it is almost like Internet's
general strike, which is being enacted for a very good reason. To some
degree, ignoring it and continuing business as usual is almost
equivalent to being a strikebreaker.

For whatever it worth, all websites where I have some degree of
control will particpate in the blackout. Even where it means loss of
revenue for one day (actually it is likely that ad revenues tomorrow
would be easily twice the usual amount due to so many publishers
shutting down their websites.)


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Matt,

Glad to have another ninja onboard :)

On 25/09/2012 21:41, Matt Corallo wrote:

I have never heard of jenkins before.  I need to do some more digging.
is this the right thing?

https://wiki.jenkins-ci.org/display/JENKINS/Mantis+Plugin

Mantis on the other hand, I know exceptionally well.  I hate
duplication of work/data unless absolutely necessary.  I will check
jenkins out (just out of interest what is it actually meant to do? the
website implies framework, but not what its for)

So, currently there are 4 potential places for bugs to be reported
1 - jenkins (and unit tests)
2 - git
3 - mailing list
4 - forum (bitcointalk...)
5? - is there still the ability to add bugs via sourceforge?

Adding to this doesnt make sense.  Each one of these reporting methods
is for a different thing.  I am not seeking to replace these (or even
unify them) I am looking for software that will take testcases and bug
reports against them [and allow for test campaigns].  Mantis is so
flexible and industry standard and if the jenkins plugin works... then
we can keep things as they are until they fit into better places.

The reason I am so behind mantis as the backbone is it works with more
or less anything, and can easily modded to work with whatever people
are most comfortable with - however it is exceptionally powerful and
has had a constant stream of workflow improvements over the past few
years.


I will check it out. I wrote a very basic script that wikified the
changelog, and linked to the changes and created wiki pages for the
testcases.  have you seen the stuff I put on bettermeans? bits keep
vanishing then re appearing.

This is the outline of the testing that I setup for 0.7

https://secure.bettermeans.com/projects/4256/wiki


Yes, I would love to unify all build testing and testcases into one
place.  I am still on the fence as to including unit tests into this.
However I do see 3 distinct type of testcases
1 - requirements based testcases (requirements based off the current
block chain rules - these are edge cases and known interoperability
issues)

2 - Acceptance based testcases - these are testcases that should be
run for every build.  Check out the General Acceptance Tests in the
wiki link for examples and testcases

3 - Testcases for reference implementations of things (like multisig -
i see these working like the /test folder when you install a new perl
module)

These three things alone are a massive task. and they still wont cover
everything.  I would like to get the workflow so that people can
sponsor or donate to a specific campaign (eg a new feature is
implemented, people want it tested so can donate just for that
campaign [developing testcases, structure, requirements, etc])

Once this is done, I will get to do some exciting stuff (like writing
fuzzers, automation, etc) unfortunately I do not know python, only perl.


Nice, I love testing.  I think we will get on :)

And I would rather go for interoperability between testing rather than
rewriting it all.

Cheers,

steve


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQYvT4AAoJEFvEB9dQFvtQlgkIAJX7JYel5RGmCsbptGdQrCnT
BR42tUwTg1t/NRUJ6RA8/Ou8lzallztQquShpLn4mZdQpoalvETdtAwcPnQKnaZb
M5inZE/IEq8WJM1y4YkHt3BLou4BJbjwncCNy1/jqcm6f2Oonrg7isVbDwY/7JlP
y/epm7XELS7NU4vVubBwQCunwvtsuydXRzuI812LiLXNqpXFMHvG2m8a2RajXE0/
xW4lOMy/hUFzEgYRQWCTAru4Ts2x3Xt26NaEUh/uKvHLwBZJ4xbdu3gpupiPb4sI
bCHnVFOC7zoQKOAnfPkCMyvtyoqpzM9HW2+DWI51FoOz851Y2F36N3Fpk/2lii4=
=W5xI
-----END PGP SIGNATURE-----


-------------------------------------
For what it is worth, I question whether this is a problem. Or, I
guess I question whether the best solution to it isn't for people to
start including more transaction fees. In fact, I'm not entirely sure
that this problem doesn't actually *encourage* people to that
solution, which would be very good if true.


I would be more comfortable if the reward for mining were more
commensurate with the value it provides. Ultimately, of course, that
means that each transaction fee would have to be more of a proportion
of the value *to the spender* of that transaction being included in
the blockchain.

(Aside: in order to convey to outsiders that miners are providing a
useful service rather than gaining undeserved reward for wasting
electricity, I refer to them as "distributed transaction verification
servers" rather than "miners" whenever possible.)

I'm pretty sure that — assuming there isn't some Bitcoin-killing
disaster — transaction fees will eventually rise, but sooner might be
better, especially with the first coinbase-halving looming.

Perhaps people will be motivated to include transaction fees if they
know that some miners don't bother to validate their transactions and
others do. They may feel motivated to reward the miners that are
serving them and punish the ones that are not. (Note: this wouldn't be
a valid strategy on their part from a strictly game-theoretic
perspective, but if they act on those motivations, then I don't care
if it was rational or not.)

Also, they may decide that they want to counteract the added delay
which those no-transactions miners are adding to *all* transactions
(with or without fee), by putting a fee on their transactions in order
to make them take less long when they are processed by a miner which
does process (some) transactions.

Already this visualization, which I typically glance at a few times a
day, usually shows a good separation with fee-included transactions
sometimes doing much better than (some) free transactions:

http://bitcoinstats.org/

However, this graph shows that the aggregate reward to the miners for
processing transaction is minimal:

http://blockchain.info/charts/transaction-fees?timespan=60days&showDataPoints=false&daysAverageString=1&show_header=true&scale=0&address=

You can see from the first visualization (assuming it is showing the
typical pattern that I've seen) how you risk greater delay by sending
your transaction without fees. The no-transactions miners push *all*
transactions, fee or no-fee to the right. This may incentivize more
people to change their transactions from red diamonds into blue
circles, in order to move their transactions further to the left, even
though the no-transactions miners are not currently discriminating
among the two types.

Therefore, the presence of those miners may help push the aggregate
fees in that latter graph up, which is something I would very much
like to see.

Regards,

Zooko


-------------------------------------
Consensus was we should do a BIP for all P2P changes, so here it is...
 feedback requested.

https://en.bitcoin.it/wiki/BIP_0035

Abstract
-------------------------------------------
Make a network node's transaction memory pool accessible via a new
"mempool" message.  Extend the existing "getdata" message behavior to permit
accessing the transaction memory pool.


Motivation
-------------------------------------------
Several use cases make it desireable to expore a network node's transaction
memory pool:
* SPV clients, wishing to obtain zero-confirmation transactions sent or
  received.
* Miners, downloading existing network transactions after a restart.
* Remote network diagnostics.


Specification
-------------------------------------------
1) Upon receipt of a "mempool" message, the node will respond
   with an "inv" message containing MSG_TX hashes of all the
   transactions in the node's transaction memory pool.

   An "inv" message is always returned, even if empty.

2) The typical node behavior in response to an "inv" is "getdata".

   However, the reference Satoshi implementation ignores requests
   for transaction hashes outside that which is recently relayed.

   To support "mempool", an implementation must extend its "getdata"
   message support to querying the memory pool.

3) Feature discovery is enabled by checking two "version" message attributes:

   a) Protocol version >= 60002
   b) NODE_NETWORK bit set in nServices


Backwards compatibility
-------------------------------------------
Older clients remain 100% compatible and interoperable after this change.


Implementation
-------------------------------------------
See https://github.com/bitcoin/bitcoin/pull/1641

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On 11.08.2012 20:56, Wladimir wrote:

That makes sense. But it's hard to translate when you just see the same
string twice and don't know the context where it will be used.


No, I just use copy and paste.


Sorry, forgot there was a compiler flag for this. No need to split this
up. As long as there is no explanation or description for each string I
think it's easier to translate whole sentences.

On 11.08.2012 20:32, Wladimir wrote:
something in

Perfect. This will prevent a lot of confusion. Thanks!

Regards,
Geir H. Hansen, bitminter.com


-------------------------------------
On Wed, Feb 22, 2012 at 11:29 AM, Michael Grnager <gronager@ceptacle.com>wrote:



I've been trying to move discussions to this mailing list, by starting
conversations here and posting links to the mailing list archives in the
discussion forums just so people know there is a conversation going on.

IRC conversations are great for rapid back-and-forth brainstorming, so I
expect a lot of work to continue getting done via IRC, but once there's
general consensus there I expect issues to migrate here.

-- 
--
Gavin Andresen
-------------------------------------
On Tuesday, January 17, 2012 2:42:51 AM Jorge Timn wrote:

Censorship is, in principle, good. Free speech and democracy are, in princple, 
evil. Idolizing Liberty is also evil. Your backward morals are worse than a 
political issue.

How about taking a few minutes to read this article by Bishop Sanborn? ;)
	http://www.traditionalmass.org/articles/article.php?id=13&catname=7


-------------------------------------
Yes, but then they should not be sponsors.

There's a very good reason why Wikipedia does not have advertisements. That is, the fear of advertisers influence on the neutral content. It is inevitably a corrupting influence. I want a good fun conference like the hackathon we just held.



----- Original Message -----
From: Andreas Petersson <andreas@petersson.at>
To: bitcoin-development@lists.sourceforge.net
Cc: 
Sent: Tuesday, July 17, 2012 11:25 AM
Subject: Re: [Bitcoin-development] bitcoin.org - remove hackathon

Am 17.07.2012 11:17, schrieb Amir Taaki:
Personally, i really don't mind sponsored speakers. If they have 
somewhat relevant topics they keep the event from becoming a "circlejerk".
for example i would really like to hear about payments innovation 
outside bitcoin.

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
On Thursday, March 22, 2012 1:13:13 AM Eric Lombrozo wrote:

I'm not sure it's a good idea to let other code into the main wallet-handling 
process/memory space. I'd suggest looking into designing a workable Wallet 
Protocol for general use between the wallet and GUIs/applications.

https://en.bitcoin.it/wiki/Wallet_protocol has a draft I made a long time ago, 
but really seems a bit overcomplicated.


-------------------------------------
On Monday, April 02, 2012 4:55:03 PM Alan Reiner wrote:

IMO, the sign-request URI should be an extension on the existing bitcoin: URI 
scheme; this way, sigNeeded can be omitted to imply "sign with a sending 
address".


-------------------------------------
The callback architecture could be such that other code would never
need to enter into the wallet-handling process/memory space. For
instance, client applications could subscribe a particular URL to get
sent an HTTP POST.

For the apps I've been working on, there really isn't any need to
access the wallet space. I was talking more about events like "A new
transaction was just seen" or "A new block was just seen", like what
libcoin seems to support (sorry, Michael, I haven't really had a
chance to look at it in depth but I will). Then there are other types
of events for other bitcoin messages could also be useful: new addr,
new node connected, node disconnected, bitcoin alert, etc...

Then there are events for dealing with potential attacks: DoS attempt,
double-spend attempts (two transactions seen with valid signatures
claiming the same output), node sending malformed messages, etc...

And then there are alerts pertaining to the status of the bitcoind
process itself: bitcoind started, bitcoind ready to accept
connections, bitcoind stopping, etc...

None of these events require the callback subscriber to have any
access to the bitcoind process/memory space and all the I/O could be
done via IPC or over network sockets.


-------------------------------------
One more thing to add. The implementation in the reference patch fixes
the blockchain forking issue however by still allowing spent coinbases
to be disconnected patched clients are still vulnerable to blockchain
corruption. While not an immediate issue it would mean
LoadBlockIndex() would error on restart and could cause problems for
new clients during the initial blockchain download.

Is there a reason not to disallow duplicate coinbases entirely?

On Thu, Mar 1, 2012 at 10:15 AM, Ben Reeves <support@pi.uk.com> wrote:


-------------------------------------
On Wed, Mar 21, 2012 at 3:54 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:
Contrasts
-My protocol works, your's doesn't. It's not enough to have a mix, the
mix needs to be verifiable to avoid
one of the mixers inserting their own key and removing a key that
should be in there. That doesn't mean you can't make your protocol
work with some more magic, but magic is required.
-You need a lot of online computation: the recipients need to be
involved with validating the mix. By contrast in mine you need to wait for
enough people to get their bitcoins to avoid partitioning. But this
might be a strength,
not a weakness.
-You avoid the problem of de-anonymizing through having the protocol
run incompletely: if the permutation is correctly computed the
transaction goes through.
-You also avoid all the problems with modifications to the bitcoin
clients and miners.

It's definitely a good alternative, once you fix the problem in 1.

On a related note, private keys and signatures have better proofs of
knowledge then hashes. Has this been considered in the P2SH
conversation? There might be ways to use this to make even better
methods for enhancing anonymity.
Sincerely,
Watson Ladd



--
"Those who would give up Essential Liberty to purchase a little
Temporary Safety deserve neither  Liberty nor Safety."
-- Benjamin Franklin


-- 
"Those who would give up Essential Liberty to purchase a little
Temporary Safety deserve neither  Liberty nor Safety."
-- Benjamin Franklin


-------------------------------------
There are test cases that can be automated. That's Jenkins, and those will
be run automagically.

Then there are tests that cannot be automated; things like "Does the GUI
look OK on all of the platforms that we support (Windows XP/2000/Vista/7/8,
Ubuntu/Debian blah with window managers foo and bar, OSX 10.5/6/7/8)."

Thanks to Matt, we're doing great with automated functional test cases (can
always do better, of course).

We're failing on simple, boring stuff like making sure we actually run on
all of the platforms that we say we run on BEFORE final release. That is
where I think a QA team can add a lot of value.

Steve: I'm worried you're over-designing The Process. A release acceptance
test plan could be nothing more than a step-by-step checklist on a wiki
page, Google Doc, or Drobox shared folder...

-- 
--
Gavin Andresen
-------------------------------------
It may be a political issue, but I don't think wikipedia becomes a
political organization for being against censorship.
This is not about left or right. Is about free speech, one of the
basic principles not only of freedom but also of democracy.
And as Gregory shows it clearly affects bitcoin directly.


-------------------------------------
Mining support for BIP 16 is still under 50%, and won't possibly be over
50% by March 1.  Which means we need a new evaluation/switchover date:

Re-evaluate support: March 15'th
Target switchover: April 1

If you're already supporting BIP16, restart bitcoind with the argument:
  -paytoscripthashtime=1333238400

... to delay switchover until April 1.

Hopefully this will be the last delay; Tycho has told me that deepbit will
support BIP16 as soon as he's able to merge and test the changes, which
will put support at well over 55%.

-- 
--
Gavin Andresen
-------------------------------------

This is purely subjective. One's best is another's worst.


Yes, so for the purposes of compiling a list of clients
and libraries, please just stick to a table of features.

On the subjective part, I'm finding the library+client
implementations to be nice, and indeed the future.
Afaik, there are two major pairs of these so far that
should be listed. Ymmv.

Can someone also please set the reply-to header
for these lists. It's really annoying to hit reply and
not have the list address show up. Thanks :)


-------------------------------------
Any progress on a release candidate QA sanity testing plan?


Bitcoin version 0.7.1 release candidate 1 is now available from:
  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.1/test/

This is a bug-fix minor release.

New features
------------

* Added a boolean argument to the RPC 'stop' command, if true sets
  -detachdb to create standalone database .dat files before shutting down.

* -salvagewallet command-line option, which moves any existing wallet.dat
  to wallet.{timestamp}.dat and then attempts to salvage public/private
  keys and master encryption keys (if the wallet is encrypted) into
  a new wallet.dat. This should only be used if your wallet becomes
  corrupted, and is not intended to replace regular wallet backups.

* Import $DataDir/bootstrap.dat automatically, if it exists.

Dependency changes
------------------

* Qt 4.8.2 for Windows builds

* openssl 1.0.1c

Bug fixes
---------

* When running -testnet, use RPC port 18332 by default.

* Better detection and handling of corrupt wallet.dat and blkindex.dat files.
  Previous versions would crash with a DB_RUNRECOVERY exception, this
  version detects most problems and tells you how to recover if it
  cannot recover itself.

* Fixed an uninitialized variable bug that could cause transactions to
  be reported out of order.

* Fixed a bug that could cause occasional crashes on exit.

* Warn the user that they need to create fresh wallet backups after they
  encrypt their wallet.


-- 
--
Gavin Andresen


-------------------------------------
Dear Bitcoiners,

libcoin is now in a state ready for its first release, which I would like to share with you!

=== libcoin is a crypto currency library based on the bitcoin/bitcoin "Satoshi" client. ===

Copenhagen, Denmark - 1st February 2012 Ceptacle announces the release of the first version of the crypto currency library "libcoin" based on the bitcoin/bitcoin "Satoshi" client.

libcoin also maintains a version of bitcoind that is a 100% compatible drop-in replacement of the bitcoin/bitcoind client: You can use it on the same computer on the same files and you can call it with the same scripts. And you can easily extend it without touching the basic bitcoin source files.

The libcoin/bitcoind client downloads the entire block chain 3.5 times faster than the bitcoin/bitcoind client. This is less than 90 minutes on a modern laptop!

In libcoin, the Satoshi client code has been completely refactored, properly encapsulating classes, removing all globals, moving from threads and mutexes to a pure asynchronous approach. Functionalities have been divided into logical units and libraries, minimizing dependencies for e.g. thin clients.

libcoin is chain agnostic, all chain (bitcoin, testnet, namecoin, litecoin, ...) specific settings are maintained from a single class (Chain) and hence experiments with chain settings, mining, security and digital currencies for research and educational purposes are easily accessible. See the ponzicoin example for how you define your own chain.

The build system of libcoin is based on CMake and supports builds of static and dynamic libraries on Linux, Mac OS X, and Windows.

The libcoin license is LGPL v. 3. This mean that you can use it in open source as well as in commercial projects, but improvements should go back into the libcoin library.

======

Read more on libcoin on: http://github.com/ceptacle/libcoin/wiki

Join libcoin on twitter: http://twitter.com/libcoin

Download "libcoin Satoshi release": http://github.com/ceptacle/libcoin/zipball/v0.4.0.1

Best regards,

Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
You might also want to check out libcoin. Its a fork of the satoshi client: https://github.com/ceptacle/libcoin

Matt

Eric Lombrozo <elombrozo@gmail.com> wrote:

Hey, guys.

I've been writing a number of apps that require realtime event
notifications, where the JSON-RPC API clearly doesn't suffice.

There are two approaches I've been taking to this end:

1) Writing my own library for dealing with raw bitcoin structures and
connecting to bitcoin nodes via the bitcoin protocol.
2) Making custom builds of the satoshi client putting callback hooks
in key points.

Neither of these two approaches is ideal. (1) involves a lot of code
duplication, (2) involves patching the satoshi client source
each time I grab a later version, with the everpresent risk of
something breaking and the need to continue maintaining these patches.
Moreover, unfortunately many of these key points happen to be in files
like main.cpp which see frequent changes.

I would like to propose adding these callback hooks to the main
branch. I am willing to help locate these key points, reorganize the
code
to place these methods in separate source files, define a callback
mechanism, and contribute source code.

-Eric Lombrozo

_____________________________________________

This SF email is sponsosred by:
Try Windows Azure free for 90 days Click Here 
http://p.sf.net/sfu/sfd2d-msazure
_____________________________________________

Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------------------------------
I think we are all so familiar with Bitcoin that we forget how daunting
and confusing it all is to new users. The clients page does a good job
in explaining that there are various pieces of software that they (the
new user) can use with their bitcoins.

It also helps with the question "Who can I trust ?"
By having the clients on a link from the "mothership" of bitcoin.org it
gives credence to all of the alt clients.

This last point is a good reason to only include open source clients
IMHO. 

RE: The position randomisation - I have to admit I was secretly pleased
with the original layout, as MultiBit just happened to have the "eye
candy" position of "top and centre".  It is only fair to have them
switch around.
-- 
http://multibit.org    Money, reinvented



-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


I think he had a typo in the CC.  here is a forward of the email.
You will have to work out the indentations yourselves :)

- -------- Original Message --------
Subject: Re: [Bitcoin-development] Bitcoin Testing Project
Date: Tue, 2 Oct 2012 22:01:19 -0700
From: Peter Vessenes <peter@coinlab.com>
To: steve <steve@mistfpga.net>

On Tue, Oct 2, 2012 at 6:15 PM, steve <steve@mistfpga.net> wrote:

_______________________________________________
Got visibility?
_______________________________________________
Got visibility?

- -- 
- ------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104



-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQbGSIAAoJEFvEB9dQFvtQw1YH+wW3QDMHHV7kf7ZQXvAswv5T
S2htfdgp1DBYBatoJB9fUU3hgHTEz1UhENH509SjS1/dxHuIxguJkbgmuSdoeB/4
rDuuYzQVcmym/G1YXvmAkCDk5/fUY4RKlCDGLg9MVMpVFhLIr6Jiwxd0NiIqWm9K
aE2bXijiTIRp1sNFxJh5SZTh9/rz1zF8TU3LBWyCegISwyBH2XeIIbVgORoMDBlm
n8yKGwPSg5PaH/eWhXR17OUMPbX6xGlMqTmBo7BZDCwPpZU470rkDsPywsn55mAf
W6EQhFjxpSCnmZwRhrkdM/Le/0ySSUvM4spPu7MlQ6ekGP2gBzzUPbKnTGHzNgQ=
=r57G
-----END PGP SIGNATURE-----


-------------------------------------
This discussion is quite bikesheddy, but (or thus? :) ) I will put in my
2c.

The main thing to think about, I think, is "what would be best for the
users". To that end, I suggest the following:

* I do think a page on bitcoin.org listing relatively major, and
relatively vetted, clients is a good idea. Removing it completely and
relegating it to a wiki page, which is likely to contain all sorts of
marginal crufty clients, would likely be a disservice to the users.

* Randomized order is likely also a disservice to the users. We should
list clients in order of "goodness", as determined by whoever(s) we
decide to put in charge of the page. This "goodness" should likely to be
some kind of weighted average of features, security, goodness for
bitcoin network, etc. [1]

** If randomized order is after all chosen, it should be done in
javascript client-side, rather than doing daily page reorgs. If people
without JS don't see random, it's not material at all.

* Prose vs. feature matrix: both have their good and bad points, as
discussed upthread. I think the users will be best served by a
combination of both:

** Prose descriptions of clients should deliberately include negative
points, not just let the user infer them by lack of corresponding
positive mention. (e.g. "This client has fast startup time. That means
you're completely trusting the server operator with your money.") This
task is left up to the person(s) in charge.

** A feature matrix, with carefully chosen and /well defined/
categories, /in addition to prose/ would likely also be of service to
the users. That could be left to the wiki though. The current wiki
clients page seems to be having a good go at it.[2]

** If we are targeting people who "don't know what they're doing", it
may be a good idea to have a 'decision assistant' type setup, where
users are asked several questions and are recommended clients based on
these answers. (This could be done in a static way by having a matrix of
questions.)


Finally - I'd say we're spending disproportionate developer resources on
this question, and if it were completely up to me, I'd resolve this
situation in the following quick-and-painless way: leave page as is, add
negative points to prose, link to wiki clients list. Estimated time to
completion: 1 hour (to think through which negative points to add).


[1] Meehl, 1954, clinical versus statistical prediction... (see also
Grove and Meehl, 1996; Sawyer, 1966) (and yes, despite the age of some
of this research, the conclusions have been surprisingly robust and
timeproof.)
[2] https://en.bitcoin.it/w/index.php?title=Clients&oldid=28615

-nanotube


-------------------------------------
MSG_MEMTX solves the issue of not knowing whether a given inv is in response to a "mempool" command or not.

I don't buy the argument that always sending a response "inv" makes things easier because code should always be able to handle misbehaviour from the remote node (ommiting the "inv"). However I would argue that it is good to have it, as it makes designing flows of logic much easier (first send this, wait for response, do this, ...).



----- Original Message -----
From: Stefan Thomas <moon@justmoon.de>
To: bitcoin-development@lists.sourceforge.net
Cc: 
Sent: Thursday, August 16, 2012 8:21 PM
Subject: Re: [Bitcoin-development] BIP 35: add mempool message


BitcoinJS will implement it, it's a useful feature and there is no
reason not to support it.

Two comments from my end:

- This is just a thought, but I wouldn't mind using a new inv_type for
this, e.g. MSG_MEMTX. I could conceivably see a future where broadcast
and relay txs are stored in a very fast local cache whereas the general
mempool is stored in a slower data structure. By being able to
distinguish incoming getdata requests I can save a few milliseconds by
querying the right storage right away. Might also help with things like
telling apart broadcast/relayed transactions from the response to a
mempool request for purposes like DoS scoring etc.

Not a big deal by any means, but I also don't see a downside to it.
inv_types are not a scarce resource, we have four billion of them available.

For now clients would just treat MSG_TX and MSG_MEMTX interchangeably.

- If a node doesn't have anything in it's mempool it sends back an empty
inv message. This is either ambiguous (if other things also send empty
inv messages in the future) or arbitrary (why should an empty inv be
associated with a mempool request of all things.) Instead why not
respond with an inv message that contains a single element of type
MSG_MEMTX and hash 0. That would a very direct way to indicate that this
response is associated with a mempool request.


I'm not married to either suggestion, just trying to add my perspective.
One thing you notice when reimplementing Bitcoin is that Bitcoin's
protocol leaves out a lot of information not for space reasons, but
because the reference client's implementation doesn't happen to need it.
Sometimes however this locks other clients into doing things the same
way. If we can make the protocol a bit richer, especially if this
doesn't cost any extra bytes, then we should consider it as it might
help some implementation down the road make a neat optimization.


On 8/16/2012 7:56 PM, Pieter Wuille wrote:


------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
I think that bitcoin.org should remain apolitical.  However maybe it 
would be good if the blackout to take effect on bitcointalk.org if 
theymos and Sirius believes it is appropriate.

Bitcoin.org should provide bitcoin.




On 17/01/2012 11:59 AM, slush wrote:

-------------------------------------
Do you mean getdata? Here is the reason for the 6 new messages:

getseginv,seginv - These are for learning about what segments of a block a node has. Else you could remove these messages and simply have nodes advertise blocks via inventory messages. In this case nodes would have to wait until they had fully received a block before relaying anything. No longer is there a benefit with nodes being able to relay segments of blocks before they have received the entire block.

gettreelevel,treelevel - These are to received a level of the merle tree. Instead you might use get data but gettreelevel is more compact than get data and is clearly differentiates itself as part of the new protocol. Perhaps these messages could include the block headers alongside the hashes and you could request many at once like with the getheaders message? If you skip these messages, then you could verify the transactions at the end but there would be problems when peers give bad segments where data would need to be downloaded again.

getsegment,segment - These are clearly important to request and receive segments for the blocks. These allows for nodes to download arbitrary segments of blocks. The optimum number of segments could be calculated by node software using measurements of download speeds and latency times, the number of connections and how likely redundancy is to occur. If a node is up-to-date and likely has many of the transactions in blocks, it can start asking for the deepest merle level (tx hashes) and ask nodes for segments, avoiding transactions it already has.

I'll get around to doing measurements myself sometime to estimate the benefit of this proposal. It will certainly be beneficial when block sizes reach some size but not much is really known except what can be assumed/guessed.

I should also mention the bitcointalk topic here: https://bitcointalk.org/index.php?topic=103295.0

On 10 Sep 2012, at 19:59, "Luke-Jr" <luke@dashjr.org> wrote:

-------------------------------------
Because many made the mistake and it isnt specified in this email, this
meeting is tomorrow (not 30 minutes ago).

On Mon, 2012-01-02 at 08:04 -0800, Amir Taaki wrote:




-------------------------------------
That's a cool idea. Very meta.

________________________________
From: Peter Vessenes <peter@coinlab.com>
To: Stefan Thomas <moon@justmoon.de> 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Monday, May 28, 2012 4:54 PM
Subject: Re: [Bitcoin-development] Punishing empty blocks?


One of the issues here though is that it would be nice if miners published their own tx rules -- it might be hard to impute them from data.

I had started a thread about this on bitcoin.org some time ago, and I don't recall what the general outcome was.

I had imagined an open service whereby a miner could publish a short string in their conbase tying to the service and the service would have different metadata, including the miner's transaction guarantees.

We offered to host this before, and would still be willing to host such a service.

Peter


On Sat, May 26, 2012 at 7:52 AM, Stefan Thomas <moon@justmoon.de> wrote:

Zooko is spot on - slower confirmations will give people a reason to set


-- 

Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ 

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Una potencial falla de seguridad ha sido descubierta en  Bitcoin-Qt
para Windows. Si tienes Bitcoin-Qt para Windows en alguna versin
entre 0.5 y 0.6, deberas salir del programa, y actualizar a la
versin 0.5.3.1 o 0.6rc4 AHORA.

La aplicacin de lnea de comandos (bitcoind), las versiones Mac y
Linux de Bitcoin-Qt, y las versiones anteriores a 0.5 no estn afectadas.

Debido a la naturaleza de esta falla, creemos que sera muy difcil
para un atacante hacer algo ms que colgar (cerrar) el proceso de
Bitcoin-Qt. Sin embargo, porque existe la posibilidad que un cierre
inesperado permita la ejecucin de cdigo remoto, consideramos esto un
incidente crtico.

Si tienes alguna pregunta, visita el canal IRC #bitcoin-dev en Freenode.

Puedes descargar el software actualizado desde SourceForge:
0.6rc
[https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/]
0.5.3.1 para Windows y 0.5.3 para Linux
[https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.3/]

- -- 
Be Happy
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAk9m4DYACgkQ77Wxq1L+vC74wgCfX4kF+BiKjO51UOgZmRib4kMP
W6sAn016/jDXOfV/WeonqtqB3GuhzG+t
=pqWY
-----END PGP SIGNATURE-----


-------------------------------------
I've written a draft BIP describing the bloom filtering protocol
extension developed by myself and Matt.

https://en.bitcoin.it/wiki/BIP_0037

(yes I know there's some kind of process around getting allocated a
number - it seems overkill for this).

Please read it and let me know if there are any missing details or
things which sound wrong.

Design-wise, it occurred to me as I wrote the BIP that the method of
delaying reception of invs is a bit ad-hoc. It may be better to have a
bloom filter be sent in the version message itself. On the other hand,
having a flag to delay invs means that the filter can be calculated in
parallel to bringing up the network connections. Whilst actually
making a Bloom filter is fast, with deterministic wallets you may need
to do a lot of calculations to find the keys to scan for.


-------------------------------------
On Fri, Jul 27, 2012 at 1:59 AM, grarpamp <grarpamp@gmail.com> wrote:

The file system is using twofish-cbc-essiv:sha256, apparently.  (I
went and dug up a mothballed machine of mine because of your post).

And I agree, encrypting everything is a good practice— I once got a
disk back from RMA where only the first sectors were zeroed and the
rest had someone elses data, since then I've encrypted everything
because you can't wipe a dead drive.

I'd love to know precisely what Bitcoin is doing thats making your
machine so unhappy... but your configuration is uncommon for bitcoin
nodes in many distinct ways so it's not clear where to start.


-------------------------------------
On Tue, Dec 4, 2012 at 3:58 PM, Mike Hearn <mike@plan99.net> wrote:

Marketing initiatives have limited windows.  This matters, perhaps,
when you're some VC pumping cash into a startup with the hopes of
being the next stockmarket pump and dump darling.  Outside of that
people use whatever they use because it works for them.

And by the numbers Linux desktops are more common than they've ever
been— and certainly Linux kernel _systems_ half the people I know have
one in their pocket and its hard to go more than a few hours without
touching one.  To some extent the "Year of the Linux desktop" is a bit
like the "Year of being able to turn lead into gold" ... we can turn
lead into gold now, but the particle accelerators, atomic power, and
atomic weapons enabled by the same technology are far more interesting
due to the particle realities of this. So we didn't get the ubiquitous
Linux desktop: We got the ubiquitious Linux server, the ubiquitous
Linux-kernel smart phone, the ubiquitous Linux television, media
player, HVAC controller, etc. instead.

Desktops— well, that didn't meet people's hopes though I think not for
the lack of marketing on the part of Linux, but because Apple stepped
up and produced middle ground products that attracted a larger
audience. Especially as MSFT dropped the ball. They did some things
better, had a running start, and had a non open source software
business model which made reaping rewards easier.

But I don't see how any of this has anything to do with Bitcoin...
Except for the point that if Bitcoin doesn't become the money system
everyone uses and instead becomes the money system infrastructure all
the systems people use depend on— just as Linux has with the desktop,
where it might not be on the desktop but its in router firmware, cloud
servers, and just about everything else— I wouldn't consider that much
of a loss.


Bitcoin already missed its first— and perhaps only— fad window in any
case. Today people say "Bitcoin? Thats still around? I thought it got
hacked". ... thanks to compromised centralized services.


Every man and his dog? Perhaps not.  But as many as can— probably so.

If we depend on the organic need for full nodes to overcome cost and
effort to run one there will always be major incentives to let someone
else do that, and the system would have its equilibrium right on the
brink of insecurity. Perhaps worse, since insecurity is most obvious
retrospectively. Security doesn't make for a good market force.


Tor is a distributed but controlled, by a small number of directory
authority operators, system.

It is a good system. But it has a trust model which is categorically
weaker than the one in Bitcoin.  If you want something where a
majority of a dozen signing keys— hopefully in the hands of trusted
parties— can decide the state of the system you can produce someting
far superior to Bitcoin— something that gives near instant
non-reversable transactions, something that gives good client security
without the complexity of a SPV node, etc.

But that isn't Bitcoin.


And yet every tor user— if the have the bandwidth available can be a
full internal relay and the software nags them to do it (and also nags
them to act as invisible bridges for blocking avoidance), and every
user is technically able to run an exit (though they don't bludgeon
users to do that, because of the legal/political/technical issues
involved).  To do any of this doesn't require a user to switch to
different software, and the tor project has previously opposed client
only software.


It's less different than you make it out to be— but it _is_ different.
  Bitcoin is a distributed currency. The value of bitcoin comes from
the soundness of its properties and from the persistence of its
security. If the integrity of the distributed ledger is disrupted the
damage produced, both in funds stolen and in undermining the
confidence of the system, can be irreversible. Because Bitcoin's value
comes from confidence in Bitcoin and not from the specific
functionality of Bitcoins (they're random numbers that sit on your
disk) even if the ledger isn't actually compromised but people
reasonably believe it could be compromised that undermines the value.
 Tor, on the other hand, is a functioning system whos value depends on
its current usefulness, and not the past or future security.

Compare in your mind— Say everyone just found out that at block
420,000 Bitcoin would stop enforcing signature correctness or block
subsidy values (and this wasn't going to be fixed), and you also found
out that one year from now Tor would hand over their sites, source
code repositories, and directory authority keys to Iran (and you have
no suspicion that they already had done so).   How fast would you stop
using Tor vs how fast would to sell whatever coins you could?


I don't think we really can send such a message.  Thanks just the same
as asking for donations, not completely unsuccessful but not easy to
make successful either.  You're arguing for people running distinct
software which has no capability to be a full node, and changing what
they're doing in order to support the network. This maximizes the
cost, because in addition to the real cost the user must take a
switching cost too, and deemphasizes investing in keeping the full
node software as usable because 'oh just run a lite node if the full
is too slow'.


-------------------------------------
I'd like to see the binaries signed with gpg, independent of any signatures
required for various operating systems.

I can't imagine a worse scenario than the bitcoin.org site being hacked and
the binaries replaced with wallet-stealing code. All of the developers seem
to have gpg keys, how hard can it be to provide a detached gpg signature
for the binary?
-------------------------------------

I'm interested to see what scripts were using OP_DEPTH and
OP_CODESEPARATOR, as the latter appears to be useless to my eyes.

Could you give some tx ids which use unusual opcodes?


-------------------------------------
One thing that occurred to me recently is that it'd be useful if
filters could contain exact matches as well as Bloom filters.

Specifically I'm thinking of things like my bond network proposal
where some outputs may be marked as special using script fragments
like "BOND" <data or hash of data> 2DROP.

This would allow systems that are only interested in data and
transactions relevant to bonds to exact-filter the chain on that
marker, and then when a transaction is discovered, add the hash of
that transaction to a parallel Bloom filter, ensuring you can see any
transactions that connect to it.

The spec as provided by Jeff doesn't specify how filters are matched
against transactions. I propose the following algorithm:

For each TX:
- Check if the hash of the tx itself matches the filter
- For each input:
  - For each script data element check if it is found in the filter
  - Check if the COutPoint.hash value is in the filter (let's you
select txns that connect to arbitrary txns of interest)
- For each output
  - For each script data element check if it is found in the filter


-------------------------------------
Regarding the decimal vs satoshi notation I see a few problems with satoshi:

* readability - humans reading the URI would expect it to accurately
reflect what is being displayed (subject to internationalisation issues)
For example, amount=1.234 is more human readable than amount=123400000 (ish)
* backwards compatibility - existing software already uses the decimal
notation
* forwards compatibility - Bitcoin needs to move beyond the satoshi to 20
dps for some reason, this remains OK within the existing schema, but forces
decimals into the satoshi scheme
* simplicity - dual decimal/satoshi variants should be discouraged under
the "single representation" approach

It's relatively straightforward to convert a string encoded decimal into an
internal integer for currency calculations just by applying a multiplying
factor. One never uses doubles or floats for money.


On 31 January 2012 14:33, slush <slush@centrum.cz> wrote:

-------------------------------------

Yes, more tests are definitely welcome.

check*sig tests are tricky, because they have to refer to previous
unspent transactions and private keys (so require a particular block
chain to test against). Brilliant ideas on a simple data-driven format
welcome.

block verification tests would be great; a collection of good/bad
block chains, starting from a common chain (maybe the testnet3
tesnet-in-a-box chain) would be very useful for regression testing.

-- 
--
Gavin Andresen


-------------------------------------
BIP 21 had broad consensus among the major implementations:
https://en.bitcoin.it/wiki/BIP_0021


BIP 19 is a document to propose adding a new payment type to the scripting system's template list.
https://en.bitcoin.it/wiki/BIP_0019

I haven't fully evaluated it completely but it seems solid. My only thoughts is that it uses a bunch of arithmetic operators which can behave in strange ways.
-------------------------------------
I'd still like to understand the rationale for having the merchant
broadcast the transaction - it seems to add complexity and create edge
cases.

How about this as an alternative proposal:

The buyer's client prepares the transaction and computes its txid.  It
then sends a ValidatePurchase message to the merchant containing the
proposed Outputs and a copy of the merchant_data along with the txid.

Assuming the proposed payment is accepted as valid by the merchant,
the buyer's client simply broadcasts the pre-prepared transaction in
the normal way, and it is the merchant's responsibility to watch for
this transaction to arrive over the p2p network/blockchain to complete
the purchase.  (So if the merchant rejects the purchase at the
ValidatePurchase stage, they never get to see the transaction that the
buyer prepared, and there's therefore no need for a send-to-self to
cancel it.)

An optional RequestReceipt message (perhaps containing the
merchant_data and txid) can be sent by the client after the
transaction has been broadcast - but by making this explicitly
optional it forces the merchant to rely on seeing the bitcoin
transaction to 'commit' the payment and not on the RequestReceipt
message.

As far as I can see this proposal has no edge cases where the buyer
and merchant have differing ideas as to whether the transaction has
'comitted' - or at least, no more edge cases than the standard bitcoin
protocol has.

roy


-------------------------------------
Thanks, I didn't realize BitcoinJS used LevelDB already.

Just one minor thing - LevelDB was definitely designed for servers, as
it comes from BigTable. It happens to be used in Chrome today, and
that was the motivation for open sourcing it, but that's not where the
design came from.

If anything it's going to get less and less optimal for desktops and
laptops over time because they're moving towards SSDs, where the
minimal-seeks design of LevelDB doesn't necessarily help. Servers are
moving too of course but I anticipate most Bitcoin nodes on servers to
be HDD based for the forseeable future.

Also, Satoshis code does use ordered access/iteration in at least one
place, where it looks up the "owner transactions" of a tx. I'm not
totally sure what that code is used for, but it's there. Whether it's
actually the best way to solve the problem is another question :-)


-------------------------------------
On Mon, Dec 03, 2012 at 06:48:34AM -0800, Amir Taaki wrote:

I don't think there is a compelling reason to encourage uncompressed public
keys anymore on the network. They take more space in the block chain for no
additional value whatsoever. Software may of course continue supporting
uncompressed keys if they wish to provide compatibility, but for a new
standard, I think it makes sense to standardize on just compressed keys.
And since that software thus needs to support the compressed encoding,
there is no reason to use a different encoding inside the derivation scheme
itself.

Regarding the encoding itself, it is not hard: just 0x02 or 0x03 (depending
on whether Y is even or odd) followed by the 32-byte encoding of X. Decoding
is harder, but is never needed in the derivation. Software internally can use
any representation (and it will), which in almost all circumstances stores
both X and Y (and even more). Decoding compressed public keys is somewhat
harder, as Y must be reconstructed (but the algorithm isn't hard) - this is
only necessary when someone wants to import an extended public key though for
watch-only wallets.

-- 
Pieter


-------------------------------------
Hi Steve,

45-90 minutes - note that its numbers from March/April, so a bit longer today, but far, far away from the 12 hours. 

I am using libcoin and the bitcoind build based on this. Libcoin is based on the Satoshi client, but refactured to use an async concurrency model. I also did a minor tweeks to the db parameters. It has earlier been tested up against Satoshi bitcoin where on some OS'es it performs similarly (at least on some linuxes) and on some faster (e.g. mac). 

What is your CPU load during a block download ? (both initially/up to the point where verification sets in and after). The initial download is typically disk I/O bound, the verification stage CPU bound, though I lean to believe that even there it is disk I/O bound (at least on my system ~50% CPU load). What should be better in libcoin is the concurrency model. The Satoshi client uses a pure reentrant mutexes model, that is not generally believed to motivate the best coding practice nor performance, you might end up without the concurrency you initially strived for *). As mentioned earlier libcoin uses a pure async concurrency model (and so does libbitcoin btw). 

I would like to stress again that these numbers will depend largely on the system running the test - I would call my laptop a bit over the average today (MB Pro, 2.66Ghz i7 dual core, 8GBRAM, 512GB SSD). But again 12 hours - I only reach such numbers on some of my VPS'es (linode 1024) that are known for notoriously slow disk I/O. (here I have a few % CPU load during the verification indicating indeed that the disk i/o is the culprit).

Cheers,

Michael


*) I like this Dave Butenhof quote: "The biggest of all the big problems with recursive mutexes is that they encourage you to completely lose track of your locking scheme and scope. This is deadly. Evil. It's the "thread eater". You hold locks for the absolutely shortest possible time. Period. Always. If you're calling something with a lock held simply because you don't know it's held, or because you don't know whether the callee needs the mutex, then you're holding it too long. You're aiming a shotgun at your application and pulling the trigger. You presumably started using threads to get concurrency; but you've just PREVENTED concurrency."




On 23/07/2012, at 17:54, steve wrote:








-------------------------------------
Hi all,

I've been wondering about whether it would be possible to wipe out the GUI
completely from the satoshi client, and reimplement any necessary data
requests as RPC calls, allowing us to fork -QT and other GUIs over and
(hopefully) dramatically simplifying the codebase that you all have to work
on.

Any thoughts about this? Once a week at least I find myself wanting to find
ways to help speed up development, this seems like it could be a big win.

Peter

-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
On Friday, July 27, 2012 5:59:20 AM grarpamp wrote:

Trying to run state-of-the-art encryption on EVERYTHING on an ancient computer 
is fairly ill-advised. I encourage you to continue with the plan to go 
shopping.


Sounds reasonable...
but why do you also need to encrypt 2+ GB of public record?

Luke


-------------------------------------
zoo of complicated (and potentially buggy/insecure) interactions. 


This is my biggest fear too. I would rather be extremely conservative in making any changes to the protocol unless absolutely needed. That includes the bloom filters which take away the fact that Bitcoin is stateless.

I was discussing this with another developer who mentioned something interesting: that always in the lifecycle of system's development, you see increasing complexity during its initial lifecycle as the field is being explored. At some later point, the technology matures and becomes standardised. At that point enough is known that the system snaps together and the cruft can be cut away to reduce the system down to core principles.

It's an interesting viewpoint to consider. I do however advise erring on the side of caution. Maybe there needs to a minimum schedule time before a new extension can be added to the protocol (except security fixes). If we're not careful, the protocol will become enormously huge and kludgy. However maybe as that developer pointed out, trying to stall the inevitable is slowing the long-term evolution of Bitcoin down.


________________________________
From: Wladimir <laanwj@gmail.com>
To: Andy Parkins <andyparkins@gmail.com> 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Saturday, June 16, 2012 10:42 AM
Subject: Re: [Bitcoin-development] Proposed new P2P command and response: getcmds, cmdlist


On Sat, Jun 16, 2012 at 10:16 AM, Andy Parkins <andyparkins@gmail.com> wrote:



It's currently (nearly) stateless, however it would be short-sighted to think it will stay that way. State is being introduced as we speak; for example, connection-specific filters.

I like the idea of a capabilities command; as time goes on and the ecosystem

Which is a perfectly reasonable requirement. However, one could simply standardize what a 'thin client' and what a 'thick client' does and offers (at a certain version level), without having to explicitly enumerate everything over the protocol.

This also makes it easier to deprecate (lack of) certain features later on. You can simply drop support for protocol versions before a certain number (which has happened before). With the extension system this is much harder, which likely means you keep certain workarounds forever.

Letting the node know of each others capabilities at connection time helps somewhat. It'd allow refusing clients that do not implement a certain feature. Then again, to me it's unclear what this wins compared to incremental protocol versions with clear requirements.

I'm just afraid that the currently simple P2P protocol will turn into a zoo of complicated (and potentially buggy/insecure) interactions.

So maybe a capability system is a good idea but then the granularity should be large, not command-level. The interaction between protocol versions and capabilities needs to be defined as well. Does offering "getdata" at protocol version 10 mean the same as offering it at protocol version 11"? Probably not guaranteed. The arguments might have changed. So it's not entirely self-documenting either.

Wladimir

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------------------------------

Sorry, that's to be expected, I shouldn't have asked.


Good point.


I usually test compile / report current and stable of things I use.


So I get that github/master is the obvious top of things.
But in looking at where the tags are between repositories,
it's still not clear to me what the workflow is.

Example...

There are these release tarballs on sourceforge, which all have
tags in github, yet no tags in gitorious. There are no 'x' branches
on github, yet there is one release applicable branch on gitorious.

I guess I'd expect to see, that if as hinted by Luke that gitorious
has the stable trees, that there would be release tags there, laid
down at some comfy point in time on the 'x' stable branches there.
(The stable branches inheriting new code from master). But there
are no such tags.

And the releases/tags seem to magically appear from nowhere on
github :) Again, I'm trying to extricate myself from CVS here.


# sourceforge tarballs
0.6.0
0.6.1
0.6.2
0.6.2.2

# github branches
  remotes/origin/master        432d28d Merge pull request #1477 from
gmaxwell/master
  remotes/origin/0.6.2         40fd689 Bump version to 0.6.2.2 for
osx-special build
# github tags
v0.6.0
v0.6.1
v0.6.2
v0.6.2.1
v0.6.2.2

# gitorius branches
  remotes/origin/0.6.0.x d354f94 Merge branch '0.5.x' into 0.6.0.x
  remotes/origin/0.6.x   5e322a7 Merge branch '0.6.0.x' into 0.6.x
# gitorious tags
v0.6.0.7


-------------------------------------
I'd suggest adding two links for each client.

One for getting the binary, and one for getting the source. (Obviously,
source being optional if you allow non-opensource clients.)


On 07/09/2012 12:44 PM, Amir Taaki wrote:





-------------------------------------
On Mon, Sep 10, 2012 at 11:07 AM, Matthew Mitchell
<matthewmitchell@godofgod.co.uk> wrote:

Why does this focus on actually sending the hash tree?  The block
header + transaction list + transactions a node doesn't already know
(often just the coinbase) is enough.


-------------------------------------
On 17 December 2012 10:19, Mike Hearn <mike@plan99.net> wrote:


Hi Mike, thanks you for the pointer.  I have read up on Protocol Buffers.

If the decision has already been made, then let's go with that, but if not
perhaps I can offer some comments.

Looking at:

http://en.wikipedia.org/wiki/Comparison_of_data_serialization_formats

And -- "Canonically, Protocol Buffers are serialized into a binary wire
format which is compact, forwards-compatible, backwards-compatible, but not
self-describing"

I can see there are advantages in this approach in that you can send
messages quickly and with low bandwidth.  However the non self describing
data means that it's significantly harder to convert from one format to
another.  Also references are important, and can be achieved in JSON.

Yet in my opinion there is great advantage to growing the bitcoin ecosystem
to interoperate with the whole net, kind of creating a complete web
economy.  The way to do this is to foster interoperability.  Having looked
at and worked with standards for the past 5-10 years that is the great
challenge.  Every system works in an island, and few talk to any others.
However, a market based economy grows exponentially more valuable with
extra liquidity.

Inventing yet another format may lead to balkanization.  If history is a
judge, the chances are high.  A self describing JSON format, however is
much more likely to interop.

I can understand the hesitation with JOSE.  However, if you get a moment,
please look at :

http://payswarm.com/specs/source/web-keys/

This should provide some of the tools that you need.

As I said above, if the matter is closed, that's fine and thanks for taking
the time to read.

Can I at least propose to make it mandatory for the binary format to have a
translation script to a self describing JSON format and back again.  I
would love to see the bitcoin ecosystem become a major part of the
infrastructure of the web itself (leading to even nice things like a proper
web of trust), as well as an awesome P2P system in its own right.
-------------------------------------
On Saturday 16 Jun 2012 09:42:21 Wladimir wrote:


My problem is that that I suspect the spectrum of clients will be far more 
than simply "thin" or "thick".  What about thick-pruned, thick-full?  What 
about thin-blocks-on-demand and thin-headers-on-demand?  These are just what 
I can think of now; it seems unwise to limit the functionality of clients 
not yet designed with a binary designation.  So... we make a field that can 
hold more than just a bit; with each possible value representing a specific 
(possibly overlapping) set of features?  Why not just enumerate the features 
then?

I did write responses to each of your following points; but they just 
sounded like me being contrary.  The short version is that I think too much 
emphasis is being placed on defining a specific set of feature->version 
mapping.  That's going to make it hard for future clients that want to 
implement some of the features but not all, and yet still want to be good 
bitcoin citizens and be able to tell their peers what they don't support.  
For example, there is no easy way for a node to tell another that it doesn't 
have the whole block chain available, so requesting it from it will fail. 


Fair enough.


That problem doesn't go away just because you don't have a capabilities 
system.  Either version 11 can speak version 10 or it can't.  I don't see 
how having a system for finding out that fact changes anything other than 
removing a load of protocol noise.

"I support getdata10" makes it far easier to discover that the peer supports 
getdata10 than sending getdata11 and watching it fail does.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------

I might be wrong but I think perhaps it would help to get this fix out before the p2sh protocol change. Otherwise a miner could combine a duplicate coinbase and an invalid P2SH transaction to create a block which can have excellent network propagation and still be guaranteed to be orphaned. This makes the attack significantly easier to perform.

If someone were to do this on the day of the P2SH switchover they could corrupt the database of all clients < 0.6 with only a single block. If it was done on an early block and was widespread enough it would make it difficult for new clients to find a genuine non-corrupted copy of the blockchain to download.

Thank You,
Ben Reeves
www.blockchain.info


On 28 Feb 2012, at 18:23, Luke-Jr wrote:


-------------------------------------
Outside of major features advertised network-wide in nService bits,
P2P protocol lacks a good method of enumerating minor features or
extensions.  The version number increment is coarse-grained, and is
not self-documenting.  A simple extension which lists supported
commands is added, as demonstrated in this pull request:

     https://github.com/bitcoin/bitcoin/pull/1471

Another option is for verack to return this information at login,
eliminating the need for a separate command/response.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hi again - and thanks for testing and finding this!

I have fixed the bug you reported:

The culprit was an implicit string constructor for the ChainAddress that caused creation of a not fully initialized ChainAddress. The right way to do it is using chain::getAddress(string) as the ChainAddress is chain specific. 

A git pull will fix it ;)

Cheers,

Michael


On 27/02/2012, at 20:03, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
On Mon, Jan 30, 2012 at 11:33 PM, Michael Hendricks <michael@ndrix.org> wrote:

Meh, careful not to mixup addrman created issues with preexisting ones
simply related to the number of connections vs the number of nodes.
Even absent addressman someone who can spin up a large multiple of the
current nodes as tcp forwarders to a system they control can capture
all of a nodes outbound connections.

Increasing the number of outbound connections is a very bad solution
to this problem: It invites a tragedy of the commons: you get the
"best" security by setting your number as high as it will let you. Who
doesn't want security?   Meanwhile we've come pretty close to running
out of open listening ports already in the past.

There is a much more scalable improvement for those concerned about
the sybil attack (I say those concerned because a sybil attack is not
that fatal in bitcoin— checkpoints prevent a total fantasy chain, it's
mostly  but not entirely a DOS risk)...

The solution is to addnode a couple of (ideally) trusted nodes, or
failing the availability of trusted nodes, a few that you think are
unlikely to be mutually cooperating against you.

A single connection to the 'good' network kills isolation attacks
dead, so a couple carefully selected outbound connections its a more
secure remedy and one which doesn't explode the network.


-------------------------------------
On Mon, Nov 26, 2012 at 4:31 PM, Luke-Jr <luke@dashjr.org> wrote:

putting payment addresses in the DNS does not require that only a
single address be used. This is an assumption and a possible use case,
but there is no requirement that payment addresses must be 1:1
associated.

-rick


-------------------------------------
Hey,

Just wondering why no-one has made one yet. Is there a reason why? I want to test it out.


-------------------------------------
Thank you!!!

It is all working now! Except "help"...

Nice work Michael!!

Best,
Thiago

2012/2/24 Michael Grønager <gronager@ceptacle.com>

-------------------------------------
On 2012 January 31 Tuesday, Luke-Jr wrote:


Is that true?  (I'm happy to be called wrong)

It doesn't seem like it to me.  The new transaction types will be rejected by 
old clients won't they?  They don't pass IsStandard().


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Hello,

Gulp.  Am a little nervous about wading into this swamp.  However, it seems 
to me that the debate has veered into the personal and away from the 
technical.  Surely if there are objections to both suggestions, that another 
solution might be better?  The answer doesn't have to be A or B, if the 
answer C turns out to be acceptable.

That being said; I am not confident enough to start making BIPs so I offer 
this idea up for my traditional mailing-list roasting but with the hope that 
I blindly stumble toward something more acceptable to everyone.

----

If the change is going to be a big one anyway and will require a client 
upgrade why not...

 - Increase the version number in transactions to make a new transaction
   structure
 - Dump the "scriptPubKey" field completely.  Everything will be pay-to-
   script-hash in version2 transactions
 - Replace it with "hashOfClaimingScript"
 - Add an "unsignedParameters" array.

hashOfClaimingScript is _not_ script.  It's just the hash of the script that 
is allowed to claim the output.  Then before scriptSig is allowed to run, it 
is hashed and compared against the hashOfClaimingScript.

unsignedParameters replaces the need for all the crazy messing around that 
OP_CHECKSIG currently does because it is specifically a block of the 
transaction that it not signed (although I would include the array size bytes 
in the signature calculation), therefore no script filtering is necessary.

The claiming script, scriptSig, can then be checked against whatever list of 
templates you like.  For pay-to-address it will probably look like:

  OP_PUSHPARAMETER {0}
  OP_PUSH { <claimant public key> }
  OP_CHECKSIGVERIFY

Handling the more complicated transactions (they're the point of all this 
after all) is pretty obvious; the unsignedParameters block can hold as many 
signatures as you like.  It also removes the need for OP_CHECKMULTISIG, since 
the script can specify the signature conditions.  e.g. a 2-of-3 script:

  OP_PUSHPARMETER {0}
  OP_PUSH { <claimant public key0> }
  OP_CHECKSIG
  OP_PUSHPARMETER {1}
  OP_PUSH { <claimant public key1> }
  OP_CHECKSIG
  OP_PUSHPARMETER {1}
  OP_PUSH { <claimant public key1> }
  OP_CHECKSIG
  OP_ADD
  OP_ADD
  OP_PUSH {1}
  OP_GREATERTHAN

(I'm sure someone cleverer than I can improve on the above)

-----

Let the flaming commence...



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Tuesday, February 28, 2012 11:48:39 AM Pieter Wuille wrote:

Has it been verified to make even rocconor's complicated transaction-based 
version impossible?


Can we do this in two steps? First, prefer blocks which don't break the rule; 
once 55%+ are confirmed to have upgraded, then it is safe to treat it as a 
hard rule.


-------------------------------------
On Wed, Oct 24, 2012 at 4:29 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Correct me if I'm wrong but...  I do not think there is any bound on
mempool size.

My proposal to age-out long-unconfirmed transactions is related, but
does not completely solve the unbounded-size issue.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Tuesday, November 27, 2012 12:02:42 AM Rick Wesson wrote:

Anonymity isn't a feature we claim to have, nor a goal of the project for the 
most part. Using a single Bitcoin address has many problems besides non-
anonymity: your customers are denied basic privacy and there is no good way to 
guarantee the user who says he paid you really did (since transaction ids are 
public record, anyone can claim they sent it).

In short, it is for the most part considered a rule to always use a unique 
address per transaction or at least per customer.

Luke


-------------------------------------
One of the issues here though is that it would be nice if miners published
their own tx rules -- it might be hard to impute them from data.

I had started a thread about this on bitcoin.org some time ago, and I don't
recall what the general outcome was.

I had imagined an open service whereby a miner could publish a short string
in their conbase tying to the service and the service would have different
metadata, including the miner's transaction guarantees.

We offered to host this before, and would still be willing to host such a
service.

Peter

On Sat, May 26, 2012 at 7:52 AM, Stefan Thomas <moon@justmoon.de> wrote:




-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
On Monday, February 06, 2012 10:44:09 AM Gavin Andresen wrote:

There are still many other pull requests that seem to be ready, but perhaps 
those can just as well wait for 0.7 if the 0.6 changes are deemed too much to 
add onto. Here are some that seem to be well-tested, and have been part of 
next-test for a while:
	719 coinbaser (already verbally accepted by Gavin for 0.6 a while ago!)
	568 rpc_keepalive
	565 optimize_FastGetWork
	715 bugfix_client_name
	562 optimize_ToHex


If this affects relaying, it will significantly harm the ability to replace 
the current spammy "green address" scheme with a sensible extra signature 
system. On the miner end, it could significantly harm adoption of such a 
system.


What else do I need to change for this?


I can also confirm I have seen at least one addr.db corruption with this.

Luke


-------------------------------------

Sure, the market is not always efficient nor desirable. This seems more like a social question though about choice and information. I do strongly feel that users should have more control over their technology, and a say in how Bitcoin operates. It is our job to present the choices and inform them to make good decisions. If we think how to implement this with a social component of the users operating the network rather than hard and fast rules, I think that's the preferrable way.

Part of the problem is that Satoshi didn't totally anticipate the growth of the network. The block reward (the subsidy) is too high, which is why transactions can afford to be so cheap. What would happen if blocks required a cumulative fee of XN BTC for N transactions before being accepted?



----- Original Message -----
From: Gregory Maxwell <gmaxwell@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: 
Sent: Friday, June 15, 2012 8:43 PM
Subject: Re: [Bitcoin-development] Near-term scalability

On Fri, Jun 15, 2012 at 2:38 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

And that use case does not need fast confirmations!

This is making the point.


The users of bitcoin can collectively choose how expensive operating a
full node is by accepting validation rules that allow it to be more or
less expensive. This is no more "real" or less "artificial" then an
imposed licensing fee or the like and it is not subject to market
forces.



-------------------------------------
I think the sourceforge mailing list system had the hiccups this
weekend; sorry for Pieter's messages appearing in your inbox multiple
times, it is not his fault.

I deleted the extra copies from the mailing list archives.


As for the contents of his message, since this mailing list was not
working discussion wandered into the pull request:
  https://github.com/bitcoin/bitcoin/pull/936

Assuming this mailing list is now fixed, I'd like to pull that
discussion back here.  The executive summary:  Pieter and I feel like
BIP 22 is overly complicated, and would like it to be simpler. I'd
especially like to hear what people think will be the "will be used by
lots of pool customers" features and what are the "will be used by
less than 5% of pool customers" features.


-- 
--
Gavin Andresen


-------------------------------------
On Fri, Jun 15, 2012 at 2:50 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

I would take the last block I solved and use it to write a transaction
to nowhere which which gave all 50 BTC out in fee.  This pays for as
many transactions in the block as I like for any value of X you want
to choose.

You should read the bitcointalk forums more often: variants on that
idea are frequently suggested and dismantled. There is a lot of noise
there but also a lot of ideas and knowing what doesn't work is good
too.


-------------------------------------
Hi,

I did describe a very similar thing back in January (also illustrated,
and, if I'm not mistaken, more simple and efficient to recalculate),
and I wanted to do a prototype, but I have been very busy with other
projects since then.

https://en.bitcoin.it/wiki/User:DiThi/MTUT

I just saw Gavin left a comment in the talk page, I'm sorry I haven't
seen it earlier.

I think armory is the perfect client to implement such an idea. I sort
of waited it to be able to run in my laptop with 2 GB of RAM before
being sucked into other projects. I even lost track of its
development.

I hope this gets developed. I will be able to help after summer if
this is still not done.

DiThi

P.S: Sorry Peter, I've sent you the message privately by mistake.
Also, I don't quite understand your concern of "unbalancing" the tree.

2012/6/17 Peter Todd <pete@petertodd.org>:


-------------------------------------
On Fri, Sep 14, 2012 at 3:57 AM, Scott Howard <showard314@gmail.com> wrote:


This is currently not feasible due to BerkelyDB limitations. All the
databases are within one 'environment', which is necessarily one directory
(it can probably be hacked around, but obviously we're really careful).

When LevelDB for the block chain and the custom format for the wallets is
introduces, various new configurations will be possible: Multiple wallets,
wallet in block chain in separate dirs, etc.

Wladimir
-------------------------------------
On Sat, Oct 20, 2012 at 1:55 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

I strongly support heading down this path. Malleability has produced a
steady trickle of surprising outcomes. In addition to the problems we
already know about and expect there may be additional security or DOS
problems that arise from allowing these.


-------------------------------------
[resend, sorry gavin]

I think these ideas all make a ton of sense, some have been floating
around for a while in various forms but it's good to draw them
together coherently.


Is more incentive needed? If you have tons of tiny outputs you already
have incentives to merge them because otherwise your txns will become
large and the fees needed to overcome the DoS limits and gain priority
will rise.

The code to do it is a bit irritating as you really want to de-frag
wallets in the background when the user is not likely to need the
outputs quickly, and I suspect over time transaction volumes will
become diurnal so it'd be cheaper to do that at night time, but it's
all possible.


Peers could provide first-seen timestamps for transactions when
announced or when downloaded with Jeffs proposed command, but the
timestamps are not necessarily trustable. Not sure if that'd open up
new attacks.


SPV clients can do it by getdata-ing on the relevant inputs, but it's
very bandwidth intensive just to guesstimate fees.


That's reasonable. I don't believe this case is worth worrying about
right now. For the common cases of

a) Customer buys from merchant (runs full node)
b) Trusted person sends money to trusting person (does not need confirms)

it wouldn't matter after the changes to the block creation code. It's
only really an issue when a user running an SPV client wishes to
accept money from somebody they do not trust, and they want it to
confirm quick-ish (within an hour), but can tolerate delays up to
that. I think this is likely to be rare.

Much more common is that you want to accept the payment immediately,
which is an oft discussed but different problem.


-------------------------------------
On Tue, Oct 2, 2012 at 1:52 PM, Peter Vessenes <peter@coinlab.com> wrote:

To be specific, do you mean

a) paid twice
     or
b) sent BF coins, then sent the same coins elsewhere
?

Double-spend is a specific technical term....

--
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
And, finally, when I say "Ditto to above" I mean "I have no idea", not
"nope". Double oops.
-------------------------------------


As for an explicitly standard way, there is none. The JSON-RPC 1.0 spec 
<http://json-rpc.org/wiki/specification> says "The specifications do not 
require a certain transport protocol. The use of TCP/IP socket streams 
is encouraged. The serialized request and response objects are sent to 
the peers through the byte streams. " The JSON-RPC 2.0 spec 
<http://jsonrpc.org/specification> goes out of its way to say "It is 
transport agnostic in that the concepts can be used within the same 
process, over sockets, over http, or in many various message passing 
environments."

The de-facto standard for bidirectional JSON-RPC is plain TCP sockets. 
BitcoinJS currently implements this - we detect whether an incoming 
connection is HTTP or raw JSON-RPC based on the first character. (HTTP 
must start with an uppercase letter, raw JSON-RPC must start with an 
opening curly bracket.)

There are two things to watch out for with JSON-RPC over plain TCP:

1. Plain TCP sockets (unlike HTTP) have no standardized authentication 
mechanism, so I added an extra RPC call auth("username", "password").

2. The TCP packets may or may not correspond to JSON-RPC messages. You 
can either use a streaming JSON parser (yajl in ANSI C, Jackson in Java, 
etc.), or you can just count (non-string-literal) curly braces to detect 
when a complete message has arrived.

Many JSON-RPC libraries come with TCP socket support out of the box: 
http://json-rpc.org/wiki/implementations

We're planning to add more features to our JSON-RPC API in the future, 
such as:

- JSON-RPC over TLS sockets
- Challenge-response authentication
- TLS client handshake (certificate authentication)

As for HTTP Keep-Alive: It works, but I don't think it's very widely 
supported among client libraries and HTTP isn't really made for this 
type of thing, so my gut instinct would be to avoid it. That said, it 
doesn't hurt to offer the option.

On 3/3/2012 6:08 PM, Michael Grnager wrote:

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Barring any last-minute showstopper issues, the plan is for release
candidate 5 to become the official 0.6.0 release on Wednesday.

So please help look for last-minute showstopper issues:

https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/

The major changes from release candidate 4:

+ Much faster writing of blkindex.dat during initial blockchain
download (by modifying the default bdb environment cache settings)

+ A new policy for wallet.dat upgrades: use the old format unless the
user either uses a feature that requires an upgrade (encrypts the
wallet) or explicitly requests that the wallet be upgraded using the
new -upgradewallet option. New wallets will use new features (for 0.6,
the only new wallet feature is compressed public keys).

+ bugfix introduced in rc4 for an assertion failure that could occur
during blockchain reorganizations

+ New code for managing the addr.dat file that prevents an attacker
from filling it with bogus entries.


- -- 
- --
Gavin Andresen
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (Darwin)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iEYEARECAAYFAk9w/mIACgkQdYgkL74406gafACdHYn6QI6QoKhkf22e0My2jCWa
IPkAn3YnNeMEmG8N6xEyCdNx3MTjgkcF
=CRL2
-----END PGP SIGNATURE-----


-------------------------------------
On Tue, Nov 6, 2012 at 7:13 PM, Luke-Jr <luke@dashjr.org> wrote:



It's not about BIP process, it's possibly about content of particular
proposals.




There's no mess with stratum mining, except in your head. There's no
requirement to have BIP for everything what people do. Stratum is NOT
related to bitcoin protocol or bitcoin implementation, it is just custom,
pooled-mining extension and bitcoin network doesn't need to know about
Stratum existence at all.




There have been peer review of the protocol. You wanted to say "I was not
invited to do peer review", right?

Please don't start it AGAIN and stop bashing Stratum in your posts, at
least in bitcoin-dev mailing list.

I promised to write BIP draft for Stratum, I proposed and implemented
get_transactions method to allow Stratum jobs inspection. What more do you
want, seriously? I'm soo tired by you, Luke.

slush

P.S. I'm sorry that other developers had to read such posts. I'll try to
sit on my hands next time.
-------------------------------------
I think it's pretty reasonable, although people will want to use node
flags to get into the addr broadcasts anyway.

That said, I suspect (based on previous discussions) that there would
be quite some pushback against putting extra functionality into the
core Bitcoin network. Most likely people will re-use the code with
different peer discovery seeds and bootstrap similar but unrelated P2P
networks for doing new applications.

For instance, what if we want to do the language translation app I've
talked about a few times before? You need a way to floodfill broadcast
invalid transactions to interested parties. The pubsub mechanism in
the Bitcoin protocol was an interesting way to do that, but I think it
got removed. To broadcast to interested nodes now, you'd have to find
them via addr broadcasts and then connect directly. And if you're
going to do that, you may as well just form an entirely independent
network.

More elaboration of the use cases might therefore be useful.


-------------------------------------

Every losing play? That's ... not excellent.

Well, this why the payment protocol spec has a way for merchants to
reply to customers with text instead of outputs.


-------------------------------------
OP_WITHIN is lower-bound-inclusive, but upper bound exclusive, so 1 0 1 WITHIN is false.


bool fValue = (bn2 <= bn1 && bn1 < bn3);

https://github.com/bitcoin/bitcoin/blob/master/src/script.cpp#L854

On 7/29/2012 6:31 PM, Amir Taaki wrote:



-------------------------------------
Blocks already checksum; they hash to a low number.

Also inre: block headers, you are furnished with a previous hash in the
first 80 bytes of the block. You can always cut the connection at that
moment if you've already seen the block headers.

Peter


On Mon, Apr 30, 2012 at 1:02 PM, Zell Faze <zellfaze@yahoo.com> wrote:




-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
On 05/02/2012 03:22 PM, Mike Hearn wrote:

Can we add Bitcoin Wallet? I'm not very good at writing descriptions, so
I would just add this for starters:

--
Bitcoin Wallet is a standalone wallet for Android devices. Its primary
focus is ease of use and being independant of central network components
(servers). It supports initiating transactions via QR code,  Bitcoin
URIs or near-field communication (NFC). It has a useful currency
conversion calculator.

Platforms: Android
Market: https://play.google.com/store/apps/details?id=de.schildbach.wallet
Project: http://code.google.com/p/bitcoin-wallet/
--



-------------------------------------
Hi,

luke-jr wants me to split this BIP into 3 separate BIPs because he says that other devs felt it was too unfocused and covered too many topics. However this discussion took place on IRC, and I never saw any of it to ascertain what happened (BIP 1 says drafts should be evaluated on the mailing list).

I think a discussion of BIP 22 perhaps did happen on the mailing list, but I don't remember it. Sorry if that's the case.

Anyway before granting the permission to allow this proposal to be pared down, and new BIPs granted for the non-core parts of this proposal, I want to know what people think. I'm not a miner myself, so I'm prescient of my lack of knowledge in the topic.


https://en.bitcoin.it/wiki/BIP_0022

Thanks



-------------------------------------

Mine too!


Reading between the lines, I believe this phrase, which is not my own
but that of experienced IETF staff, refers to the groups visible at
http://www.iana.org/protocols/ (which you yourself cited). Whether it
is formally used or not is unknown to me.


Expert opinion estimates six weeks, and by current estimates, we
should have an arrival circa February.


I would like to suggest that perhaps exactly this sort of banter is an
excellent illustration for the Bitcoin community of what we have been
up against in this (conceivable simple an public benefit oriented)
endeavour. If you also look at the fact that the ISO4217 registry (to
take currency/commodity codes as just one example) there is apparently
not even a public list of requirements for codepoint issue.  This sort
of thing is *exactly* why the internet community appears to
desperately need an open registry - allowing public internet bodies
(IANA) to function to support innovation and interconnectivity for all
sectors of the internet's various financial communities so that
anyone, including innovators, can obtain interoperability via simple,
hassle-free paths, without encountering self-important bureaucrats.

We anticipate victory circa February.

- Walter


-------------------------------------
Hello everyone,

a few days ago we merged Tor hidden service support in mainline. This means
that it's now possible to run a hidden service bitcoin node, and connect to
other bitcoin hidden services (via a Tor proxy) when running git HEAD. See
doc/Tor.txt for more information. This is expected to be included in the 0.7
release.

Additionally, such addresses are exchanged and relayed via the P2P network.
To do so, we reused the fd87:d87e:eb43::/48 IPv6 range. Each address in this
80-bit range is mapped to an onion address, and treated as belonging to a
separate network. This network range is the same as used by the OnionCat
application (though we do not use OnionCat in any way), and is part of the
RFC4193 Unique Local IPv6 range, which is normally not globally routable.

Other clients that wish to implement similar functionality, can use this
test case: 5wyqrzbvrdsumnok.onion == FD87:D87E:EB43:edb1:8e4:3588:e546:35ca.
The conversion is simply decoding the base32 onion address, and storing the
resulting 80 bits of data as low-order bits of an IPv6 address, prefixed by
fd87:d87e:eb43:. As this range is not routable, there should be no
compatibility problems: any unaware IPv6-capable code will immediately fail
when trying to connect.

-- 
Pieter

-------------------------------------
RE: SignedReceipt:  I agree it is superfluous.  I'll remove it from the spec.

RE: "it is controversial use of the host key to use it for digital
signing of documents"  :  The idea of embedding a x509 certificate
chain comes from the IETF's JSON Object Signing and Encryption working
group "JWS" specification, so I can't be TOO controversial.

RE: the ifex-project and other electronic invoicing standards:  Thanks
for the pointers, Walter! I'm all for adopting the best ideas that
have come before, as long as we end up with something useful and small
enough to convince ourselves it is as secure as we can make it. I
looked at the ifex spec, and quickly got lost. It would help me if you
could write up what our motivating use cases would look like if
implemented on top of ifex.

RE: jgarzik's suggestion to allow txids in the Payment: that worries
me, because it is trivial to create several different variations of
the same transaction (same inputs to same outputs) with different
txids (re-signing inputs uses a different signature nonce, which
changes the signature/txid, for example).

RE: using self-signed certificates:  as Mike said, I assume Bitcoin
clients will have some way of managing root certificates, so experts
could add trusted self-signed certs.

-- 
--
Gavin Andresen


-------------------------------------
I'm pleased to announce the release of BitCoinJ 0.4, the leading Java
implementation of the Bitcoin protocol. BitCoinJ implements simplified
payment verification, a lightweight mode in which no central server or
authority is needed but the resource requirements are still low enough to
be usable on smartphones.

This version of the library is used in the new releases of Android Wallet
and MultiBit.

New in this release <http://code.google.com/p/bitcoinj/wiki/ReleaseNotes>

   - Ability to use "getheaders" to quickly catch up new users to the head
   of the chain. This is a big performance win.
   - ECKeys no longer require the private part, allowing for "watching
   wallets" that cannot spend, but still gather and track the transactions
   associated with the public keys.
   - A new API that implements transaction confidences. Get a quick summary
   or detailed information about how much confidence you can have that a given
   transaction won't be reversed.
   - A new DerbyBlockStore that stores block headers and related data in
   the Apache Derby relational database.
   - Protocol buffers are now a supported serialization format for the
   wallet. This means BitCoinJ based protobuf wallets can be read and
   manipulated by any language/platform with a protobufs implementation, which
   is most of them. There are extension points in the format to allow third
   parties to add new features.
   - Various new event listeners that help you learn when the state of the
   wallet or transactions change.
   - Support for post February 20th version handshakes (most library users
   already got this fix via backports)
   - All event listeners are now allowed to remove themselves during their
   own execution.
   - New APIs that allow you to create offline transactions and then
   broadcast them at a later point. Pending relevant transactions are recorded
   and announced to all newly connected nodes, ensuring a transaction won't
   "get lost" if there was flaky network connectivity at the time of creation.
   Pending transactions are supported much better in this release than in
   previous releases.
   - Wallet now can now take an invalid transaction and complete it by
   adding sufficient inputs and a change output. This enables the creation of
   multi-sends, as well as making experimentation with contracts easier.
   - Support for BIP 14: apps can now set their own "user agent" which will
   be put in the subVer field along with the library version.
   - Updated DNS seeds list.
   - A new WalletTool program for command line usage, and a ToyWallet app
   showing how to set everything up.
   - Support parsing and checking of alert messages.
   - New articles explaining how to use the library:
      - Working with
transactions<http://code.google.com/p/bitcoinj/wiki/WorkingWithTransactions>
      - Working with the
wallet<http://code.google.com/p/bitcoinj/wiki/WorkingWithTheWallet>
   - The usual assortment of bugfixes, new APIs, robustness and test suite
   improvements.

Thanks to everyone who contributed to this release, in particular Andreas
Schildbach, Miron Cuperman, Roman Maneleil, Chris Rico and Vasile Rotaru.

In the next release cycle, I'll be focusing on the following areas:

   1. Real support for transaction fee calculations (most users apply a
   custom patch for this today)
   2. A better block chain API
   3. Have the library manage save points for the wallet itself
   4. Further chain download time optimizations
   5. More support for moving apps onto "work done" as a confidence
   measurement

Of course contributors are welcome to work on whatever they want.

thanks
-------------------------------------
Why though? The bottleneck is not network traffic but disk space usage/blockchain validation time.



----- Original Message -----
From: Mike Hearn <mike@plan99.net>
To: Jeff Garzik <jgarzik@exmulti.com>
Cc: Bitcoin Development <bitcoin-development@lists.sourceforge.net>
Sent: Friday, June 15, 2012 3:43 PM
Subject: Re: [Bitcoin-development] New P2P commands for diagnostics, SPV clients


Matts point that a branch-per-transaction may duplicate data is well
made, that said, I suspect a format that tries to fix this would be
much more complicated.

How about see this project as a three part change?

First step - add the mempool command and make nodes sync up their
mempools on startup.

Second step - if protocol version >= X, the "block" message consists
of a header + num transactions + vector<hash> instead of the full
transactions themselves.

On receiving such a block, we go look to see which transactions we're
missing from the mempool and request them with getdata. Each time we
receive a tx message we check to see if it was one we were missing
from a block. Once all transactions in the block message are in
memory, we go ahead and assemble the block, then verify as per normal.
This should speed up block propagation. Miners have an incentive to
upgrade because it should reduce wasted work.

Third step - new message, getmerkletx takes a vector<hash> and returns
a merkletx message: "merkle branch missing the root + transaction data
itself" for each requested transaction. The filtering commands are
added, so the block message now only lists transaction hashes that
match the filter which can then be requested with getmerkletx.

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
On Sat, Oct 6, 2012 at 12:37 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

Just to close the loop on this: I finally got in touch with Thomas on
IRC and walked over the security issues I brought up here, plus a
number of other ones.

He took the concerns seriously and rapidly redesigned big swaths of
electrum to eliminate the issues structurally.  Electrum no longer a
classical thin client it is now a slightly watered down
simplified-payment-validation node with generally the same security
properties as other SPV nodes. Its network behavior leaves it somewhat
more vulnerable to isolation and compromise by a high hash power
attacker, because it does not (yet) make an effort to make sure it's
really on the longest chain. It is also more vulnerable to transaction
hiding (a DOS attack) for similar reasons.  But this is still a
massive improvement.  The UI was also changed and the confirmation
status of payments is no longer hidden.

There are still things to improve— both in the client and the security
communication to users. But I wanted to leave a note that it's come a
long way and that I now feel confident that any remaining issues will
be resolved.


-------------------------------------
Hi.

I've removed by blockchain information and started redownloading it, on a
fast connection, using the latest git version (tagged v0.7.1rc1), on a SSD
disk.

Everything goes very fast, except that a lot of duplicate blocks are
processed. New blocks arrive quickly, then a lot of duplicates seem to be
processed at a much quieter pace, while the chain height does not increase
anymore.

Is that expected? Isn't there a way to limit unneeded blocks downloads?

SetBestChain: new best=000000000000a664b1f5  height=114310
work=2478070628744107557  date=03/20/11 22:08:47
ProcessBlock: ACCEPTED
received block 00000000000064fbb040
SetBestChain: new best=00000000000064fbb040  height=114311
work=2478397878545837400  date=03/20/11 22:12:52
ProcessBlock: ACCEPTED
received block 0000000000006c7d5cf8
SetBestChain: new best=0000000000006c7d5cf8  height=114312
work=2478725128347567243  date=03/20/11 22:14:27
ProcessBlock: ACCEPTED
received block 0000000000009d72b51c
SetBestChain: new best=0000000000009d72b51c  height=114313
work=2479052378149297086  date=03/20/11 22:50:22
ProcessBlock: ACCEPTED
received block 00000000000014d91e7f
SetBestChain: new best=00000000000014d91e7f  height=114314
work=2479379627951026929  date=03/20/11 23:15:37
ProcessBlock: ACCEPTED
received block 000000000000034002cb
SetBestChain: new best=000000000000034002cb  height=114315
work=2479706877752756772  date=03/20/11 23:24:47
ProcessBlock: ACCEPTED
received block 00000000000032c97ae9
SetBestChain: new best=00000000000032c97ae9  height=114316
work=2480034127554486615  date=03/20/11 23:28:03
ProcessBlock: ACCEPTED
received block 00000000000055503e82
SetBestChain: new best=00000000000055503e82  height=114317
work=2480361377356216458  date=03/20/11 23:36:16
SetBestChain: new best=000000000000b7ce72e8  height=114318
work=2480688627157946301  date=03/20/11 23:37:44
SetBestChain: new best=00000000000076788899  height=114319
work=2481015876959676144  date=03/20/11 23:46:41
SetBestChain: new best=000000000000d04ffc5a  height=114320
work=2481343126761405987  date=03/20/11 23:55:28
SetBestChain: new best=000000000000514f0116  height=114321
work=2481670376563135830  date=03/21/11 00:02:01
SetBestChain: new best=00000000000022f1d1a0  height=114322
work=2481997626364865673  date=03/21/11 00:08:11
SetBestChain: new best=000000000000370e907e  height=114323
work=2482324876166595516  date=03/21/11 00:18:39
SetBestChain: new best=000000000000dab36141  height=114324
work=2482652125968325359  date=03/21/11 00:27:57
SetBestChain: new best=0000000000009f9401c1  height=114325
work=2482979375770055202  date=03/21/11 00:31:44
SetBestChain: new best=0000000000000e774dae  height=114326
work=2483306625571785045  date=03/21/11 00:48:00
SetBestChain: new best=000000000000b751fde0  height=114327
work=2483633875373514888  date=03/21/11 00:55:10
SetBestChain: new best=000000000000b377b247  height=114328
work=2483961125175244731  date=03/21/11 01:03:44
SetBestChain: new best=0000000000008a324822  height=114329
work=2484288374976974574  date=03/21/11 01:13:59
SetBestChain: new best=0000000000004270b478  height=114330
work=2484615624778704417  date=03/21/11 02:19:15
SetBestChain: new best=0000000000006b3f7c56  height=114331
work=2484942874580434260  date=03/21/11 02:47:57
SetBestChain: new best=0000000000009bc3a829  height=114332
work=2485270124382164103  date=03/21/11 02:55:29
SetBestChain: new best=000000000000308b5ad5  height=114333
work=2485597374183893946  date=03/21/11 02:55:44
SetBestChain: new best=0000000000007637ea6e  height=114334
work=2485924623985623789  date=03/21/11 03:10:04
SetBestChain: new best=0000000000000006acb7  height=114335
work=2486251873787353632  date=03/21/11 03:20:49
SetBestChain: new best=000000000000ab316f00  height=114336
work=2486579123589083475  date=03/21/11 03:43:16
SetBestChain: new best=0000000000005e87ca89  height=114337
work=2486906373390813318  date=03/21/11 03:44:37
SetBestChain: new best=000000000000adbb9bf5  height=114338
work=2487233623192543161  date=03/21/11 03:50:07
SetBestChain: new best=00000000000097ccfcf2  height=114339
work=2487560872994273004  date=03/21/11 04:02:14
SetBestChain: new best=0000000000000ab6f760  height=114340
work=2487888122796002847  date=03/21/11 04:04:52
SetBestChain: new best=00000000000099fc0aab  height=114341
work=2488215372597732690  date=03/21/11 04:11:18
SetBestChain: new best=00000000000038f85ffc  height=114342
work=2488542622399462533  date=03/21/11 04:21:02
SetBestChain: new best=0000000000008cf7ad33  height=114343
work=2488869872201192376  date=03/21/11 04:32:41
SetBestChain: new best=00000000000026f435ba  height=114344
work=2489197122002922219  date=03/21/11 04:40:07
SetBestChain: new best=000000000000a234fe35  height=114345
work=2489524371804652062  date=03/21/11 05:04:04
SetBestChain: new best=0000000000008f808957  height=114346
work=2489851621606381905  date=03/21/11 05:06:09
SetBestChain: new best=000000000000bb884dcb  height=114347
work=2490178871408111748  date=03/21/11 05:11:53
SetBestChain: new best=00000000000038cade45  height=114348
work=2490506121209841591  date=03/21/11 05:19:06
SetBestChain: new best=0000000000001e3155cd  height=114349
work=2490833371011571434  date=03/21/11 05:25:27
SetBestChain: new best=00000000000064fb7182  height=114350
work=2491160620813301277  date=03/21/11 05:27:41
SetBestChain: new best=000000000000a4cb0d57  height=114351
work=2491487870615031120  date=03/21/11 05:30:26
ProcessBlock: ACCEPTED
received block 0000000000007e7aa361
ERROR: ProcessBlock() : already have block 113868 0000000000007e7aa361
received block 000000000000af24d6fe
ERROR: ProcessBlock() : already have block 113869 000000000000af24d6fe
Added 1 addresses from 211.30.28.213: 26 tried, 8283 new
received block 00000000000094e6dc06
ERROR: ProcessBlock() : already have block 113870 00000000000094e6dc06
received block 000000000000d9efaa82
ERROR: ProcessBlock() : already have block 113871 000000000000d9efaa82
ERROR: FetchInputs() : 902e449ac3 mempool Tx prev not found abfd88f0e4
stored orphan tx 902e449ac3 (mapsz 877)
Added 1 addresses from 24.124.62.104: 26 tried, 8284 new
received block 000000000000a5695904
ERROR: ProcessBlock() : already have block 113872 000000000000a5695904
Added 1 addresses from 211.30.28.213: 26 tried, 8284 new
received block 0000000000002d0aa359
ERROR: ProcessBlock() : already have block 113873 0000000000002d0aa359
received block 000000000000d91ea603
ERROR: ProcessBlock() : already have block 113874 000000000000d91ea603
received block 000000000000d3c72ce3

  Sam
-------------------------------------
On Tuesday, March 06, 2012 12:34:15 PM slush wrote:

I think nobody has discussed P2SH with Tycho recently, since the priority is 
to get BIP 30 deployed first.


-------------------------------------
On Thu, Jul 26, 2012 at 7:27 AM, Mike Hearn <mike@plan99.net> wrote:

The OP_DEPTH are all screwups in P2Pool blocks.

( the software was making tiny payments to scriptpubkey 'script' due
to a bug, and it went unnoticed for a long time because it was assumed
that it was just some p2sh user intentionally being stupid )


-------------------------------------
There seems to be consensus that we should go ahead and do a release,
before leveldb or ultraprune or anything major lands.  There is no
major landmark feature, but just a useful collection of small changes.
 It seems like a good time to Release Early, Release Often and make a
checkpoint release.

Some rough draft release notes were dumped in
https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes.txt

Opening the floor...  What do we collectively want to happen, before
0.7 release?  What is the todo list for 0.7?

After cleaning out some pull requests yesterday, and looking at the
list today, I see

1) CreateNewBlock: Child-pays-for-parent / Add transaction fee later
luke-jr https://github.com/bitcoin/bitcoin/pull/1647

2) Translations update 2012-08-01 (fetched from Transifex)
Diapolo https://github.com/bitcoin/bitcoin/pull/1644

3) Add address groupings RPC from coderrr's coincontrol patches.
gmaxwell https://github.com/bitcoin/bitcoin/pull/1642

4) Add 'mempool' P2P command, and extend 'getdata' behavior
jgarzik https://github.com/bitcoin/bitcoin/pull/1641

5) PROBABLY NOT, BUT MAYBE: Relay blocks as a "preview" before
checking the transactions in them
luke-jr https://github.com/bitcoin/bitcoin/pull/1586

6) JSON-RPC method: prioritisetransaction <txid> <priority delta>
luke-jr https://github.com/bitcoin/bitcoin/pull/1583

7) HOPEFULLY: Addnode optimization and addnode access via RPC
BlueMatt https://github.com/bitcoin/bitcoin/pull/1549

8) MAYBE: Transition to requiring block height in block coinbases
gavinandresen https://github.com/bitcoin/bitcoin/pull/1526

9) WE MUST PICK ONE: RPC: lock push-down, preparing for
parallelization opportunities
jgarzik https://github.com/bitcoin/bitcoin/pull/1494
    or
RPC: add facility to enable RPCs to run outside cs_main, wallet locks
jgarzik https://github.com/bitcoin/bitcoin/pull/1493

10) I THINK WE WANT THIS?  Make IPv6 support optional again (defaults
to enabled)
luke-jr https://github.com/bitcoin/bitcoin/pull/1431

11) MAYBE: getblocktemplate ('getmemorypool', post IRC debate)
luke-jr https://github.com/bitcoin/bitcoin/pull/936


Devs -- feel free to commit directly to doc/release-notes.txt if there
is a missing commit, or something that may be better described.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
And if you do an update now "help" is there too ;)

/M

On 25/02/2012, at 03:11, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Hi Michael,

from what I have noticed, bitcoin blockchain download/verfication all
happens in 1 thread.  (so multicores doesnt really help)

That said, I have never tried on an ssd.

What I do have is 6 SATA 6gbs configed as RAID0 Drives.
32gb of ram. ubuntu 64 (yeah I know), this runs upto 16 VM's
(I have 4 of these)

However I have not tried to download the blockchain on the master os,
just in virtulisation.  However, the dedicated machines that I have been
using for benchmarking the VM's against is a q6600 8gb ram sata2 hdd -
Win 7 (seems faster than slackware...) to me it has always felt like
network bandwidth was the issue.  I might instrument the bitcoin-qt exe
to only pick low ping nodes (has someone already done this?)

I guess it is time to start some benchmarking (like the gpu comparison page)

hte verification for the 5 past 5 days was negliglable. I am off on a
flight to australia tomorrrow, so I will set some breakpoints and do
some timings in a debugger.

This will all happen on an e-450 (wonderful machine!)

Thanks very much for your response. it would seem that I am 'doing it
wrong' :/

cheers mate,

steve

(this message isnt signed because I have forgotten my password.)

On 24/07/2012 09:25, Michael Grnager wrote:
Live Security Virtual Conference



-------------------------------------
This conversation reminds me that I'd like to see a comprehensive list of
tests that alt processors / generators can run against.

I haven't looked in the client code for some time, but does that exist now?
That would be a nice 'I want to help' early project, getting together
inputs and expected outputs / stack states for implementers to check
against.

As it is right now, we've split our codebase a bit; we rely on the client
to check the validity of a transaction, the balance of a given address, and
converse with the network, but we have written most of our own code for
stuff like block gen; I expect we will also do that for transaction
creation.

Peter



2012/3/22 Michael Grønager <gronager@ceptacle.com>




-- 

Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
-------------------------------------
I've noticed a few transactions that have zero-length input and/or output scripts. There's a couple examples in block 0000000000000159a27442ee8b7f9ffad0cd799b003eafe007de9fbb47bd6ce7:

Txs: cdb553214a51ef8d4393b96a185ebbbc2c84b7014e9497fea8aec1ff990dae35, af32bb06f12f2ae5fdb7face7cd272be67c923e86b7a66a76ded02d954c2f94d


Is there ever a legitimate reason to create a transaction with a zero-length script? Should the protocol even allow it?

-Eric Lombrozo

-------------------------------------
On Wednesday, February 22, 2012 11:29:59 AM Michael Grnager wrote:

This fits...


What Gavin said.


-------------------------------------
Any chance the blockchain.info iphone app could be included on the clients page? The source is available under an lGPL license: https://github.com/blockchain/My-Wallet-iPhone. More info:https://blockchain.info/wallet/iphone-app

Also the javascript web front end can be reviewed using a combination of https://github.com/blockchain/My-Wallet and https://github.com/blockchain/My-Wallet-Integrity-Checker but I could see why that might be more of an issue for the the official site.

Thank You,
Ben Reeves

On 9 Jul 2012, at 15:00, Gregory Maxwell wrote:


-------------------------------------
On Mon, Dec 03, 2012 at 10:28:13PM +0100, Mike Hearn wrote:

Actually that has absolutely nothing to do with SMTP.  It's down to
the file format of the standard BSD UNIX mailbox (which uses lines
beginning with 'From ' to delimit messages).

roy


-------------------------------------
Could you spell out the attack explicitly? Presumably there aren't a
lot of people with the "malice energy" to perform the attack but not
to figure it out for themselves. I, however, have the "niceness
energy" to think about it for a few minutes but not to figure it out
for myself. If in your opinion it is realistically dangerous to post
it publicly, would you be so kind as to include me in the private
sharing of the explanation?

By the way, I found a couple of cases of slightly bad handling of
merkle trees when I inspected the code (v0.4) that was, I'm 99% sure,
not exploitable. I never got around to reporting it yet. I'm sorry
about that. My discoveries might interact with the one you're talking
about here. I should definitely explain mine to y'all soon. (Possibly
in private for the first pass, in case it is more exploitable than I
thought, or has become exploitable since v0.4.)

I showed it to a couple of other people at the time who helped me make
sure that it wasn't exploitable.

I'll make time to explain what I found within a week.

Regards,

Zooko


-------------------------------------
On 06/19/2012 02:18 PM, Mark Friedenbach wrote:

I was using "unbalanced" to refer to "query time" (and also 
insert/delete time).  If your trie nodes branch based on the next byte 
of your key hash, then the max depth of your trie is 32.  Period.  No 
one can do anything to ever make you do more than 32 hops to 
find/insert/delete your data.   And if you're using a raw trie, you'll 
always use /exactly/ 32 hops regardless of the distribution of the 
underlying data.  Hence, the trie structure is deterministic 
(history-independent) and cannot become unbalanced in terms of access time.

My first concern was that a malicious actor could linearize parts of the 
tree and cause access requests to take much longer than log(N) time.  
With the trie, that's not only impossible, you're actually accessing in 
O(1) time.

However, you are right that disk space can be affected by a malicious 
actor.  The more branching he can induce, the more branch nodes that are 
created to support branches with only one leaf.


-------------------------------------
My reply-all forward was blocked (over 40k), sigh. I figured I'd spammed
the list enough for one night.
-------------------------------------


Agree that you need a third party to verify identity. But the verification policy of sites is the job for a payment provider not a payment technology. So if you would like verification of the site you could just sign the memo using standard S/MIME - why mix it with the payment protocol?

Further, it is controversial use of the host key to use it for digital signing of documents, and not even within the policy of a host certificate as far as I recall.

The problem you are trying to tackle is that we don't have an ID solution on the internet today for this purpose. Certificates for signing messages are distributed freely and insecurely only based on temporarily having an email from within an organization, and the host certificates are meant for SSL handshakes. Funnily, any CA can issue digital certificates for email signing for any domain, even though they don't own them, and without notifying the owner. DANE actually solves this, but until then using the host certificates is unintended use, it is cryptographically a nice solution, but legally and standard-wise a hack.

/M

-------------------------------------
On Tue, Jan 31, 2012 at 7:22 PM, Matt Corallo <bitcoin-list@bluematt.me>wrote:


I like the mustimplement: idea, though I'd recommend a shorter
(abbreviated) prefix, to keep URL sizes small for QR codes and such,

Wladimir
-------------------------------------
On Mon, Nov 26, 2012 at 6:19 PM, Luke-Jr <luke@dashjr.org> wrote:


This is messy.   It's important to people to know that their cert will
be accepted by ~everyone because non-acceptance looks like malice.  If
the cert system is actually to provide value then false positives need
to be low enough that people can start calling in law enforcement,
computer investigators, etc.. every time a cert failure happens.
Otherwise there is little incentive for an attacker to not _try_.

Obviously the state of the world with browsers is not that good... but
in our own UAs we can do better and get closer to that.

Would you find it acceptable if something supported a static whitelist
plus a OS provided list minus a user configured blacklist and the
ability for sophisticated users to disable the whitelist?

This way people could trust that if their cert is signed via one on
the whitelist they'll work for ALL normal users.. and the UI can have
very strong behavior that protects people (e.g. no 'click here to
disable all security because tldr' button)... but advanced users who
can deal with sorting out failure can still have complete control
including OS based control.


-------------------------------------
On Mon, Jul 9, 2012 at 2:54 PM, Jim <jim618@fastmail.co.uk> wrote:

This ordering wasn't accidental.


-------------------------------------

Will try all these things out this weekend. Thanks.


-------------------------------------
On Fri, Dec 7, 2012 at 6:01 AM, Mike Hearn <mike@plan99.net> wrote:


Yes, my next step is prototyping.

Note that this is not a BIP yet:  I want to have a working implementation
before making this an Official BIP.




Changed:
   receipt_url: Secure (usually https) location where...

Though it's not strictly necessary, it'd be nice to have defined


yeah... I had similar thoughts on what to do if some Outputs specify an
amount and others don't. I'm still waffling on whether or not I like
allowing repeated Outputs; a single Output would make the spec a fair bit
simpler, and if a merchant wants to split up a payment for some reason they
could just generate another transaction.

I want to move on to actually implementing this before creating complicated
rules. Maybe the best way to tip a waitress is to get two separate
PaymentRequests, one for the restaurant and one that goes directly to the
waitress (depends on whether or not the restaurant needs or wants to know
how much their employees are getting tipped, I suppose).  Maybe it would be
best to have a separate "gratuity" Output in the PaymentRequest. That's the
kind of detail I think doesn't need to be worked out right now, I'd rather
restaurants tell us what they need/want.



This is the case of getting an UNSIGNED payment request; I've changed the
wording a little to make that more clear.

If a bitcoin client accepts unsigned payment requests (a couple of people
have asked if that would be possible so I think that is desired), then it
doesn't have the payer's identity-- all it has is the Outputs that will be
paid.





Not a BIP yet....

serialized_paymentrequest -> serialized_payment_request?


Done.




I still like the idea of only including the root CAs who have jumped
through the hoops needed to get the "allowed to issue EV certs" blessing.
 I'm not suggesting that all bitcoin merchants must get EV certs, but I am
suggesting that they must get a certificate from one of the most reputable
certificate authorities, and the ability to issue EV certificates is, I
think, a good proxy for that.

But, again:  Not a BIP yet.  Lets get something implemented and then hammer
out details (implementing always turns up edge cases you forgot when
spec'ing).


-- 
--
Gavin Andresen
-------------------------------------
As the only person to have created and maintaining a full reimplementation of the Bitcoin protocol/standard, I do think Bitcoin is filled with arbitrary endianness and magic numbers. However it is a tiny and simple protocol.

The big problem is not implementing the Bitcoin protocol, but the fact that once you have created a codebase, you want to perfect and fine-tune the design. During the meantime, the Bitcoin protocol is being changed. Change to the Bitcoin protocol is far more damaging to people that want to implement the protocol than any issues with the current protocol.

That's not to say, I disagree with changes to the protocol. I think changes should be a lot more conservative and have a longer time frame than they do currently. Usually changes suddenly get added to the Satoshi client and I notice them in the commit log or announcements. Then it's like "oh I have to add this" and I spend a week working to implement the change without proper consideration or reflection which ends up with me having to compromise on design choices. That is to remain compatible with the protocol.

However it is not my intent to slow down progress so I usually try to hedge against that kind of feeling towards conservatism.



----- Original Message -----
From: Jeff Garzik <jgarzik@exmulti.com>
To: Wladimir <laanwj@gmail.com>
Cc: bitcoin-development@lists.sourceforge.net
Sent: Sunday, June 17, 2012 5:19 PM
Subject: Re: [Bitcoin-development] Proposed new P2P command and response: getcmds, cmdlist

On Sat, Jun 16, 2012 at 4:42 AM, Wladimir <laanwj@gmail.com> wrote:

What is missing here is some perspective on the current situation. It
is -very- easy to make a protocol change and bump PROTOCOL_VERSION in
the Satoshi client.

But for anyone maintaining a non-Satoshi codebase, the P2P protocol is
already filled with all sorts of magic numbers, arbitrarily versioned
binary data structures.. already an unfriendly zoo of complicated and
potentially buggy interactions. There is scant, incomplete
documentation on the wiki -- the Satoshi source code is really the
only true reference.

I see these problems personally, trying to keep ArtForz' half-a-node
running on mainnet (distributed as 'blkmond' with pushpool).

In an era of HTTP and JSON, NFS and iSCSI, bitcoin's P2P protocol is
woefully backwards, fragile, limited and inflexible when it comes to
parameter/extension exchange and negotiation. Even iSCSI, that which
is implemented on hard drive firmware, has the ability to exchange
key=value parameters between local and remote sides of the RPC
connection.

Calling the current P2P protocol "simple" belies all the
implementation details you absolutely -must- get right, to run on
mainnet today. Satoshi client devs almost never see the fragility and
complexity inherent in the current legacy codebase, built up over
time.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
Source code URL:  https://github.com/jgarzik/picocoin/

I'd like to announce another bitcoin implementation, which is really
two useful pieces in one:

     libccoin - a bitcoin library, written in C
     picocoin - A lightweight, C-based SPV bitcoin wallet client

libccoin supports all key network datastructures (block, transaction,
etc.), script parsing and validation, transaction and block
validation, a "headers-only" or full block database, and many other
features essential to any bitcoin client.  libccoin passes all key
encoding, script and transaction tests available in the Satoshi
reference bitcoin client.

picocoin is much more under construction.  When complete, it will be a
very low resource, command line / JSON-driven bitcoin wallet.
Advanced security features already implemented include required wallet
encryption, fork-based process separation of P2P networking and wallet
(and chroot/SELinux jailing coming soon), something that the reference
Satoshi client does not even support.

Status:  Alpha quality, developer release.  Passes reference client
base58/script/transaction tests, but is still a developer-only
preview.

Feature list:

    Intended to be a full-feature bitcoin support library.  The
library will not be limited to "what picocoin needs."
    Supports all core data structures and network messages
    Full script implementation
    Passes hundreds of available reference client tests
    Supports multiple block chains: main or testnet3
    Very low resource usage (cpu, disk, and memory)
    Small codebase (both source code and compiled object)
    Supports advanced thin-client features such as "bloom filtering",
an upcoming proposal that will reduce client bandwidth usage.
    Works on big endian machines, as well as little endian machines
    Multi-platform: Linux supported currently.  Should work on
OSX/BSD/Windows with minimal modifications.
    libccoin should work on Windows.  picocoin will work on Windows,
but be a bit less secure than other platforms due to lack of fork.
    Improved security:  fork-based process separation firewall between
networking and wallet code -- your wallet is never directly exposed to
the network.
    Follows the philosophy of "do, not hype."  This library is already
far more secure and capable than other libraries hyped as the "future
of bitcoin" by their authors.

Code contributions are welcome (see github URL above).
Comments are welcome.
Donations are welcome too (1BrufViLKnSWtuWGkryPsKsxonV2NQ7Tcj).

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

That's pretty much what we have today - in future other schemes can be
proposed as extensions. Protocol buffers are easily extended, they
ignore unknown fields. Then you'd wait and see what the invoice
request looked like and produce an invoice with the right security
bits.


It's not obvious to me, incidentally. The web of trust has been
dead-on-arrival since it was first proposed, and for good reasons.
SSL/X.509, for better or worse, has significant usage.

Your case of a small business is a perfect example of people who won't
be using GPG. If they don't want to buy an SSL cert, they can just as
well put a reference number in the memo field or a "Hey Bob, here is
the bill we discussed". The payer does not get the multi-factor auth
protection so if their computer has a virus, they may be hosed. But
that's good incentive for sellers to get verified. Some CA authorities
do it for free these days.


-------------------------------------
Although quite true, I actually agree though that there should be some sort of checksum for the blocks.  Bandwidth may not be a bottleneck now (or ever), but it may be at some point.  This change will help Bitcoin scale.

------------------------
"It stopped being just a website a long time ago. For many of us, most of us, Wikipedia has become an indispensable part of our daily lives."
— Jimmy Wales, Founder of Wikipedia 
Help protect it now. Please make a donation today: http://www.wikimediafoundation.org/wiki/Donate



--- On Mon, 4/30/12, Amir Taaki <zgenjix@yahoo.com> wrote:



-------------------------------------
On Wed, Feb 1, 2012 at 9:18 AM, Michael Grønager
<gronager@ceptacle.com> > The libcoin/bitcoind client downloads the
entire block chain 3.5 times faster than the bitcoin/bitcoind client.
This is less than 90 minutes on a modern laptop!

I'm guessing that you benchmarked this against the version you forked
from rather than the current reference client?

If so— I suspect your speedup was almost entirely because you removed
the secure allocator and as a result fixed the mlock performance bug
[https://bitcointalk.org/index.php?topic=56491.0] as a side effect. On
some systems the mlock issue makes a very big difference (on other
systems not so much).

In any case, I finally got libbitcoin built and I'm disappointed to
report that in the same time it takes the reference client to fully
sync, libbitcoin only made it to height 138k (of course, because the
time is mostly spent late in the chain 138k is not very far along— I'm
guessing it's going to take libbitcoin 3x-4x longer all said)

I assume the reason it's actually slower is because it's CPU bound on
ECDSA checks, which are skipped in bitcoin in blocks up to the highest
hardcoded checkpoint.  Without that difference I suspect libbitcoin
would be about the same speed— maybe a little faster because of the
other changes you mentioned (though, e.g. lock profiling shows hardly
any contention during sync).

I don't doubt your rpc performance is a lot better. There is a
longstanding pull request for async rpc for the reference client that
hasn't been merged.


-------------------------------------
(oops sorry greg- replied to you by mistake)

That address he gives is 77 characters/bytes (same thing). What I'm asking is how can it be so small. I know that it's encoding a script, but then I started trying to imagine what kind of script and to me it seems that 2 public keys are too large for those 77 characters when encoded.

That is the example quoted on the forums:
57HrrfEw6ZgRS58dygiHhfN7vVhaPaBE7HrrfEw6ZgRS58dygiHhfN7vVhaPaBiTE7vVhaPaBE7Hr


Could it be a mistake?


----- Original Message -----
From: Gregory Maxwell <gmaxwell@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Sunday, January 29, 2012 5:19 AM
Subject: Re: [Bitcoin-development] Quote on BIP 16

On Sat, Jan 28, 2012 at 11:52 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

... No it's not a mistake. P2SH _prevents_ needing long addresses.

Lets unpack the acronym "pay to script _hash_". Hashes only need to
be 128-256 bits in size or so to have acceptable security, so you
don't need something longer than that for paying to a hash.

Note that gavin is saying 70 characters, not bytes.

Without some form of P2SH then only way for you to make a personal
choice of asking people to pay to a two-factor protected account or
two a multiparty trust that manages the finances of an organization
is using some form of "P2S", pay-to-script.

In other words, you'd have to have an address that encodes a full
script specification for the sender to pay to, instead of just
encoding its hash. As a result these addresses would be much longer
(and potentially very long).

The minimum size of a two address involving encoded script would be on
that order, but they get bigger quite quickly if you add more options
to the script (actually 70 sounds quite small, it should be more like
100 for a minimum two pubkey script).

In addition to the unworkability of very long addresses as described
by gavin (amusingly I am unable to copy and paste the quoted example
in one go) a P2S solution has several problems which you might
consider more or less important:


(1) They are highly vulnerable to invisible substitution. E.g. I can
trivially take a P2S address, change one or two characters and get a
script which is redeemable by anyone. With P2SH you have to do
computation which is exponential in the number of unchanged digits to
get a look alike address.

(2) The sender is fully responsible for fees related to the enlarged
transactions. Even if _you're_ willing to take the txn-processing time
and fee burden of a 30 person joint trust address, random e-commerce
sites will not be and will randomly reject your addresses.

(3) They create another input vector for non-trivial data which must
be inspected and validated, potentially presenting an attack surface.

(4) They leave the complicated (long) release rules in the transaction
outputs. When a transaction is mined we can't be sure if it will ever
be redeemed. The outputs are unprunable. In a future world where
many nodes prune output space is far more important than input space
and it would make sense to require more fees for it because we're
never sure how long it would need to be stored (making it an
attractive target for someone who wants to make Bitcoin unusable by
spamming it with worthless data). P2SH reduces output sizes to the
absolute minimum without inflating the total data size.


-------------------------------------
RE: 0x06/0x07 'hybrid' public keys:


I say treat any transactions that use them as 'non-standard' -- don't
relay/mine them by default, but accept blocks that happen to contain
them.

I agree that a rule change isn't worth it right now, but making them
non-standard now is easy and should make a rule change in the future
easier.

-- 
--
Gavin Andresen


-------------------------------------
On Fri, Aug 17, 2012 at 9:40 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

OK, just updated 'mempool' branch to not return "inv" if mempool is empty.



MSG_MEMTX is not a good idea for this use case.  Just sent a ping(nonce).

Bitcoin P2P processes requests in-order, and responds accordingly.
The remote end may insert asynchronous messages into the response
stream, certainly, but responses to queries are processed and returned
in-order.  A 'getdata' response is fully sent before a 'ping' response
is sent, etc.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I do think it would be nice to sweep up dust transactions, however I'm not
that happy with your solution

1) Wouldn't the need to re-transact your coins to keep them safe from
"vultures", result in people frantically sending coins to themselves, and
thus expand the block chain, instead of reduce growth?

2) putting those hard limits in passes a value judgement that IMO should
not be present in the protocol. <1BTC may be worth a lot some day, or it
could go the other way around, with dust spam of 10+ BTC. Either way the
limits will have to be changed again, with yet another fork.

3) The (normal) user does not have a view of his balance consisting of
inputs and outputs of various sizes. He just sees his balance as one
number. And somehow, inexplicably (except through a very difficult
explanation), it's going down... what if he has 10000 BTC in 0.9999999 BTC
units? Annnnnd it's gone after 210000 blocks.

I wonder if there is a way for the whole process to be transparent to the
user. The wallet is 'defragmented' but without losing the swept up coins to
the miner.

Wladimir



On Mon, Dec 3, 2012 at 12:19 PM, Michael Gronager <gronager@ceptacle.com>wrote:

-------------------------------------
Hi Michael,

 Let's talk a little bit more about this awesome stuff!

2012/3/22 Michael Grnager <gronager@ceptacle.com>

Well, +1000 for that!! Since bitcoin-qt and bitcoind binaries share a lot
of functions... There is a need for some kind of library, right?! So, both
(and even more apps) can use it!  :)


AWESOME!!



 I'll try to help you here... One thing that I like to try and announce is:

 Use P2Pool with libcoin instead Bitcoin! BUT, to that work, libcoin must
behave EXACTLY like Bitcoin 0.6.0rc5 (at least).

 If it works, I'll update my P2Pool guide here:

 A Complete Guide to P2Pool - Merged Mining (BTC/NMC/DVC/IXC/I0C) plus LTC,
Linux:
 https://bitcointalk.org/index.php?topic=62842.0

 I think that this will bring much more eyes to Libcoin!! Don't you think?!

 Let's do it?!?!



COOL!! I just finish my Diaspora test environment, can you try it?!

https://quilombas.com/



Too bad... lol

My plan with Diaspora is to include a wallet for each user and, Libcoin
sound perfect for it.

If I use original bitcoind, each Diaspora user will consumes a lot of
resources and I'll need to build a private cloud computing for running
user's wallets more safely...

You know when you log into Diaspora and there is a Cubbi.es app for it?!
So, the same way Cubbi.es manages/shows your pictures within Diaspora, my
(our) application will manage our Bitcoins!! And users will be able to
send/sell Bitcoins between them (maybe integrating it with Bitcoin-OTC will
be a good idea for the future)...


Cheers!
Thiago Martins
-------------------------------------
Hello all,

Mike Hearn has submitted a pull request to add a pong message in reply to a ping.

This warrants an upgrade of the network protocol version number, which is since BIP14
independent from the version numbers of the reference client.

Any opinions about a numbering scheme? Currently the value 60000 is used. We could
simply start increasing the number one by one now for every change, or we could
do a "cleanup" to 100000 first, and start incrementing from there.

-- 
Pieter


-------------------------------------
I don't think this is the right mailing list for discussion of this
Blackout topic. I know this is definitely not the right mailing list
for proselytizing.

On Tue, Jan 17, 2012 at 11:03 AM, Luke-Jr <luke@dashjr.org> wrote:


-------------------------------------
On Fri, 2012-06-15 at 15:34 +0200, Mike Hearn wrote:
Its arguably not a change to network rules as its something that users
can already do today by patching their clients.  Obviously any
implementation would have sane defaults which allowed for a significant
number of transactions to/from a given address at a time, avoiding
whacking random people unless they are large enough that they should
really already be fully aware of how bitcoin works.
I would think SD would switch to using fresh addresses for each bet.
But even that is a good thing, at least where user privacy is concerned.
However, I would hope that SD would see the rule tweak and, in order to
avoid having to generate a number of new addresses per second (or, if
they went the pool route, having a huge pool of many thousands of
addresses), they would consider implementing sendmulti support.
I agree, free transactions isnt something we should aggressively push as
a feature of Bitcoin, its simply not.  However, in the current system
free transactions are usually confirmed within a small number of blocks,
and for a number of users, that is an important feature that draws them
to get through the initial hurdles of converting money to Bitcoin and
understanding enough of the system to trust it.  I believe that if we
can incentive large transaction creators to avoid delaying free
transactions, we should and giving them the option to delay their own
transactions seems like a perfectly reasonable way to do so.  Even if
you drop all the per-address limit stuff, allowing transaction creators
to add a simple flag to transactions seems reasonable when they want to
encourage Bitcoin to continue to grow as it does today.  Obviously
keeping free transactions confirming won't be possible forever, but
hopefully that will be as a result of natural growth which can encourage
further growth without the need for free transactions and not as a
result of a few actors in the community creating a transaction volume
significantly greater than their user-base.
ACK, thats an important thing to implement IMO, but I really dont see it
as something that replaces the option to deprioritize your own
transactions to below 0-fee transactions.  It could even allow users who
receive payouts which are below 0-fee transactions to place a fee on the
subsequent transactions to allow the payouts to confirm quicker (if done
right).
I would be surprised if more than a handful of devs audit such a thing.
And I would say that does define an increase in centralization.
Sadly, old nodes do not know where to look for such data, and I'm fairly
certain people running old nodes don't read the forums enough to catch
when it is announced that old nodes should make sure to
-connect=archive.bitcoin.org in order to avoid initially having horrible
initial bootstrap times and eventually not being able to connect to
full-chain-serving nodes at all.
Sadly, disk space isnt the issue.  Each connection to bitcoind (not that
it cant be fixed, but currently) eats a nice chunk of memory.  An
organization that wants to provide nodes for old nodes to connect to
would need to have a significant number of open incoming connection
slots, have plenty of bandwidth for nodes that are in IBD and have
plenty of memory and CPU to manage all the connections.

Sadly, BDB's infamous database corrupted messages appear all too often,
and the usual response is "delete the chain and resync."  I have a hard
time believing that old nodes will rarely be in IBD.  
I agree that its very possible to have archival nodes available and to
make it work, but I have yet to see anyone doing any work to actually
get commitments to run archival nodes and I have yet to see any
discussion of what, exactly, that would entail.

Matt




-------------------------------------
On Wed, Oct 24, 2012 at 06:35:08PM +0200, Mike Hearn wrote:

So all data push operations? Including or excluding 1-byte constants?

What about the entire output script? (if I want to match just one particular multisig output script)


I'm not sure. As soon as you have 129 transactions in a block (including coinbase), you need 8 path
entries for each included transaction, which requires more bytes than the transaction itself.

When you're including M out of N transactions of a block, you never need more than N-M path entries
in total to reconstruct the merkle root. With the proposed format, it requires M*ceil(log2(N)).

For a 1000-transaction block, when matching ~everything, you need >300 KiB of overhead, while almost
nothing is required.

-- 
Pieter


-------------------------------------
Apologies if this has been discussed elsewhere. I don't recall us ever
reaching a solid conclusion on it.

A node that has pruned its block chain cannot serve the chain to new
nodes. So there are three options for bootstrapping a newly installed
node:

1) Have some kind of special archival nodes that never prune
(advertised via the services field?). Encourage people to run them,
somehow.

2) Ship a post-pruning block chain and tx index with the client
downloads, so the client starts up already bootstrapped.

3) Some combination of both. It's safe to assume some people will keep
unpruned chains around no matter what. But for many users (2) is
easiest and archival nodes would be put under less load if they were
used only by users who wish to fully bootstrap from only the code.

I remember some people, Greg in particular, who were not a fan of
approach (2) at all, though it has the benefit of speeding startup for
new users as there's no indexing overhead.


-------------------------------------
On Mon, Nov 26, 2012 at 5:37 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Comments:

1) Payment message should include ability to specify the transaction
_or_ a transaction id sent via normal means over the network.

2) I think a significant bitcoin userbase will want to operate outside
the full root-CA chain.  Just look at https:// websites now.
Self-signed certs are quite common, because it is easier, while being
more secure than http://

So some provision for self-signed certs, a use case in wide use
elsewhere, or equivalent thereof, seems reasonable.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

I'm aware of the memory and i386 issues, and going shopping.


Sync... yes, depending on the rate/sec and size of them, that would be an
issue. "Enterprise" systems with UPS, good disk, etc assume writes are
committed upon return, eliminating need for software apps to do sync. So
I need to figure out how to turn that off?

Is sync on for everything, or just the wallet (where it could be argued as ok)?


Guessing bitcoin's writes are small? So a RAM dev intent would be cheaper
and faster than SSD for that.


I'll try to search that. If it's anything like "delete old blocks/tx/coins that
have both been validated in the past and fully spent in the future since we
no longer need to validate further back beyond them [1]", that would be
interesting.

[1] Unless you're a historian or some usage other than casual transactions.


-------------------------------------

Looks good to me.

On 3/3/2012 4:44 PM, Luke-Jr wrote:



-------------------------------------
On Wed, Oct 24, 2012 at 11:56 AM, Mike Hearn <mike@plan99.net> wrote:

Thanks for taking the time to write this up.

I still don't understand what purpose the apparently gratuitous
inefficiency of constantly resending common tree fragments. There are
many points of complexity in this protocol— handling premature
disconnections without missing blocks, the actual implementation of
the hash functions for the filter, validation of the hash tree, etc.
Presumably these components will just get implemented a few times in
some carefully constructed library code, so I don't see an
implementation complexity argument here— except the fact that it isn't
what Matt has implemented so far.

The current design can cause massive overhead compared to pulling an
unfiltered block should a filter be somewhat overboard and also makes
this filtering useless for applications which would select a small but
not tiny subset of the transactions (e.g. 10%).

Also, it's not mentioned in the page— but the hash function used is
not cryptographically strong,  so what prevents a complexity (well,
bandwidth in this case) attack?  someone could start using txids and
txouts that collide with the maximum number of other existing txouts
in order to waste bandwidth for people.  Is this avenue of attack not
a concern?


-------------------------------------
How is this not the most important world issue right now?

EVERYTHING is under threat. Go nuclear to show our nerd-rage.

Everybody blank your personal sites too. Americans, take to the streets. World, go scream at the US embassy.



-------------------------------------
On Sun, Jan 29, 2012 at 12:23 AM, Alan Reiner <etotheipi@gmail.com> wrote:
[snip]

Be careful not to conflate multisig _addresses_  and P2S with multisig
output scripts in general.

Of the issues I raised only the size of the potentially unprunable
transaction outputs is an argument against multisig outputs which
aren't getting packed up in addresses.

Things like negotiated escrow arrangements can work okay either way.

I think P2SH is still better for these for two reasons: Reasonable
anti-spam behavior by network participant may make it hard to make
large output scripts (see above), but this isn't an issue yet...  and
P2S(H) lets you use a separate escrow-maker tool for clients paying
into escrow without any knowledge or support of escrow transactions in
that client. This uncoupling is important both for general "feature
velocity" as well as providing a uniform feature set across bitcoin
services (e.g. you negotiate paying someone via escrow, you use a tool
to make a mutually agreed escrow configuration, but your funds are in
MTGOX— no issue if P2SH is widely used).


-------------------------------------
They could be included as well of course, but from a seller
perspective the most important thing is consistency. You have to be
able to predict what CAs the user has, otherwise your invoice would
appear in the UI as unverified and is subject to manipulation by
viruses, etc.

So using the OS cert store would effectively restrict merchants to the
intersection of what ships in all the operating systems their users
use, which could be unnecessarily restrictive. As far as I know, every
browser has its own cert store for that reason.


-------------------------------------
Thanks for this, Amir.

My initial reactions:

1) This is cool and useful (but see 3)
2) This is significantly less secure than validating an entire blockchain;
it's certainly worth working out some use cases here in more detail than
just a sample conversation. More on this below
3) What about discovery? Will a client now have the chance to look for
NODE_STRATIZED clients on IRC? How do you envision a stratized server
decides which transactions to relay/store? Or is it just a caching layer in
front of a high quality blockchain service? If it is just a caching
service, the question of cache hits / misses is an interesting one as well.
4) What are the economic motivations to run a stratized server? Other than
cheating people of course.
5) Seems like a 'send me everything for this source address' is going to
save a lot of roundtrip conversations for what I imagine the most common
request will be.

Inre: majority agreement on transactions, and even balances, it would be
nice to work out some theoretical security / cost / value calculations for
the following scenarios:

Likely value and cost to someone of subverting / lying about
1) An n-confirmation transaction, n > 0
2) A 0 confirmation transaction
3) A NODE_STRATIZED transaction chain for a client with m connections to
NODE_STRATIZED servers
4) An address balance request for a client with m connections to
NODE_BALANCE_INFO (I made this name up) servers

Peter
-------------------------------------
On Mon, Apr 30, 2012 at 1:50 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

Personally, all this seems far too focused on a centralized website
(bitcoin.org), and presents far too many choices at once to the user.

On bitcoin.org (registered by Satoshi), I would rather see the Satoshi
reference client and perhaps an "other clients" link on the wiki.

Modern websites are working hard to _reduce_ the number of download
links, not _increase_ them.  See, e.g.
http://fedoraproject.org/en/get-fedora where a single download choice
is presented, and then an "other options" link is below the great big
download button.

Rather than fighting over what a particular bitcoin.org page should
look like, why not maintain an independently managed
BitcoinClients.org website?  Or GetBitcoinClient.org or somesuch.

Solve this problem in a distributed fashion, rather than stuffing it
all onto bitcoin.org.  Bitcoin.org, IMO, is the home of the "reference
project" not the entire bitcoin community.  Emphasizing that months
ago was why the forum was moved to bitcointalk.org.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Introspection/command discovery is nice, but I would prefer it to be immediately done in the first version exchange so no assumptions as to how a network is operating need to be made.

I like the idea of a flat list of commands. It might make sense to have "meta"-commands that alias to groups of commands. i.e "original" for the current core subset up to (and including) "pong". The aliases could exist in a text definition file which is held on github or bitcoin.org/


----- Original Message -----
From: Jeff Garzik <jgarzik@exmulti.com>
To: Bitcoin Development <bitcoin-development@lists.sourceforge.net>
Cc: 
Sent: Saturday, June 16, 2012 2:13 AM
Subject: [Bitcoin-development] Proposed new P2P command and response: getcmds, cmdlist

Outside of major features advertised network-wide in nService bits,
P2P protocol lacks a good method of enumerating minor features or
extensions. The version number increment is coarse-grained, and is
not self-documenting. A simple extension which lists supported
commands is added, as demonstrated in this pull request:

  https://github.com/bitcoin/bitcoin/pull/1471

Another option is for verack to return this information at login,
eliminating the need for a separate command/response.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
On Sat, 2012-06-16 at 10:27 +0200, Mike Hearn wrote:
Agreed, I was largely giving a reason why one may want to negotiate the
filter settings in response to your question as to why it was done.  As
long as there are sane limits (you cant make a 1GB filter by specifying
0% fp and some crazy number of entires), filter negotiation largely isnt
worth it (also prevents any floats from appearing in the p2p protocol,
though in either case it shouldn't be able to cause issues).

Matt



-------------------------------------
What you list below was actually the plan - just havn't gotten there yet, but it will be dead easy.

/M


On 22/03/2012, at 11:50, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------

BitCoinJ does not verify signatures (it is an SPV implementation), so
I'm not sure what you mean by this. Are you using old code? There used
to be some stuff that checked signatures but it was removed some time
ago.


-------------------------------------

Nodes repeat wallet transactions and any previous transactions that
are not yet included in the chain (see
CWalletTx::RelayWalletTransaction). So I don't think it's an issue.

(ok, bitcoinj clients don't do that, they just announce their own transactions)


-------------------------------------
On Sunday, October 14, 2012 8:52:33 PM Kyle Henderson wrote:

This needs some clarification. If the USA has "requested" it, then presumably 
there's some legality involved, and our US developers shouldn't be made liable 
for it. The specific reason SourceForge has restricted access should be made 
known so non-US developers (or gitian builders) can evaluate their own laws 
and hopefully at least one will be in a jurisdiction that allows it.
But GitHub is also US-located, so hosting it there may be a problem too.

Luke


-------------------------------------
This is definitely worth doing and I wish you every encouragement.

For my part I'm working on a different area of the Bitcoin ecosystem and
that is taking up all my time so I can only cheer you on from the sidelines.

On 25 September 2012 21:49, Daniel F <nanotube@gmail.com> wrote:

-------------------------------------
On Tue, Sep 25, 2012 at 1:34 PM, Jorge Timón <timon.elviejo@gmail.com> wrote:

This is discussion about transactions which are not in the chain yet.


The double spending transaction is not stored— which is, in fact, the
problem which creates these huge chain. When a transaction depending
on the doublespend is received we do not know its parent (because we
dropped it because it was a rule violation) so we keep it around as an
orphan hoping its parent arrives.

The software could maintain a cache of rejected txids to consult for
orphan txn's parents, but it would need to be dropped any time there
is a reorg so I don't know how useful it would be.


-------------------------------------
Peter, I like the idea of being able to know what fees to expect from different miners (it is like a service description / SLA for their service), but I would prefer a more distributed discovery mechanism for the information on the fees (Spent 10 years on Grid Computing...).

Miners could e.g. include a pointer to a webpage (or even their min fee) in the coinbase (encoded properly, like the "/P2SH/" string for BIP0016). That way clients could look it up them selves or you could create sites accumulating this information from the chain it self.

So something like :
        const char* service_sla = "|https://my_ubercool_asic_mining_pool/sla.php|";
        COINBASE_FLAGS << std::vector<unsigned char>(service_sla, service_sla+strlen(service_sla));
 
The format of the sla.php page should then be specified too - but it could be a json-rpc call returning a json object like (as result):
{ 
    sla_version: "0.1",
    accept_no_fee_tx: false,
    min_fee: 50000,
    big_tx_fee: 10000, // extra fee pr kb
}
I guess miners could work out a more suitable set of fees...

Seems like this calls for a BIP ?

/M



On 28/05/2012, at 16:54, Peter Vessenes wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
I think it's worth pondering the different things we may want in
future, even if that future is quite far out, just to ensure we have a
robust design that won't box us in later. Brainstorming feature ideas
now doesn't commit anyone to implementing them, but it may help
improve the final v1 design.


A simple way to solve this problem is just use the SSL identity of the
server that is taking part in the protocol, but it's not much harder
to embed a signature + cert chain into the invoice itself. And once
you're doing that, allowing several different sigs/cert chains is
pretty easy. It means you keep the design open to cases where SSL may
not be appropriate. Eg, you could create invoices signed by your
web-of-trust identity, or some non-SSL Bitcoin specific verification
system.

None of those things have to actually be implemented, but by
considering them now we can make the protocol more future prooof.


A signed invoice + the blockchain transactions does this, BUT with a
major caveat: if you have not set up dispute mediation, there is
nobody to prove faultlessness to.

So I'm not sure this would be very useful. Supporting real dispute
mediation seems more practical, but also more work.


This would be nice, I think invoices could be wrapped by another
protocol that handles it. I'm not sure it needs to be a part of the
core payment protocol. There are lots of different ways to implement
this and I'm not sure there's agreement on what it should look like -
somebody needs to build a "proprietary" implementation first.


-------------------------------------
I have no objections to a rc1 happening before I'm back.

--
Gavin Andresen


On Aug 2, 2012, at 10:45 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:



-------------------------------------
Guys!

 Only for the record, I'll integrate BitcoinJS (app) into Diaspora and, the
server side will be based on libcoin!
 Of course, this code will be part of Diaspora and every single Diaspora*
Pod will be able to host its own users's wallets...  ;-)
 I appreciate any help during this development!

Cheers!
Thiago

2012/3/28 Michael Grønager <gronager@ceptacle.com>

-------------------------------------
OK, I went ahead and changed mustimplement out for req (required).  Its
not quite as expressive, but its much shorter and still makes sense
(IMHO).  I also explicitly stated that numbers shouldnt contain commas
and should use period to separate whole numbers and fractional decimal
fractions (to avoid any localization concerns).

Matt

On Tue, 2012-01-31 at 20:02 +0100, Wladimir wrote:




-------------------------------------
Obviously this LGTM :)

Minor caveat, IMHO we should support all CAs used by the popular
browsers. This ensures no merchant ever finds that their SSL cert they
already own is OK for the web but not for Bitcoin. I don't see a need
to be stricter here, given all it achieves is signing some data in a
way linked with a domain name.

X.509 is pretty baroque indeed, for our use cases it'd not be hard to
do better. In particular, the inability to delegate properly rather
defeats the benefits of chained certificates. For the payment
processor case what you really want to do is take your keys, then
issue a new cert that is specific to signing Bitcoin transactions and
give that to the payment processor secure in the knowledge that they
cannot MITM your secure connections. Unfortunately X.509 wasn't
designed for the web and thus certificates you buy are marked such
that they are not allowed to sign for other certs (due to lack of real
namespace support).

This leads to the idea of redefining the cert chain part of the
protocol like this:

  repeated bytes x509_chain = 1;

becomes

  message Certificate {
    enum Type {
      X509 = 1;
    }
    required Type type = 1;
    required bytes data = 2;
  }

  repeated Certificate cert_chain = 1;

Then if later we want to introduce our own minimal certificate formats
which include features we want, we can add new enum types to do so.

Note that if an old client encounters an invoice with a cert type it
doesn't recognize, it will abort parsing of the message entirely. So
the request to download the invoice should probably include a protocol
version number of some kind so the server knows when it's safe to use
new invoice features.


-------------------------------------
Hey, looks good!  I'm glad to see them sorted alphabetically :)

A couple comments:  I don't think the entries for "wallet security" and
"backups" accurately describe Armory.  Wallet Security should say
"Encrypt/Offline" or something to to that effect -- after all, offline
wallets are the holy grail feature of the Armory.  And backups should say
something like "One-time Printable" if it fits within the box.

Otherwise, I really like the layout and design.  Although despite the fact
I enjoy being first on the list, I think Bitcoin-Qt should still go first.
 It is the "reference" client, and I think it's relevant that it is the
"de-facto" client for the majority of users, and the one with the most
quality control and stability.

-Alan


On Mon, Apr 30, 2012 at 1:50 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------

I'd thought about bumping the coinbase transaction version, but the
problem is if we want a smooth rollout then, during the rollout, every
time a new block comes in the percentage of the last 1,000 blocks that
support the new version has to be computed.

If that means looking in the coinbase transaction, then either the
last 1,000 coinbases have to be stored in memory or they have to be
fetched from disk. Which isn't a huge deal, unless we start
aggressively pruning spent transactions, and that coinbase 900 blocks
back got spent and pruned.

On Sun, Jul 22, 2012 at 4:52 PM, Luke-Jr <luke@dashjr.org> wrote:

Hmm...  I think it'd be ok to give 3 of the 4 block version bytes as a
simple extranonce, so version=0x00000001 is what we have now, version
2 blocks are any with 0x02 in the low byte, 0x03 is version 3, etc.  I
don't think we'll go through 253 block versions before we're all dead.

That'd be 7 bytes of nonce in the block header, which is
  72,057,594,037,927,936  ~ 72 petahashes = 72,000 terahashes

So: the changes for version 2 blocks would be "has height in the
coinbase, and has a 1-byte version number with a 3-byte extranonce."


No, the rules are "enforce the rules when the chain has a
super-majority."  Since block 190192 is in a part of the chain with
zero other version==2 blocks, the height-in-the-coinbase rule will not
be enforced.

-- 
--
Gavin Andresen


-------------------------------------
On Wed, Feb 1, 2012 at 4:15 PM, Luke-Jr <luke@dashjr.org> wrote:

The error about not finding boost is a red herring and as far as I can
tell bogus. The problem is that it finds Qt and tries to configure
some Qt code that doesn't seem to have actually been released. Try
http://pastebin.ca/2108766


Also, you'll probably need to set BDB_INCLUDE_PATH manually or it
won't find db.h

Hope this helps,
Aidan


-------------------------------------
On Thursday, August 02, 2012 4:43:25 PM Jeff Garzik wrote:

Based on pull-capable dev comments, I've personally noted these branches as 
accepted for 0.7:

+
+ m) getmemorypool: longpolling support
+ luke-jr https://github.com/bitcoin/bitcoin/pull/1355
+
+ m) Refactor transaction/accounting time
+ luke-jr https://github.com/bitcoin/bitcoin/pull/1393

I also personally feel these are appropriate and ready for 0.7:
+
+ m) Treat generation (mined) transactions less different from receive
+ transactions
+ luke-jr https://github.com/bitcoin/bitcoin/pull/1409

Also these, but they need testing:
+
+ m) Bitcoin-Qt (Windows only): enable DEP for bitcoin-qt.exe
+ diapolo https://github.com/bitcoin/bitcoin/pull/1614

I also feel it is very important that Wumpus/laanwj decide on a name for his 
client (formerly known as Bitcoin-Qt) and add it to the software instead of 
simply claiming it is "Bitcoin" as it has for a week or so now - that change 
is anticompetitive and will confuse new users into thinking Bitcoin is the 
software too easily.

Luke


-------------------------------------
I won't be able to make it this time.  My feeling is IRC is a good place to
bounce ideas around when time and people happen to be available, but having
meetings there will inevitably lead to decision making that's better done
in a slower manner via email.

Comments:

   BIP process: are we happy with how it is working? What can we do to improve
it?

Needing some kind of process to allocate a number is over the top. I
skipped this for the bloom filtering BIP. We should take off the part of
the {{BIP}} template that says "don't just pick a number and add a bip" -
that's exactly what people should do. I'm not sure there's any need for an
editing role either.

    Is it time to feature-freeze 0.8

I'd like more time to get the bloom filtering work in. It'll be easier to
promote the 0.8 release if we can sell it as "important
scalability/performance improvement for the network, upgrade to help
Bitcoin keep growing", as whilst there's no real auto update or organized
people who religiously update promotion is very important. I think
ultraprune + bloom filtering is the two major scalability improvements we
have right now.
-------------------------------------
Linux typically uses the FHS, which various distros often bastardize:
 http://www.linuxfoundation.org/collaborate/workgroups/lsb/fhs
BSD typically uses the traditional hierarchy, for which admins
 often add /home and /opt:
 http://svnweb.freebsd.org/base/head/share/man/man7/hier.7?revision=HEAD&view=markup

You'd have to read them both and decide which camp you're in.
 https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard

Since bitcoin isn't really an X app at it's core, XDG doesn't really
apply.
 http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html

Further, bitcoin doesn't allow easy separation of the files without
detachdb (off by default), nor does it supply a user agnostic system
daemon to do the block processing separately from user wallet ops.
So I would suggest until then it remain split up somewhere under
.bitcoin rather than in /var or anywhere else.

And when you figure out where I should place my messages in
full the first time, please let me know because I obviously need help.


-------------------------------------

What problem does it solve?

If the problem it will solve is "it will only take 4 hours to download
the entire blockchain next year instead of taking 16 hours" then no, I
don't think we should do it, both 4 and 16 hours to get fully up and
running is too long.

If the problem it will solve is the "too easy to get a DB_RUNRECOVERY
error" because bdb is fragile when it comes to its environment... then
LevelDB looks very interesting.

If the problem is bdb is creaky and old and has obscure semantics and
a hard-to-work-with API, then yes, lets switch (I'm easily seduced by
a pretty API and blazing fast performance).


As long as it compiles and runs on mac/windows/linux that doesn't
really worry me. I just tried it, and it compiled quickly with no
complaints on my mac.

Lack of infrastructure because it is new does worry me; for example,
could I rework bitcointools to read the LevelDB blockchain?  (are
there python bindings for LevelDB?)


Satoshi rolled his own network serialization because he didn't trust
existing serialization solutions to be 100% secure against remote
exploits. Then it made sense to use the same solution for disk
serialization; I don't see a compelling reason to switch to some other
serialization scheme.

Modifying the database schema during migration to better support
applications like InstaWallet (tens of thousands of separate wallets)
or something like Pieter's ultra-pruning makes sense.

-- 
--
Gavin Andresen


-------------------------------------

The point of using signed invoices as virus protection isn't to change
what the user sees on the infected host. The point is the invoice can
be relayed to a second device that isn't also compromised which then
independently renders a payment confirmation screen (like your mobile
phone), and it has an identifier in it that's useful to people, like
bitmit.net instead of an address.

If it was just showing you a Bitcoin address, that doesn't mean
anything to you so a virus on your PC could wait until you want to
make a large payment somewhere and swap out the address in use. You'd
never know it was the wrong address and you'd happily confirm on your
second device.

For this to work, the seller has to be able to predict what certs you
have in all your devices. If it's up to the OS vendors then it's hard
to know and in practice all that'll happen is somebody will compile a
list of CAs that are "known good" (ie, present in all deployed mobile
and desktop OS') and that'll be the minimal cert list. No different to
if it was hard-coded in the spec.


Nothing says your wallet software can't provide cert management UI
like browsers do.

In practice I have a feeling that cert management UI is one of the
least used parts of a browser. I've used browsers for years and the
only time I've ever had to go into those screens was to manage
installation/removal of self signed certs used by various
organizations. I never manually revoked a root authority. When it was
necessary due to breaches (Comodo/DigiNotar) the browser makers
revoked them for me.


-------------------------------------
BIP 0020 is the old URI scheme BIPisized.

ATM it is Draft status.

I do not know enough about the discussion back last year to know whether to move it to Accepted status or not. My feelings are that having a re-decision (even if it was accepted last year) is healthy since it makes no sense to have a standard before a standardisation process existed.

For now, it is Draft status until there's a general agreement.
-------------------------------------
On Monday, January 30, 2012 1:07:16 PM thomasV1@gmx.de wrote:

BIP 21 is not forwards-compatible, and is intentionally designed to be biased 
toward decimal. BIP 20 is neutrally biased, forward-compatible, and has been 
implemented for over a year now. If BIP 20 is to be Superceded, a proposal 
should improve on it, not make it worse with bigotry and short-sightedness.


-------------------------------------
Since I seemingly could not find the "create new post" link on the
forum, resorting to here...

a few feedbacks:
1) It would be helpful I think to, when the client first starts, to
ask "do you want to set a password to encrypt your wallet'? (if yes
take them to the encrypt wallet dialog).
I had been confused, since I knew 0.5 had "wallet encryption" I
assumed it would prompt on startup...
Also nice might be a message "first we have to synchronize with the
network, this will take several hours, then you'll be ready to go" or
some odd.
2) After synchronizing with the network, I believe the OS X client
started *always* crashing on startup.  Lost the backtrace but will
post it here if I can reproduce it.
3) With the forum I can't seemingly reply or create new posts? (rogerdpack)

Cheers!
-roger-


-------------------------------------

I agree on this. Please don't turn Bitcoin project/homepage into some
political agitation. Not everybody care about political attitude of main
project developers.

slush

On Tue, Jan 17, 2012 at 1:46 AM, Alan Reiner <etotheipi@gmail.com> wrote:

-------------------------------------

Exactly!


Nope - its almost like calling the version:0+5 possible collision with new evil, say "ponzicoin" with version=5 a possible flaw that could be exploited... And you can already create non-existing addresses with a matching checksum...


I will rest my case, not due to the "flaw", but I got some info on the bitfields of the "version" (thanks Luke!) - this makes the +5 less arbitrary, however, I don't think the bitfield interpretation is that well known, so there might already be "version"-collisions...:

Network class:
00xxxxxx - main network
01xxxxxx - reserved
10xxxxxx - reserved
11xxxxxx - test network

Network:
xx00xxxx - bitcoin
xx01xxxx - reserved
xx10xxxx - OTHER (next octet)
xx11xxxx - Namecoin

Network specific:
xxxx000y - PubKeyHash
xxxx001y - reserved
xxxx010y - p2sh
xxxx011y - public key (raw)
xxxx100y - signature
xxxx101y - reserved
xxxx110y - private key (raw)
xxxx111y - OTHER (next octet)

y = 0/1 depending on aesthetics (I guess to force the address to be either 1 or 3). 

This also opens up for extensions - (if xx10xxxx or xxxx111x) the next byte will be part of the version.

/M





-------------------------------------
First and foremost, I consider this thread an utter waste of time. These 
matters were "finished" over a year ago, and there is no need to dig them up 
again just because there are numbers for BIPs now. I don't intend to continue 
this topic any further than necessary, since my time (and everyone else's) is 
better spent working on *actual forward progress*, not this attempt to rewrite 
history. That being said...

On Sunday, January 29, 2012 5:40:14 PM Amir Taaki wrote:

Before the BIP process was formalized. The process itself existed long before.


It did. In early 2011, there was a consensus and multiple implementations (by 
name, I know of at least Spesmilo and WalletBuddy). This is by definition the 
Final status. It was not until months later that anyone objected to the 
standard.


You are contradicting the assignment of BIP 0020 to a preexisting standard 
here.


By trying to demote BIP 0020 from Final to Draft, you are not following the 
specification in BIP 0001.


Rather, I am claiming that assigning a number does not give you the authority 
to demote a preexisting standard. No other standards organization has 
attempted to claim preexisting standards don't exist or change their status.


Anyone is welcome to submit a new BIP aimed at Superceding BIP 20 (and doing 
so might make good sense soon, with various new functionality), but until that 
occurs, BIP 20 remains the Final status it has been for a whole year now.


-------------------------------------
Hey,

https://github.com/bitcoin/bitcoin.org/pull/46

I tried to keep it professional, and non spammy.



-------------------------------------
Check it :) https://github.com/bitcoin/bitcoin.org/pull/34


-------------------------------------
Version 0.6 release candidate 3 binaries are available at:
  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/

The big reason to run rc3 is to get the BIP30 security fix that takes
effect on March 15.

It also includes a fix to the problem of running rc1, upgrading, and
being stuck on the wrong block-chain fork

-- 
--
Gavin Andresen


-------------------------------------
Reposting from my tech blog:
  http://gavintech.blogspot.com/2012/03/full-disclosure-bitcoin-qt-on-windows.html

----------------

A major bug in Bitcoin-Qt on Windows went unnoticed for over four
months. The bug was in the bitcoin-qt.pro file, in these two lines of
code:
  windows:LIBS += -lws2_32 -lshlwapi
  windows:DEFINES += WIN32
See the bug?

I don't-- I can't see it, because the problem was Bitcoin-Qt on
Windows should have been linked with the "mingw" multithreading
library and compiled with the -D_MT to turn on support for
multithread-safe C++ exception handling in the "mingw" library (you
can see the 3-line fix here).

There might be developers reading this who have had experience writing
multithreaded mingw-based C++ applications who will say "Duh! You guys
are idiots, everybody knows that!"

If that's you and you're interested in Bitcoin:  we need people like
you to help out! Review the code, review the build process, let us
know when we're being idiots. There seem to be a lot fewer Windows
developers willing to help out with Bitcoin than Linux or Mac
developers, which is unfortunate since a majority of our downloads are
Windows users.


Non-mingw-C++-multithreaded developers are reading this and thinking
"the bug was THERE?  Not in some #ifdef WINDOWS C++ code or some
slightly-out-of-date library that you were linking against?"


The other reason this bug went unnoticed for so long is because it
almost never matters. Bitcoin-Qt doesn't throw a lot of exceptions
normally, and most of the time the single-threaded-application
exception support in mingw works just fine. I'm still not sure exactly
what triggers the bug-- probably something like two threads throwing
exceptions at the same time, or one thread being interrupted while in
a try{} block and then resuming later and crashing because the
exception handling code is in a different state.

Matt Corallo deserves a lot of credit for being persistent and finding
the bug when investigating hard-to-reproduce reports of Bitcoin-Qt
crashing sometimes when run with the -server flag and handling
JSON-RPC requests. He was never able to get the code to crash when
running outside of the debugger, which is typical of bugs related to
multithreading. But he did see crashes not involving RPC requests, and
that is why we consider this a critical issue and are telling
everybody affected to upgrade immediately.

It it exploitable? Could an attacker craft bitcoin protocol messages
that triggered the bug and compromised Windows computers? Has it
already been exploited?

We don't know. We think it would be extremely difficult to craft a
usable exploit, partly because it is hard to even trigger the bug
reliably but also because Bitcoin-Qt has some security-in-depth to try
to prevent this type of bug from becoming exploitable.

If we're very careful and extremely lucky, this will be the last time
we have to tell users to shutdown and upgrade immediately because of
some potential vulnerability. But there is no such thing as perfect
security, and I expect that there will be another subtle bug either in
Bitcoin or in one of the many libraries we link against that becomes a
potential security issue.

That doesn't mean we give up and go back to paying each other with
cowrie shells; it means we assume that devices get compromised and
design around that assumption. I think that is a lesson that the
entire software industry needs to learn better.


-- 
--
Gavin Andresen


-------------------------------------
Hi Steve,

I see dramatic differences in performance on virtual machines vs running directly on the iron. I am not an expert in virtual machines, but it seems to me that they are weak when it comes to disk i/o. And berkeley DB, as used by bitcoin is a sucker for disk i/o. In top I easily hit >1/#processors in top wa, meaning that the cpu doing the blockchain download is just waiting for the disk all the time.

I would like to do a test keeping database log files in memory. It should not matter for durability of the wallet, as it flushes at each write anyway. As for the blockindex, it will remain consistent, but might be lagging some blocks behind at startup, which shouldn't really matter (except that the same block could end up appearing twice in the block00X files, inelegant, but not really a problem).

Otherwise the system you describe (raid0 over 6 disks) should perform like crazy wrt disk i/o, at least on par with SSD. It is your virtualization I am worried about.

Have a safe trip to down under!

/M

On 24/07/2012, at 21:56, steve wrote:




-------------------------------------
On Mon, Jul 9, 2012 at 10:00 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

Er, to be clear, I left the android software in because the source is
available (And I'm told its had some review).

I removed the proprietary software section the plug for the
blockchain.info webservices, and the demotion of the armory client.

As far as criteria goes, I don't think we should list anything with a
security model weaker than SPV unless users can practically operate
their own servers. …and even that I'm a little uneasy with, because
most people will use the defaults. Ideally even thin clients would
have a near SPV security model, just without the bandwidth. But since
the alternative for thin clients is centralized web services the lower
standard will probably have better net results for now.

Nor do I think we should list anything which can't currently be
subjected to independent review of the whole stack (e.g. including the
server components in thinclients, unless the server is untrusted). In
the future this should be raised to there existing actual evidence of
third party review.


-------------------------------------
I would like to propose two things that are closely related.  I will 
start making BIPS if there's positive feedback.  Sorry it's so long, but 
I felt both should be in the same email...


_*(1) Signature Blocks*  -- A more-robust, versatile, message-signing 
exchange_

Satoshi client 0.6.0 introduced message signing, but I've been fairly 
unimpressed with the implementation.  Strictly speaking, it works, but 
it's really not intended for "regular users."  There is no indication of 
what message was signed or what address signed it.  Key recovery works 
for the computers processing it, but the user has no idea what this 
chunk of random data is.  They don't even know if the message they 
thought they signed is what's in the signature (along the lines of the 
copy&paste virus, the message could be switched out without the user 
noticing).

I have implemented Signature Blocks 
<https://bitcointalk.org/index.php?topic=56424.msg776163#msg776163> in 
Armory (as of v0.55), which is a fully-functional expansion on the 
idea.  Along the lines of BIP 10, a signature block is a human-readable 
chunk of data that immediately identifies the address and the message 
that are being signed.  It is easily copy&pasted via email or text 
files, and is fairly compact for visual identification.   Click the link 
above to see an example signature block and an Armory screenshot of the 
UI (which needs improvement, but still usable).  The verification 
process will include:

-- Check that the public key (included or recovered) matches the address 
field.
-- Verify that the signature matches the included message for this 
public key
-- The message is properly formatted with a standardized character set 
and escape/replacement scheme for things like newlines or double-quotes.

gmaxwell already pointed out that key recovery makes the "Public Key" 
field pointless.  Okay fine -- I just don't have key recovery 
implemented yet in Armory, and when I do I can ditch that field (or 
simply make it optional).  The point is to create a versatile, 
human-readable standardized form, much like the BIP 0010 
signature-collection scheme <https://en.bitcoin.it/wiki/BIP_0010>.


_*(2) Sign-Message URI scheme***-- Request signed messages from users 
using URIs_

I had the idea that for certain services, the first funding address 
could be used to identify the owner of an account, and all account 
maintenance (such as cashouts) be done through signed messages with this 
address.  For instance, the user would need both a login password *and* 
a signed message in order to make a withdrawal or purchase:

     ("Please withdraw 12.3 BTC from acct 1828349132 to address 
1Hfr3jk2093f")_signed_by_A

This gives the service the ability to use two separate factors to 
authenticate the request (username&password *and* access to unencrypted 
wallet).  This /could/ work with manual signature blocks alone... but 
it's too many steps for regular users.  However, I think it's workable 
if we expand bitcoin URIs to include "Signature Requests".

The URI scheme would add a few parameters to the scheme, and would have 
to have further replacement rules to make sure that messages are handled 
properly.   The general CONOPs would be (*Con*cept of *Op*eration*s*):

     -- User navigates to "Withdraw funds" on webpage
     -- Webpage has you fill in the details:  from-account, to-address, 
withdrawal amount
     -- Webpage produces a clickable URI link that loads all the 
information into your client, including addr-reqd-for-sig
     -- Client asks for confirmation and passphrase (if necessary) then 
produces a signature (and sig block if necessary)
     -- URI may include reply-to field that tells it where to send the 
siganture when it's ready

So the extra tags that would be needed would probably be:

         "*requestSig*=True":
                 Flag to identify that this is a signing request URI
         "*sigNeeded*=1Qjf3392k31h"
                 The address that needs to sign the message
         
"*message*=Please%20withdraw%2012.3%20BTC%20to%20addr%201Hfr3jk2093f"
                 Some encoding of the message that can be parsed the 
same way on all systems
         "*replyurl*=http://requestor.com/sig_replies.asp?"
                 (Optional) After signing, application will submit the 
signature to the replyurl

The reply url could be simply an http URL which will use bitcoin URI 
syntax, with the fields above copied.  Therefore, to complete the above 
request, the application handling the request will simply send an HTTP 
request to:

     
http://requestor.com/sig_replies.asp?*sigNeeded*=1Qjf3392k31h&*message*=...&*signature*=1fb1893ac193...&*replySig*=True

Any thoughts?  (I have no doubts that there are :) )

-Alan





-------------------------------------
My only comment is that it should be called escheatment, not demurrage ;)

It's relation to demurrage is only that it might be desirable to garbage
collect decayed bit-dust. We looked at it early-on in the Freicoin
development, but rejected it as a possibility due to reasons others have
mentioned, even though we were starting from a hard-fork position.


On Mon, Dec 3, 2012 at 3:19 AM, Michael Gronager <gronager@ceptacle.com>wrote:

-------------------------------------
I've been working on a patch to make transaction inputs (scriptSigs) with
extra data non-standard, as part of a general attitude of "try to
anticipate possible problems before they turn into real problems."

Today, any node on the network that is relaying unconfirmed transactions
can add bytes to the transaction's scriptSig's before passing it on, and
that modified version of the transaction will get relayed and might
possibly get mined.

For example, take a standard scriptSig that is:   OP_PUSHDATA <signature>
OP_PUSHDATA <public key>
... and change it to:   OP_PUSHDATA <Hi Mom!> OP_PUSHDATA <signature>
OP_PUSHDATA <public key>
... and the modified transaction will pass all of the IsStandard(),
IsValid(), and OP_CHECKSIG checks.

That is... unexpected, especially since it changes the transaction id.  You
might transmit a transaction with ID 123 but find out it has been mined as
transaction ID 456.  Satoshi's code doesn't care (it just looks like an
attempted double-spend of the coins), but I wouldn't be surprised if it
caused problems for other implementations or other transaction-handling
software.

My patch will make transactions with extra stuff in the scriptSig
non-standard, so they won't get relayed or mined by new nodes. Alternative
implementations will still have to deal with all types of double-spends, of
course, and there are other ways of producing two transactions that are
identical except for their scriptSigs  (you can generate an arbitrary
number of valid signatures for a transaction if you have the private keys,
for example) so this isn't a panacea for poorly-implemented bitcoin
transaction handling software. But it does remove some "wiggle room," which
is generally a good idea for improving security.


I'm still thinking about how much further to go with this:

+ I think requiring that the <signature> and <public key> be DER-encoded
for the transaction to be IsStandard() is a good idea.  DER encoding
defines a canonical way of representing data; Satoshi's code relies on
OpenSSL to decode signatures and public keys, and OpenSSL accepts any, more
general, BER encoding.

+ I'm tempted to require that the "filler item" to workaround the
OP_CHECKMULTISIG pops-one-too-many-items-off-the-stack bug be exactly OP_0.

Discussion welcome; I should be making a pull request for my patch this
afternoon.

--
Gavin Andresen
-------------------------------------
On Thu, Apr 12, 2012 at 7:24 PM, Amir Taaki <zgenjix@yahoo.com> wrote:



No, it is more about distinguishing between replies (multiple asynchroneous
request) and spontaneous notifications of the other peer.
Every state would still be tracked locally on the client side.

I don't understand why you say my proposal would make the protocol more
stateful. I think it doesn't.
Each reply is only  the result of the current request only, and there is no
new session information.
As you see in my implementation, there is not even a new variable.
Request/reply id is a very robust pattern that is compatible with stateless
protocols.

Indead, this change doesn't directly improve on peer that don't answer
requests: it only enables to do so easily in a secondary step. This step
can only be done when all peers on the network are running the modified
code.
-------------------------------------

Sounds good to me. I think it's important to give people a chance to fix
their software, but Pieter's proposal does that.

On 10/21/2012 7:05 PM, Gavin Andresen wrote:



-------------------------------------
On Mon, Jul 9, 2012 at 10:44 PM, Alan Reiner <etotheipi@gmail.com> wrote:

I'm generally not a fan of feature matrixes, they encourage "checkbox
decision making"— which is seldom very good for the decider, though
it's much loved by the marketing department that puts together the
matrix.  But just becase something is loved by marketing departments
for its ability to set the agenda in variously biased ways doesn't
mean its a great thing to emulate.

Take the matrix Luke linked to for example[1].  Now imagine that we
tunnel MyBitcoin from a year ago and drop it into that table.  It
would have every light green, except 'encryption' (which wouldn't have
been green for bitcoin-qt then either). It would basically be the
dominant option by the matrix comparison, and this is without any
lobbying to get MyBitcoin specific features (like their shopping chart
interface) added, not to mention the "_vanishes with everyone's
money_" feature.

I don't think I'm being unreasonable to say that if you could drop in
something that retrospectively cost people a lot into your decision
matrix and it comes out on top you're doing something wrong.

In tables like this significant differences like "a remote hacker can
rob you" get reduced to equal comparison with "chrome spoiler",  and
it further biases development motivations towards features that make
nice bullets (even if they're seldom used) vs important infrastructure
which may invisibly improve usage every day or keeps the network
secure and worth having.  "Of course I want the fastest startup! Why
would I choose anything else?" "What do you mean all my bitcoin is
gone because the four remaining full nodes were taken over and reorged
it all?"

I wouldn't expect any really important features which don't have
complicated compromises attached to them to be omitted from all
clients for all that long.

Basically matrixes make bad decision making fast, and by making it
fast it's more attractive than careful decision making that always
takes time.  The text is nice because it contextualizes the complete
feature set and helps you understand why different clients exist, what
problems they attempt to solve, and what compromises they make. ...
without making the unrealistic demand of the user they they know how
to fairly weigh the value of technical and sometimes subtle issues.


[1] https://en.bitcoin.it/wiki/Clients


-------------------------------------
Yeah, for actually storing transactions the approach Satoshi uses of
relying on a database engine makes sense and is what the code already does,
so I'm not sure why this is a problem.

The real problem with Satoshis code for scaling down to smaller devices
(and one day desktops too) is the need to store all the chain headers in
RAM. BitcoinJ avoids this but just creates more problems for itself in
other places, partly because we also try to avoid a database engine
(read/write traffic on phones can be insanely expensive, especially on
older ones, and so sqlite is known to be a serious cause of performance
pain on android apps).
-------------------------------------
On Thursday, May 24, 2012 4:33:12 PM Jeff Garzik wrote:

FWIW, based on statistics for Eligius's past 100 blocks, it seems 10% (1 in 
10) of 1-txn blocks is not actually unreasonable. This also means these 1-txn 
mined blocks are not necessarily harming Bitcoin intentionally. Anyone care to 
figure out the math for how fast miners need to finish processing transactions 
to reduce the number of 1txn blocks?


-------------------------------------
On 9/22/12, Mike Hearn <mike@plan99.net> wrote:

I see. By "input scripts" I thought you meant scriptPubKey rather than
scriptSigs. We only need to sign scriptPubKey. Right, Jeff?


Great, there's no need for an additional SIGHASH.
I guess you're implementing the simple case you describe first.
Do you plan to implement the more general case with n participants
instead of only 2 (a Ripple transaction)?
That would be awesome.

-- 
Jorge Timn



On 9/22/12, Jeff Garzik <jgarzik@exmulti.com> wrote:


-- 
Jorge Timn


-------------------------------------
On 06/19/2012 01:59 PM, Gregory Maxwell wrote:

The point is not that they get it *wrong*, it's that the implement it 
*differently*.  Given a set of 100 TxOuts, there's a seemingly-infinite 
number of ways to construct a binary tree.  Put them in in a different 
order, and you get a different tree. *They're all correct and legal* in 
terms of satisfying expectations of insert, delete and query runtime -- 
but they will produce different root hashes.   And the differences in 
underlying structure are completely transparent to the calling code.

I'm extremely uncomfortable with the idea the you can have all the nodes 
in the tree, but have to replay X years of blockchain history just to 
get the same tree configuration as someone else.  However, a trie 
configuration is history-independent -- given an unspent-TxOut list, 
there's only one way to construct that tree.  That's an important 
property to me.

I can't tell if you're joking about Judy structures: I've never heard of 
them.  But I'll look into it anyway...

-------------------------------------

Which is why I find the "SignedReceipt" somewhat superfluous. If you implement a payment system, like bit-pay/wallet you are likely to double that through some sort of e-mail receipt anyway.

Further, the inclusion of x509 is not really needed in the spec - you don't need to sign the invoice with an x509, you can use the payment key. The proof would still be equally binding, and valid also for non holders of x509 (server) certificates (like normal people).
Finally, host certificates does not normally keep in their "purpose" S/MIME Signing. So you are bending the intended use of the x509 certificate anyway.

/M




-------------------------------------
This is not just "a political issue". The internet as we know it is at
stake, and bitcoin depends directly on a working, single, globally
connected internet (at least for now, until mesh networking goes
anywhere...).

*Everyone* using bitcoin has the interest in keeping the internet working
and un-balkanized. That's not a political opinion, it's a fact.

The laws could also criminalize both the users and developers, if they
regard bitcoin as a "payment network". And countries aren't too fussy about
extradition to the US (see the case of Richard O'Dwyer).

Though I agree that SOPA and PIPA are just manifestations of a brand of
censorship that is spreading all over the world. Stopping these laws won't
solve the underlying issue either. Other countries will keep pushing for
them, and we can't blank out the page for every country.

However, that does not make the issue "political and thus meaningless".
Also: "being too small to matter" is never a good argument to not do
something. It is fear paralysis.

Wladimir

2012/1/17 Jorge Timón <timon.elviejo@gmail.com>

-------------------------------------
Just another question concerning BIP21:

On the wiki, the description of the "message" parameter reads:
"message that shown to the user after scanning the QR code"

I believe that the purpose of this parameter is to contain a description of the  transaction. This has use cases that go beyond QR codes.

If I am right, then I would say that naming it "message" is misleading. In fact, "message" suggests that a message will be sent to someone (the recipient of the funds? a third party?), which is not the case here. That parameter should probably be called "description". 

-- 
Empfehlen Sie GMX DSL Ihren Freunden und Bekannten und wir
belohnen Sie mit bis zu 50,- Euro! https://freundschaftswerbung.gmx.de


-------------------------------------
On Thursday, February 23, 2012 3:26:40 PM Gavin Andresen wrote:

Wouldn't that prevent the user from registering it?


-------------------------------------

Not at the rate suggested


Well, retransmitting 1BTC ones every 4 years isn't that bad. So I don't see a need for another fork for this reason.


Agree to this - and also to the fact that it will be hard to introduce - it would be changing the protocol quite a lot (perhaps too much).

A better set of relay fee rules rewarding a decrease in # UTXOs is probably the (easiest) way forward.

/M



-------------------------------------
On Mon, Dec 03, 2012 at 05:34:12PM -0500, Jeff Garzik wrote:

Funilly enough pretty much all low-level links that make up the
Internet use either bit-stuffing or byte-stuffing to escape a
particular bit sequence or byte that terminates an HDLC frame.

I'm not particularly agreeing or disagreeing with you on the
suitability for the case at hand, but as an absolute your statement
doesn't hold water.  The use of a terminator for a variable-length
data structure rather than a length prefix is a design desicion that
has little-to-nothing to do with the debate of text-versus-binary.

Anyone remember Holerith constants?

roy


-------------------------------------
On Thursday, February 02, 2012 8:46:05 AM Michael Grnager wrote:

I found the problem: you are trying to use static libraries. Best practices 
are to use shared libraries (except for specific scenarios like universal 
"Linux" binaries) and most distros do not have static libraries installed by 
default.

The coinQt stuff was also creating a problem.

I am able to build with this patch:
diff --git a/CMakeLists.txt b/CMakeLists.txt
index dea37c4..b876881 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -352,7 +352,7 @@ ENDIF(BDB_FOUND)
 #Note: We need as a minimum Boost 1.47 to support the signal_set used in 
Server. A backup signal_set has been created, though.
 SET(Boost_NO_BOOST_CMAKE ON)
 SET(Boost_ADDITIONAL_VERSIONS "1.47" "1.47.0" "1.48" "1.48.0")
-SET(Boost_USE_STATIC_LIBS        ON)
+#SET(Boost_USE_STATIC_LIBS        ON)
 SET(Boost_USE_MULTITHREADED      ON)
 SET(Boost_USE_STATIC_RUNTIME    OFF)
 
@@ -804,9 +804,9 @@ SET(PKGCONFIG_FILES
 #  libcoin-coinMine
 )
 
-IF(QT4_FOUND)
-  SET(PKGCONFIG_FILES ${PKGCONFIG_FILES} libcoin-coinQt)
-ENDIF(QT4_FOUND)
+#IF(QT4_FOUND)
+#  SET(PKGCONFIG_FILES ${PKGCONFIG_FILES} libcoin-coinQt)
+#ENDIF(QT4_FOUND)
 
 FOREACH(PKGCONFIG_FILE ${PKGCONFIG_FILES})
   CONFIGURE_FILE(${PROJECT_SOURCE_DIR}/packaging/pkgconfig/${PKGCONFIG_FILE}.pc.in
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 0011392..67044d1 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -19,9 +19,9 @@ FOREACH( mylibfolder
 
 ENDFOREACH()
 
-IF (QT4_FOUND AND NOT ANDROID)
-    ADD_SUBDIRECTORY(coinQt)
-ENDIF()
+#IF (QT4_FOUND AND NOT ANDROID)
+#    ADD_SUBDIRECTORY(coinQt)
+#ENDIF()
 
 IF(ANDROID)
     configure_file("${LIBCOIN_ANDROID_TEMPLATES}/Android.mk.src.in" 
"${CMAKE_CURRENT_BINARY_DIR}/Android.mk")


-------------------------------------
On 2012-01-02 14:41:10 -0800, Gregory Maxwell said:

Neat!  I had a similar idea but you've clearly beat me to [a big part of] it.



I'm not so sure about that.  If you accept X successor blocks as proof 
that none of the transactions in a block re-used an output, then the 
cost of attacking is X*50BTC since the hashpower needed for the attack 
could have earned that much reward.

However, an attacker could use the same faked X-block sequence to 
attack multiple clients by putting several double-spend transactions in 
the first faked block.  This would spread out the cost over more than 
one attack.  So simply checking that the value of the transaction is 
less than X*50 isn't necessarily enough, although the logistics of the 
attack aren't exactly easy.

There's also the question of knowing what the difficulty for those X 
blocks ought to be.  If the attacker controls your network connection 
(e.g. your ISP attacks you) you wouldn't be able to get a second 
opinion on how high the difficulty ought to be, and might get fooled by 
X very-low-difficulty blocks that were each produced with a lot less 
than 50BTC worth of hashpower.

  - e




-------------------------------------
RE: Roy Badami's comments on edge cases around submitting a Payment
message to a merchant and then not receiving a timely response:

I agree, it is messy.

I'm hesitant to try to specify One True Way of handling it in the
spec; I've got a feeling that this might be a place where different
implementations might try different things, with the best
implementation winning.

For example, if some future nifty-keen Bitcoin client is re-using an
old Invoice to send a monthly subscription payment and they can't
contact the paymentURI, then the right thing is probably for it to
retry once a day for three or four days and if they all fail then give
up and tell the user that the service is no longer in business (or
changed their paymentURI without leaving behind a redirect).

If it has a single-use Invoice created a minute or two ago, the right
logic might be:
  + If the paymentURI is completely non-responsive, just error and
tell the user "payment failed"
  + If connected to the paymentURI and payment sent, but disconnected
before receiving a response, then try to send-to-self the coins to
cancel payment.

Again, I'm not at all sure that is the best way to handle it;
implementors have the right incentives to give their users the best
user experience, so I feel comfortable leaving the spec fuzzy for now.

-- 
--
Gavin Andresen


-------------------------------------
Almost forgot...

Begin forwarded message:


-------------------------------------
On 4/12/12, Jeff Garzik <jgarzik@exmulti.com> wrote:

Why not just adding a field expiration_block = H2?
It seems more explicit and flexible than using a 144 * N constant.
You're changing the protocol anyway, right?

Another question, aren't different peers going to get different H1 for
the same tx?


-------------------------------------
AWESOME!! Thank you!!

Anyway, I found a new problem... lol

/usr/local/bin/bitcoind getinfo #okay
{
    "version" : 40001,
    "blocks" : 168753,
    "connections" : 8,
    "difficulty" : 1376302.26788638,
    "testnet" : false
}

/usr/local/bin/bitcoind getaccountaddress ""  # okay...
1J4vNcvEdeCuLH4yvyoC2gxFEF4zquoJ87

/usr/local/bin/bitcoind listaccounts # NOT okay...
{
}

/usr/local/bin/bitcoind getaccountaddress "teste" # okay
1E6pGh6AAtuJdFXheZMp1zdYmvdqAQn9QT

/usr/local/bin/bitcoind listaccounts # NOT okay...
{
    "teste" : 0.00000000
}

Where is my default account listed at "listaccounts" output?!

Best,
Thiago

2012/2/26 Michael Grønager <gronager@ceptacle.com>

-------------------------------------
On Tuesday, June 05, 2012 12:00:25 AM Mike Koss wrote:

For example (just a draft; in reality, merged mining would probably be
             integrated in a hardfork)
 4 bytes: Block version number = 2
31 bytes: Hash of the block 2 back, except for the minimum last 8 bits of zero
 1 byte : Share difficulty (measured in "zero" bits)
 4 bytes: Timestamp
 4 bytes: "Bits" (current target in compact format)
 4 bytes: Nonce


The final <share difficulty> bits (minimum 32) of the block header are zero.


The hash of this block header, concatenated with a valid share candidate for 
the next block header, must hash to a value less than the current target 
offset against the share difficulty (this algorithm may need adjustment).


The first share becomes a block only after a second share is found that 
combined hashes to meet the real difficulty. That second share becomes a block 
when a third is found. Etc.


-------------------------------------
No objections.

On Sun, Oct 21, 2012 at 7:05 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:


-------------------------------------
I think it's perfectly reasonable to debate ordering.  I personally don't
think Armory should be up front, because it's not intended for beginners.
 How's that for honesty?  I don't think anyone is trying to game the system
right now, I think we're trying to come up with a reasonable mechanism for
appealing to new users and get the community more connected.   And make
sure everyone understands the system.

On the other hand, perhaps it's better to take the acceptable 80% solution,
and revise it over time...

Amir, I don't have access to the page.  I've never been able to view it.
 Changing my hosts file doesn't seem to do anything.  Can you just forward
me the text?  I'll send you an approval email.




On Wed, May 2, 2012 at 3:43 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
I have finally got around to revising the BIP 22 draft, and would appreciate 
further review: https://en.bitcoin.it/wiki/BIP_0022

I believe this revision addresses Geir's last email in March, as well as some 
practical problems some pools recently came across.

To summarize the changes from the last revision in March:
- The submitblock(<data>, <params>) method is renamed to getmemorypool
- Requesting a job now uses getmemorypool(<params>) to provide client
  capabilities and other information to the server
- Longpolls use a parameter in the getmemorypool request, not necessarily a
  separate URI
- The client can inform the server of its own size and sigop requirements in
  advance
- The client can request detailed transaction data from the server, necessary
  to sanely manipulate the transactions included in the final block without
  discarding fees or making the block invalid due to not having enough
- With both client and server support, blocks can be proposed before wasting
  time mining them, to ensure they are otherwise valid
- Servers can be arranged into single logical services, with failover and load
  balancing (similar to the getwork X-Host-List and X-Switch-To extensions).

You can see the full diff here:
https://en.bitcoin.it/w/?title=BIP_0022&action=historysubmit&diff=26408&oldid=25544

Luke


-------------------------------------
On Mon, Jun 11, 2012 at 4:36 PM, Mike Hearn <mike@plan99.net> wrote:

HAHAHA.   Have you consider doing comedy full time?

Actual BDB files are absolutely not deterministic. Nor is the raw
blockchain itself currently, because blocks aren't always added in the
same order (plus they get orphans in them)

But the serious inter-version compatibility problems as well as poor
space efficiency make BDB a poor candidate for read only pruned
indexes.


The binaries distributed by bitcoin.org are all already compiled
deterministically and validated by multiple independent parties.  In
the future there will be a downloader tool (e.g. for updates) which
will automatically check for N approvals before accepting an update,
even for technically unsophisticated users.

This will produce a full chain of custody which tracks the actual
binaries people fetch to specific source code which can be audited, so
substitution attacks will at least in theory always be detectable. Of
course, you're left with Ken Thompson's compiler attack but even that
can be substantially closed.


-------------------------------------
For some reason sourceforge is not sending me updates anymore but I can see the replies online

There could be a slightly more simple protocol which gives all the transactions hashes and nodes can then download the transactions separately. However there are two problems:

1. Downloading all the transactions individually might be inefficient. My proposal will allow nodes to request multiple transactions at once.
2. Why not add a few additional components to the protocol to allow requests for any level of the merkle tree? It's not very complicated at all and protects against the future.

Sure, analysis needs to be done to see at what point the proposal would give benefit and I will hopefully get around to doing some measurements of peer behaviour to aid with this.

I think it's a good idea to think ahead rather than only do what is beneficial for the network currently. The block sizes at the moment are about 0.1MB but what if the bitcoin demand starts pushing that into megabytes? And yes the ~0.95MB limit needs to be changed in order for bitcoin to grow that far. Why would the limit not be lifted? How will bitcoin demand be satisfied other than having large fees to deter transactions, hoping the fees are large enough to balance the demand with the block size limits to prevent many transactions being unconfirmed and annoying users? That limit has got to go eventually. And then it could be that block sizes do become large enough to worry about the performance in relaying.

Best not to leave this to the last minute, so at the very least I think it's good to talk about this.

-------------------------------------
On Sunday, July 29, 2012 10:17:51 AM Mike Hearn wrote:

Considering that Gavin is not interested in participating in any way in the 
stable versions, I would prefer to see someone else responsible for OS-vendor 
signing.



-------------------------------------
It appears that something about Boost doesn't play nicely with the default
build instructions (possibly the switch to clang++?).

I will dig in eventually but for now, if anyone has a recipe that fixes
things, let me know.
-------------------------------------
On Thu, Nov 29, 2012 at 06:31:24PM +0100, Mike Hearn wrote:

[snip]

All good reasons, thanks for the explanation.

Though I still like my idea of a ValidatePurchase message that allows
a buyer to ask a merchant "would you accept this payment?" without
actually supplying a signed transaction.  Make it optional if you care
about minimising the number of round trips, e.g. for fast NFC
payments.

Having such a message reduces the extent to which you need to trust
the merchant not to spend a transaction that they've rejected.  (And
in the non-Internet connected case this is particularly useful since
the client won't have the ability to broadcast a pay-to-self
transaction.)

roy




-------------------------------------
On Mon, Jan 2, 2012 at 5:23 PM, Elden Tyrell <tyrell.elden@gmail.com> wrote:


Er, no—  if a node controls the private keys for a transaction, and
that transaction makes it into the chain then it can safely assume
that its unspent (at least once its buried a few blocks into the
chain).  This is the essence of a SPV node.

What it can't do is perform this function for txn which aren't its
own. Though the system could be extended in a compatible manner to
make this possible: https://bitcointalk.org/index.php?topic=21995.0


-------------------------------------
I like this idea, although I would say the blockchain should go in
/var/lib/bitcoin by default, right? I'm just a longtime LInux guy, not a
formal sysadmin, though.

Peter

On Fri, Sep 14, 2012 at 11:15 AM, grarpamp <grarpamp@gmail.com> wrote:




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
When bitcoind exits cleanly, it does not seem safe for the blockchain
to clean up the following hierarchy with rm -r ?

database/
db.log
.lock
debug.log
addr.dat
wallet.dat

And what about adding to the above list the following files when
bitcoind crashes:

__db.*

Is there an option to make bitcoind roll/flush the above files on
exit so they can be removed/ported?

No matter the answers, bitcoind should not be dumping core.


Bitcoin version v0.6.2.2-unk-beta ()
Default data directory /.../.bitcoin
Loading addresses...
dbenv.open LogDir=/.../.bitcoin/database ErrorFile=/.../.bitcoin/db.log

************************
EXCEPTION: 11DbException
Db::open: Invalid argument
bitcoin in AppInit()
terminate called after throwing an instance of 'DbException'
  what():  Db::open: Invalid argument
sh: abort (core dumped)

file unknown has LSN 38/7968116, past end of log at 1/28
Commonly caused by moving a database from one database environment
to another without clearing the database LSNs, or by removing all of
the log files from a database environment
__db_meta_setup: /.../.bitcoin/addr.dat: unexpected file type or format


[New Thread 28801140 (LWP 100964/initial thread)]
(gdb) bt
#0  0x2873e9a7 in kill () from /lib/libc.so.7
#1  0x2852d397 in raise () from /lib/libthr.so.3
#2  0x2873d4da in abort () from /lib/libc.so.7
#3  0x285a0880 in __gnu_cxx::__verbose_terminate_handler () from
/usr/lib/libstdc++.so.6
#4  0x285a508a in std::set_unexpected () from /usr/lib/libstdc++.so.6
#5  0x285a50d2 in std::terminate () from /usr/lib/libstdc++.so.6
#6  0x285a4f58 in __cxa_rethrow () from /usr/lib/libstdc++.so.6
#7  0x0816d2ea in PrintException (pex=0x288251b0, pszThread=0x82f4cfa
"AppInit()") at util.cpp:792
#8  0x08087625 in AppInit (argc=2, argv=0xbfbfedf0) at init.cpp:113
#9  0x0808766d in main (argc=Cannot access memory at address 0x3) at init.cpp:96


-------------------------------------
Yet more comments (I guess at some point we need to stick a fork in it
- or at least move on to implementing a prototype version).

Maybe don't require the payment URI to be HTTPS. If you want to pay a
Tor hidden service then HTTPS just adds unnecessary complexity. Just
recommend to merchants that they use an encrypted connection and leave
it at that.

Though it's not strictly necessary, it'd be nice to have defined
behavior for if you want to pay more than the requested amount, for a
tip. Perhaps rather than "zero value outputs will be ignored" say, "if
some outputs have value and others don't, the user will be given the
option of overpaying and the extra money will be split evenly between
the zero valued outputs". That way a waitress can have the phone add a
zero-valued output to her own wallet and that would prompt the wallet
software to display some convenient UI for adding on 10% or whatever.

receiptURI -> receipt_url ? technically it has to be resolvable so
"uri" isn't quite right.

"Display the proposed Outputs in as human-friendly a form as possible"
.... ??? Surely you'd just display the total amount requested? I don't
think it ever makes sense to try and display outputs to the user
directly.

Re: the UI TODO - agreed but let's take it out of the BIP and maybe
make it an alternative document. Or just replace it with a
recommendation that "the user interface should be designed to ensure
users understand the difference between an unsigned and signed payment
request, for best practices see <here>"

serialized_paymentrequest -> serialized_payment_request? Otherwise
languages that use CamelCase will look odd ....
setSerializedPaymentrequest()

The question of root CAs still needs resolution. I stick with my
recommendation to support all CAs that browsers support. Obviously,
it's better for a merchant to obtain an EV cert than a domain
verification cert - the UI can reflect the higher level of
verification.

I doubt there's a need to specify a max number of certs in a chain.
But if you want to, go for something high, like 256. There's no point
in trying to put DoS mitigations into something like this, for the
same reason HTML doesn't impose a maximum page size. It's in the
message builders interest to ensure it gets read by all users.
Crashing their clients doesn't achieve anything as long as the crash
isn't exploitable.




On Fri, Dec 7, 2012 at 11:45 AM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
On Tue, Jan 31, 2012 at 12:17 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

I think I've explained myself poorly.  On my nodes, the old address
database routinely has 120k addresses.  With the new address manager,
it will have 20k addresses.  Filling the former with 60% evil nodes
requires 72,000 evil nodes; while the latter requires 12,000.

As I mentioned in my first post, I think the new address manager "is a
valuable improvement over what we have today".  I think it should be
included in the next release.

I also think we should be aware that we're making it somewhat easier
to isolate outbound-only nodes.  A single listening node can support
15 non-listening nodes (125/8).  The network currently has 5
non-listening nodes for every listening node.  That ratio has stayed
quite stable, so I think we have wiggle room if we wanted to allow
more outbound connections in some circumstances.

-- 
Michael


-------------------------------------
On 2012-01-23 20:00:59 -0600, Alberto Torres said:

Thanks for writing this up (it's high time somebody did).  I like your 
acronym, but shouldn't it be "MTUO" since you spend *outputs* rather 
than *transactions*?  A transaction can have multiple outputs, some of 
which are spent and others which aren't.

I've added a link to your proposal on the 
https://en.bitcoin.it/wiki/Thin_Client_Security wiki page.


Just like OP_EVAL/p2sh, this creates the (small) risk of a blockchain split.

Unlike adding a new transaction type, here it's possible to eliminate 
this risk: give each MTUT an additional "prev" pointer (hash of some 
prior block) which points to the latest prior block with a correct 
MTUT.  This produces a "chain within the chain" of blocks that have 
valid MTUTs.  Hostile miners are free to add bogus-MTUT-blocks; those 
bogus blocks will simply never be included in the "inner chain", just 
like invalid blocks mined by hostile miners are never included in the 
blockchain.  By downloading the last day's worth of blocks (which is 
not much data at all), a client can see which "inner chain" the 
majority of the hashpower believed during the last 24 hours.  This 
eliminates the need for a vote in any specific block -- in effect you 
get a "rolling election".

This "inner chain" approach can be broadened to a K-ary tree by 
including K-many prior-block pointers.  With one of these in every 
block (and sensible choices) you wind up with 
O(log_K(chain_length))-operation hash-secure access to arbitrary blocks 
in the middle of the chain.  This is an important building block for 
ultra-high-security thin clients.  Even if only a 1/K of the network's 
hashpower starts adding these pointers the worst-case number of 
operations needed to reach an arbitrary block will still converge 
(though much more slowly) towards this ideal.

  - e




-------------------------------------
On Monday, January 30, 2012 2:13:52 PM Gary Rowe wrote:

If the goal is to reduce complexity, strtol-compatible amount is the answer ;)


-------------------------------------
c-base is holding a day on p2p technologies on the 11th. From 20:00 will be the section on Bitcoin.

If you want to do a talk, then email me (genjix@riseup.net) and I’ll add you to the schedule.


-------------------------------------

Oh, hmm, well then, what is the difference or usage
between these two repositories in regards to the project?

Which one are the formal releases tagged (tbz's cut) in?

Which one has the branches with the commits that will
make it into the next formal release? ie: tracking along
0.5.x, 0.6.x, HEAD/master (to be branched for 0.7.x).

https://github.com/bitcoin/bitcoin
https://git.gitorious.org/bitcoin/bitcoind-stable

I seem to be seeing more tags in the former, and
more maintained branches in the latter?


-------------------------------------
Has anyone got long term longs that contain the pool size and timestamps?

Unfortunately I forgot to enable timestamps in the logs for my own
nodes (the privacy benefit of disabling this by default is
questionable, imho). But just looking at the general trends and
cross-checking against my own memory it definitely seems that there
are more and more pending transactions that don't get cleared into
blocks.

One of my nodes now routinely has 4000 transactions in the mempool.
Blocks typically clear only a few hundred at most, which is what you'd
expect given current transaction rates (around 300 per ten minute
interval). So what are the other pending transactions doing and why
aren't they getting drained out of the mempool?


-------------------------------------
On Sat, Sep 22, 2012 at 5:10 AM, Jorge Timn <timon.elviejo@gmail.com> wrote:

Yes, SIGHASH_ALL was the crucial piece I was missing.

I have updated the post to add a concrete example with as much detail
as necessary for programmers to recreate.  Review requested:
https://bitcointalk.org/index.php?topic=112007.msg1212356#msg1212356

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
If you are interested, I could push libcoin to bitcoin (e.g. bitcoin/libcoin) and then you could build bitcoind bitcoin-qt on libcoin.

libcoin solved most of the problems you list below. And if you worry about the copyright/license I am also willing to change that to make it fit.

libcoin have no global thread mutexes and and there is no blocking of the main thread due to rpc methods (except for a sendto), further, e.g. a reorganize only locks the main thread for a split second while the final commit is done. 

The libcoin rpc supports keep_alive and pipelining, runs in its own thread (but can also run in the same thread as the node) and uses async operation. Ipv6 is easy to implement in libcoin as the CAddress/Endpoint class is implemented as a subclass of boost::endpoint, only thing holding back is deciding on an ipv6 format on IRC, and, I then I would really like to reverse the order of the last 12 bytes in the address db (they are opposite to boost).

Cheers,

Michael

On 31/03/2012, at 12:54, Pieter Wuille wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
I've implemented an alternative to the BIP 32 proposal.  I wanted a system
based on a hierarchical string representation (rather than hierarchy of
integers as BIP 32 proposes).  For example I name keys like this:

[hd1.75491111].store.1. 1D7GM5dkUtxvGeWgn7SYtanBuyj1MD1EZy
[hd1.75491111].store.2. 1QAqDbzpNKViGSjVe1XmnGbmZtvz5hM7t1
[hd1.75491111].store.3. 14XkSN92QLGeorYPpoVbG87DQhowEx3mFn
[hd1.75491111].store.4. 1JLcGdod6Wm33rMZuZZUmAEE6osLhM4QMn

First draft of proposal:

https://gist.github.com/4211704


I envision using this in services, so I've not done any work to recommend
how the keys would be represented directly in the client (I just map from a
seed value and
a hierarchy string in order to deterministic ally derive ECDSA public and
private keys).

I'm happy to release my source code for this (Python).  But I'd first like
to get feedback about any security concerns with my scheme (I note that I
don't introduce the enlarged
key space that BIP 32 does with its "chain code" - I'm wondering if that
represents a weakness of my scheme vs. BIP 32).

On Mon, Dec 3, 2012 at 12:44 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:




-- 
Mike Koss
CTO, CoinLab
(425) 246-7701 (m)

A Bitcoin Primer <http://coinlab.com/a-bitcoin-primer.pdf> - What you need
to know about Bitcoins.
-------------------------------------
look at the first line of the if statement


// Check for conflicts with in-memory transactions
CTransaction* ptxOld = NULL;
for (unsigned int i = 0; i < tx.vin.size(); i++)
{
COutPoint outpoint = tx.vin[i].prevout;
if (mapNextTx.count(outpoint))
{
// Disable replacement feature for now
return false;

// Allow replacing with a newer version of the same transaction
if (i != 0)
return false;
ptxOld = mapNextTx[outpoint].ptx;
if (ptxOld->IsFinal())
return false;
if (!tx.IsNewerThan(*ptxOld))
return false;
for (unsigned int i = 0; i < tx.vin.size(); i++)
{
COutPoint outpoint = tx.vin[i].prevout;
if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)
return false;
}
break;
}
}


________________________________
From: Peter Vessenes <peter@coinlab.com>
To: Peter Todd <pete@petertodd.org> 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Thursday, April 26, 2012 6:11 PM
Subject: Re: [Bitcoin-development] Trusted identities


These are interesting thoughts, karma for bitcoins essentially.

I would like CoinLab to publish a 'cost of subverting 1-n transactions with 90% probability' metric soon, and I think it would help everyone to understand what that number is.

When we started out, you probably needed to wait 5 blocks for $10 or $20 of bitcoin value transfer.

Now, I'd happily accept a $1k transaction with 1 confirmation.

More difficulty shortens the safe time we can transact large volumes in, which is good for the network.

I'm not sure of the current implementation of replacement transactions, can anyone on the core team speak to this? Can I replace transactions, or is that part of the spec unimplemented or deprecated right now?

Peter



On Thu, Apr 26, 2012 at 8:49 AM, Peter Todd <pete@petertodd.org> wrote:

It recently occured to me that we can use the public nature of the block


-- 

Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ 

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Gavin,

Sorry for the delayed response, I wanted to take a couple of days to
reflect on your email.

On 26/09/2012 19:09, Gavin Andresen wrote:


And their are other methods too.



The GUI::Test package for perl will allow this to be greatly
automated. (I have done this before on the localisation of photoshop.)



this why we need detailed testscripts and plans.  so we know what has
and hasnt been done. The more boring the task the more work that needs
to go into testcase development.  This is the area I see as my
greatest failing last time.  I have a large number of virtual machines
and should have at least this work.  But we need very detailed
testcases.  with decent testplans just downloading the software,
syncing the block chain, syncing an existing wallet, rescanning the
blockchain and verifying the balance would cover a large number of
tests.  The idea behind having lots of very specific testcases is you
get to see what tests have not been run.



I understand your concern, however I have taken a couple of days to
reflect on this and I still strongly feel that in order to make sure
that this sticks, and is still useful in 1 years time we need to lay
proper foundations. Those foundations are not word documents,
spreadsheets, etc.  they are selecting the right tools for the job.

We can gain so much benefit from using 3rd party software.
(bettermeans would rock if it wasnt rotting)

I am sure you could do your coding work just using vi, but an sdk
makes it much easier and allows you to work in a more productive manner.

I have had a couple of off list emails with some testers and they also
feel that it is very important to make sure we have a sound foundation
(mantis is so much more than just a bug reporting tool, I see the bug
reporting functionality as secondary to the main test run
functionality - but it doesnt have to be mantis based, we do need
workflow and testcase software though - and proper software for this
is much better than just a massive google doc.) however I am checking
out some other software that has been recommended.  It will be very
hard to change 'the process' once we have something we are used too
(just look at the current resistance) I promise nothing will change
for the dev team.  But test does need other tools, and processes.

If you feel that strongly that I am going about this the wrong way, I
am happy to step back and let someone else sort it out (I will still
do all the testing I possibly can). I would feel that this would be a
real shame and we have the chance to setup requirements to
functionality to tests all with traceability. why not do it right from
the start?

I will open up my vps' somepoint over the next few days and you can
see what I mean. I will setup a fake git project, and sort out the
interactions.


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQZz1pAAoJEFvEB9dQFvtQRLkIAJtPCkW1R9vmMPY9u4o+ET1t
w4pV/+W2PXo2p86HnljCIPLV/cua/1I/EJp7XR7s145Nj4KZUbzHGhvUUmwDOHW2
TGvJs+HO1bjsJfh4pWEb6PXcW3TguZxZSt5/rBAAI/5BeomSuRcZOdoV87D1xnK8
TSlgaseWrJcpKLO30/FQA3QnH/bjJ4OBmtHp8WaOtSnfww9Zbb5VYca37O15c2U4
2d0RUunDg1w2kRbkKjztxr3YasSOX+07Uvj4d5Lw7zgA0U93krNWVT1Ypo94dNJ7
6SyKi30UuqDdJ9XxZrMB/LBVNGOLlIBNWL++ocu5GFnOn9pnw57ZMBZM5g6YDpo=
=ekQ/
-----END PGP SIGNATURE-----


-------------------------------------
Satoshi's paper mentions that storage requirements for the blockchain 
can be reduced by deleting transactions whose outputs have been spent.

If I understand correctly, this technique can only be used for reducing 
*storage* requirements, not *bandwidth* needed for the initial chain 
download by a high-security client that doesn't trust any of its peers 
-- right?

The rule is "trust the longest valid chain of blocks".  Part of a block 
being "valid" is that each transaction's inputs are unspent and their 
sum exceeds the transaction's outputs unless it is a coinbase.  This 
cannot be verified for "stubbed out" transactions -- they have outputs 
but no inputs, and aren't coinbases.  So a paranoid client booting up 
for the first time needs to be given an un-stubbed chain, right?

Of course, if a client decided to accept a stubbed blocks only when the 
sum of the difficulties in the blocks after it exceeds some number N, 
then attacking it could be made very expensive by picking a large 
enough N.

Please let me know if I have misunderstood something.




-------------------------------------
On Sat, Jun 16, 2012 at 4:42 AM, Wladimir <laanwj@gmail.com> wrote:

What is missing here is some perspective on the current situation.  It
is -very- easy to make a protocol change and bump PROTOCOL_VERSION in
the Satoshi client.

But for anyone maintaining a non-Satoshi codebase, the P2P protocol is
already filled with all sorts of magic numbers, arbitrarily versioned
binary data structures..  already an unfriendly zoo of complicated and
potentially buggy interactions.  There is scant, incomplete
documentation on the wiki -- the Satoshi source code is really the
only true reference.

I see these problems personally, trying to keep ArtForz' half-a-node
running on mainnet (distributed as 'blkmond' with pushpool).

In an era of HTTP and JSON, NFS and iSCSI, bitcoin's P2P protocol is
woefully backwards, fragile, limited and inflexible when it comes to
parameter/extension exchange and negotiation.  Even iSCSI, that which
is implemented on hard drive firmware, has the ability to exchange
key=value  parameters between local and remote sides of the RPC
connection.

Calling the current P2P protocol "simple" belies all the
implementation details you absolutely -must- get right, to run on
mainnet today.  Satoshi client devs almost never see the fragility and
complexity inherent in the current legacy codebase, built up over
time.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

Yeah, alternatives to X.509 chains don't interest me right now except
in the sense that they should be cleanly implementable with future
extensions.

So if you care about DANE or DNSSEC or custom PKI infrastructures or
whatever, rather than proposing them as replacements here (DOA), just
figure out how you would extend the protocol in Gavins mail in a
future extension. If you can't see a clean way to do it then let's
discuss that. If you can think of a way to do it then let's table it.
Better replacements can come in later BIPs.


-------------------------------------
I mentioned this on IRC a week or so ago, noticing that though they are
not executed and required to be well-formed, we still count any sigops
that appear in them (which I guessed may be an interesting attack if you
could get a miner to put a byte in there that is the equivalent of
OP_CHECKSIG because we dont count the sigops in the coinbase scriptSig
during mining, however luke pointed out that we always push the content
of coinbase scriptSigs properly by default, and those modifying the code
should spend time researching this stuff anyway, so if they break it,
its their fault (and now they can find this email)).

Matt

On Mon, 2012-07-23 at 02:07 -0400, Jeff Garzik wrote:




-------------------------------------
On Fri, Jul 6, 2012 at 9:49 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:



thoughts, I want to let it percolate. Thanks!




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
These discussed features are all useful but quite contradicting.

I imagine that a user will be able to switch between different coin 
selection policies "minimize fees","max privacy","defragmentation","i 
don't care" and even switch between them for individual sends.


-------------------------------------
On 28.02.2012 23:06, Luke-Jr wrote:

Looking forward to implementing this in my pool backend and miner.

A few comments:

"transactions 	add or remove transactions (both of the above; default if
"transactions" omitted) "

In the above, you may want to specify that the "transactions" referred
to here is the one in the first table (JSON-RPC response object) and not
the mutations. For a moment I thought free tx editing was the default.

Long polling as currently implemented in pools has a race condition.
Does the miner reconnect first or does another block change happen
first? "Double" block changes are common with merged mining and I'm
doing all sorts of tricks in my pool backend to reduce this problem.

How about another entry "longpollid" in long poll responses. The last
seen longpollid should be included by the client in future long poll
requests. This enables the server to see if the client has missed any
block changes. The ID could perhaps be submitted in an HTTP header
(X-LongPollID?) if we wish to keep the JSON-RPC params empty, or params
could hold an object with a key "longpollid". Could be a string or
number, like "workid".

Another useful value in the getmemorypool response would be "height", so
the miner can include the correct height in the coinbase. I would like
that in bitcoind as well. One JSON-RPC call instead of two, and no race
condition between getmemorypool and getblocknumber.

It should be explained how target vs. fulltarget works.

Perhaps some things should be optional for a client to implement? I
think "noncerange" is of limited use and there's a good chance of
getting the endianness wrong.

Regards,
Geir Harald Hansen


-------------------------------------
RE: BIP 21 versus BIP 20:  I like BIP 21; simpler is better.

RE: signing and dating URIs:  good ideas.  I think we should agree
that there is consensus around BIP 21 and then after there is some
experience with signing/dating URIs you should write follow-up BIPs .

-- 
--
Gavin Andresen


-------------------------------------
thanks for the great reply jeff. i'm going to get a virtual machine set up
on my system later tonight so at the very least, i myself can start testing.

steve - haven't heard from you in almost a week. I'd still really like to
get a look at the test cases and such you set up.

Arklan

----------
As long as there is light, the darkness holds no fear. And yet, even in the
deepest black, there is life. - Arklan Uth Oslin

I want to leave this world the same way I came into it: backwards and on
fire. - Arklan Uth Oslin



On Tue, Oct 9, 2012 at 5:12 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
On Mon, Jul 9, 2012 at 5:21 AM, Amir Taaki <zgenjix@yahoo.com> wrote:

I've reverted these additions to the page, nothing personal but—

At the moment I'm strongly opposed to including any non-reviewable
client options (including centrally operated web services) on the
page, and I think this need to be discussed along with establishing
requirements.


-------------------------------------
Op 1 feb. 2012 10:48 schreef "Andy Parkins" <andyparkins@gmail.com> het
volgende:
continue
rejected by

IsStandard() is for accepting transactions into the memory pool.
Non-standard transactions are verified just fine when they are in the block
chain.

BIP16/17 both create transactions that, when interpreted as old scripts,
are valid. The only change to the protocol is that previously-valid
transactions become invalid. As long as a supermajority of miners enforce
the new rules, everyone can happily keep using their old bitcoin client.
They won't create the new transaction type, and don't accept them as
payment, but they will accept the new block chain.

If we do a breaking change to the protocol - such as adding a new
transaction type - ALL users must upgrade. Those who don't will see a fork
of the chain from before the first new-style transaction. That is not the
case now.

-- 
Pieter
-------------------------------------

See: https://en.bitcoin.it/wiki/Technical_background_of_Bitcoin_addresses

And the attached graphics - here it is defined as network byte and network id.

Anyway - can probably live with some bit level subdivision into network id and address class.

/M

-------------------------------------
On 2012 January 28 Saturday, Michael Gronager wrote:


I'm throwing this out as an idea; not necessarily saying it's doable or even 
good.

There is spare capacity in the base58 encoding.

 - The address hash is 20 bytes
 - The checksum is 4 bytes
 - The address type is 1 byte
 
The longest and largest address is therefore 25 bytes of 0xff (it's not 
possible to all be 0xff of course).  Converting those 25 bytes of 0xff to 
base58...

 hex:    ffffffffffffffffffffffffffffffffffffffffffffffffff
 base58: 2mXR4oJkmBdJMxhBGQGb96gQ88xUzxLFyG

This is 34 base58 symbols.  It's not the largest base 58 number that will fit 
in 34 symbols though...

 base58: zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
 hex:    20a8469deca6b5a6d367cbc0907d07e6a5584778de27ffffffff
 vs hex:   ffffffffffffffffffffffffffffffffffffffffffffffffff

i.e. there are a few unused bits (~5) available in the base58 representation 
that can be added without changing the number of symbols in the address.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On 05/03/2012 01:46 AM, Wladimir wrote:

I don't want to add fields to the URI-spec, I just want to add them /to 
the client/.  To me, it is ideal to have separate strings for labeling 
/addresses/ vs labeling /transactions/ -- i.e. different strings would 
show up in the address book (owner info) than what shows up in the 
transaction history (purchase info).   I say it's ideal because that 
concept seems to fit perfectly with availability of "label=" and 
"message=" fields in BIP 21, but it won't actually work if Bitcoin-Qt 
won't/can't do it that way.

For now, it seems that I should count on all important information being 
in the /label/ field, since users creating URLs would have to assume 
anything in the /message/ field will not be saved.  Though I imagine the 
message data will be /displayed/ after the URI is clicked, just not saved.

To expand the concept slightly further, it might make sense in the 
future for users to populate the /message/ and /label /fields with lots 
of data, using newlines.  The first line would be used as a summary and 
displayed in the address book and ledger.  The extra lines would all be 
displayed when the user opens up a details window.  All of it would be 
automatically generated by the merchant, and the purchaser would end up 
with detailed documentation on every purchase they've made for zero effort.

-Alan

-------------------------------------
On Thu, Jun 14, 2012 at 9:22 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:

BIP 10 <https://en.bitcoin.it/wiki/BIP_0010> could use some improvement.  I
created it for offline and multi-sig tx but there was no reception to it
because no one was using offline or multi-sig tx at the time except for
Armory (which only currently implements offline tx).  So I made something
that fit my needs, and it has served its purpose well for me. But I also
think it could be expanded and improved before there is wider adoption of
it.  It's a little clunky and not very rigorous.

Elements of it that I'd really like to keep:

(1) Some aspects of human-readability -- even if regular users will never
look at it, it should be possible for advanced users to manually copy&paste
the data around and see what's going on in the transaction and what
signatures are present.  I'm thinking of super-high-security situations
where manual handling of such data may even be the norm.
(2) Should be compact -- I took the concept of ASCII-armoring from PGP/GPG,
because, for the reason above, it's much easier and cleaner to view/select
when copied inline.  If a random user accidentally runs across it, it will
partially self-identify itself
(3) Includes all previous transactions so the device can verify transaction
inputs without the blockchain.


Things that could be added:

-- It needs a BIP16 script entry (this was created for vanilla multi-sig
before BIP 16 was created)
-- Comment lines
-- Version number
-- Use base58/64 encoding
-- Rigorous formatting spec
-- Binary representation
-- A better name than "Tx Distribution Proposal"

I'll be releasing the Beta version of Armory soon, and after that, I'll
probably be thinking about a multi-signature support interface.  That would
be a good time for me to tie in a better version of BIP 10 -- one that is
compatible with other clients implementing the same thing.
-------------------------------------
On Tue, 2012-01-31 at 06:27 -0800, Amir Taaki wrote:

The send crap was not in the original spec, is not implemented anywhere,
and should have been removed as part of the BIP 21 copy/paste.  It is
now gone.

As for the expire time, well thats a bit problematic IMHO.  Technically
BIP 21 is still a draft, but it is implemented in all versions of
Bitcoin-Qt for drag and drop and adding a field which restricts the
validity of a URI for new clients, but which old clients will gladly
accept could result in some ugly situations IMO.

Matt



-------------------------------------
GregM, wasn't sure how to answer your question, and as to
conflicts [1]. I think I grasped it in my reply to something on
tor-talk, which is on its way here pending moderation due to bcc.
I put that part below. The FYI referred to seednodes as
they exist on Tor / I2P today.



/ [1] Well bitcoin wouldn't know to offload traffic to any of those
/ blocks, or a specific host on them, if you had them set up locally
/ via *Cat or Phantom... for bitcoin use. It would probably end up
/ half useful similar to the above FYI. But that would just affect
/ bitcoin, not whatever else you were running on them.


-------------------------------------
Yep, I want to chip in and also express my gratitude for these useful tests. I sent a personal email to Gavin before.

I plan to make some more complex tests by combining several of the simpler ones.



----- Original Message -----
From: Gavin Andresen <gavinandresen@gmail.com>
To: Stefan Thomas <moon@justmoon.de>
Cc: bitcoin-development@lists.sourceforge.net
Sent: Sunday, July 29, 2012 9:52 PM
Subject: Re: [Bitcoin-development] script tests - invalid script in script_valid.json?


Yes, more tests are definitely welcome.

check*sig tests are tricky, because they have to refer to previous
unspent transactions and private keys (so require a particular block
chain to test against). Brilliant ideas on a simple data-driven format
welcome.

block verification tests would be great; a collection of good/bad
block chains, starting from a common chain (maybe the testnet3
tesnet-in-a-box chain) would be very useful for regression testing.

-- 
--
Gavin Andresen

------------------------------------------------------------------------------
Live Security Virtual Conference
Exclusive live event will cover all the ways today's security and 
threat landscape has changed and how IT managers can respond. Discussions 
will include endpoint security, mobile security and the latest in malware 
threats. http://www.accelacomm.com/jaw/sfrnl04242012/114/50122263/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------

My last note in this sub-thread.

There are no IANA registry groups, there is no such thing, and no way
to form one. The IETF can ask the IANA to form a registry but these
things take lots of support and take a long time, and these are only
created through standards track RFC. ICANN runs the IANA and there is
no such framework that you elude to. Review
http://www.iana.org/protocols/

If you are applying for a gTLD, good luck with that.


-rick


-------------------------------------

It's cool that Armory already does this. I never had time to implement
good coin selection for bitcoinj :(

Just a couple of points: as this is primarily a side effect of
SatoshiDice, and a successful payment protocol will stop them doing
it, code put in place to do temporary cleanup now probably won't
seriously affect peoples privacy over the long term. Most people
aren't going to end up with lots of tiny outputs.

Second thing, it's best to carefully separate "anonymity" from
"privacy". Privacy is supposed to be a feature of the system (it says
so in Satoshis paper) because people demand it. If I loan a tenner to
my friend and he is able to find out what I earned last month, then
that trade was neither anonymous nor private. In this case I want
privacy but anonymity isn't useful. Mixing up anonymity with privacy
is not only a public relations problem, but can lead to confusion from
users when they, eg, try and buy Bitcoins from an exchange and are
asked to provide ID proofs.


-------------------------------------
On Tue, Nov 27, 2012 at 11:42:01AM +0100, Michael Gronager wrote:

Gavin's proposal differs in this from my original proposal, where I
exactly *didn't* want to couple the receipt with the acceptance of
the Bitcoin transaction.

If a merchant/payment processor is willing to take the risk of zero or
low confirmation transactions (because they are insured against it,
for example), they were allowed to reply "accepted" immediately, and
this would be a permanent proof of payment, even if the actual Bitcoin
transaction that backs it gets reverted.

For that reason, I also had a separate "pending" state, which means the
receiver isn't willing to just accept the current state as irrevocably
paid. In this case, the sender was allowed to retry until the receipt
sayd "accepted" or "rejected".

The whole point was to avoid that customers/merchants would have to
deal with the uncertainty involved in Bitcoin transaction. At some
point, someone is going to accept the transaction (whether that is at
0 or at 120 confirmations), and acceptance will at the higher level
be considered a boolean anyway - not some "probably, unless reorg".

-- 
Pieter



-------------------------------------


will be used by Electrum servers 

-- 
Empfehlen Sie GMX DSL Ihren Freunden und Bekannten und wir
belohnen Sie mit bis zu 50,- Euro! https://freundschaftswerbung.gmx.de


-------------------------------------

Thinking about it some more and re-reading the Scalability wiki page,
I remembered that a nice bandwidth optimization to the protocol is to
distribute blocks as header+list of tx hashes. If a node has already
seen that tx before (eg, it's in the mempool) there is no need to send
it again.

With the new command to download the contents of the mempool on
startup, this means that blocks could potentially propagate across the
network faster as download time is taken out of the equation, and
indeed, with the signature cache the hard work of verifying is already
done. So this could also help reduce orphan blocks and spurious chain
splits.

Are you planning on implementing any of this Jeff? I think we have the
opportunity to kill a few birds with one or two stones.


-------------------------------------
On 01/23/2012 06:50 PM, Mike Hearn wrote:

Hi Mike,

Bitcoinj has a class named ECKey. I just hardwired it with a main() to
check the mentioned transaction's signature.

I debugged the official client to get the exact data (hash, signed data
and public key). I checked signatures of transactions prior to the
mentioned one, all work, so the test code and the data I got are very
likely correct.

It might be that I'm using old bitcoinj code (I think it is 0.3, can't
find a version string anywhere), but I doubt that has any impact on the
ecc verification. Even if it did, I got my on code too, so what are the
odds that two implementations fail at the same point?

Anyway it would be helpful if someone just tried to run a verification
independently with the mentioned transaction (with BouncyCastle and with
openssl) and see whether he/she gets the same result.

I tried with BouncyCastle 140 and the newest 1.46, both fail.

Robert.


-------------------------------------
The Internet Financial EXchange (IFEX) Project is an open body for the
discussion and development of financial standards for the internet
community.  The project seeks to focus on enhancing interoperability
between financial settlement systems of all types, including
conventional financial systems, emerging digital currencies,
alternative financial communities, and financial service providers.

Interested parties are invited to review the proposals on the website
at http://www.ifex-project.org/ and join the mailing list at
http://group.ifex-project.org/

Two items on the site that may be of particular interest:

(1) The latest version of the IIBAN Proposal (v1) for financial
endpoint identification at
http://www.ifex-project.org/our-proposals/iiban.  This latest version
includes initial IANA registry contents and a reference mechanism for
financial endpoint transcription error correction. (Relevance: In
contrast to settlement system-specific financial endpoint identifiers,
IIBAN provides a democratically allocated, 13 character identifier
that is already familiar in format to users in Europe and other
countries and is theoretically compatible with conventional banking
infrastructure in those regions.  In addition, IIBAN is not tied to
any specific financial commodity or settlement system, and provides
strong protection against identifier transcription errors.)

(2) The IFEX Protocol is a *work in progress* that hopes to bridge the
gap between conventional financial systems, emerging digital
currencies, alternative financial communities, and financial service
providers by providing a standard protocol for transaction and
settlement path negotiation with arbitrary financial instruments,
currencies or assets.  (Relevance: better connectivity, lower
settlement fees, real time redundant financial routing, arbitrary
instrument/currency/asset handling)

How IFEX's proposed infrastructure differs from existing projects:
 - Not a currency, not a settlement-network, but a mechanism for bridging them.
 - Broader and more inclusive scope than existing vendor-specific APIs
and conventional finance industry networking protocols. Global focus.
No legacy 'features'. No artificial barriers to innovators.

The hope is to move towards an open source implementation of the (work
in progress) IFEX protocol that interoperates with major and emerging
settlement networks for the benefit of all parts of the community. We
have already had expressions of interest from representatives in a
range of communities (Bitcoin, CES, Ripple, W3C Web Payments, digital
currency exchange developers, etc.), and look forward your input on
the mailing list.

Happy Friday the 13th!

Regards,
Walter Stanish
The IFEX Project
http://www.ifex-project.org/


-------------------------------------
A small change to the protocol is proposed for satoshi client v0.7
(upcoming release):

    Add 'mempool' P2P command, and extend 'getdata' behavior
    https://github.com/bitcoin/bitcoin/pull/1641

The genesis of this command is to permit SPV clients to access the
memory pool, but secondary uses include diagnostics and miner download
(so that miners won't miss lucrative TX's due to node restart).
"getdata" behavior is extended to include any memory pool transaction,
relaxing a previous "getdata" restriction.

Didn't feel this warranted a BIP, but can write one if people really want one.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hello everyone,

Luke's getmemorypool/BIP22 pull request has been open for a
long time, and didn't receive too much discussion.

I think that having a stable and flexible API for negotiating
block generation is important to be standardized. The fact that
it allows moving block generation to specialized programs is a
step in the right direction. However, it seems to me that too
few people (myself included) understand all the details of
BIP22 (or don't care enough) to judge their necessity. I gave
up trying to follow all design decisions some time ago, and as
it seems I'm not alone, nobody liked merging support for it in
the Satoshi client. This is a pity, and I hope the situation
can be improved soon.

I'm sorry for being this late with these comments, but I think
it's essential that the standard is not more complex than
necessary (making it as easy as possible to write either
servers or clients for it), and perhaps even more important,
that its purpose and intended use cases are clear.

proposal and submit. The general idea is that 
  1) a miner requests a block template
  2) builds/modifies a block based on this, and optionally
     uses propose to check whether the server is willing to
     accept it before doing work
  3) submits when valid proof-of-work is found
I'd like to see this process described in the BIP at least,
it too me way too long to extract this.

Regarding the block template: is there a particular reason
for sending the full transactions (serialized in hex) both in
templates and submissions? The server will always need to have
access to the transaction database anyway, and clients will
(afaics) rarely care about the actual transactions. My
suggestion would be to just transfer txids - if the client is
interested in the actual transactions, we have the
gettransaction RPC call already. This seems to be captured by
the several "submit/*" and "share/*" variations, but making
it optional seems way more complex than just limiting the API
to that way of working.

That's another thing that bothers me in the standard: too many
optional features. In particular, I understand the usefulness of
having some flexibility in what miner clients are allowed to
modify, but I'm unconvinced we need 10 individually selectable
variations. In particular:
* coinbase outputs: can we just add a list of required coinbase
  outputs (amount + scriptPubKey) to the template? If no
  generation+fee amount remains, nothing can be added.
* coinbase input: put the required part in the template;
  miners can always add whatever they like. Is there any known
  use case where a server would not allow a client to add
  stuff to the coinbase?
* noncerange limiting: if coinbase input variation is not
  limited, there is certainly no reason to limit nonceranges.
  This adds unnecessary complexity to clients, in my option.
* time/*: put a minimum and maximum timestamp in the template
  (i believe those are already there anyway). Anything in
  between is valid.
* transactions/add: what is the use case?
* transactions/remove: i'd just standarize on having all
  transactions be removable (perhaps except those marked
  'required').
* prevblock: one getmemorypool per new block shouldn't be
  a problem imho, so do a longpoll instead of having the client
  able to modify prevblock themselves.

One more thing that I do not like is often several ways for
specifying the same behaviour. For example, txrequires specifies
that the first N transactions are mandatory, a 'required' field
in the transaction list itself specifies that that transaction is
mandatory, and the lack of transactions as variation means that
they must not be touched at all. Pick one way that is flexible
enough, and discard the others.

In summary, I'd like to see the standard simplified. I have
no problem merging code that makes getmemorypool compliant to
a standard that is agreed upon, but like to understand it first.

In my opinion - but I'm certainly open to discussion here - the
standard could be simplified to:
* getblocktemplate: create a new block template, and return it.
  The result contains:
  * bits, previousblockhash, version: as to be used in block
  * curtime, maxtimeoff, maxtimeoff: client chooses a timestamp
    between (curtime - local_time_at_receipt + local_time),
    decreased by mintimeoff and increased maxtimeoff
  * expires, sigoplimit, sizelimit: unchanged
  * subsidy: amount generated (5000000000 for now)
  * coinbaseaux: what generated coinbase's scriptSig must start
    with
  * coinbaseoutputs: list of objects, each specifying a required
    coinbase output. Each has fields:
    * amount: sent amount
    * scriptPubKey: hex serialized of the output script
  * transactions: list of object, each specifying a suggested
    transaction (except for the coinbase) in the generated block.
    Each has fields:
    * txid: transaction id
    * depends: list of dependencies (txids of earlier objects in
      this same transactions list).
    * fee: fee generated by this transaction, which increases the
      max output of the coinbase.
    * required: if present, transaction may not be dropped.
* submitblocktemplate: submit an object containing a hex serialized
  block header, hex serialized coinbase transaction, and a list of
  txids. Returns true or string describing the problem. Proof of
  work is checked last, so that error is only returned if there is
  no other problem with the suggested block (this allows it to
  replace both propose and submit).

Are there important use cases I'm missing?

-- 
Pieter


-------------------------------------
On MSG_MEMTX:  The current version has a much higher Just Works value.

On empty "inv":  It is generally better to do something
unconditionally, than have a response generated only under certain
conditions.

And Alan is correct to note that unknown messages are ignored
(intentionally, for expansion).  However, unconditionally returning a
response has little to do with feature probing/discovery.  It is
simply a clear, deterministic indication that processing is complete,
for each invocation.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

I wish there were a bitcoin-user mailing list??? But the one on
sourceforge is dead. Forums are too full of avatars, smilies,
sigblocks and dead mass to be of much use. Not to mention
when they vanish, any content dies with it instead of living
on in various archives.


-------------------------------------
Video from the event: http://www.youtube.com/watch?v=EQ2rb4pHH1g


The Hackathon is over, thanks for all the participants and sponsors! I 
had loads of fun, and there were lots of great ideas flying around!

Thanks especially to:

- IN-Berlin, for providing the space to hold the hackathon!
- Sponsors: bitstamp.net, bitcoin2012.com and localbitcoins.com
- Room77 (the restaurant at the end of capitalism), for hosting the afterparty and the burgers & pampero 
- Jury: yossarian + other people who attended the presentations 

The results - winner first

1. Offline transactions for BitcoinJ/Android bitcoin wallet: Andreas Schildbach and grazcoin
- Ability for Android Wallet to do offline transactions
2. Bitcoin Pong: genjix
- Multiplayer pong, where you can win (or lose) bitcoins 
3. acceptbit.com: Jeremias Kangas and Stefan Thomas
- an ultra-safe merchant tool, where you can accept payments without sharing your private keys 
4. BitcoinJ Multisig: yellowhat and PK
- way to do multisig transactions for BitcoinJ/Android
5. Double-spend monitor: genjix
- tool to monitor double spends
6. Bitcoin-autosave: Mike Hearn
- BitcoinJ improvements (Mike did also loads of other stuff, and helped with winner project too)
7. Live-calculator: genjix
- Tool for btc accepting restaurants
8. Bitcoin mages: genjix
- Strategy game, where you play for bitcoins
9. Embed block message: genjix
- simple tool for embedding messages in block chain

Source code

genjix: https://gitorious.org/bitcoin-hackathon
acceptbit.com: https://github.com/kangasbros/electrumpos
Bitcoin Wallet: https://github.com/livne/Bitcoin-Wallet-for-Android (branch hackathon)

Other

Participants, send jeremias your bitcoin addresses please 

The next hackathon will be organized before bitcoin london conference, Wed 12th and Thur 13th september, london. 


-------------------------------------
On Wed, Oct 3, 2012 at 1:49 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Agree, though needs testing


Agree


Agree, though sipa raised a valid issue.  lockunspent, like the
existing listunspent, is wallet based.

As raw transactions might spend outputs _not_ in the wallet,
lockunspent would miss those.

I think this is OK, because listunspent is already wallet-based, but
it should be noted.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

I don't think the bloom filter settings have any impact on server-side
load ... a node still has to check every transaction against the
filter regardless of how that filter is configured, which means the
same amount of disk io and processing.

How can you reduce load on a peer by negotiating different filter settings?


-------------------------------------
On Mon, Dec 3, 2012 at 1:24 PM, Michael Gronager <gronager@ceptacle.com>wrote:



I disagree completely. The only power granted to miners is to decide the
order of otherwise valid transactions (up to postponing some indefinitely)
- they have no ability to control the rules for validity them self  In
particular, the rules that prevent double spending and (monetary) inflation
of the currency are deliberately NOT left to miners. If this were the case,
they could just as well vote to keep the 50 BTC block payout, and that
would certainly not be what people signed up for.

-- 
Pieter
-------------------------------------
On Sat, Apr 14, 2012 at 5:27 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

Looks like you're already headed in the right direction :)

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Can this be amended? I think it makes much more sense to allow people to input labels not numbers at this level.

General category names for different accounts is much more human than numbers, and you can still use incrementing numbers if you prefer.



-------------------------------------

What computer is the initial start time 24-hours+ now?   On normal
systems initial sync-up now takes a couple hours.  It could be slower,
of course, if you have the bad luck to end up with unresponsive peers—
but that will also make the SPV nodes slow.

Better to be conservative I agree, but calling it a dozen times longer
than I'd expect is perhaps a bit much.

Refine refine refine.


-------------------------------------
On Sat, Jan 28, 2012 at 11:52 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

...  No it's not a mistake.  P2SH _prevents_ needing long addresses.

Lets unpack the acronym "pay to script _hash_".  Hashes only need to
be 128-256 bits in size or so to have acceptable security, so you
don't need something longer than that for paying to a hash.

Note that gavin is saying 70 characters, not bytes.

Without some form of P2SH then only way for you to make a personal
choice of asking people to pay to a two-factor protected account or
two a multiparty trust that manages the finances of an organization
is using some form of "P2S", pay-to-script.

In other words, you'd have to have an address that encodes a full
script specification for the sender to pay to,  instead of just
encoding its hash.  As a result these addresses would be much longer
(and potentially very long).

The minimum size of a two address involving encoded script would be on
that order, but they get bigger quite quickly if you add more options
to the script (actually 70 sounds quite small, it should be more like
100 for a minimum two pubkey script).

In addition to the unworkability of very long addresses as described
by gavin (amusingly I am unable to copy and paste the quoted example
in one go) a P2S solution has several problems which you might
consider more or less important:


(1) They are highly vulnerable to invisible substitution.  E.g. I can
trivially take a P2S address, change one or two characters and get a
script which is redeemable by anyone.  With P2SH you have to do
computation which is exponential in the number of unchanged digits to
get a look alike address.

(2) The sender is fully responsible for fees related to the enlarged
transactions. Even if _you're_ willing to take the txn-processing time
and fee burden of a 30 person joint trust address,  random e-commerce
sites will not be and will randomly reject your addresses.

(3) They create another input vector for non-trivial data which must
be inspected and validated, potentially presenting an attack surface.

(4) They leave the complicated (long) release rules in the transaction
outputs.  When a transaction is mined we can't be sure if it will ever
be redeemed. The outputs are unprunable.   In a future world where
many nodes prune output space is far more important than input space
and it would make sense to require more fees for it because we're
never sure how long it would need to be stored (making it an
attractive target for someone who wants to make Bitcoin unusable by
spamming it with worthless data).  P2SH reduces output sizes to the
absolute minimum without inflating the total data size.


-------------------------------------

If that's the case then the negotiation protocol needs to be specified
too. It seems heavy though. If a node is getting overloaded it could
just disconnect intensive peers or refuse new connections.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

I'm not a vendor, however I have a code-signing key for windows; I could
sign the windows installer and binary.

On 30/07/2012 3:15 AM, Luke-Jr wrote:

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.19 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iF4EAREIAAYFAlAV8ZYACgkQBJ8cMDO159ZNVgD+KsQUlNcTDSmTGaHvLbAw0Cxy
OCDfnsFbaiLoX2xWP3MBAOnN/QvcYY8f2WzMfI+N1PfnydRYGxlkA2JZ2Nrtnxcv
=qeUe
-----END PGP SIGNATURE-----


-------------------------------------
One more thought:

RE: "Receipt" verus "Acceptance" :

I believe "Receipt" is the right term-- it means "I got your payment",
NOT "your payment has cleared."  E.g. if I hand a merchant a paper
check they'll hand me a receipt, but the check could still bounce.
That's the analogy here-- a merchant might give you a receipt, but if
the transaction is rejected by the network for whatever reason (Finney
attack maybe) you cannot expect to go to court with your
invoice/receipt and claim you made a valid payment.


-- 
--
Gavin Andresen


-------------------------------------
Can we please drop the binary vs text issue? We have been around it
millions of times already. There are no compelling arguments to use
text here and several obvious problems with it. If you think you've
found a good argument to use JSON, please research protocol buffers
more thoroughly and see if it changes your mind.


-------------------------------------
On Fri, Feb 3, 2012 at 4:52 AM, Aidan Thornton <makosoft@gmail.com> wrote:

No developer politics are involved— the cuts to the stable versions
have always been done from Luke's repository simply because he
maintains it.


-------------------------------------
On Sun, Jul 22, 2012 at 11:37 PM, grarpamp <grarpamp@gmail.com> wrote:

That's actually slower-than-Atom class hardware you're running on
there, with full disk encryption on what's a very CPU and IO-heavy
workload. From the benchmarks I remember, your CPU is literally slower
than the first generation of single-core netbooks - the ones reviewers
recommended against using full disk encryption on because they just
didn't have enough CPU power to manage it. It's not surprising that
Bitcoin isn't usable on that setup.


-------------------------------------
Seems reasonable to me.
On 4 Feb 2012 14:03, <thomasV1@gmx.de> wrote:

-------------------------------------
Here are my latest thoughts on a safer OP_EVAL alternative, inspired
by all the ideas and agitated IRC and email
discussions of the last week or so:

Goal:  Let users publish a short "funding address" that is the hash of
an arbitrary redemption Script revealed when they spend the funds,
implemented in a backwards-compatible-in-the-blockchain way.

Proposal:

A new 'standard' transaction type, "pay to Script hash":

scriptPubKey:  HASH160 <push-20-byte-hash>  EQUAL

Redeemed with the same scriptSig as the OP_EVAL proposal:
<signatures> <serialized Script>

Old clients/miners will ignore <signatures> and just validate that the
hash of <serialized Script> matches.

New clients/miners will recognize the new type of transaction and will
do the following additional validation:

1. Fail validation if there were any operations other than "push data"
in the original scriptSig.
2. Deserialize the top (last) item on the scriptSig stack (fail
validation if it fails to deserialize properly).
3. Run an additional validation on the deserialized script, using the
remaining items on the scriptSig stack and the deserialized script as
the scriptPubKey.


---------------

As Amir said in IRC chat today, "the idea is a hack.... but I like it."

I like it, too-- it is cleaner than OP_EVAL, more straightforward to
implement, and pretty much exactly matches the feature I care about
(moving code from the scriptPubKey to the scriptSig). There are no
special cases like "CODESEPARATORS not allowed in <serialized
script>".

-- 
--
Gavin Andresen


-------------------------------------
OK - from your path it looks like linux. What version of Boost do you use. I require 1.47 or 1.48. - I will change that, but it is quite handy for signal_sets - will make an alternative scheme though.

And, as for 0.4 vs 0.5 - I have tried to follow the changes, which were mostly (?) related to the integration of the qt client, which would have to be re-done anyway. Then there were some deadlock fixes, that I don't need ;). A fix for a special attack, that I have included. But I will go over everything again.

Cheers,

M



On 01/02/2012, at 16:26, Luke-Jr wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


Hi,

On 11/10/2012 16:46, Gavin Andresen wrote:

essentially yes - in all seriousness, I have come around to your way
of thinking, it is not worth arguing about. we end up in the same place.

:) nothing is final though. I will be opening it up to Arklan in a bit
(I have a pool match tonight so after that depending on how drunk i
get.) and to another couple of people who have emailed me off list who
would like to be involved in testing.

I have not created any new tests for the new stuff.  this is still the
noddy stuff.

It covers everything that needs to be covered for a newbe or someone
upgrading clients.

and it is in many formats the moment (from wiki to test runner) none
particularly useful (about to import into mantis, just fiddling with
the fields so it does testcases)

I have been trying to separate the tests into what can be automated,
recorded and checked by watching the video and have sanity checks
along the way (published sha and sha256 of the binaries match) -
(obviously the test is flagged to be run manually if there is any doubt)

I did take myself outside and had a little sit down and talk to
myself.  Lets not run before we can walk. I will still keep the grand
ideas, but they are on the back burner. (I got called a blue skies
thinker today, wtf is one of them? I said smiled and said thanks)

the main things we make sure we get tested right are all the GAT tests
in bettermeans.They are more protocol based and should be run against
all releases.  Lets nail that process, peer review it, retest it, then
use that as a basis for The Process. I will temper my zealousness. I
realise that I can come across as bullish or even aggressive in my
emails.  I never mean too.(unless I say I am. That is not an excuse
for my poor english language skills.)

But I still think that the people running the tests should have the
greatest say in what software is used. So once you have access to the
server and the cases feel free to install your favourite software and
see what other people think.

but we have a vague structure and workflow so it will be interesting
to see how it works out.

the git integration will be trivial.

please email me if you would like access.  I am off out in 15 mins but
I promise to have all access sorted by tomorrow.  I am only using 3
vps to show example testing and test platforms.  I would like it if we
could get a technet license with the donations so far, I use mine (and
my msdn) for work.

also check out bettermeans for the formats that I will be using.

bollocks. bollocks. bollocks

https://secure.bettermeans.com/projects/4180

bye bye bettermeans. how we never knew ye.

Gavin, can we get a bitcoin-test mailing list please.  it would be
used for discussion of testing, tools, ideas, chatter, etc.  it would
not be a place reporting bugs... This list seems very focused and I
always feel like I am disrupting things with my emails about test.  I
dont mind admining the list. I would rather be vocal and inclusive, I
dont think the dev list is the place for that.


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQdwWxAAoJEFvEB9dQFvtQiuMIAJpdu23biq56apMO/KfqmSB0
kQPflDD2XMxTknfqzRs35/EFgL0mJ/cYfY3qTW9JOWL/cit4ieq2EA4P3uQeFFDC
NCxIuDxOzOIaZ+SzRZENXdpVWKRNP1RgUCANm3YfrJBlavr9a/om36nP1IK0W4MB
QcPXrrZvipt1xhx1G/V6NvYbZA3lTAJBFzuz2oRJNwlYoExJFw8EHBypa67BUNOj
NDg1Wu5Ppyq7dZbgfhw4HxIIvgwn/vaSm/tX6HJxyKN7HUJIbIyQrSbPGUvWCsBW
KI6e88DPdG0x0ltqVXja+51n3F9G4H/zTIbB0GyiRDn0GcGwi/GolF5PAgz0tR8=
=zniH
-----END PGP SIGNATURE-----


-------------------------------------
BlueMatt, did the BIP0021 Wiki entry for "req:" to "req-" get updated? I'm
looking there now and it seems to be still at "req:"
-------------------------------------
I think it's a great initiative Steve,

On Tue, Sep 25, 2012 at 10:41 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:


The pulltester and Jenkins are really useful, I think it's best to
keep these and improve them if needed.


Which brings me to another issue: we desperately need a page that
links all the developer resources for bitcoin dev:

- link to my doxygen docs (https://dev.visucore.com/bitcoin/doxygen/)
- bluematt's pulltester and jenkins
- any testing dashboards Steve is going to add

But also:

- how to check out the source code, how to find the build instructions
for your platform
- contribution guidelines
- where to ask w/ development problems (this mailing list, #bitcoin-dev)
- where to begin, which bugs to solve first
...

Maybe on bitcoin.org, but at least easy to find for people that want
to contribute, not just some deeply nested wiki page. Ie, something
like

https://www.mozilla.org/en-US/contribute/
http://www.ogre3d.org/developers
...

I'm willing to write this. But I know these kinds of proposals always
end in a big discussion about what should be and what should not be on
bitcoin.org, however we should be a bit pragmatic here.

Wladimir


-------------------------------------
On Thu, Oct 11, 2012 at 11:46 AM, Gavin Andresen
<gavinandresen@gmail.com> wrote:

Posted a call for testing in this forum thread,
https://bitcointalk.org/index.php?topic=117487.0

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Saturday, March 03, 2012 10:05:58 AM Gavin Andresen wrote:

I wasn't aware anyone was considering JSON-RPC over anything other than HTTP.

I've updated the draft to include long polling, and remove some assumptions of 
using HTTP for transport.


-------------------------------------
I added the ability to do controlled generation of blocks to gavin's fuzzer

https://github.com/genjix/bitcoin/tree/fuzzer


bitcoind -daemon
bitcoind setfuzzpreviousblock000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
bitcoind setgenerate true

It will start hashing the block with the previous hash field set to000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f and the target as 0x1d0000ff

On completion it will dump the hex value of the block to debug.log and exit.

You can then feed that block to your implementation in whatever controlled manner you wish (i.e with libbitcoin I made a simple tool in a few lines to read the hex and send it via the network in localhost). If anyone wants the libbitcoin tool then let me know and i'll paste it over on IRC.


-------------------------------------
Hey,

I made a list of things to ask about:

https://en.bitcoin.it/wiki//10_Jan_2012

Feel free to add things to the agenda. Those are just random things I wanted to discuss.



-------------------------------------
I think it would be great to have more nonce space with less merkle
calculation; keeping track of all possible versions of a block already
takes real RAM, real computation. Being able to change one bit in the
header and send out a new block for checking would ease our pool server
work by a real amount, somewhat on the work generation side, but also on
the checking old work side; we'll have a lot fewer unique transaction /
coinbase sets to hold on to for checking when we get back a solution.

Peter


On Tue, Jul 24, 2012 at 4:58 PM, Mike Hearn <mike@plan99.net> wrote:




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
On Fri, Mar 2, 2012 at 2:57 PM, Watson Ladd <wbl@uchicago.edu> wrote:

That's very exciting!  I'm eager to read the paper for all of the
details, and working out what else would need to be done besides a new
opcode to enable strong anonymity (at the very least, I assume we'll
need one or more new 'standard' transaction types that clients
understand).

-- 
--
Gavin Andresen


-------------------------------------
On Friday, March 02, 2012 1:51:41 PM Amir Taaki wrote:

This isn't implementation-specific. If you read it, you should notice it is 
intentionally generic for multiple use-cases. Right now bitcoind supports 
getmemorypool for a few use cases, but this proposed BIP enables it to be 
utilized for many more. Specifically, Eligius and at least a few other pools 
wish to move toward a more decentralized method of pooled mining (similar to 
the proprietary p2pool protocol). Eligius already supports miners producing 
their own work with getmemorypool using this draft, and our Eloipool server is 
open source (AGPL-3) for others to adopt (I know of at least one other pool 
planning to do so). Other pools not using Eloipool also have expressed 
interest in this, so a standard is desirable.


-------------------------------------
Mushoz makes a good point:
	https://bitcointalk.org/index.php?topic=58450.msg695052#msg695052

Do we have enough downloads on 0.5.2rc1 to get the final rushed out and onto 
the website?


-------------------------------------
On 2012 January 31 Tuesday, Andy Parkins wrote:


Having thought about it; I've realised that the above is simply BIP16 without 
the backward compatibility work in it.  If BIP16 renamed the scriptPubKey 
field to "hashOfClaimingScript" and no longer ran it as a script, it woudl be 
close to identical.  We'd simply define the field as

 0xa9 0x14 <hashOfClaimingScript> 0x87

Detection of this format of scriptPubKey activates "version2" processing of 
the transaction.  And similarly, a new definition of scriptSig to be two 
fields:

   unsignedInitialStackBlock
   scriptClaim

I'm sure nobody cares about my opinion; but that's actually been the moment 
of epiphany for me (and I raise it here, in case it is for someone else).  
Having previously been against BIP16, I'm now happy with BIP16 -- it's a 
progression towards the ideal... having a literal claimScriptHash field 
instead of scriptPubKey; and never running scriptPubKey.

Potentially OP_CHECKSIG could be simplified as well because the rules could 
be "anything that's not the serialized script" in scriptSig is not signed.

I can imagine one day, when the network is all BIP16 compliant, that 
scriptPubKey will no longer be allowed to run as script at all.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Sun, Jul 15, 2012 at 1:52 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

ACK on removing outdated material

Vladimir does raise a fair point, though.  Hackathon seems appropriate
for bitcoin.org as it is focused on dev-related activities.  (full
disclosure: speaking at bitcoin2012.com)  The conference might or
might not be.  The conference does seem community focused, so I don't
object to it being on bitcoin.org...  But if consensus prefers
otherwise, that's OK too.

PS.  This seems like material for pull requests, which is preferred
over mailing list email + git push.  When working on the satoshi
client, we all ACK each other's pull req for anything beyond the
trivial.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Since several independent clients (I know at least libcoin 
<https://github.com/ceptacle/libcoin/blob/master/src/coinHTTP/RequestHandler.cpp> 
and BitcoinJS 
<https://github.com/bitcoinjs/bitcoinjs-server/tree/master/lib/rpc>) aim 
to implement JSON-RPC APIs which are either a superset of the original 
client's or have at least some compatible functions, I think you can 
make a case for including JSON-RPC API calls within the domain of BIPs.

In this instance the BIP aims to create a common protocol between 
different clients, miners, mining proxies and pools. That's a lot of 
software, so standardization definitely seems like a good idea and I 
can't think of a reason not to use the BIP process.

I have some comments on the content of the BIP, but since this thread is 
more of a meta-discussion I'll wait until the BIP is officially proposed.


On 3/2/2012 7:51 PM, Amir Taaki wrote:

-------------------------------------
This thread is discussing two unrelated things.

Your first email asked about transaction pruning ("stubbing"). You're
correct. This doesn't do anything for initial chain download bandwidth or
time. In fact it makes it slower because you have the overhead of deleting
the old transactions. It exists purely to save disk space.

Christians reply is about simplified payment verification (SPV) mode. It is
unrelated to transaction pruning. SPV clients can download only the chain
headers with no bodies all the way from the genesis block until the
creation time of their youngest key. This does reduce initial setup time
and in fact is now implemented in BitCoinJ, but it's still linear in the
length of Bitcoins life, so that's ultimately unsustainable. You need a
regular series of checkpoints signed by a trusted developer and a circular
block store to have truly bounded overheads. The merkle tree is still
useful because it allows for SPV clients to receive only the transactions
of interest yet have nearly the same assurances that downloading full
blocks would give - remote nodes can now hide transactions from you (dos)
but not invent new ones.

SPV clients do not use "number of blocks on top" as a way to decide
validity. They look for the best chain they can find, same as a regular
node does. As Satoshis paper says, if an SPV node has access to the P2P
network and is also talking to you, you can defraud it for as long as you
can dominate the networks hash power (51% attack) because you can create a
harder chain than everyone else can. However your invalid blocks won't be
accepted by the rest of the network regardless of how many there are or how
much work they represent, so as soon as you stop dominating the network the
correct chain will catch up and replace yours, resulting in the fraud being
detected and shown to the SPV user.
-------------------------------------
I've been following this thread closely, and Mike is correct here -
protocol buffers is definitely the way to go.


On 17 December 2012 09:19, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------


As it states in the source code, signatures cannot sign themselves.  If
scriptSigs were included in the data that is being signed, the act of
inserting the newly calculated signature for one input would break the
signatures for all the others.
-------------------------------------
on 09/26/2012 01:49 AM Wladimir said the following:


May I suggest a page bitcoin.org/developers, that links to a wiki page
of developer resources?
That way there's an easy link from the main site, but the content is
readily editable and expandable.

-------------------------------------
On Sat, Mar 31, 2012 at 12:03:17AM -0400, Luke-Jr wrote:

Nice summary, thanks.


I think that's right - for several reasons, the time between 0.5 and 0.6 was 
over 4 months. I prefer more frequent releases, as it slows down development
this way.


I'd rather see a decent encapsulation of wallet and blockchain data structures
that allow us to make their mutexes private, and let only the code from the
respective mutex take locks in it when necessary. That will automatically
lead to multithreaded RPC, but in a safe way, without needing guesswork about
which two calls may or may not be called simultaneously.

Of course, that requires a lot more work, but at some point that will be needed
anyway, imho.


I've used loadblocks often in my personal branches. At least on Linux it seems
to work fine. The data scanning code is mostly Cish though, and there may be
more preferrable to use boost or generic C++ solutions.


I've already had a fully functional IPv6 node based on 0.3.24. Most of the changes
there have since been incorported in netbase (#735), and because of a risk for DoS'es
based on the much larger number of addresses an attacker could have under his control,
addrman (#787) was necessary before IPv6 could be fully implemented. So, the technical
part of supporting IPv6 seems mostly finished - right now, it's mostly just removing
some (!IsIPv4()) checks and adding listen/connect code that is IPv6-compatible.
I'll do a pullreq for that soon.

There are a few other issues, though. For example: how will relaying work: will IPv4
nodes relay IPv6 addresses? If not, the IPv6 bitcoin network will be completely
separate from the IPv4 one, though both may overlap in some points. The opposite is
also possible: allowing all nodes to relay IPv6 addresses, but only use them in case
an IPv6-compatible interface is detected. Any opinions about this?

Something else was suggested by Jeff: what if a node accidentally connects to itself?
As we're moving towards multiple local addresses with IPv6, the chances for this
become larger. Finally, there are always extra risks involved, as we could unknowingly
be opening DoS or others vulnerabilities.

Finally, supporting IPv6 in a somewhat general way would pave the way for bitcoin
functioning for example as a Tor or I2P hidden service, by using onioncat-like
tor-encoded-in-IPv6 addresses. This way, two bitcoin nodes could connect to eachother
without the need for passing any exit node.

-- 
Pieter


-------------------------------------

Good thing I can still spend, even with an incomplete blockchain :)


1) I'm not seeing an option to split the wallet, debug log and other
privates pathwise from the blockchain.
2) Because encrypt everything is reasonable standard practice.
https://en.wikiquote.org/wiki/Cardinal_Richelieu [ref: disputed quote]

BTW, logs for this box say at least 9 days were spent attempting to
crunch the most recent 3100 blocks before it was overrun with new
ones and retired. (There's no formal start timestamp, just some entries...)


-------------------------------------
I've been having a discussion with d'aniel from the forums about how
to handle the possibility of a majority-miner conspiracy to raise
inflation, if most economic actors use SPV clients.

Because of how blocks are formatted you cannot check the coinbase of a
transaction without knowing the fees in the block, and the fees can
only be calculated if you have all the input transactions for every
transaction in that block. Because the attack scenario is an attempted
takeover of the economy by miners, attempting to put hints into the
blocks won't work - we have to assume the hardest chain is in fact
wrong according to the rules signed up to by the Bitcoin user.

The most obvious goal for a cartel of miners is to change the
inflation formula, either for purely selfish reasons (they want more
money than can be obtained by fees) or due to coercion by
governments/central banks who still subscribe to the "inflation is
good" idea.

Whilst "good" nodes (still on the old ruleset) won't relay blocks that
violate the rules no matter how hard they are, in a situation where an
SPV client DOES hear about the bad best chain, it would switch to it
automatically. And who knows how the network might look in future -
perhaps most nodes would end up run by miners, or other entities that
upgrade to the new ruleset for other reasons.

d'aniel made a good proposal - having good nodes broadcast
announcements when they detect a rule that breaks the rules, along
with a proof that it did so. Checking the proof might be very
expensive, but it would only have to be done for split points,
limiting the potential for DoS. If a node announces that it has a
weaker chain and that the split point is a rule-breaker, the SPV
client would download the headers for the side chain to verify the
split, then download all the transactions in the split block along
with all their inputs, and the merkle branches linking the inputs to
the associated block headers. In this way the fee can be calculated,
the inflation formula applied and the coinbase value checked.

If the block is indeed found to be a rule-breaker, it'd be blacklisted
and chains from that point forward ignored.

Miners may decide to allow themselves to create money with
non-index-zero transactions to work around this. In that case the good
node can announce that a given tx in the rule-breaker block is
invalid. The SPV node would then challenge nodes announcing the longer
chain to provide the inputs for the bad tx all the way back to a
pre-split coinbase.

Doing these checks would be rather time consuming with huge blocks,
but it's a last resort only. In the absence of bugs, the mere presence
of the mechanism should ensure it never has to be used.


-------------------------------------

We are not establishing an IETF working group, which is an option that
was explored prior to the Paris meeting and has been sidelined at
present for depth-of-bureaucracy by the backing commercial entities.
Rather, we are establishing a top-level IANA registry group. This is
not anticipated by the IETF old-guard working with us to be either (a)
controversial or (b) possible to block.

- Walter


-------------------------------------
On Mon, Dec 3, 2012 at 5:26 PM, Roy Badami <roy@gnomon.org.uk> wrote:

His point (pun intended) stands.  SMTP uses "." terminator, which also
causes annoying confusion.

You shouldn't need to escape and unescape data that is not being
interpreted in any way.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I tried this and got:

./bitcoind listaccount:
{
}

bitcoind getnewaddress
1DumTDw6quNqnUegJsXL2AJjDA9fmxRY7o

./bitcoind setaccount 1DumTDw6quNqnUegJsXL2AJjDA9fmxRY7o test

./bitcoind listaccounts{
   "" : 0.00000000,
   "test" : 0.00000000
}

Seem like the default account ( "" ) need to be initialized ?? Will test the same with the old client and see if it behaves similarly..

/M


On 27/02/2012, at 20:03, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
On Saturday 16 Jun 2012 07:45:00 Wladimir wrote:

It's less of a problem in a (nearly) stateless protocol like Bitcoin.

I like the idea of a capabilities command; as time goes on and the ecosystem 
of thin/spv/semi-thin/headers-only/blocks-on-demand/reverse-search-
blockchain/memory-pool-query clients becomes more varied, it's going to be 
more an more important.  The particular example that occurs is thin clients 
connecting to the network are going to want to ensure they are connected to 
at least one non-thin client.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------

Hardly. I don't have any particular timeline in mind. But I disagree
we have "forever". New ideas have a certain time window to take off
and become credible. If they never overcome their problems in that
time window, eventually people just give up and move on. Does anyone
take desktop Linux seriously anymore? No. "The year of desktop Linux"
is a joke. People took it seriously in 2001 but despite great progress
since, the excitement and attention has gone. There were steady
improvements over the last 10 years but nobody is creating desktop
Linux startups anymore - Bitcoin shouldn't go the same way.

It's unclear we need to have every man and his dog run a full node.
Tor is a successful P2P network where the number of users vastly
outstrips the number of nodes, and exit nodes in particular are a
scarce resource run by people who know what they're doing and commit
to it.

The Tor guys could have said "every node should be an exit if
possible", but that would have been a short term optimization at the
cost of long term stability, and anyway doesn't seem to have been
necessary so far. Even with no incentives, they were able to obtain
the resources they need.

So why should Bitcoin be different? If there are a million users
supported by 50,000 full nodes, that wouldn't sound unhealthy to me.
We can easily send a clear and consistent "this is important, please
help" message without complicated auto-upgrade/downgrade schemes that
risk annoying users.


-------------------------------------
While happily processing these:
received block ...
SetBestChain: new best=...  height=...  work=...
ProcessBlock: ACCEPTED

bitcoind very often refuses to answer rpc queries such as getinfo/stop,
or signals such as kill/ctrl-c. It even registers:
 ThreadRPCServer method=getinfo/stop
in the debug log. But the action doesn't happen as expected.

Shouldn't it be checking and processing all user interrupts like
once per block and doing the chain in the background?

How do busy commerce servers deal with this poor rpc handling?

Is there a way to increase the priority of user scheduled tasks?
What's going on? Thanks.


-------------------------------------


I strongly agree, but this is *why* I suggested moving it to the wiki. I
recently had to choose an XMPP client and I looked on xmpp.org - after a
frustrating experience with their listing [1], I went to Wikipedia who
have an decent feature-based matrix [2].

(There may be better examples, but I'm using this one, because this
actually did happen.)

This is just anecdotal, but there are some reasons why wikis tend to do
a better for this kind of thing is because they are:

- more up-to-date (anyone can update them)
- more in touch with users:
  -> Users can edit the page and add a column to a feature matrix for
example).
  -> The editing discussions include users. I guarantee there are more
Bitcoin end users with a wiki account than a Github account.
-  immediately recognizable as a wiki (thanks to Mediawiki/Wikipedia.)
As such many users will correctly treat and interpret the information
presented as community-generated and fallible.

So they are more user-oriented in the sense that they will be influenced
by a diverse set of backgrounds and views vs. a Github based page which
will be dominated by developers. If you want to see "the result of
internal politics", the current client page is a good example. We
couldn't agree on the columns for a feature matrix, so now we just have
walls of text. Some of the options that are de-facto the most popular
with users like BlockChain.info or just using your MtGox account are not
mentioned at all. When analyzing client security, Greg discussed
counterparty risks but ignored other risk factors like default backup
behavior and the usability of security features.

But even if I grant you that those clients' overall risk profile is
worse than Bitcoin-Qt's, maybe I'm happy to take that risk in exchange
for less setup/maintenance effort. Based on our support requests at
WeUseCoins I know that there are tons of users with < 1 BTC in their
wallets. If my hourly wage is 20$ and I have 20$ in my Bitcoin wallet
then spending one hour per month downloading/updating/figuring-out the
client is equivalent to a total loss.

The list is obviously designed by open-source developers and that's
fine, it's bitcoin.org, arguably we *should* try to push users in a
specific direction, arguably we *should* err on the side of caution in
order to not be caught recommending a hosted wallet that gets hacked.
But if user orientation is supposed to be the focus, then the wiki will
both allow us (because it's less "official") and force us (because users
will have a say) to include even clients we personally wouldn't use. :)


[1] http://xmpp.org/xmpp-software/clients/
[2]
http://en.wikipedia.org/wiki/Comparison_of_instant_messaging_clients#XMPP-related_features





On 7/9/2012 8:30 PM, Mike Hearn wrote:




-------------------------------------
On Mon, Jul 9, 2012 at 11:21 AM, Amir Taaki <zgenjix@yahoo.com> wrote:

yes:

http://code.google.com/p/bitcoin-wallet/
and it is built upon
http://code.google.com/p/bitcoinj/

harald


-------------------------------------
On Fri, Oct 26, 2012 at 10:21 AM, Mike Hearn <mike@plan99.net> wrote:

Which happens and is a concern. Altcoins have been attacked on things
we fixed. For example, litecoin nodes were being run out of disk space
through addr.dat flooding.

I think we've been generally fortunate that the level of griefing is
low (though not non-existent).  But part of the reason its been low is
that it's probably harder to DOS attack bitcoin than you believe. In
the reference client a lot of work has gone in to removing attacks
with sublinear cost for the attackers.

That people aren't attacking much now is not an argument to accept a
new vulnerability much less a _normative_ vulnerability in the
protocol.

That it's no big deal even attacked would be a fine argument to me, so
I'll go try to convince myself of that.


Please don't put that kind of black helicopter junk in my mouth. I
agree with you the point that these aren't a source of concern for me.


-------------------------------------
I hope that this input does not come too late; I haven't had time to review
the proposal until now.

For alt-chains that have time-varying value (Freicoin[1], currently), it is
necessary in some applications to include a "reference height" in the
invoice. Since the bitcoin protocol does not assume a universally
agreed-upon time source, Freicoin (and presumably other
yet-to-be-implemented time-varying chains) uses blocktime as the clock for
time-value calculations: outputs lose 2**-20 of their value with each
passing block. The reference height for an invoice is the blocktime at
which amount values are specified and the reference point for time-varying
calculations. As a concrete example, an invoice for payment of 50 frc today
could be satisfied by 49.99313402 frc tomorrow.

To implement this, we would require an optional "uint64 refheight" field in
the invoice structure. "refheight" or "nRefHeight" is what we call this
value internally, but "blocktime" or "blockheight" would work as well.

Github is currently down, so I apologize if a suitable field has already
been added.

Cheers,
Mark Friedenbach

[1] http://freico.in/ "Freicoin: a P2P digital currency delivering freedom
from usury."


On Mon, Nov 26, 2012 at 2:37 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:

-------------------------------------
I found that the problem is the version of the Qt SDK I used didn't
like the new MacOS version. Re-installing Qt fixed it.

On Mon, Nov 26, 2012 at 4:05 PM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
OK, here is one thing:

what is the purpose behind counting the number of sig ops after you have executed the script in ConnectInputs?
Seems like it would be too late then.



----- Original Message -----
From: Gavin Andresen <gavinandresen@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: Bitcoin Dev <bitcoin-development@lists.sourceforge.net>
Sent: Saturday, January 7, 2012 10:48 PM
Subject: Re: [Bitcoin-development] Pull 748 pay to script hash


I count the 1 major merge then 8 commits to fix bugs or tweak
things... I just tried reverting them and stopped when I got scared
I'll accidentally revert a fix we do want to keep.

Instead, I updated my gavinandresen/master github branch to the state
of the tree just before the OP_EVAL merge, so for code review purposes
you can look at:

https://github.com/gavinandresen/bitcoin-git/compare/master...pay_to_script_hash

There are unrelated 0.6 pulls in those changes, too, but it should be
pretty obvious what is what.

-- 
--
Gavin Andresen



-------------------------------------

Copy/paste error in the does :(

about the output script in its entirety?

It's an informal way to say data elements. If you insert a key then it
matches both single and multi sig outputs regardless of location.


We think probably not.
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 01/10/2012 14:52, Arklan Uth Oslin wrote:

Nice one, I worked in games for quite a few years. (before getting
into finance then pentesting) there are about 6 keen testers now.
maybe we should get a bitcoin-test mailing list, where we can discuss
stuff without disturbing the dev team.


Great question... for me I feel structure is the most important thing
to sort out first.  However we desperately need detailed testcases for
the release of a new version. - Not too much on the change log stuff,
more on the noddy stuff (as gavin points out below), downloading and
making sure it works on a non dev machine, make sure the wallet isnt
overwritten, etc.) doing games qa I imagine this would be an ideal
place for you to start.  I have a MSDN and TechNet licence so if you
need some reference ms virtual machines I can help you out.

However we need some testcase software.  Please check out what was
done on bettermeans for the stuff I was planning out...

It details everything from recompense and testcases. bettermeans kinda
died a death though...

check out:

Bitcoin over all-
https://secure.bettermeans.com/projects/4180/wiki/Page_index
discussion
https://secure.bettermeans.com/projects/4180/boards

0.7
https://secure.bettermeans.com/projects/4256/boards
and
https://secure.bettermeans.com/projects/4256/wiki

I still have the testcases, but until we get some proper testcase
software I am loathed to publish them in a half arsed format. (they
worked well on bettermeans, then just vanished one day...) what
testcase software are you familiar with?

apart from that, what do you feel you can do for the project? how long
have you been involved in bitcoin?  It may well be worth reading up
all the dev stuff on the wiki so you can get you head around how the
bitcoin protocol is different from the daemon and qt client. What do
you think you can and will enjoy doing? What is your skill set in
regard to networking, crypto and operating systems. (not that you need
any, in any we still want and need you. :)

there really is room for you to do whatever role you want, and as
little or as much as you want - however funding is now a very tricky
issue. so much so that I am not sure I want anything to do with
it(distribution of coin based on work.). - I just paid for some logo
spec work out of my own pocket (for example).  I have some testers i
know irl who are willing to work for coin.

NOTE: This response has nothing to do with the bitcoin foundation.  I
am not a member of the foundation. I do not speak for them or even
probably with them. I am still trying to work out how much qa the
foundation should be responsible for, and/how it is supposed to work.
I think the games cert process would be ideal for this.  This however
this a discussion that probably wont have my involvement.  (personally
I believe that the foundation should publish requirements with example
code and testcases for each aspect of the reference client. (on
reference platforms - I do not expect many to agree with this though)

As a side note, what happens to the donations to the bitcoin testing
project? do they get moved over to the foundation? this question is
bigger than this email. as far as I know they are all on an address
Gavin holds. Actually I would like to be involved in any discussions
that would impact QA, does this mean I need to join the foundation or
just go lone wolf?

tbh I dont really understand foundations.  I always thought they were
just a tax dodge.

Sorry for the long message. :)

How fast is your code?
Got visibility?

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://www.enigmail.net/

iQEcBAEBAgAGBQJQaaieAAoJEFvEB9dQFvtQUi0H/3Eh72DqxwBt6AeNos/hJNqQ
ZowMNFRupJQM301EJ7SPQmcnVuc3RF2Jw//ckpAqdpkqhHCgGO9HX/q+Ic2A9erQ
CfKbUOwQgqKuLQTZ8eT5UMh969Uw8PMazo711d2I23etU0VhSK/MvjB5IiYIq5fB
RJdCEluwvACaiftqfm4RA9HXXJGMnsZtlSWjVQCkg2FyYZKfpctEFdGCg6R8IaP7
ypyglR7TfygcjhUMHeWkQQCP2m2gBOHpx9H99uNBosF+6pLBhCiGUrwVkl8HUiiN
4YfhsvoRQ0BWNgvO9wH1H4EyyZtJsE7S926BNkhd4uewWGV/qe8gML+uJRstPDg=
=L66i
-----END PGP SIGNATURE-----


-------------------------------------
Summarizing a discussion from #bitcoin-dev this morning:

The merge window for pull requests for a 0.6.1 release is now open.

This will be a bug-fix and code-cleanup only release, with the goal to
have Release Candidate 1 binaries available for testing in three
weeks: April 23'rd.  We want this to be a quick release cycle so we
can start pulling new features for a 0.7 release in a month or so.

The major issues I would like to get resolved:
 # 1024 Correct passphrase crashed the client
 # 1012 bitcoin-qt slow to shut down after recent commits

There are currently 189 open issues in our bug tracker; lets try to
get that down to under 100.

I know this will frustrate some of you who think development is
happening at a snail's pace; feel free to pull and test new features
(IPv6 support and coin control) that are important to you. Adequate
testing is still our biggest issue, if you want your favorite feature
to get into bitcoin core faster please spend some time helping test
other people's favorite features.

-- 
--
Gavin Andresen


-------------------------------------
On Saturday, March 03, 2012 9:23:08 AM Stefan Thomas wrote:

You mean explicitly mention the getwork longpoll protocol as part of the 
getmemorypool BIP? Probably a good idea.


HTTP and JSON-RPC are a client-server model; there is no way for the server to 
make calls to the client. It's not practical to expect clients to run their 
own JSON-RPC server - many cannot listen on WAN ports at all.


-------------------------------------
On Tuesday, November 06, 2012 6:47:34 PM Gavin Andresen wrote:

Not much has changed besides internal workings, right?
Though perhaps that's still significant enough for 0.8.


Amir seems to be more and more absent these days, so it might be nice to setup 
a successor failsafe in the event that he cannot be reached. It would be a 
shame for the BIP process to fall apart merely because we can't get numbers 
assigned.

But more important to the success of BIP today, I think, is encouraging wider 
community participation. The stratum mining mess seems to be a direct result 
of lack of participation in the GBT BIP process (resulting in it not being as 
ideal as some pools desire) and lack of any peer review/contribution toward 
the stratum protocol. What can we do to increase awareness of BIP and 
encourage more collaboration?

Luke


-------------------------------------
It certainly wouldn't hurt if there was a way to use OP_MULTICHECKSIG 
with hash160 values instead... I doubt that's workable, though.

At the moment, I feel that the copy&paste size problem is much smaller 
than the risk we take implementing such a huge change to the network.  I 
almost feel like, we should have multi-sig in place, thoroughly tested 
and available, as something to fall back on if something goes wrong with 
BIP 13/16/17 after implementation.  After all, I've been promoting the 
idea of considering the "cost" to fixing an erroneous/insecure 
implementation, as consideration for the proposals at hand.

But gmaxwell has expressed some compelling reasons why plain multi-sig 
might be abused, which maybe suggests we don't want it ever considered 
standard...?  I guess I'm not really promoting one thing or another, but 
I feel like copy&pasting is not a big deal (after all, it exists to 
moving large amounts of data around).  Then of course, I use 
home-shift-end all the time, and regular users may not be so adept at 
copying long strings.

-Alan



On 01/29/2012 12:10 AM, Amir Taaki wrote:



-------------------------------------
In other words when we roll out the update, we have to make sure we have
other words we just have to be very, very vocal about the change when it
happens and make sure miners are all on board.

Matt

On Wed, 2012-02-29 at 22:05 +0000, Ben Reeves wrote:





-------------------------------------
Coinbase scriptSigs aren't required to be well-formed. They're
never executed.


-------------------------------------
This is a good idea. I think I can come up with the cash, I will
follow up with gavin.

Sent from my smartphone!

On Jul 29, 2012, at 7:18 PM, Mike Hearn <mike@plan99.net> wrote:



-------------------------------------
Matt Corallo posted a modification of BIP 20 in an earlier email and I asked him if he wanted to become the champion of that BIP he submitted.

It is a modification of BIP 20 sans the alternative non-decimal number stuff.

https://en.bitcoin.it/wiki/BIP_0021


Right now, I will ask the GUI client implementations like MultiBit or Bitcoin-Qt, not different codebases like BitCoinJ or libbitcoin if they support BIP 20 or BIP 21. Feel free to raise any objections.

More weight will be given to GUIs with actual URI scheme implementations and it's good to have a general consensus.
-------------------------------------
On Thu, May 24, 2012 at 8:51 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

It's important to understand the motivations before acting— otherwise
you'll fail to do anything useful.

E.g. if they're empty because some miners want to drive up fees or
fight against the rapidly increasing blockchain size there isn't much
you can do there.

If they're empty because they're mined by botnets which don't have a
local copy of the chain in order to load their victims less (and avoid
central pooling) then you want something like
https://bitcointalk.org/index.php?topic=68396.0

If they're produced by people who think they gain a mining speed
advantage by not including them then then we need education— dropping
their blocks won't help much: we've seen miners go a month with 100%
of their blocks being orphaned.


-------------------------------------
On Tue, Jun 19, 2012 at 11:05:20AM +0200, Mike Hearn wrote:

I'm all for moving away from BDB. It's a very good system for what it is
intended for, but that is not how we use it. The fact that it is tied to
a database environment (but people want to copy the files themselves
between systems), that is provides consistency in case of failures (but
because we remove old log files, we still see very frequent corrupted
systems), the fact that its environments are sometimes not even forward-
compatible, ...

Assuming LevelDB is an improvement in these areas as well as resulting in
a speed improvement, I like it.


How portable is LevelDB? How well tested is it? What compatibility
guarantees exist between versions of the system?

I don't mind including the source code; it doesn't seem particularly
large, and the 2-clause BSD license shouldn't be a problem.


Jeff was working on splitting the database into several files earlier, and
I'm working on the database/validation logic as well. Each of these will
require a rebuild of the databases anyway. If possible, we should try to
get them in a single release, so people only need to rebuild once. 

PS: can we see the code?

-- 
Pieter


-------------------------------------
On Mon, Jan 16, 2012 at 9:12 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:


Agreed, a notice would be enough. No need to make the entire site
inaccessible either.

Wladimir
-------------------------------------
I think Alan's list of 'what should an ideal first client look like' is
right here.

relatively quickly but still have the safety of a deterministic wallet
then they should have a good first user experience. MultiBit is not
there yet, but BIP32 support is on the roadmap.

If we have a 'shopping list' of what we want in a first client then that
gives me (and others) a list of what to focus on implementing.

Also, as BIP32 support is added to clients and codebases then the actual
variant of software to use to access your wallet will become relatively
less important. Combined with a standardised seed -> passphrase
algorithm the user can just type in their long passphrase into any BIP32
compliant software and click/ buzz/ whirr : there is their wallet. We
should have a little logo for HD wallet compliance ! :-)

As Bitcoin's users become more varied there will be a spectrum of how
'involved' they want to be computationally so we should have offerings
to reflect this.



On Tue, Dec 4, 2012, at 07:09 PM,
bitcoin-development-request@lists.sourceforge.net wrote:


-- 
http://multibit.org    Money, reinvented


-------------------------------------
On 2012 January 31 Tuesday, Luke-Jr wrote:


I imagine the BIP16 supporters would say the same?  Isn't that the essence of 
the current impasse?


My suggestion is backward compatible.  You'd only have to make version2 
transactions for version2 addresses; and the join between version1 and 
version2 is not a problem since the version1 source can be detected, and the 
handling of the version2 transaction altered as appropriate (it's only a 
matter of switching from the hash check to running the two scripts as 
normal).



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Sat, Jan 07, 2012 at 08:12:35PM -0500, Gavin Andresen wrote:

Uhm, was it? I just added some unit tests though.


Very true; compressed public keys are 32 bytes smaller (so more keys
fit in a script), and are about 5% more CPU intensive to verify.

-- 
Pieter



-------------------------------------
https://en.bitcoin.it/wiki/Clients


-------------------------------------
On Tue, Nov 27, 2012 at 9:43 AM, Michael Gronager <gronager@ceptacle.com> wrote:

I think this is a problem with confusing terminology rather then the
spec itself.

The original formulation had a receipt being something generated
purely by the buyer. The signed Invoice message  + the Bitcoin
transactions paying to the outputs + the merkle branches showing
acceptance by the network *is* the receipt.

The SignedReceipt message is useful in the sense that it shows
confirmation by the merchant, but if you don't get one, you can still
prove you paid the invoice. So from this perspective perhaps
SignedReceipt should be renamed to Acceptance or something like that,
and then the spec should call out that a signed invoice plus accepted
Bitcoin transactions is mathematically a proof of purchase.


-------------------------------------

Yes, but at the cost of privacy. Generators of payment requests always
have the option of just adding a single output and being done with it.
But in future they'll probably want to keep their income in unlinkable
chunks of a size that's up to them, and multi-outputs are needed for
this (the idea being, the users wallet tries to keep a
close-as-possible match between the requested outputs and their own).

OK, let's punt on tipping for now.


I see. If I were to implement a wallet I'd just display nothing
(except the size of the request). Showing an address doesn't really
help the user in any way.


The hoops only actually apply for EV certs though, they aren't
required to do that verification for DV certs.

The main reason to use the browser root CAs is that merchants are
guaranteed to be able to re-use their existing certs. Otherwise they
might have to buy new ones, which would be annoying.


-------------------------------------
On Wed, 2012-09-26 at 13:28 +0100, steve wrote:
For a mantis plugin, sure, I guess...
Jenkins currently just runs the test script after each new commit to
bitcoin (and provides binaries to anyone who wants them), so its pretty
basic (though jenkins has way more features than we use).  The bitcoin
one lives at http://jenkins.bluematt.me/
We currently keep a changelog at https://en.bitcoin.it/wiki/Changelog (I
went back and added tons of logs a while back and it got updated, though
0.7 seems to be missing...) anyway, automating that would be nice...
Having more info on that changelog page would be nice.
I have been meaning to catch up with the various attempts at better
bitcoin testing that have started up a few times, but I keep never
getting around to it...
Even if unit tests are considered separate, having it all run in one
huge test script makes it quite easy to implement new things (like
pull-tester) which test some arbitrary bitcoind commit in the same way
as every other tester.  
The BitcoinjBitcoindComparisonTool.jar file which is run as a part of
the test scripts tries to hit as many block acceptance edge cases as
possible (I'm sure I missed a ton, but it hits a lot too).  I've also
been pushing alternate implementation implementors to use it to test
their own implementations.
As far as I'm concerned more test cases are more test cases, it may get
unwieldy to maintain, but at least we'd have more test cases :)

In terms of general testing strategies, I really prefer to script it
all, jenkins is quite nice in that it can have slave workers using a
different OS which run their own tests and then report back to the main
jenkins instance.  Getting a real Windows slave to run the installer and
test that thoroughly as well as basic Mac things (I know OSX uses a very
different build system...) would be nice (though I dont really have time
to write all those tests...)

re: GUI testing is hard: I've heard Qt's unit test framework is really
powerful and can even include things like click scripting and analysis
of the current views (though, I agree, its still no doubt hard).  

Matt




-------------------------------------
The thing that bugged me most about the original spec was the sole reliance
on X.509 - glad to see you've made that optional.  I think many people will
balk at deferring our identity trust to the existing CA's.  I think it's a
fine bootstrap method, but I'd really like to see another option that
allows for out-of-band trust (based on ECDSA, probably).

It would also be really nice to migrate to textual representations of data
structures as opposed to binary ones.  The most successful internet
standards are based on text, making them that much more accessible for
developers to deal with them.   JSON would be my preferred candidate.

Why don't we sign the text representation of a (utf8) JSON, rather than
some complex encoding standard of JSON?  That way the signatures are simple
- and you need only retain the original textual representation of a message
to validate the signature (as well as the decoded version, if you don't
want to alway re-parse the message when writing programs that use it).

On Sat, Dec 1, 2012 at 11:25 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:




-- 
Mike Koss
CTO, CoinLab
(425) 246-7701 (m)

A Bitcoin Primer <http://coinlab.com/a-bitcoin-primer.pdf> - What you need
to know about Bitcoins.
-------------------------------------
Hi Martinx,

I am looking into it now - I just tried on my Ubuntu 11.10 - I got by Script.cpp with no problems.

I have Boost 1.48.1, but I can't see that causing the issue - I will retry with a cleaner machine...

/M

On 23/02/2012, at 18:31, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
Some concerns regarding Bloom Filters. I talked with Stefan Thomas on 
the Hackathon Berlin about this.
I tried to follow the discussion closely but i have not taken a look at 
the code yet (is there already an implementation?) so please correct me 
if i got something wrong.

The way the Bloom filters are planned now this requires a complicated 
setup. basically the client will ask the server to replay the whole 
blockchain, but filtered.
This is not optimal for the following reasons:
This will require the server to do a full scan of his data and only 
filter out non-matching entries.

Really lightweight clients (like Bitcoincard), clients with shared 
private keys (electrum-style), or brainwallets - will ask the following 
question quite often to "supernodes": Given my public keys/addresses, 
what is the list of unspent outputs. i think it would make sense to 
include such a command, instead or in addition to the filterload/filterinit.

And perhaps more severe: as far as i understand classic bloom filters, 
the server has no method of indexing his data for the expected requests. 
There is simply no data structure (or maybe it has to be invented) which 
allows the use of an index for queries by bloom filters of *varying 
length* and a generic hashing method.

im not sure what a really efficient data structure for these kinds of 
query is. but i think it should be possible to find a good compromise 
between query flexibility, server load, client privacy.

one possible scheme, looks like this:

the client takes his list of addesses he is interested in. he hashes all 
of them to a fixed-length bit array (bloom filter) of length 64KiB (for 
example), and combines them with | to add more 1's with each address.
the server maintains a binary tree data structure of unspent outputs 
arranged by the Bloom filter bits.
to build the tree, the server would need to calculate the 64KiB bits for 
each address and arrange them in a binary tree. that way he can easily 
traverse the tree for a given bloom query.
if a client whishes to query more broadly he can calculate the bloom 
filter to 64KiB and after that fill up the last 50% of the Bits with 1. 
or 95%. the trailing 1 bits even don't need to be transmitted to the 
server when a client is querying. of course, if the client is more 
privacy-concerned he could also fill up random bits with 1, which would 
not change much actually.

the value of 64KiB is just out of thin air.
according to my experimentation using BloomFilter from Guava - 
currently, also 8KiB would be sufficient to hava a 3% false positive 
rate for the 40000 active addresses we have right now.

someone more familiar with hashing should please give his opinion if 
cutting a bloom filter in half has any bad consequences.

Andreas


-------------------------------------

Bitcoin-qt is translated into a pretty broad set of languages (now— I
cant tell you how many of them are _good_). Listing language just
under multibit makes it sound like a distinguishing characteristic.
Might it be useful to add two info lines to each entry:  One with the
language codes it supports (ISO 639 please, not flags),  and another
line with operating system support? (perhaps not, they're all
win/mac/linux, enh?)   These are both things which are particular
suitable to clear objective enumeration.


-------------------------------------
I hope you all take a moment to see what DANE leverages with DNSSEC
and SelfSigned x.509 certs. DANE provides the capability for any
entity to associate a self signed certificate with a domain name. This
capability removes the critical path of whitelists and/or Root CA
certs.

Another nifty thing is that it can associate a cert to a domain and a
payment address, if one were to put said address in the DNS :)

Now I am sure the majority of the bitcoin user-base desires anonymity,
but as a merchant I would like to be knowable and wouldn't mind it if
my identity and those of my transactions were "known" and associated
both with my domains and x.509 cert. In most commercial transactions
(which include many of those that leverage invoices) identity is
important, at least for the merchant.

-rick


On Mon, Nov 26, 2012 at 3:52 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:


-------------------------------------
On Thu, Mar 1, 2012 at 8:09 AM, Ben Reeves <support@pi.uk.com> wrote:

I am not following you here, can you explain what you're thinking?


Because this would make it impossible for nodes to prune the vaules.
They'd all forever have to keep a set of all the coinbase hashes in
order to perform the test. The height-in-coinbase BIP will make
duplicates effectively impossible to create, which is a much more
clean behavior.


-------------------------------------
I see. That is undeniably more secure and "bitcoin-y" than my suggestion.

It's also really a lot more work, especially in that it requires extra
linkages between codebases that in my mind are largely separate.

I'm just one voice, but I persist in believing that the 'lighter' solution,
especially for something that may not be a particularly big problem in the
bitcoin world is good -- it carries much less technical implementation debt
going forward, and has a lower risk of sort of seizing up development with
additional necessary code to worry about for those implementing to-spec
clients.

If that lighter solution turns out to be gameable, or has problems that
require the full force of the bitcoin network and concepts, that would be
the time to implement the improved version. That's just my approach,
however. I worry that building in any additional requirements to the
protocol or codebase adds significant cost to the network as a whole over
the next 10 years.

Peter

On Tue, May 29, 2012 at 11:39 AM, Luke-Jr <luke@dashjr.org> wrote:




-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------

Further, bitcoin doesn't allow easy separation of the files without
detachdb (off by default), nor does it supply a user agnostic system
daemon to do the block processing separately from user wallet ops.
So I would suggest until then it remain split up somewhere under
.bitcoin rather than in /var or anywhere else.


-------------------------------------
Messages over 40Kbytes big require moderator approval on this list; if
you want your messages to appear promptly, please trim excessive
quoting before hitting send.

Thanks!

-- 
--
Gavin Andresen


-------------------------------------
On Thu, Aug 16, 2012 at 01:32:04PM -0400, Jeff Garzik wrote:

I like the idea of being able to query the memory pool of a node; the
implementation is straightforward, which is good. Maybe effectively using the
command can be added? I suppose it is interesting in general for nodes to
get a memory pool refill at startup anyway.


I'm not sure about this last. What is it good for? inv packets can always be
sent, even not in response to others, so it is not that this gives you an
acknowledgement the mempool is updated?


This seems safe, although it forces other full implementations that want to
expose protocol version 60002 (or later) to also implement this. What do they
think about this?

I would like to suggest to allocate an extra service bit for this. We still
have 63 left, and this is a well-defined and useful extra service that was
not yet provided by any earlier node. Doing that would also mean that
mempool-providing survices may be discovered before connecting to them, as
the service bits are carried around in addr messages. Any opinions about that?

-- 
Pieter


-------------------------------------
On Thu, Nov 29, 2012 at 12:31 PM, Mike Hearn <mike@plan99.net> wrote:

This brings up an additional point.  If we're mutually trusting
parties (or secured by some kind of external mechanism), and you've
given me a payment which I haven't broadcast for confirmation— and
later we make another transactions I should be able to offer you the
original unconfirmed txn and ask if you'd instead be willing to write
a replacement that combines both payments.


-------------------------------------
On Fri, 2012-06-15 at 15:43 +0200, Mike Hearn wrote:
ACK
If vector<hash> is sorted in the order of the merkle tree, you dont need
to forward the merkle tree to non-filtered nodes, further saving some
small amount of bandwidth.  For filtered nodes, you would still need to
forward merkle branches anyway.
ACK
I really dont think it would be /that/ difficult to make it getmerkletxs
vector<hashes>. And then respond with a partial merkle tree to those
transactions.

Matt



-------------------------------------
My personal opinion is that the ideal first client has three features:

(1) Starts up and is usable within a couple minutes (even 10 min the first
time would be okay, to sync block headers)
(2) Supports Windows, Linux and OSX
(3) Uses deterministic wallets that can produce a permanent backup
(preferably paper)

Encryption is a major upside, too, but people new enough to Bitcoin that
they need such a simple client, can survive without encryption (thye're not
going to be holding a ton of coins) -- as long as they are made aware that
they do not currently have encryption, and the associated risks (and other
options).

I think it's extremely important that users have a clear way to backup
their coins to offline media or paper, in such a way that they don't ever
need to worry about it again.  Not only does it give users protection
against hard-drive loss, it means that they may find it again in the far
future when they haven't used Bitcoin in 2 years, and it reminds them that
they still have coins (and they don't have to type in 1000 private keys to
get their coins)

For that reason, I think Multibit is an excellent choice.  I haven't spent
much time with it, but I do understand it to  satisfy (1) and (2) clearly,
and (3) may be happening in the near future (along with encryption).  But I
do wonder if it has enough staffing behind it to be the center of attention
(no offense to jim618, but if this becomes the "de-facto" client for new
users, we should make sure there's a lot of people available to support it
-- what if a major security bug is found?  how long would it take the
current team to identify, fix and test that bug?)

-Alan


On Tue, Dec 4, 2012 at 12:46 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------

I agree this is a very pertinent subject, and with a bit of looking
around it is clear that there is a requirement here for emerging
financial ecosystems of many types, certainly not just for the Bitcoin
community, which until now seems to have been getting along just about
OK despite the current levels of complexity.

That said, I have a number of serious concerns with the proposal.

1. Undue Broadening of Scope: From an architectural perspective, if
one accepts the unix mantra of "do one thing and do it well" as
reasonable and time-proven doctrine, given that Bitcoin is already
trying to be both a commodity and a distributed consensus-based
settlement system, does it really make sense to attempt to tack-on
business-level functions?

2. X.509: I have read (somewhere or other, recently) that it is
generally considered bad form to mandate specific cryptographic
systems in new protocols where open support is possible. Given the
recent issues with X.509, the security nightmare that already exists
with the volume of (sometimes cracked, sometimes
government-compromised?) issuers, and the complexity of the scheme, it
seems a little strange to singularly mandate X.509, despite its
widespread use at present.  There are also a swathe of potential
issues around DNS interdependence, information leakage within
certificates themselves and/or their DNS-interpretation by clients,
etc. I would consider suggesting open support with initial support for
GPG, as it is apparently preferred as a simple and further
decentralized solution by the majority of the open source and
cryptographic software development community.

3. Failure to Review Existing Work: I would urge anyone to be wary of
adopting any proposal that does not inform itself through reference to
existing protocols in the same area.  In this area there are a few
protocols in current use (chiefly in Europe) such as those listed at
http://en.wikipedia.org/wiki/Invoice#Electronic_invoices as well as
various hosted platforms such as http://xero.co.nz/ (chiefly
Australia/New Zealand). Often, existing work shows its age with
after-the-fact alterations that sit poorly with initial assumptions:
exactly the kind of situation one can walk in to developing against a
proposal before adequately researching the area.

4. Complexity of Metadata: Physical and digital invoicing for
businesses operating at scale often requires delivery terms, product
classification codes, locale-specific taxation (often at multiple
levels), various fees and discounts (sometimes fulfillment-speed
linked with multiple tiers/thresholds), and other features that I am
skeptical are ever going to be made fully available within a business
protocol tacked on to a hybrid digital currency/settlement system
(like Bitcoin) as a secondary concern.

5. Non-BTC Currencies/Currency-like Commodities: No approach to
non-BTC currencies appears to have been made, which makes the
"invoice" of limited utility for almost all businesses, save those
willing to accept all of the 'capital risk' (exchange rate fluctuation
risk) inherent in a BTC-based fulfilment process with a potential term
long enough to justify an invoicing process. (Does this narrow scope
actually cover any existing business?)

6. DNS: As already mentioned with regards to X.509: a huge red flag as
an area of potential vulnerability, or at least information leakage.

I must now admit that in raising the above I am definitely biased.  My
employer (Payward, Inc.) and other organizations (OpenCoin, Inc.,
etc.) have been working with the Internet Engineering Task Force
(IETF) on tabling some open proposals within this area under the
auspices of the Internet Financial Exchange Project
(http://ifex-project.org/).  Our hope is to facilitate the requisite
standardisation within internet-connected systems to deal with what is
perhaps fairly characterised as a relatively heterogeneous outlook on
the rise of cryptographic (and other alternate) currencies and
commodities, and emerging settlement infrastructures.

Whilst the current Bitcoin proposal is admirable for correctly raising
the area as one of immediate concern, I hope that the above points out
some of the perhaps as-yet unconsidered complexities and draws in to
question whether Bitcoin is in fact the appropriate place to implement
a solution, given the hassles that will entail.  After all, wouldn't
Bitcoin developer time would be better spent improving the core of
bitcoin (ie. distributed settlement system and commodity) rather than
adding new features?

I would invite parties within the Bitcoin community with an interest
in non directly settlement-linked financial transaction negotiation
and reporting features to consider contributing to the existing,
re-usable efforts at the IFEX Project, rather than supporting the
extension of one currency/commodity and settlement infrastructure (ie.
Bitcoin) which IMHO is likely to detract from developer time, increase
complexity, and perhaps result in a less polished and re-applicable
solution overall.

Our proposals:
 - X-ISO4217-A3 (X-ISO4217-A3). A published proposal that provides a
mechanism for the open identification of currencies or currency-like
commodities on the internet.  (Bitcoin is registered as XBTC).
http://www.ifex-project.org/our-proposals/x-iso4217-a3
 - Internet IBAN (IIBAN). A published proposal that provides a
mechanism for the open identification of financial endpoints on the
internet. (IBAN compatible, checksum-included, name-squatting problem
avoiding. The registry of entities is IANA-managed, encourages GPG
use, and avoids the X.509 requirement.)
http://www.ifex-project.org/our-proposals/iiban
 - Internet MIC (IMIC). A published proposal that provides a mechanism
for the open identification of financial markets on the internet.
(Such as most Bitcoin exchanges)
http://www.ifex-project.org/our-proposals/imic
 - Internet Financial EXchange (IFEX). A proposal under development
that facilitates the negotiation of financial transactions between
internet-based financial endpoints. (The area we would love your
input) http://www.ifex-project.org/our-proposals/ifex

Sincerely and with the utmost respect for the Bitcoin project's excellent work,
Walter Stanish


-------------------------------------
On Tuesday, May 29, 2012 8:52:49 AM Michael Grnager wrote:

Please not JSON, and not hard-coded logic. Bitcoin already has a secure 
scripting system - perhaps we can decide on an initial stack format and run a 
script retrieved from the URI?



-------------------------------------
On Fri, Sep 14, 2012 at 1:27 AM, Wladimir <laanwj@gmail.com> wrote:

Indeed.  See many threads on the forum discussing this...  a
frequently requested feature.

As Wladimir says, it's a database constraint at the moment.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hello all,

wanting to move to IPv6 support in the Satoshi bitcoin client
somewhere in the future, the way IP addresses were managed is not
really possible anymore. Right now, basically all addresses ever seen
are kept - both on-disk and in-memory, and sorted on last-seen time
with some randomization. For some people this lead to multi-megabyte
addr.dat files that took ages (well, seconds) to load.

After some discussion with Gregory Maxwell and others on IRC, I
decided to write a specialized address manager based on an entirely
different principle: only keep a limited number of addresses, keep and
index them in-memory, and only occasionally (and asynchronously) dump
them to disk. This of course leads to a weakness: attackers may try to
poison your entire address cache with addresses they control, in order
to perform a Sybil attack. This is especially dangerous in the context
of IPv6, where much more possible addresses exist.

To protect against this, we came up with this design: keep two tables:
one that keeps addresses we've had actual connections with, and one
that maintains untried/new addresses. Both are separated into several
limited-size buckets. Each tables provides a level of protection
against sybil attacks:
 * Addresses in the first table are placed in one of only a few
buckets chosen based on the address range (/16 for IPv4). This way, an
attacker cannot have tons of active nodes in the same /16 range, and
use those to fill the table.
 * Addresses in the second table are placed in one of a few buckets
chosen based on address range the information came from, instead of
the address itself. This way, an attacker spamming you with tons of
"addr" messages can only still have a limited effect.
 * All crucial decisions (selection of addresses, picking a place in a
bucket, which entry to evict if necessary, ...) are randomized with
biases to improve efficiency. Selection of buckets is based on a
cryptographic hash using a secret key to deterministically randomize
behaviour.

The implementation is available in pull request 787
(https://github.com/bitcoin/bitcoin/pull/787), but there is certainly
need for testing, and room for improvements. Test reports, comments,
constructive criticism, suggestions and improvements are very welcome.

-- 
Pieter


-------------------------------------
Our divergence is on two points (personal opinions):

(1) I don't think there is any real risk to the centralization of the
network by promoting a SPV (purely-consuming) node to brand-new users. 
In my opinion (but I'm not as familiar with the networking as you), as
long as all full nodes are full-validation, the bottleneck will be
computation and bandwidth, long before a constant 10k nodes would be
insufficient to support propagating data through the network.  In fact,
I was under the impression that "connectedness" was the real metric of
concern (and resilience of that connectedness to large percentage of
users disappearing suddenly).  If that's true, above a certain number of
nodes, the connectedness isn't really going to get any better (I know
it's not really that simple, but I feel like it is up to 10x the current
network size).

(2) I think the current experience *is* really poor.  You seem to
suggest that the question for these new users is whether they will use
full-node-or-lite-node, but I believe it will be a decision between
lite-node-or-nothing-at-all (losing interest altogether).  Waiting a day
for the full node to synchronize, and then run into issues like
blkindex.dat corruption when their system crashes for some unrelated
reason and they have to resync for another day... they'll be gone in a
heartbeat.

Users need to experience, as quickly and easily as possible, that they
can move money across the world, without signing up for anything or
paying any fees.  After they understand the value of the system and want
to use it, they are much more likely to become educated and willing to
support the network with full node. 

-Alan




On 12/04/2012 07:27 PM, Gregory Maxwell wrote:



-------------------------------------
2 compressed pubkeys


----- Original Message -----
From: Amir Taaki <zgenjix@yahoo.com>
To: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Cc: 
Sent: Sunday, January 29, 2012 4:52 AM
Subject: [Bitcoin-development] Quote on BIP 16

Gavin said:
"Part of the controversy is whether really long bitcoin addresses would work-- would it be OK if the new bitcoin addresses were really long and looked something like this:57HrrfEw6ZgRS58dygiHhfN7vVhaPaBE7HrrfEw6ZgRS58dygiHhfN7vVhaPaBiTE7vVhaPaBE7Hr
(or possibly even longer)

I've argued no: past 70 or so characters it becomes a lot harder to copy and paste, a lot harder to scan an address with your eyes to see if you're paying who you think you're paying, harder to create a readable QR code, harder to upgrade website or database code that deals with bitcoin addresses, etc. There is rough consensus that very-long addresses are not workable."

How could you have a 70 byte long address without a P2SH scheme? Is this a mistake?

------------------------------------------------------------------------------
Try before you buy = See our experts in action!
The most comprehensive online learning library for Microsoft developers
is just $99.99! Visual Studio, SharePoint, SQL - plus HTML5, CSS3, MVC3,
Metro Style Apps, more. Free future releases when you subscribe now!
http://p.sf.net/sfu/learndevnow-dev2
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
of China, but sourceforge downloads are also blocked in China. Also
quite easy to bypass though.

I think it's easy to overestimate the problem. Users in these countries
(even non technical ones) quickly learn how to bypass hurdles in the
network. Although it would be great to host downloads on neutral
territory it might also be sufficient to provide the SHA256 of a malware
free binary...




-------------------------------------
Forum URL: https://bitcointalk.org/index.php?topic=112007.0

gmaxwell was talking about colored coins[1] in IRC recently.  They are
potentially interesting in the context of distributed bonds[2], which
I am currently pursuing with pybond[3].

Here is the problem I am trying to solve, does the crowd have an answer?

1. Alice transfers a 1-satoshi colored coin to Bob.
2. Bob transfers 100 BTC to Alice.  May be restricted to 1 txout, if
that eases implementation details.
3. Steps #1 and #2 happen as an atomic unit, all-or-none.
4. Alice and Bob must both approve this atomic transfer of coins, with
appropriate signatures.

Is this possible within the current bitcoin system?  As far as I can
see, the answer is "no" but maybe I'm missing something.

My best guess to the answer is "possible, but requires a new SIGHASH_* type"?

[1] https://bitcointalk.org/index.php?topic=106449.0
[2] https://bitcointalk.org/index.php?topic=92421.0
[3] https://github.com/jgarzik/pybond

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
It just occurred to me that the block version number could easily be used as a 
cheap "extra nonce" right now. Considering that we will probably see lots of 
ASIC miners running at 1 TH/s per rig before the end of 2012, it might be 
desirable to save the block version for this purpose.

The current block height in coinbase addition currently proposes to use block 
version 2. However, the protocol change is in fact to the coinbase 
transaction, not the block itself (which really doesn't have any extensibility 
without a hardfork anyway). Perhaps we should consider bumping the coinbase 
transaction version number to 2 for this instead?

Also, Jeff noticed that block 190192 has version==2 without a valid block 
height in the coinbase. I suspect this may be the result of combining the 
current blockheight-in-coinbase pullreq with P2Pool. This means that if we go 
forward with the version==2 marker, we will forever need to make an exception 
for that block. Moving the version==2 to the coinbase transaction version also 
means whoever makes that transaction (thus deciding whether to put the height 
in it or not) also sets the version number - instead of the block version 
coming from bitcoind and the coinbase transaction coming from P2Pool or other 
software.

Thoughts?

Luke


-------------------------------------

I'll be trying your implementation soon. And libbitcoin/subvertx too.
Partly because they're also non-interpreted, and partly to what seems
better architected...

To the minimal extent of my understanding... I'd like to see wallet
ops completely separated from background chain ops. ie: have
a chain daemon doing it's thing, updating, verifying, etc. The
generator doing it's thing. And a wallet app that can independently
manage separate wallets in parallel, referencing the live chain files
as needed. It seems a library would allow quality focus on the separate
functions and let apps/ui's use the fn's as desired on top. Right now, it
seems I have to run bitcoind and can only deal with one wallet at a time,
having to stop it, deal with state issues, swap in a new wallet, start
it, and repeat till illness ensues :( And when the chain is being processed
hard by the daemon cpuwise, bitcoin RPC takes minutes to respond, if ever
or errors out. If wallet ops or statistical queries on the chain need it for
integrity or reading, a db checkpoint/lock/logroll could be implemented into
the chain demon processes with a client lib api to trigger it as needed.
Don't know, just saying.

fyi... boost 1.48 and db 4.8.30 work fine with 0.5.2, 0.5.x, and master,
you just need to compile and include it by hand if you want it and
your package manager doesn't have it.


-------------------------------------
As I understand the attack, the attacker gets compensated for the shares
they earn, but the pool will be denied any valid blocks found.  The
attacker DOES NOT have access to the Bitcoins earned in the unreported
block (only the mining pool has access to the Coinbase address and
transactions in the block).

So it's a zero-net-cost attack for the attacker (but no chance of making a
profit) to hurt the pool operator.  The only way to detect such an attack
now is to look for "unlucky" miners; at the current difficulty, you can't
detect this cheat until many millions of shares have been earned w/o a
qualifying block.  Since an attacker can also create many fake identities,
they can avoid detection indefinitely by abandoning each account after a
million earned shares.

I don't understand your proposal for fixing this.  You would have to come
up with a scheme where:

- The miner can detect a qualifying hash to earn a share.
- Not be able to tell if the hash is for a valid block.

The way I would do this is to have a secret part (not shared with the
miners) of a block that is part of the merkle hash, which is also used in a
secondary hash.  Difficulty is then divide into two parts: the first,
solved by the miner (earning a "share" - e.g., 1 in 4 Billion hashes).  And
a second, solved by the pool (1 in Difficulty shares).  A valid block would
have to exhibit a valid Share Hash AND a valid Pool Hash in order to be
accepted.

This would be a very major change to the Block structure.  Given that
attackers do not have direct monetary gain from this attack, I'm not sure
we can justify it at this point.

On Sun, Jun 3, 2012 at 7:04 PM, Luke-Jr <luke@dashjr.org> wrote:




-- 
Mike Koss
CTO, CoinLab
(425) 246-7701 (m)

A Bitcoin Primer <http://coinlab.com/a-bitcoin-primer.pdf> - What you need
to know about Bitcoins.
-------------------------------------
On Fri, Mar 2, 2012 at 2:57 PM, Watson Ladd <wbl@uchicago.edu> wrote:


Here is an alternative protocol:


N parties wish to purchase equal amounts of Bitcoin without the
exchange being able to link their future transactions, they each put
the relevant amount of gold/whatever up at the exchange.

The exchange provides the exchanges public key, and the user provides
a public key for signing.   Externally the N participants agree on a
collection of non-cooperating mixers (the mixers may actually just be
the participants themselves, independent third parties, etc).   Each
participant generates a new bitcoin address, and encrypts it with the
the public keys of the the exchange and all the mixers using an
appropriate communicative homorophic scheme (or just a layers stack of
regular encryption keys).  The participants then combine their
encrypted addresess into a block and hand it off to the mixing chain.
Each mixer randomizes the order and decrypts all the messages with its
key.

At the end of the chain the exchange does the final decryption and
presents a list of addresses to the involved users.  Users validate
that their address is in the set and sign the entire set.  Once all
involved users have signed, the exchange pays.


This requires no changes to the Bitcoin system and could be trivially
implemented by anyone interested.  It provides anonymity which is
strong so long as any one of the mixers is uncompromised.  It has very
low overhead.   It is not directly resistant to disruption, but if
participation in an identified round requires a key provided by the
exchange, abusive users can be detected and excluded.

Have I explained this clearly enough? I could probably implement the
whole system it if its unclear.

Can you contrast this with your proposal for me?


-------------------------------------
The bottleneck for the android Bitcoin Wallet app is rapidly becoming
bandwidth and parse time.

On Fri, Jun 15, 2012 at 8:42 PM, Amir Taaki <zgenjix@yahoo.com> wrote:


-------------------------------------
Alan,

On Wed, Apr 4, 2012 at 2:01 AM, Alan Reiner <etotheipi@gmail.com> wrote:


That is a laudable goal.

So your proposal is about signing "Preformatted messages from sites" to
make financial transactions more secure, not arbitrary user-to-user
messages such as email. That really restricts the scope, which is good.

In this case there is no use for S/MIME, which deals with encoding/signing
multipart mail messages. And no need to deal with MIME headers, html, or
embedded images, and such. And we can simply require one character
encoding, no need to support hundreds.

The "request signing" bitcoin URL makes sense in my eyes. Less copy/pasting
is good. Do mind that there is usually a URL size limit (depending on the
browser) so this cannot be used for long messages/contracts. A possible
solution would be to make an option to pass the address where the message
can be retrieved (and maybe also where the signature must be sent, to save
a copy-paste back?).

Looking at existing solutions, the only other "sign request" that I know of
is the CSR (https://en.wikipedia.org/wiki/Certificate_signing_request) but
the functionality and goal is very different.

It'd be useful (and IMO most important) to write down some use-cases in
which this makes P2SH easier and less involved. How many steps can be
eliminated of the 14?

Wladimir
BTW: we also still need a BIP to define URL signing / authentication
itself.
-------------------------------------
On 11 Sep 2012, at 20:42, Gregory Maxwell <gmaxwell@gmail.com> wrote:


You wouldn't need to pipeline the requests, just place more than one inventory vector in get data, right? Well my messages would save the space of those inventory vectors. Instead of needing 36 byte inventory vectors for each transaction and a var int, you would need two var ints only. And then the transaction responses only need one header, so you save 24 bytes for each transaction after the first. You could say that is a small benefit.
 

Well it depends on wether you seriously think bitcoin blocks should be limited at a million bytes or not.


Look at bittorrent. With bittorrent you don't download files from a single peer all at once.


Why wouldn't requesting minimum fees in the software work as is done currently?


So what you essentially suggest is having bitcoin banks that maintain trust through Open Transaction contracts which contains proof of agreement, providing some legal protection? One wonders why have bitcoin at all then? Why not have an elaborate e-money system between several banks using Open Transactions? Bitcoin doesn't just contain proof of if something was done right or not, it contains actual certainty that it will be done right. And how does Open Transactions prevent fractional reserve fraud?

I suppose when people consider bitcoin banks, they will consider bitcoin being useless.


Set the change to occur at some block in the future leaving time for people to upgrade. Send out alert messages to notify users to upgrade. Issue is, some people might not like the change for whatever reasons.

As far as I see it, if bitcoin won't scale, then it's worth looking at something different to bitcoin that will scale.

-------------------------------------
On Sun, Sep 23, 2012 at 8:12 AM, Mike Hearn <mike@plan99.net> wrote:

Yeah, my public nodes currently have 2200+  Over time, it gets
cluttered naturally due to the disconnect between what miners mine and
what relayers relay.

I've long argued that all mempool implementations should limit the
lifetime of any TX to a specific number of blocks.  Rationale:
- bitcoin clients retransmit until TX is confirmed
- provides a deterministic lifetime for a TX; if you KNOW a TX will
disappear 144 blocks (24 hours) after you stop transmitting, then it
is probably safe to initiate recovery procedures and perhaps revise
the transaction
- prevents zombie TXs from littering memory... they hang around,
wasting resources, but never get confirmed

No one has strenuously argued against this, so I suppose it is down to
writing a patch, and coming up with a good number we (as a network)
can agree upon.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
My one big concern about this that users find a way to exploit this
behavior for themselves.  If it's too easy for users to create tx they know
will get stuck and expire, it's no different than letting them cancel their
zero-conf transactions.  i.e. I pay 0.5 BTC in a store for a candy bar, so
I send it using a combination of inputs and fees that I know will lead to
it being stuck and expire.

On the other hand, if such conditions are deterministic enough, it could be
detected by the recipient and flagged.

It's not a huge deal, but it's something to consider.

-Alan



On Thu, Apr 12, 2012 at 2:38 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------

I think there is general consensus this is a good idea.


I don't think the problem is with SatoshiDice, but is with the current
fixed/inflexible fee rules:

----------------------------

I've been thinking about fees a lot the last couple of days, and I'm
close to making a formal proposal. Here are my thoughts so far:

It seems to me there are two typical use cases:

Case 1:  I want my transaction to be confirmed quickly, and am willing
to pay a fee to make that happen.

Case 2: I want my transaction to be confirmed eventually. I'd rather
not pay, unless I have to.

I don't think the current code handles those two cases as well as it
could; here's a proposal to fix that:

o Let miners decide on how many free transactions they'll support, by
letting them specify how much of each block to set aside for 'free'
transactions (bytes) and what the threshold for 'free' is
(bitcoins/kilobyte). I think a new RPC call to get/set the parameters
dynamically is the right way to go.

o Change the block creation code to calculate a
bitcoin-fee-per-kilobyte for each transaction, where the fee and size
are both calculated based on the transaction and it's dependent
descendants (so we get the receiver-can-opt-to-pay-the-fee behavior we
want). Order transactions so highest-paying get into the non-free
space first.

o Fill up the "free" space (if any) with the highest-priority
transactions, where priority is a function of transaction size, age of
inputs, number of bitcoins... and ratio of inputs to outputs (to
encourage combining inputs so more pruning is possible).

The fee-paying space in a block lets Use Case #1 users compete to make
their fees high enough to get into the block.

The free space should let non-spamming Use Case #2 users (who don't
send a lot of transactions, and so have well-aged, high-priority
inputs) send transactions for free, at least as long as there are
miners willing to accept free transactions.

The question is: how do clients suggest fees to users if miners might
have very different fee policies?

I think full, transaction-verifying clients can watch how long
transactions stay in the memory pool to figure it out. I'm gathering
statistics right now to test a couple of simple heuristic algorithms
for reasonable fee/priority policies.

But that won't work for newly started clients that haven't seen a lot
of transactions enter/exit the memory pool, or SPV clients that can't
lookup transaction inputs (so can't calculate what fees are being paid
-- and once we have bloom filters may not be paying attention anything
but their own transactions, anyway).

I'm still thinking about that.

Maybe a new p2p network command: you give me a list of block hashes, I
tell you average fees paid per kilobyte for fee-paying transactions in
those blocks, and minimum and average priority of free transactions in
those blocks.

Maybe the big mining pools all publish their fee policies and that
information somehow gets to clients (encoded in the coinbase? ... but
they have a strong incentive to lie to try put upward pressure on
fees... ).

Maybe each client developer runs a "fee policy server" and clients
periodically ask it for reasonable fee rules (HTTP fetch info from a
web page that is updated as often or infrequently as is convenient,
maybe). I think I like this solution the best, it should let clients
compete to have the smartest/bestest algorithms for saving their
user's money on transaction fees.

-- 
--
Gavin Andresen


-------------------------------------

Nothing wrong, it's all default install. I documented the platform
for anyone who wants to confirm it.


And what, similarly, is your platform?
It takes 5 seconds... on my Cray.


Use of Tor was stated. Tor is fast enough. I can copy the entire
3GiB of the .bitcoin dir in 7 days... off a slow hidden service.
And 0.5 days via exit.


Encryption is a perfectly reasonable thing to expect users of
bitcoin to be interested in doing. In fact, those not encrypting
their disks should probably rethink that plan.


Well, without detachdb, it's somehow tied to the wallet, whether
while processing or offline. And the wallet and debug.log are
not relocatable from the data. And encrypting everything is perfectly
reasonable anyways. As is storing your valuable data on filesystems
that verify the integrity of their data on disk, such as ZFS/BTRFS.

These days, crypto, Tor, and ZFS are common and non-arguments.


Again, timings with no CPU/OS/disk specs are useless infos.


-------------------------------------
On Tuesday, April 03, 2012 2:46:17 PM Gavin Andresen wrote:

I wonder if it's possible to make sigs compatible with PGP/EC ?


-------------------------------------
On Sun, Jun 17, 2012 at 01:01:12PM +0200, Mike Hearn wrote:


-- 
Pieter



-------------------------------------
The more I think about this topic, the more I think the first task at hand
is to implement secure, private messaging...the nature of any messages
(payment requests or otherwise) sent between wallets is such that it needs
to be secured.  And the great thing is that it's easy to do and you don't
need to solve the PKI problem.  Have the wallet maintain one or more ECC
key pairs for the purposes of signing and encrypting messages.  Allow these
to be shared between wallets, or exported/imported, etc.  You can punt on
the whole topic of verifying the others' public keys using PKI (I mean,
people use bitcoin addresses today without the use of any formal or
explicit PKI to verify them...people will make do without it for
communications keys just fine...and they can always use PGP or other PKI if
they feel the need...most people would just pick up the phone to verify a
friend's public key)...this also doesn't preclude the use of X.509 for the
merchant/customer scenario...

For a payment protocol, you could do something like this: use https & ssl
certificates/CAs as one method of obtaining an ECC public key...pki_type
could be "https" and pki_bytes could be a url for the https location to
download the ECC public key.  The software would reject (or warn) if the
SSL certificate isn't considered valid by the normal CA validation process.
 The wallet would not necessarily need to permanently store ECC public keys
obtained in this manner.  This approach doesn't require people to obtain
new certificates just for bitcoin.

In fact, there would be very little difference to the proposed payments
protocol if this approach were taken...instead of using X.509 directly for
signing and encrypting messages, you are using it for signing and
encrypting the ECC public key exchange.  And this allows people that don't
have web servers or SSL certificates to exchange their ECC public keys by
other means and be able to use this payment protocol as well as any others
that one could imagine.  So, I actually think this is a better way of
keeping PKI out of the scope of the proposal.

Payment requests are just one kind of messaging between wallets.  I've also
mentioned the "cheques" feature.  I'm sure there are many more
possibilities.  Having a uniform method of securing messages sent between
wallets (that doesn't depend on external tools) would be a great step
forward IMO.
-------------------------------------
Alan, apologies about the installer - I was just using your website info to
infer how it all fitted together.

On 2 May 2012 20:43, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
During/before the Payment Request there should be a method to exchange 
the public keys to be able to generate a common multisig address.
Should this be handled in a different protocol, or be included in this 
spec?
Or is there a method for the customer to verify that the specified BIP16 
Output contains his address and the one from an escrow service?

--
Andreas


-------------------------------------
On Tuesday, May 29, 2012 3:36:34 PM Peter Vessenes wrote:

A new message can be added to the p2p relay network, similar to tx and alert 
broadcasts, that allow miners to publish/update their policy URI signed by the 
key in question. Counter-DDoS rules could decline to relay or store URIs for 
keys that haven't been published in - or achieved statistical significance in 
- the last N blocks.


-------------------------------------
On Sun, Dec 16, 2012 at 4:15 PM, Melvin Carvalho
<melvincarvalho@gmail.com> wrote:


I thought this had already been covered up-thread?

When creating something that must be hashed and/or compared, the data
structure must be created and reproduced precisely, byte-for-byte.
JSON offers significant -disadvantages- in this regard.  With JSON,
you would therefore require an additional middle layer, between JSON
and application, ensuring that all fields are output in the same
order, all whitespace is not only perfectly preserved -- but reliably
generates identical whitespace output for identical inputs, given two
separate JSON implementations.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I'm very interested in this. I was expecting transitive/multi-hop
transactions (Ripple) with colored coins, and I don't understand why
is not possible.


---
SIGHASH_ALL: This is the default. It indicates that everything about
the transaction is signed, except for the input scripts. Signing the
input scripts as well would obviously make it impossible to construct
a transaction, so they are always blanked out. Note, though, that
other properties of the input, like the connected output and sequence
numbers, are signed; it's only the scripts that are not. Intuitively,
it means "I agree to put my money in, if everyone puts their money in
and the outputs are this".
---

Why "Signing the input scripts as well would obviously make it
impossible to construct a transaction"?
I don't understand that part. I think a new SIGHASH_* type that
doesn't pay attention to that "obviously" is needed to achieve what we
want.

Say we want the following transaction:

A 1 satoshi -> B 1 satoshi -> C 100 btc -> A

It would be necessary to sign the following:

Inputs: from srcA, from srcB,
Outputs: 1 satoshi to destB, 1 satoshi to destC, 100 btc to destA

"from srcC" is not really necessary.

This same scheme can be used for n-hops.

What am I missing?

On 9/22/12, Jeff Garzik <jgarzik@exmulti.com> wrote:


-- 
Jorge Timn


-------------------------------------
On Tuesday, January 31, 2012 9:27:26 AM Amir Taaki wrote:

It does among implementations such as Spesmilo and WalletBuddy, and has for 
some time. More importantly, it achieved consensus and Final status before any 
objections were made. Final only changes to Superceded. What's the point of a 
formal BIP process if that process won't be followed?


That's not incompatibility, and not true. The standards use hexadecimal 
numbers, and I can't even think of a single case off-hand where decimal is 
used.

That being said, I'd be fine with a spec that used strtol-compatible satoshis 
for amount. This is both simple and forward-compatible.

On Tuesday, January 31, 2012 9:53:57 AM Gary Rowe wrote:

This is true only for BTC users. While that might be a sensible unit today, it 
almost certainly won't be in the future. amount=0.00001 is much worse than 
amount=1000 or amount=1x3


Existing software uses Satoshis internally, and it's generally regarded as a 
design flaw that it uses BTC numbers in the JSON-RPC protocol.


This strikes me as more of "let's test the code earlier rather than later" 
than forwards compatibility. The problem is that it's pretty much unanimous 
that floating-point should never be used, and without that both 
representations will be rounding when there are smaller units available.



-------------------------------------
On 04/14/2012 10:20 PM, Jeff Garzik wrote:


Just to let you know, Bitcoin Wallet for Android already supports
directly sending transactions via NFC and QR-Code. Currently, receiving
such a transaction is handled the same way as if it was received via P2P.

This means the sender does not need to have internet access the moment
he pays. The transaction is being broadcast into the P2P network by the
receiver.

Cheers,

Andreas



-------------------------------------
On Mon, Feb 6, 2012 at 6:27 PM, Wladimir <laanwj@gmail.com> wrote:


And maybe WalletModel::sendCoins has to be changed.
Does CScript.SetBitcoinAddress work for the new address type?

Wladimir
-------------------------------------
On Wednesday, February 01, 2012 11:20:22 AM Michael Grnager wrote:

Upgrading to 1.47 did not change the error at all... :/


-------------------------------------
To ensure forward compatibility with optional fields, we need to define how
a client handles fields that it doesn't know about.

When should it display an error message, and when should it silently accept
and ignore the extraneous fields?

(For example, if something that restricts the validity, such as "expires"
is added later on, it is pretty important not to ignore it. Older clients
should refuse to comply.)

URL signing should indeed be addressed in a separate BIP and be an
extension mechanism, IMO.

"expires" and "message" could go into BIP 21 one as they're easy to
implement and don't need much discussion.

Wladimir

On Tue, Jan 31, 2012 at 11:01 AM, Gary Rowe <g.rowe@froot.co.uk> wrote:

-------------------------------------
On Tue, Jan 31, 2012 at 12:17 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

I think I've explained myself poorly.  On my nodes, the old address
database routinely has 120k addresses.  With the new address manager,
it will have 20k addresses.  Filling the former with 60% evil nodes
requires 72,000 evil nodes; while the latter requires 12,000.

As I mentioned in my first post, I think the new address manager "is a
valuable improvement over what we have today".  I think it should be
included in the next release.

I also think we should be aware that we're making it somewhat easier
to isolate outbound-only nodes.  A single listening node can support
15 non-listening nodes (125/8).  The network currently has 5
non-listening nodes for every listening node.  That ratio has stayed
quite stable, so I think we have wiggle room if we wanted to allow
more outbound connections in some circumstances.

-- 
Michael


-------------------------------------
Update: this class of machine just became useless for bitcoin.
When blk0002.dat was created to store more blocks, all forward
progress processing blocks turned into losing ground by 20 or so
a day. Guessing both datfiles were being accessed at once resulting
in disk based overload. I've not seen any other mentions of crypto
in this thread so I'm not sure how well new hardware would perform.
Going shopping I guess.


-------------------------------------
while perfectly true for now, hopefully that won't remain the case as we
get people on board with testing. ...ok, sure, it might be a while... but
having the separate list with help with archival type stuff and other
things eventually. we'll see how useful it actually is in time.

Arklan

----------
As long as there is light, the darkness holds no fear. And yet, even in the
deepest black, there is life. - Arklan Uth Oslin

I want to leave this world the same way I came into it: backwards and on
fire. - Arklan Uth Oslin



On Thu, Oct 11, 2012 at 1:20 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
I propose a pragmatic solution: Try running the Multibit client. i am 
not sure if the linux/java based installer would work,so maybe you have 
to build it from source.
I tried it out is really fast compared to bitcoin-qt. after install it 
took me 15 seconds to get updated and running. Importing a private 
key/rescanning the blockchain was done in under 30 minutes.
It requires Java 6, i think there is a distro even for freebsd.
of course, you cannot do things as solomining with it since it uses SPV.



-------------------------------------
On Wed, Nov 28, 2012 at 11:43:19AM +0100, Mike Hearn wrote:

FWIW I re-read the specs again and turns out my memory was wrong. (I
last looked at this about four months ago) Duplicated fields are handled
in a defined manner, with the last field seen in the serialization being
the one whose value is used. Again, repeated fields are treated as
elements of a list, preserving order.

It does raise the interesting question do the implementations that don't
preserve order of unknown fields, preserve the order of multiple unknown
fields, either repeated or not?


I gotta admit, I suspect they won't be that open. Protocol buffers was
designed because Google needed a fast serialization method suitable for
many different internal projects. Needing round-trip idempotence seems
like a rare requirement to me, especially for internal use.


Well, actually you can take advantage of the message concatination
ability of protocol buffers to extend a message by simply appending the
new fields to the existing thus either defining new fields, or
overriding old values as required. If you want to de-duplicate though
you run into the problem all over again.

On the other hand JSON handles this case fine too provided that your
JSON implementation supports dictionary objects with arbitrary fields.
Just use the object as is and the unknown fields will be re-serialized
properly at the other end. Some implementations will have to be careful
to handle collisions with existing keys in the namespace. (consider in
Python what would happen if you mapped your object to a class instance,
and the serialization included the key "__init__")

That said, JSON is quite problematic with numbers. For instance, you
have to be careful to keep integers represented as pure integers below
what Javascript can handle, the maximum integer exactly representable in
a double float, or the JSON won't be parsable in Javascript even if many
other languages handle it fine. Protocol buffers is at least pretty
explicit about what size integers are.


Note that I think the SignedInvoice message itself is broken, because
protobuf implementations have no reason to guarantee that they can give
you the serialized bytes of the Invoice sub-message. It's a quite
specific use-case that isn't needed for pretty much anything but crypto.
FWIW I took a quick look at the official API's, C++, Java and Python,
and as far as I can tell none of them support accessing the binary
serialization of a message field other than by re-serializing the
message.

Really the invoice field should be declared as bytes serialized_invoice,
as inconvenient as that is to work with.


Since the Payment message includes an *untrusted* Invoice that the
vendor needs to authenticate the whole invoice no matter what on Payment
reception. In many cases that implies they have to keep some sort of
database of "quotes" or similar anyway as the client can change anything
they want otherwise. Again that leads back to the argument of why not
just stick with the merchant_dat as you suggest, which will usually be
some short invoice number attached to a database? A vendor that wants to
operation a stateless invoicing system can just stuff a HMAC-protected
serialized invoice into the merchant_data

I guess you could use a mutable invoice field as a way of achieving some
sort of negotiation protocol, but I think it's better to stick to the
original concept of just ensuring that the user is really paying the
right amount to the right address.

-- 
'peter'[:-1]@petertodd.org
-------------------------------------
On Wed, 2012-10-24 at 14:54 -0400, Gavin Andresen wrote:
I believe you meant NOT complicating?
Sadly that requires (potentially) more DoS potential because you require
nodes to store each transaction that could be requested instead of just
going ahead and forwarding them.  I agree the BIP should not specify
that the sending node is required to keep track of which transactions
have been announced/sent to clients, however since the reference client
does so currently, that implementation is significantly simpler (note
that it is a bounded set in the reference client, so even the reference
client doesn't really fully comply with the BIP as stated here).  

Matt



-------------------------------------

Well, I think what Stefan had in mind was http keep-alive combined with an event system. So similar to the way a web chat application work, just for json-rpc. BitcoinJS already uses this for realtime updating a webwallet. Libcoin is also prepared for this with a quite advanced, non-blocking, http server so I second Stefan that an update function could indeed be of relevance.

Btw - question to Stefan as the JavaScript guru - what do you consider the standard/defacto-standard/right/best-practice way of doing S->C json-rpc, what (javascript) library do you use for this?

Cheers,

Michael





-------------------------------------
On 2012 February 01 Wednesday, Pieter Wuille wrote:


Ah.  My misunderstanding then.
 

That makes a big difference.  Thanks for the correction.


Andy


-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Tue, Jan 31, 2012 at 09:35:26AM +0100, Wladimir wrote:

It is actually a "send of private key", not to. And I agree, it should be part
of a separate BIP.

-- 
Pieter


-------------------------------------
I've added some more commits:

https://github.com/mikehearn/bitcoin/commits/leveldb

It's still not ready for a pull req but is a lot closer:

1) Auto-migration is there but not well tested enough (I only tested
with empty wallets).
2) Migration progress UI is there so you have something to watch for
the few minutes it takes. Script execution is disabled during
migration
3) LevelDB source is checked in to the main tree, bitcoin-qt.pro
updated to use it
4) LevelDB is conditionally compiled so if there's some unexpected
issue or regression on some platform it can be switched back to BDB

Still to go:

1) More testing, eg, with actual wallets :-)
2) Update the non-Qt makefiles
3) On Windows it's currently de-activated due to some missing files
from leveldb + I didn't test it

If you want to help out, some testing and makefile work would be
useful. I may not get a chance to work on this again until next week.

On Wed, Jun 20, 2012 at 2:41 PM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
Shudder.

:-)

On 31 January 2012 15:02, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------

And this gets you what?

Users who have active wallets will have their bandwidth wasted for as
long as you keep up the attack. Once you stop active wallets won't be
rescanning that part of the chain and new users won't be scanning it
either, as they skip blocks before their earliest key time using
getheaders. So basically you can waste the bandwidth of active users
for a while, by spamming transactions. This is not a new attack.

Anyway, it's trivial to DoS the entire Bitcoin network today. It
hasn't ever happened. Maybe one day it will, but the only rationale
people can come up with for such an attack beyond random griefing is
governments, and complexity attacks are really not their style. Much
easier to just pass a law.

I'm not saying DoS should be ignored, but I do feel there are limits
to how far down that rabbithole it's worth going.


-------------------------------------
I have just finalized porting BitcoinQt to build using libcoin as its basic crypto library.

You can find the project at:

https://github.com/ceptacle/libcoinqt

It is based on the latest 0.6 branch of BitcoinQt.

There are a few things not yet ported:
* update the splash text while loading
* some of the globals have not found a replacement (see optionmodel for details on this)
* UPnP - this awaits the similar functionality in libcoin
* Proxy support - same...

To build libcoinqt you need to first build libcoin, then build libcoinqt using qmake or Qt Creator.

Note: I have only tested on MacOSX - more tests and features next week.

Have a nice weekend!

Michael

-------------------------------------
Sources are available here:

http://code.google.com/p/bitcoin-wallet/

Mats

Quoting Amir Taaki <zgenjix@yahoo.com>:





-------------------------------------
Well, detachdb doesn't appear in the -\? help
because it's stuffed under pnp, which is not set
in my build. please fix for people, tx :)

#ifdef USE_UPNP
#if USE_UPNP
            "  -upnp            \t  "   + _("Use Universal Plug and
Play to map the listening port (default: 1)") + "\n" +
#else
            "  -upnp            \t  "   + _("Use Universal Plug and
Play to map the listening port (default: 0)") + "\n" +
#endif
            "  -detachdb        \t  "   + _("Detach block and address
databases. Increases shutdown time (default: 0)") + "\n" +
#endif


-------------------------------------
AWESOME!!!

I can compile libcoin at my Ubuntu 11.10... I just need to install:

sudo aptitude install libboost1.46-all-dev

...alongside with another already installed dependencies, and now it works!!

Thank you!
Thiago

2012/2/23 Michael Grønager <gronager@ceptacle.com>

-------------------------------------
On Sun, Feb 19, 2012 at 17:45, Michael Grnager <gronager@ceptacle.com> wrote:

well, spammers are everywhere :)

h


-------------------------------------
Thursdays at 18:00 UTC (6PM Europe/1PM east US/10AM west US) seem to
be a good time for the core dev team to meet on the #bitcoin-dev
freenode IRC channel to chat.

I'd like to talk about:

o Can we put together a TODO list to get to a 0.8 release candidate ?

o Is it time to feature-freeze 0.8 and work on just testing the new
features and fixing existing bugs (the issues list keeps getting
longer and longer ... )?

o BIP process: are we happy with how it is working? What can we do to
improve it?

What else should we talk about?

-- 
--
Gavin Andresen


-------------------------------------
On Sun, Jun 17, 2012 at 5:22 AM, grarpamp <grarpamp@gmail.com> wrote:

It isn't inside the ifdef in bitcoin git master.

(For future reference this sort of request is probably best opened as
an issue in the github issue tracker instead of posted to the list).


-------------------------------------
On Sun, Jun 10, 2012 at 7:06 PM, Mike Hearn <mike@plan99.net> wrote:

I'm not a fan of anything which introduces unauditable single source
material.  "Trust us" is a bad place to be because it would greatly
increase the attractiveness of compromising developers.

If we wanted to go the route of shipping pruned chains I'd prefer to
have a deterministic process to produce archival chains and then start
introducing commitments to them in the blockchain or something like
that.   Then a client doing a reverse header sync[1] would bump into a
commitment for an archival chain that they have and would simply stop
syncing and use the archival chain for points before that.

This would leave it so that the distribution of the software could
still be audited.

More generally we should start doing something with the service
announcements so that full nodes that don't have enough bandwidth to
support a lot of syncing from new nodes can do so without turning off
listening.


[1] https://en.bitcoin.it/wiki/User:Gmaxwell/Reverse_header-fetching_sync


-------------------------------------
Please review and comment...

Block v2, Height in Coinbase
https://en.bitcoin.it/wiki/BIP_0034

  BIP: 34
  Title: Block v2, Height in Coinbase
  Author: Gavin Andresen <gavinandresen@gmail.com>
  Status: Draft
  Type: Standards Track
  Created: 2012-07-06

Abstract

Bitcoin blocks and transactions are versioned binary structures. Both
currently use version 1. This BIP introduces an upgrade path for
versioned transactions and blocks. A unique nonce is added to newly
produced coinbase transactions, and blocks are updated to version 2.


Motivation

1.    Clarify and exercise the mechanism whereby the bitcoin network
collectively consents to upgrade transaction or block binary
structures, rules and behaviors.

2.    Enforce block and transaction uniqueness, and assist unconnected
block validation.


Specification

1.    Treat transactions with a version greater than 1 as non-standard
(official Satoshi client will not mine or relay them).

2.    Add height as the first item in the coinbase transaction's
scriptSig, and increase block version to 2. The format of the height
is "serialized CScript" -- first byte is number of bytes in the number
(will be 0x03 on main net for the next 300 or so years), following
bytes are little-endian representation of the number.

3.    75% rule: If 750 of the last 1,000 blocks are version 2 or
greater, reject invalid version 2 blocks. (testnet3: 51 of last 100)

4.    95% rule ("Point of no return"): If 950 of the last 1,000 blocks
are version 2 or greater, reject all version 1 blocks. (testnet3: 75
of last 100)


Backward compatibility

All older clients are compatible with this change. Users and merchants
should not be impacted. Miners are strongly recommended to upgrade to
version 2 blocks. Once 95% of the miners have upgraded to version 2,
the remainder will be orphaned if they fail to upgrade.


Implementation

https://github.com/bitcoin/bitcoin/pull/1525 and
https://github.com/bitcoin/bitcoin/pull/1526

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
It's easy to say, this page is controversial, so let's get rid of it.

However that starts the project down the road of being dominated by
our internal politics rather than what actually makes sense from the
end users perspective. That route spells doom for any product. You can
always tell when a UI or product is the result of internal politics,
whether it be the difficulty of plug-n-play hardware on Linux (no
driver api) to how Microsoft is incapable of producing anything that
isn't built on Windows. Gmail labs is another example of this.

It makes sense that if I go to bitcoin.org, I am educated about the
system and what is available for it. It doesn't make any sense to have
some stuff on the main site and other stuff on a wiki (which may get
randomly vandalized and looks less professional), based on how
"controversial" some developers find it.

FWIW I am dead set against anyone randomly changing the website
without a pull request and such changes should be reverted and
resubmitted through the proper channels. I don't perceive much value
in randomization or trying to make this page "fair". If anything, we
need to pick somebody (one person) who has a strong focus on regular
people and their needs, then just make them the sole committer to the
website. That way disputes can be resolved by them making a decision,
instead of ridiculous edit wars.


-------------------------------------

Looks good to me. I also second the notion that we should deploy this 
quickly, given that it's a bug fix.


On 2/28/2012 5:48 PM, Pieter Wuille wrote:



-------------------------------------
https://github.com/gavinandresen/bitcoin-git/tree/fuzzer

It is a transaction fuzzer; adding block fuzzing is on the TODO.

Basic usage is:
1. Use the send* RPC commands to get one or more transaction IDs
2. Run a script that repeatedly calls relayfuzzed with a nonce/txid
... and see how the connected peer(s) react to all the fuzzy 'inv/tx'
protocol messages.

I built it to stress-test BIP 16, there are lots of useful features that
could be added.  Patches welcome!

-- 
--
Gavin Andresen
-------------------------------------
This is super cool!

I have a feature request: it would be awesome to be able to provide private
keys at the command line with the signature, turning the client into a
wallet-less signature machine.

Peter


On Thu, Jun 14, 2012 at 9:22 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:

-------------------------------------
Github URL: https://github.com/jgarzik/pynode

pynode is a simple bitcoin P2P client, based on ArtForz' half-a-node,
which maintains a blockchain database and TX memory pool.

It is intended to be a useful base for another projects, such as
network monitoring nodes.

At present, it is mainly for developers and not end users.  Here is
what pynode does NOT do:

*    RPC
*    key management (wallet)
*    script verification
*    chain re-org

Here are the limited things that pynode can do at present:

*    Outgoing TCP connection to a single remote P2P node
*    Initial blockchain download
*    Maintain a transaction memory pool, with TX's removed as they are
confirmed in blocks
*    Maintain an indexed blockchain database


Over time it will become more capable, but this is an alpha quality
release for developers at present.

Contributions welcome!  It is intended to become a full, wallet-less
node over time (though if somebody wanted to contribute a wallet
module, that is OK too)

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
the Satoshi client. (It was actually what got me to write libcoin in the
first place...). The Satoshi client HTTP server executes all rpc commands
in its own thread, but to do so, it needs to stop the thread of the Node,
even though the command executed is just a query (i.e. not a SendTo), you
hence have two threads blocking each other and when they wait, you wait...
In libcoin all the query methods access the blockChain as a const object
and they can hence safely query it without intervening the work of the Node
thread. The exception are the SendTo methods that first query if a
transaction can take place, then pushes it to the work-queue of the Node
thread and again exits immediately. The actual execution then follows once
the Node has finished its current tasks (e.g. validating a block).

Hello Michael,

I'm impressed by your refactorings, and hope some of them can make it into
the Satoshi codebase. I am however not sure what you've said above is safe.
In particular, how do you guarantee that no other thread modifies the
blockchain structure while you are performing your query on it? Does the
query code operate on a const copy of the structure, or is there guaranteed
only one thread accessing it?

I've been thinking about moving to read-write locks that allow multiple
threads reading the datastructure simultaneously, but removing the locking
all together sounds wrong to me.

-- 
Pieter
-------------------------------------
On Mon, Dec 3, 2012 at 10:30 AM, Mike Hearn <mike@plan99.net> wrote:



I would like to second this point...privacy is essential because the market
demands it.  If Bitcoin doesn't do it well (and I would argue that it
doesn't today), then eventually a competitor to Bitcoin will do it better
and that would be the beginning of the end for Bitcoin.  Debates about
whether it was or wasn't a core feature are pointless.
-------------------------------------
OK - I've added a comment to the pull request.

On 2 February 2012 17:39, Matt Corallo <bitcoin-list@bluematt.me> wrote:

-------------------------------------
On Tue, Dec 4, 2012 at 9:08 PM, Alan Reiner <etotheipi@gmail.com> wrote:

Not so— a moderately fast multicore desktop machine can keep up with
the maximum possible validation rate of the Bitcoin network and the
bandwidth has a long term maximum rate of about 14kbit/sec— though
you'll want at least ten times that for convergence stability and the
ability feed multiple peers.

Here are the worst blocks testnet3 (which has some intentionally
constructed maximum sized blocks),E31230 :
(with the new parallel validation code)
- Verify 2166 txins: 250.29ms (0.116ms/txin)
- Verify 3386 txins: 1454.25ms (0.429ms/txin)
- Verify 5801 txins: 575.46ms (0.099ms/txin)
- Verify 6314 txins: 625.05ms (0.099ms/txin)
Even the slowest one _validates_ at 400x realtime. (these measurements
are probably a bit noisy— but the point is that its fast).
(the connecting is fast too, but thats obvious with such a small database)

Although I haven't tested leveldb+ultraprune with a really enormous
txout set or generally with sustained maximum load— so there may be
other gaffs in the software that get exposed with sustained load, but
they'd all be correctable. Sounds like some interesting stuff to test
with on testnet fork that has the POW test disabled.

While syncing up a behind node can take a while— keep in mind that
you're expecting to sync up weeks of network work in hours. Even
'slow' is quite fast.


Thats not generally concern for me. There are a number of DOS attack
risks... But attacker linear DOS attacks aren't generally avoidable
and they don't persist.

Of the class of connectedness concerns I have is that a sybil attacker
could spin up enormous numbers of nodes and then use them to partition
large miners.  So, e.g. find BitTaco's node(s) and the nodes for
miners covering 25% hashpower and get them into a separate partition
from the rest of the network. Then they give double spends to that
partition and use them to purchase an unlimited supply of digitally
delivered tacos— allowing their captured miners to build an ill fated
fork— and drop the partition once the goods are delivered.

But there is no amount of full nodes that removes this concern,
especially if you allow for attackers which have compromised ISPs.
It can be adequately addressed by a healthy darknet of private
authenticated peerings between miners and other likely targets. I've
also thrown out some ideas on using merged mined node IDs to make some
kinds of sybil attacks harder ... but it'll be interesting to see how
the deployment of ASICs influences the concentration of hashpower— it
seems like there has already been a substantial move away from the
largest pools. Less hashpower consolidation makes attacks like this
less worrisome.


Yes, I said so specifically.  But the fact that people are flapping
their lips here instead of testing the bitcoin-qt git master which is
an 1-2 order of magnitude improvement suggests that perhaps I'm wrong
about that.  Certainly the dearth of people testing and making bug
reports suggests people don't actually care that much.


No. The "question" that I'm concerned with is do we promote lite nodes
as equally good option— even for high end systems— remove the
incentive for people to create, improve, and adopt more useful full
node software and forever degrade the security of the system.


The current software patches plus parallelism can sync on a fast
system with luck network access (or a local copy of the data) in under
an hour.

This is no replacement for start as SPV, but nor are handicapped
client programs a replacement for making fully capable ones acceptably
performing.


Making the all the software painless for users is a great goal— and
one I share.  I still maintain that it has nothing to do with
promoting less capable and secure software to users.


-------------------------------------
On Thu, Aug 16, 2012 at 1:56 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

Yes.


A simple guarantee of 1:1 correspondence between request and response.
 The bitcoin protocol sometimes simply elides a response when the
response would be empty, and this makes it difficult to know whether a
request is timing out or already processed.

Sending a ping(nonce) after each P2P command is another way of achieving same :)


An nServices bit would be a better fit for this optional service, but
nServices bits seemed like a scarce resource, so I elected to be
conservative.

Absent the scarce-resource concern, I'd vote for an nServices bit.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I just finished adding NATPMP, together with IDG UPnP, to libcoin. This enables libcoin/bitcoind to setup port mapping also on Apple routers (AirPort Extreme/Express/TimeMachine) and a few other that supports this protocol.

libcoin/bitcoind first tried to setup mapping using UPnP, if that fails it resorts to using PMP. 

It chooses a lease time of (default) 20 minutes and renews this every 10 minutes. This also means that if you are running libcoin on your laptop it will, when e.g. moved to your work, just setup the mapping there and the mapping back home will silently expire.

To include portmapping in libcoin/bitcoind the only thing needed is to add the PortMapper class and start it:

        PortMapper mapper(node.get_io_service(), port);
        if(portmap) mapper.start();

where "portmap" is the former "upnp" command line option.

Also note that I choose to include the relevant portions of miniupnpc and libnatpmp in the coinNAT library to make it easier to build.

I choose to make a rather aggressive setting for quitting searching for an IGD device (3 seconds). If I waited too long here the PMP port mapping would only kick in after the other clients had tried to connect to the new node and timed out.

If it is too small please notify me - I only have access to a UPnP router sporadicly. 

And btw: Also added proxy capability to libcoin (have a look in coinChain/Proxy.h for implementation details).

Cheers,

Michael

-------------------------------------
Hello,

I've written this proposal. C&P of the overview:

Satoshi's original paper describes a way of prunning spent
transactions in the blockchain to save storage space while it remains
consistent and verifiable, but it's useless for partial blockchain
downloads: while you can know if a given transaction is in the
blockchain, you can't know if it has been spent in a subsequent
transaction.
This proposal describes how to add a hash-tree based check in the
blockchain that allows to verify if a transaction is unspent without
downloading and checking all the blockchain. The idea is not new, but
at the time of this writing there isn't any technical description of
how this should be done. Aditionally, this solution is rather simple.

https://en.bitcoin.it/wiki/User:DiThi/MTUT

Cheers

-- 
Alberto Torres Ruiz (a.k.a. DiThi)


-------------------------------------
i'll second the bitcoin test list.

Arklan

----------
As long as there is light, the darkness holds no fear. And yet, even in the
deepest black, there is life. - Arklan Uth Oslin

I want to leave this world the same way I came into it: backwards and on
fire. - Arklan Uth Oslin



On Thu, Oct 11, 2012 at 11:45 AM, steve <steve@mistfpga.net> wrote:

-------------------------------------
Tomorrow, Feb 14'th at 21:00 UTC on #bitcoin-dev on Freenode IRC I'd
like to chat about:

Status of BIP 16 support (progress towards 50% hashing power).

Protocol change coming up Feb. 20 (checksums in version messages).

Duplicate coinbase issue (and requiring block height in the coinbase
as a solution).

Then when we're done talking tech we can all send each other bitcoins
with addresses that are cute Valentine's day messages...

-- 
--
Gavin Andresen


-------------------------------------
On Thu, Apr 12, 2012 at 11:41:05AM -0400, Gavin Andresen wrote:

If there is a reasonable use for it, I have no objections.

However: the bitcoin P2P protocol is not fully request-reply based, and trying to use
it that may be be less intuitive than how it looks. For example, doing a second
identical "getblocks" request will not result in more "inv" replies, as the client
prevents retransmits. This is not a large problem, but maybe such an extension
should also include an extra "denied" message, which is sent if the client is
unwilling to answer (and may also be used to report transactions that are not
accepted into the memory pool, for example).

-- 
Pieter


-------------------------------------
I think you need the stronger change.  Otherwise, the mystery miner could
just put in a few transactions to himself to mask his block.  His block
would appear to be of some use while not being helpful.

-Arthur

On Thu, May 24, 2012 at 9:33 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
On Mon, Apr 2, 2012 at 11:23 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:


It would be nice to have 100000 as the baseline, "frozen" protocol.
-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sat, Jun 2, 2012 at 8:52 PM, Luke-Jr <luke@dashjr.org> wrote:

I'm unclear on the economics of this attack; we spent a bit of time talking
about it a few months ago at CoinLab and decided not to worry about it for
right now.

Does it have asymmetric payoff for an attacker, that is, over time does it
pay them more to spend their hashes attacking than just mining?

My gut is that it pays less well than mining, meaning I think this is
likely a small problem in the aggregate, and certainly not something we
should try and fork the blockchain for until there's real pain.

Consider, for instance, whether it pays better than just mining bitcoins
and spending those on 'bonuses' for getting users to switch from a pool you
hate.

Watson, I don't believe the attack signature you mention is a factor here,
since the pool controls the merkle, only that pool will benefit from block
submission. The nonce / coinbase combo is worthless otherwise, and so this
attack is just in brief "get lucky, but don't submit."

So, can anyone enlighten me as to some actual estimates of badness for this
attack?

Peter
-------------------------------------
On Mon, Jan 30, 2012 at 9:05 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Sο— would we remove it or leave it deactivated as a fallback users can turn on?

I have two different thoughts about IRC depending on the answer.

I think it's important that we have more mechanisms then just DNS and
hardcoded seednodes.

This is important because the mechanisms we have are all pretty
subject to blocking. Now— before you say it— Bitcoin isn't intended to
be blocking resistant (combine it with Tor and Tor anti-censorship
tools) but by making blocking a bit harder we discourage people from
even trying, even if we're not seriously in the anti-blocking
business— and it gives bitcoin users more confidence because there is
a bit less FUD  "What if your ISP blocks it?? It uses DNS! Someone
might take away the domains! SOPA PIPI ACTA CIPA Alakazam".

Is the fact that users can addnodes / addr.txt enough of an
alternative to address this?   _If so_, then removing it is a good
idea.  I volunteer to maintain a multi-channel joining node for the
foreseeable future to avoid letting old clients get partitioned
(several people need to do this).

An area where I think our mechanisms are inadequate absent IRC is
announcing new nodes. I had a new listener up for over a week recently
and was basically getting no inbound until I enabled IRC.   I
volunteer to do some measurement of this (e.g. bring up some nodes
with no irc and find out how long until sipa hears about them).  If
DNS seeds are slow to learn about new nodes we may need to add a
simple UDP announcement feature.

In any case, I hadn't been thinking that we would completely remove
IRC— I was expecting us to keep IRC around but turned off.

In particular I think it may be a little risky to turn off IRC at the
same time as deploying addrman, because if addrman has unexpected bad
behavior IRC is what may keep things going.  Obviously it should be
well tested enough to feel confident, but belt-and-suspenders is the
way to go.


If we do keep in the long run I think it's important to _fix_ IRC.
Right now it has some really stupid behavior which is highly
pro-partitioning.

*/who only returns a few nodes, and because most idlers aren't
actually working (no port forward) it's usually for there to be only a
few that work. (I've never seen zero, but I've seen 1).
*Other than who we only learn about nodes when they join. But the
stable long lived nodes we need to hear about seldom rejoin. Nonuseful
windows boxes go up and down a lot.
*Nodes sit in a single channel forever. There are 100 of them.
Especially with fewer clients on line nodes may be sitting alone with
no correctly working nodes with them.
*Nodes recently seen on IRC are highly promoted in the peer selection.

So, here is an updated irc.cpp which I've been running (in various
versions) for a while:
http://people.xiph.org/~greg/irc.cpp

It does the following things:
* Only stays connected for a half hour
* If its sure its not listening it uses a random nick so people won't
try to connect
* Reconnects if it needs more connections
* If the node is actually listening (evidence by actual incoming
connections) it reconnects on its own every 1-2 hours and joins two
channels at random rather than one.
(it doesn't change peer selection— It's hard to be confident of the
impact of that change. I think addrman makes it less of an issue)

I've only not submitted it as a pull request because I haven't had a
chance to test to my standards, and because I felt unsure about the
future of IRC.

I feel strongly that if we're going to keep IRC as a backup we should
fix it. If we're not going to bother then thats fine— but I think we
need to think carefully if we're doing enough for bootstraping (with
the points I made) without it.

Certainly getting it off by default would be a good move. The botnet
allegations are horrible.


-------------------------------------
Hi Walter,

This could be of interest to the XChange project. See GitHub:
https://github.com/timmolter/XChange

The aim of this project is to provide a unifed API for applications to
access financial exchanges. At present it supports Bitcoin exchanges (MtGox
and Intersango are the primary focus with others to follow). It is in the
very early stages of development, but is likely to be integrated into the
MultiBit Bitcoin client (see http://multibit.org) in the near future (early
prototypes are available directly from sources).

One problem that the XChange development team faces is that each exchange
rolls its own data model and uses its own protocol (web socket, socket IO,
direct socket and so on). To provide a reference implementation of how an
exchange should publish its data would be beneficial.

Kind regards,

Gary

On 13 April 2012 10:34, Walter Stanish <walter@stani.sh> wrote:

-------------------------------------
On Sunday, January 15, 2012 5:37:05 PM Jeff Garzik wrote:

I agree (with the conclusion). There are much more important and urgent 
problems than SOPA/PIPA that we'd need to constantly 'blackout' if we did it 
over every single problem.


-------------------------------------
On Thu, Dec 20, 2012 at 12:43 PM, Mike Hearn <mike@plan99.net> wrote:



No, it's not a killer...just a hassle.  JSON is convenient and ubiquitous
and there is something to be said for that (and I wanted to point out that
the JOSE objection was invalid).  Protobufs are nice and efficient, but who
cares.  You're talking about direct communications rather than something
that will be bounced around every node in the mesh network.  I don't really
care much either way, it's not worth debating.  I'm just thankful no one is
arguing for XML or IIOP.  :)


This leaves too much to chance for my taste.  Forget email, what about
jabber, ICQ, skype, IRC?  Email is just one communications medium, there
are many others for which there would be no assurance that the payment
request hasn't been tampered with.  You could at a minimum allow a person
to create a normal ECC key, but have it used as an identity in
communications rather than a payment address.  You store it in a separate
file in ~/.bitcoin/id  ...you don't have to solve the whole set of PKI
problems, people could exchange identities using any secure channel they
are comfortable with (email + phone verification of a short hash id would
be sufficient).  In another scenario, an id could be made available over
https, using the normal SSL certificate and CA infrastructure to verify
authenticity.  This way all messages could be signed and/or encrypted
without the user having to go out of their way to use external tools or
infrastructure that is often not very user friendly.  You also need
encryption for the "cheque" feature...asking people to use GPG would be too
much of a burden (and email DKIM doesn't offer encryption).

Indeed, "cheques" could become the dominant method of person to person
payments...first, you would obtain someone's id, which you might already
have on file (rather than obtaining a bitcoin address), then you would
generate a "cheque" for the amount desired and send it to them...the
recipient then has full control over what address they want to sweep the
funds to as well as whether they'd like to include a miner fee to speed the
confirmation along. Despite the fact that you may send many payments to the
same identity, the only thing showing up on the p2p network and the block
chain is the one time use address for the cheque and the recipient's wallet
address.  This means the recipient has much more control over the address
policy used (compared with simply giving out a bitcoin address that may be
reused).
<<<


I know, but as I was responding, I began to realize this is a mistake.
 It's worthwhile to tackle that problem first...if done right, it would pay
huge dividends.  Also, identity is one thing, an elaborate trust based
identity verification system (like CA's) is a whole other thing.  I think
the former is pretty simple actually...and it's all that's really needed
for the time being (as I alluded, a bitcoin identity could be communicated
or verified using the existing X.509/CA infrastructure if desired...you
could also use the PGP infrastructure).




Actually, I was speaking more in terms of relying on the address to match
up a transaction to an invoice.  The merchant_data field frees you from
having to do that.



Yeah, that's neat...I hadn't thought of that possibility.



It's not a big deal, I just think a referential model is more general than
embedding objects within each other.



Ah, I see it was renamed PaymentACK...the point of signing a PaymentACK is
that while you could prove that you paid according to a PaymentRequest, a
signed PaymentACK is proof that the recipient acknowledged you have made
that payment.
-------------------------------------
On Wed, Nov 21, 2012 at 01:38:37PM -0500, Matt Corallo wrote:

Sure, it's nothing important, but it seems like it fails to do what it was intended for.

How about just this: tweak + i*0xFBA4C795 (number optimized to give large seed
differences for every tweak). If you want variation when changing the number of hash
functions, just choose a different seed. 


It's probably not worth it for something that is max 36 kilobytes. If ever
necessary, we can define a new message type that just lists a number of bits to
be set in the server-side filter.

For now, I agree that you should just send the filter as intended, and not expect to
do many filteradds (though you should take the implicitly-added txids into
accounted when computing the filter size).

-- 
Pieter



-------------------------------------
On Tue, Jan 31, 2012 at 9:53 AM, Gary Rowe <g.rowe@froot.co.uk> wrote:

Lots and lots of people do.  Go place a sell order on mtgox for
$999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
per BTC and look at the awesome doublemax trade it actually stores for
you.


-------------------------------------

It would be slightly worse than shipping a full block but not seriously so.

If you just want to saturate bandwidth or disk IOPS you could probably
just request random blocks over and over again.


-------------------------------------
Hi,

I'll reply to myself here, just to mention that the issue is solved.

Dave Hook from Bouncycastle replied that in the particular signature 
mentioned, one of the ASN1 encoded Integers is actually negative (which 
is not a valid coordinate for a point on a curve I assume). Since ASN1 
integers are always signed, one has to pad "big" values with a zero byte 
to stay positive.

Workaround is easy for verification (convert to positive).

Robert.

On 01/24/2012 06:33 PM, Brautigam Rbert wrote:
...


-------------------------------------
On Tue, Feb 28, 2012 at 18:12, Brautigam Rbert
<robert.brautigam@netmind.hu> wrote:

As explained in the BIP, that would prevent pruning, as it would
require each full node to keep a database with all transaction hashes
ever.


It won't happen by accident. Duplicate coinbase transactions are
possible however (by badly written software, or malicious intent).
Transactions that spend duplcate coinbases can be made to have the
same hash as well.

-- 
Pieter


-------------------------------------
Just to chime in on the MultiBit Merchant aspect. The architecture is that
MBM is a Java backend, but executes as a simple command line:

java -jar mbm.jar server config.yml

As Mike expects, MBM offers a RESTful API using HAL+JSON. It provides a
comprehensive set of order and invoice processing, accounting,
inventory/delivery management and customer account handling facilities for
use with a wide variety of online business models.

There will be a variety of front ends, one of which is an online shop. They
also have the same startup command structure.

Since most folks are shy of using any technology, it is likely that MBM+<x
client> will be offered as part of a SaaS type solution. This allows anyone
who doesn't have the knowledge to configure it for themselves to make use
of it.

MBM will use BitcoinJ and will depend on a bucket of public keys for
transactions until the HD support is in place to allow generation of public
keys without private keys being present. This removes the need for private
keys to be present on the servers, and allows consumers of the SaaS model
to provide their own transaction keys.

The code is released under MIT license so anyone, anywhere can use it to
build the Bitcoin economy.

More info:
https://github.com/gary-rowe/MultiBitMerchant/wiki/Introduction
http://gary-rowe.com/agilestack/2012/06/06/multibit-merchant-genesis/

On 10 October 2012 12:19, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
Are we looking at the same list? Because here is the order I added: Bitcoin-Qt, Armory, Electrum and MultiBit. Maybe try CTRL-F5 to force a refresh of your browser.

Also about the descriptions: yeah I know. I think it's better to put this up first and then have everyone submit their own descriptions and screenshots. Otherwise it'll be a nightmare to coordinate until everything is perfect. I did message you on IRC today but maybe you were offline.

I didn't copy paste the Armory description from the website because it really sounds too spammy like a sales pitch. Here I was trying to give an even handed balanced overview of all the clients. For each client I was trying to empaphise a 'theme'. Bitcoin-Qt is stability. Armory is advanced. Electrum is convenient. MultiBit is ease of use.

________________________________
From: Alan Reiner <etotheipi@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com> 
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net> 
Sent: Monday, April 30, 2012 7:23 PM
Subject: Re: [Bitcoin-development] new bitcoin.org clients page


Hey, looks good! I'm glad to see them sorted alphabetically :)

A couple comments: I don't think the entries for "wallet security" and "backups" accurately describe Armory. Wallet Security should say "Encrypt/Offline" or something to to that effect -- after all, offline wallets are the holy grail feature of the Armory. And backups should say something like "One-time Printable" if it fits within the box. 

Otherwise, I really like the layout and design. Although despite the fact I enjoy being first on the list, I think Bitcoin-Qt should still go first. It is the "reference" client, and I think it's relevant that it is the "de-facto" client for the majority of users, and the one with the most quality control and stability.

-Alan



On Mon, Apr 30, 2012 at 1:50 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

Check it :) https://github.com/bitcoin/bitcoin.org/pull/34


-------------------------------------
On Sat, Oct 20, 2012 at 7:55 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

I strongly support this too. It is good to make the protocol as
well-defined as possible in a self-contained way, ie define all the
parsing and processing without referring to specific current
implementations of other libraries such as OpenSSL.

What always bothered me is that OpenSSL can change their API to accept
new obscure key encodings at some point, or change their
interpretation, and bitcoin will automatically change with it. As
bitcoin happily links against any OpenSSL version you provide it, in
worst case, this can result in forks and unexpected behavior
completely out of our control.

Wladimir


-------------------------------------
OK - didn't took the weekend:

support for "port" is on github now :)

Only took two lines:

            ("port", value<unsigned short>(&port)->default_value(8333), "Listen on specified port for the p2p protocol")

and using the port option in the Node constructor (was there already):

        Node node(chain, data_dir, args.count("nolisten") ? "" : "0.0.0.0", lexical_cast<string>(port)); // it is also here we specify the use of a proxy!

/M



On 24/02/2012, at 19:49, Martinx - ジェームズ wrote:


Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager@ceptacle.com
Web: http://www.ceptacle.com/



-------------------------------------
On Sun, Jun 17, 2012 at 7:04 PM, grarpamp <grarpamp@gmail.com> wrote:

0.6.2 is very widely used, more so than the other acceptably updated backports.


I can't speak for anyone but myself:

I don't run master on wallets with large amounts of (non-testnet) coin
in them, except for a few times when I needed access to this feature
or that or just in a isolated capacity for testing.  In any use with
real wallets I'd be sure to have good backups that never touched the
new code.

We have at various times had bugs in master that would corrupt wallets
(though IIRC not too severely) and have bugs that would burn coin both
in mining and in transactions (though again, I think not too
severely).  My caution is not due to the risk being exceptionally
great but just because there is probably no remedy if things go wrong,
this caution is magnified by the fact that we don't currently have
enough testing activity on master.

Testnet exists so that people can test without fear of losing a lot of
funds and with the 0.7.0(git master) testnet reboot it should be more
usable than it has been.   It would be very helpful if anyone offering
bitcoin services would setup parallel toy versions of your sites on
testnet— it would bring more attention to your real services, it would
give you an opportunity to get more testing done of your real
services, it would show some more commitment to software quality, and
it would let you take a more active role in advancing bitcoin
development by doing a little testing yourself that you couldn't do on
your production systems.


-------------------------------------
At the moment if you visit bitcoin.org then you're recommended to
download the full client. I think we all agree that at some point we
need to start presenting users with something more like this:


To get started, download wallet apps A or B.

If you'd like to contribute your computing resources to the Bitcoin
network and have a fast computer with an unfiltered internet
connection, download:

   - for desktop machines, Bitcoin-Qt
   - for servers, bitcoind



Obviously not that exact wording.

I personally feel it's a bit early for this, but it's true that users
are being turned away by the fact that they're pointed to Bitcoin-Qt
by default, so having some kind of roadmap or plan for changing that
would be good.

I think MultiBit is maturing into a client that I'd feel comfortable
recommending to end users who take the fast-start path, though it
still has a few serious lacks (encrypted wallets aren't released yet,
bloom filters will help performance a lot, needs to catch up with some
newer features). But there doesn't have to be a one true client.

The alternative, I guess, is to make Bitcoin-Qt have an SPV mode. I'm
not convinced this is the best use of time, but if somebody steps up
to do it, that could also work. MultiBit has some unique features that
are quite useful like integrating charting and exchange rate feeds.

What does everyone think on this?


-------------------------------------
On Mon, Jul 9, 2012 at 11:54 AM, Amir Taaki <zgenjix@yahoo.com> wrote:

If you had authored this as a pull request rather than making the
change unilaterally I would have recommended leaving it so the
reference client was always first. I also would have suggested that it
use JS randomization instead of jekyll in order to get more even
coverage, though I think thats a more minor point.

Some people were concerned when this page was created that it would
just be a source of useless disputes.  I think its becoming clear that
this is the case. I think the cost of dealing with this page is
starting to exceed the benefit it provides and we should probably
consider removing it.


-------------------------------------

That's why I posted the details of the machine so interested people
could duplicate it if they are working in these areas. Once I'm on new
hardware and playing around I, also, may find some discoveries.

I have no doubt that 'common' is windows seven on core2duo
without ecc and no crypto or hashing for the disk :)


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 03/08/2012 01:07, Gary Rowe wrote:

Hi Gary,

Thanks for the response. :)

I have started all this in bettermeans, but lost a lot of work (which
I am working on how to redo - but I am on holiday at the moment, and
have restricted access to my test setups)

Here is the discussion thread I had with gavin about acceptance tests.

https://secure.bettermeans.com/boards/4316/topics/7261

Here is the work I have currently done (note, it was losing all the
General Acceptance Tests and getting no response from bettermeans that
has lead me to not want to use it)

also note that the terminology I have been using is a little wrong, I
refer to release 0.7 as testnet release 0.7 - I will tidy it up. - I
did this before and it looks like it got reverted somehow.

here is the main wiki space that I have been using.

https://secure.bettermeans.com/projects/4256/wiki

For the General Accceptance Tests, check

https://secure.bettermeans.com/projects/4256/wiki/Dev_general_acceptance_tests

These are the basic acceptance tests based off the changelog

https://secure.bettermeans.com/projects/4256/wiki/Dev_acceptance_tests

However, notice no tests are in there yet.

There is plenty more stuff on bettermeans so please go have a poke
around.  I will try to get at least a wiki setup on a vps I have
control of (in germany, and provided by CINFU and paid for with
bitcoins) and get the stuff moved over and put the tests back up.  I
can do a limited amount of testing if the release is to happen in the
next week or two, So I will focus my efforts on the installation tests
and wallet tests. Ideally I would like to get all the GAT's done.

Hopefully this fleshes things out a bit more.

Please feel free to add/edit but remember your stuff might magically
disappear, it might be better to wait for the wiki move.  I intend on
doing the wiki move today. but that might not happen.

(I have a feeling that it was me adding stuff from an account that is
not on the BTP that blew things up, just a feeling though)

I would like to keep tests informal if possible, but that kinda goes
against the purpose of the tests. this is a bit tricky to explain if
you have not had a look at bettermeans.  bettermeans kinda has its own
BIP and voting mechanism, which is quite nice and it is what I want to
emulate - this should reduce the need for vetting of tests... have a
look at what is there and see what you think.

:)

cheers,

steve
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.17 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/

iQEcBAEBAgAGBQJQGxkFAAoJEFvEB9dQFvtQeD0IAJe9BJz/mv+kZjhk7LH1d7HH
c46D7s2Y8a+2Yobve4KtRGMoQZQiqqXGIdZ2nHVO77s0zICixqdtcKlRvBZHybw9
pB8hFYmeBdXvMHj7TR4kMbMKqTJ2z/B6m1qEKFfCRIXQXnyD5qNYhFocyQMwz53A
dkwhpoiWNVqcgnz51XEnphyohu0TPsPbOOyCrT7ORdyAgLJAs5Ig1sKbTAdSxOux
flEYKOVk0gse2b8lO2ly+eLwcQgI7jrzy+qkSKmNajRKFdvHUODXo4RraR08qiaJ
SUpmN/43uQZ4atMdOCZxD5DWKjBO96sj6mkB/po5lzIEEtkhzyp/wmKdHtlvZ/Q=
=Fonn
-----END PGP SIGNATURE-----


-------------------------------------
Alan Reiner wrote:

PATRICIA Tries (aka Radix trees) have worst-case O(k), where k is the
number of bits in the key. Notice that since we would storing k-bit
hashes, the number of elements must be less than 2^k, or else by
birthday paradox we would have a hash collision! So O(log N) <= O(k).

You're right, though, that such a trie would have the property that
any two trees containing the same data (leaves) will be identical. I
can't think of any reason why this is useful, although I am hoping we
can figure out what is triggering your intuition to desire this! I am
indeed assuming that the tree will be incrementally constructed
according to the canonical (blockchain) ordering of transactions, and
that the balancing rules are agreed on as part of the protocol.

-- 
Andrew Miller


-------------------------------------
There appears to be some non-trivial mining power devoted to mining
empty blocks.  Even with satoshi's key observation -- hash a fixed
80-byte header, not the entire block -- some miners still find it
easier to mine empty blocks, rather than watch the network for new
transactions.

Therefore I was wondering what people thought about a client
implementation change:

     - Do not store or relay empty blocks, if time since last block < X
       (where X = 60 minutes, perhaps)

or even stronger,

     - Ensure latest block includes at least X percent of mempool
unconfirmed TXs

The former is easier to implement, though there is the danger that
no-TX miners simply include a statically generated transaction or two.

The latter might be considered problematic, as it might refuse to
relay quickly found blocks.

Comments?  It wouldn't be a problem if these no-TX blocks were not
already getting frequent (1 in 20).

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Fri, 2012-06-15 at 13:29 +0200, Mike Hearn wrote:
The idea can be more generalized in that there are many cases where the
generator of a transaction doesn't care about confirmation times, and
would really be willing to make their transaction lower priority than
other 0-fee transactions.  This enables the first point with lower
confirmation times for a while longer.
As it turns out, we already have an indication that someone is willing
to wait longer for confirmations - rapid reuse of an address.  
1) Green Addresses: The whole point of a green address is that you are
trusted based on your address, not necessarily based on confirmations of
your transactions.  In this case, you are generally willing to wait a
bit longer for confirmations than the average user depositing coins into
their Mt. Gox account.  
2) Donation Addresses: If you are using a publicized donation address,
you probably aren't depending on getting your coins *now* to turn around
and ship a product and, again, you are a bit more willing to tolerate
longer confirmation times.
3) Lazy (or overworked) coders: If, for whatever reason, someone
designing a bitcoin site decides that it is simply easier to make users
pay to a single address for everything, such actions should generally be
discouraged.  Such a setup is worse for end-user privacy.  Also, such
laziness (or likely just overworked and not having time to fix the
issue) is likely also laziness across the board including ignoring
multisend for payouts.  If you discourage such address use forcing site
designers to implement more sane policies, hopefully they will do enough
research to also do multisend.  Note that though this is where one
addresses sites like SatoshiDice, its also the one where we are likely
to have the least impact...

One of the ways to implement such deprioritization of rapidly-reused
addresses is to limit the count of address re-uses by default in memory
pool.  By limiting relaying of such transactions, you a) give nodes
across the network some small say in the transactions which they have to
deal with relaying outside of blocks, instead of relying on miners to
make decisions which are good for the total network load, but which are
worse for them.  b) You allow sites which wish to re-use addresses to do
so initially to keep the time-to-launch the same as it is today, but
force them to re-think their design decisions as they grow to
(hopefully) decrease their impact on the average Bitcoin full-node
operator.  Sites which begin to see their transactions rate-limited have
several options:
1) Make a deal with a miner to feed them their list of now-non-relayed
transactions outside of the regular p2p network and have them manually
added to blocks.  Id argue that such setups are going to become more
common in the future and such out-of-band transaction relaying should be
encouraged.  This also shifts the delay for other transactions from a
constant delay getting into blocks until there is room for additional
0-fee transactions to a spike on each block from the given miner.  I
highly prefer this, as you would see usually only one or two block delay
getting your transaction confirmed at the worst case, instead of a very
fuzzy unknown delay that could stretch on for some time.
2) Use rotating addresses.  This is likely the simplest to implement,
and I would absolutely think this is what most sites would end up doing.
Though it doesn't result in a decreased load on the transaction-relaying
nodes, it does at least allow for a minor improvement in user privacy.  

In the end, it boils down to an optional transaction deprioritization.
I think all of the above are largely no brianers to everyone.
Definitely something that is very appealing as we need to scale up.
My point was that the easiest way to do it would be to ship a pruned
snapshot with Bitcoin, and such a system, while verifiable, would
increase Bitocin's centralization.  Though it is quite possible to prune
the chain while downloading at checkpoints or when blocks are N deep, it
complicates the initial download if no one has the chain to begin with. 

Another point I made was that by doing chain pruning by default, we may
see a decrease in non-fClient nodes (for compatibility, I would assume
pruned nodes have to set fClient) which is what old clients look for to
connect to, possibly complicating using Bitcoin for clients that either
wish to run a full IBD or older clients which need a non-fClient node
before they are happy (which could be an issue when you look at the very
poor "upgrade-apathy" in the Bitcoin community with people running
long-outdated versions because they don't feel like upgrading).

All that said, I do believe pruning will eventually have to come to
encourage p2pool and other getmemorypool-based pool mining, but
(obviously) its something that needs careful consideration in its
overall effects across the network before its applied.




-------------------------------------
There are several major changes in git HEAD that are ready for wider
testing. The best way of getting lots of testing is to release
binaries, so I'm going to be pulling together a release candidate in
the next day or two.

The goal will be to get at least a full month of release candidate
review/testing before releasing a 0.6 final, with zero High Priority
bugs ( https://github.com/bitcoin/bitcoin/issues?labels=Priority+High&state=open
)

Here's the proposed TODO list for a rc1:

Pull:
800 : bug fix, multiple output display fix in GUI
799 : Have bitcoind recomend a secure RPC password
769 : Make transactions with extra data in scriptSig non-standard

Rebase/pull:
795 : Fix minimize to tray

Pull a modified version of:
755 : Don't vote for /P2SH/ unless -p2sh specified

I'd like to pull 787 (CAddrMan: stochastic address manager) but it
didn't pass my sanity tests.

I'm going to start a separate discussion thread with some thoughts on
rolling out higher-level multisignature support.

-- 
--
Gavin Andresen


-------------------------------------
As replied on the github issue:

Personally I still think it's better to have a clear standardized "protocol
version", that implies what capabilities are supported, instead of a
capability-based system that explicitly lists them.

Capability-based systems (just look at OpenGL) tend to become horrendously
complex, as you have to take into account all possible combinations of
possible interactions, and constantly check for support of specific
features instead of just comparing a version number.

Sure, it can be necessary to distinguish between different types of nodes,
but there is no need to make it this fine-grained.

Wladimir

On Sat, Jun 16, 2012 at 3:34 AM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
On Thu, May 24, 2012 at 8:57 PM, Luke-Jr <luke@dashjr.org> wrote:

The times in your log are very accurate, assuming your system clock is
remotely accurate.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
RE: sharing parts of the merkle branches when returning a 'merkleblock' :

I think I agree that complicating the BIP for what should be a very
rare case (more than a handful of transactions in a block match the
transactions in your wallet) is the right decision.

I want to make sure I'm understanding this bit correctly:

"In addition, because a merkleblock message contains only a list of
transaction hashes, any transactions that the requesting node hasn't
either received or announced with an inv will be automatically sent as
well. This avoids a slow roundtrip that would otherwise be required
(receive hashes, didn't see some of these transactions yet, ask for
them)."

Requiring serving/relaying nodes to keep track of which transactions
they have or have not sent to their peers makes me nervous. I think
requiring an extra 'inv' round-trip would be simpler to implement and
less likely to lead to some kind of DoS attack.

-- 
--
Gavin Andresen


-------------------------------------

Do it in two parts...
- overview, history, architecture model, 'whys'.
- agnostic table of features, platforms, stats, protocols, etc

Last, resolve whether or not bitcoin.org is independant.
It cannot be if it does not accept all lib/client under it's umbrella
or has a lib/client project of it's own. You will hit up against this,
just saying.



No, they all do this and build it, subject to their feature set.


No, all implementations are suited for whoever, subject to their feature set.


Which project, the given client or the bitcoin meme.


Right, anyone who doesn't is unwashed rebel scum, running default
installs of xp, on systems with bad ram, who post their home address,
transaction logs, and pink bits on facebook.


Again, a feature set / usage model thing.



Hey, we're fast, easy and for noobs, me too.


But at least the backing specifics to that claim are stated.



Yeah, every lib/client will have a donation thing on their own site,
and the developers own real world wallet.


Not sure of this claim. It's all in the usage. Run your own remote,
use anonymizers, etc. Right?


-------------------------------------
Hi,

 Why bitcoin.org promotes some private enterprises and not others?
May, I for example, have 20% of over the fold space on bitcoin.org
homepage for Bitcoin Magazine prmotions? Pretty please? </sarcasm>

Kind Regard,
Vladimir Marchenko.


On 15 July 2012 18:52, Amir Taaki <zgenjix@yahoo.com> wrote:


-------------------------------------
I don't think it's minimally invasive to layer PGP's web of trust on top of
Bitcoin, in fact, the opposite.

solution to the web of trust. Digital cash with an existing web of trust in
place was a working concept in the mid-1990s, courtesy of David Chaum, I
believe.

I totally agree on the kitchen sink concern; I would personally like to see
something like a one-year required discussion period on all non-security
changes proposed to the blockchain protocol. We know almost nothing about
how bitcoin will be used over the next 20 years; I believe it's a mistake
to bulk up the protocol too rapidly right now.

There's a famous phrase from the founder of Lotus about Lotus' engineering
process: "add lightness." The equivalent for protocol design might be "add
simplicity." I'd like to see us adding simplicity for now, getting a core
set of tests together for alternate implementations like libbitcoin, and
thinking hard about the dangers of cruft over a 10+ year period when it
comes to a technology which will necessarily include a complete history of
every crufty decision embodied in transaction histories.

Peter


On Tue, Apr 3, 2012 at 1:42 PM, Wladimir <laanwj@gmail.com> wrote:



-- 

Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
-------------------------------------
Gavin's grandma needs to be able to use bitcoin.  Here is a real world
sampling of the types of people wanting to use bitcoin but are having some
difficulty which I have collected from Facebook.  Should we listen to the
end user? :-P

*"what is the intention of Bitcoin? Is it supposed to be - eventually - for
dummies like myself or is it just for those individuals who are code and
algorithm writers? I downloaded a wallet but how do I know if I need more
software or a massive computer system to solve "the problem" for the next
block? With all the talk of mathematical problem solving on a world wide
network of computers I can't see a small laptop figuring out anything thus
not gaining any bitcoins. Why should I be interested in this if it appears
it's just for computer scientists?"*

*"hi, instaled bitcoin qt, but after it dowladed all the stuff, now i get
DEP protecction from windows, and it tells me bitcoinQT need to run with
DEP on, dont let me make an exception for it, nor work it i turn DEP only
for sys, so hwat i should do?"*

*"hi, i'm new to bitcoin, i got a bunch of free bitcoins from a bunch of
the free sites. how come when i tried to send my bitcoins to myself, it
says the fee exceeds the balance? I thought there was no fees?"*

*"Is there a way to speed up the process of synchronisation with the
network? It has been taken ages on my MAC.*
*Any help would be nice"*
*
*
*and more...*

Sorry if this doesn't belong to the bitcoin-development email list.  I just
see this as end-user/customer data gathering to refine the requirements,
since this is software engineering...isn't it?

Jim

On Tue, Dec 4, 2012 at 6:54 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------
I started working on a new feature to allow for watch-only addresses in wallets. https://github.com/bitcoin/bitcoin/pull/2121

In order to integrate this feature nicely into bitcoin / bitcoin, it will be necessary to disable signing and privkey export operations for watch-only addresses. Since disabling these things for only some of the keys in a wallet but not others is an API nightmare and complicates CreateTransaction logic, I propose adding multiple wallet capabilities and specifying upon creation whether a wallet is a:

1)  full signing wallet
	- importaddress is disabled.

2) watch-only wallet
	- signing and privkey export operations are disabled.
	- importprivkey only saves the associated address but not the private key. (behaves like importaddress <address for privkey>)

In order to do the above, it will be necessary to add multiple wallet support. Anyhow, that was my initial motivation for multiple wallets - but obviously, there are a number of other reasons why people might want multiple wallet support.

----------------------

Adding the ability to specify multiple wallets with associated names and passphrases in the config file should be fairly straightforward. However, exposing multiple wallets via RPC will be tricky as the existing RPC is not designed to support multiple wallets.

As to not break compatibility with the existing RPC calls, we can have a main wallet which is always used as the default wallet. If the user wants to use a different wallet, the name of the wallet would have to be specified in the call. Unfortunately, it doesn't look like we can use many of the existing RPC calls (sendfrom, sendmany,sendtoaddress, etc...) since they all have optional parameters already and it would be awkward to just tack on the wallet name parameter at the end. Also, walletpassphrase is problematic as it is not stateless. So it looks like we need a whole separate set of calls which require a wallet name and passphrase (if the wallet is encrypted).

For instance,
	walletsendtoaddress <walletname> <passphrase> <bitcoinaddress> <amount> [comment] [comment-to]

I welcome any proposals or suggestions as to how this should be done.


-------------------------------------

Fair enough, although I would posit:
 0. You can't get more secure than not doing it at all.
 1. Small is sometimes beautiful, but sometimes just the 999th
crippled and half-featured attempt at a nontrivial problem space
(...linked heavily to implementation-time assumptions and/or specific
peer systems, and by its very nature destined for the dustbin of time?
Well, maybe. Eventually, we all are.)
 2. X.509 is not small (or beautiful, unless one is some weird new
kind of centralized cryptographic trust fetishist, of some sort you
might see with furrowed brows, boozing at midday sporting key & anchor
tattoos in old convention polo-shirts, mumbling to themselves about
the employee-motivation benefits of single sign-on...)


Yes. Understandable. Thoughts around an IFEX protocol proposal, unlike
the other proposals, are still drafty (err...as a coastal verandah?)
and not the clearest. However, we have much research and progress has
been achieved in the odd year-or-so since beginning.  The fundamental
concerns of such a protocol (regarding the establishment of neutral,
open and technically-viable proposals for internet-wide
currency/commodity, market and financial endpoint identification) have
already been reasonably met.

This has opened the door to the potential for faster progress on the
IFEX protocol itself ("a mechanism for the identification,
negotiation, description, execution and management of financial
transactions over their lifetime"), like, right about now. Which is
kind of the same zone of potential functionality (at least in a naive,
linguistic comparison sense) that people are talking about here.
Because of the hope to garner more interest from the Bitcoin community
with this post (do read on!), I spent a bunch of hours today cleaning
up and converting the IFEX Protocol's current breezy-draft form back
from the wiki formatting it had been lazing and grazing (and growing,
albeit slowly) in for the greater part of the year and moving to
Github (forks and issues very much encouraged) over here:
https://github.com/globalcitizen/ifex-protocol
  (Discussion list at http://group.ifex-project.org/ actually has
quite a few members at present, despite appearances to the contrary)


Re: "implemented on top of ifex", this is kind of opposite to how IFEX works.

IFEX's idea is to provide a flexible yet stable protocol that lets
individual (potential, ongoing, or completed) transactions on
arbitrary (legacy, conventional, emerging, or future) settlement
systems (in arbitrary currencies/commodities) to be described and
facilitated (executed, routed, monitored, etc.) in real time, by
describing accurately the objective properties of each of those
systems and components.

So, for example, an end user, requiring a transfer of <x> of <y>
currency/commodity from 'point a' to 'point b' would find routes to
achieve that, evaluate them in terms of monetary and temporal
overheads against their own trust and risk models plus any legal,
privacy or other requirements in order to select and effect the most
appropriate manner of settlement.

In short, IFEX sees Bitcoin as having such-and-such properties,
matches that to a need to transfer some funds, and effects the
transfer, monitoring and/or reporting on its state in a normalized
fashion throughout its lifetime.

I'll try again to describe the motivating use case:
==============
Recognising that Bitcoin is not the only emerging financial community
or settlement system facing real world business integration
challenges, and recognising the significant complexity of these in
common situations (multi-hop transactions, arbitrary currency
transactions, foreign exchange automation, liquidity guarantee
challenges, settlement latency negotiation, invoicing periods,
commercial payment or shipping terms, sovereign (exchange rate
fluctuation) and other forms of risk management, potentially
simultaneous multi-level fee, tax and discount requirements,
product/service coding, line items, complex tax calculations
(particularly in the US, and which may be based on both buyer and
seller geolocation), legal requirements to include various metadata,
etc.), instead of investing valuable developer time on internal
implementation (and subsequent maintenance) of a tightly-scoped
(==crippled?) business-level protocol extension to Bitcoin that can be
perhaps fairly characterised as unlikely to quickly evolve to meet
many of these real world requirements, and with as yet unclear real
world demand for such from the Bitcoin community, who must already
overcome significant complexity hurdles to use Bitcoin at all, Bitcoin
developers can instead simply declare this "out of scope" (win!) and
focus on Bitcoin's current roles as a digital commodity and settlement
system.

This approach to scope limitation has excellent historical support
from the unix community - "do one thing and do it well". Bitcoin
already does a few things, notably in its triple roles as
network-community, currency-like-commodity, and settlement system.

The alternative is that instead of creating load for the Bitcoin
developers, who may be ill-equipped and ill-resourced to properly
tackle these peripheral requirements, interested parties instead
contribute to projects like IFEX that view systems such as Bitcoin as
core use cases but are not limited by Bitcoin developer time or
project trajectory, and promise re-usability for other conventional,
emerging and future currencies/commodities/settlement systems, thus
retaining the capacity to attract interest and resources from those
communities (and broader, internet-centric interest groups and
infrastructure) toward a common goal, while creating a valuable shared
platform for interoperability between Bitcoin and those other systems
(including legacy financial systems) that allows Bitcoin to
objectively showcase its strengths.

Net result: Bitcoin developers can focus on Bitcoin. Meanwhile,
business level integration things completely tangential to the core
bitcoin codebase get done with a far broader scope and applicability,
providing a broader community and potential resource base for moving
things forward, and presenting a less "shifting-sands" approach to
potential implementers (who are safe in the knowledge that their now
standardized infrastructure can support a wide range of
currencies/commodities, settlement systems, financial network
topologies settlement paradigms, and will not critically rely upon any
given component system as a single point of failure). Bitcoin, through
the platform IFEX develops, gets to compete at the business level on a
fair and even basis with legacy and other emerging systems based upon
its highly desirable objective properties (speed, reach, low
overheads, rapid connection, lack of wacky X.509 certificate
purchasing requirements... yet, etc.), such that a business case *not*
to use it in various commercial settings becomes difficult to field.
Everyone wins.
==============

Note that the above basically echoes much of the (less verbose? more
digestible?) information available at http://ifex-project.org/ where -
along with http://tools.ietf.org/ - the full text of existing
proposals are also available, but attempts to do so in a more specific
fashion for Bitcoin developer community.

Considering the above, and that a single system is never going to meet
every person's needs all of the time (yes, even Bitcoin!), I really
hope that the Bitcoin developer community will see the benefits of
supporting an external rather than internal solution to business level
(or at least non directly settlement-facilitating) financial
transaction requirements, both for the Bitcoin project itself, its
users, and for that broader and longer-term goal (in very much the
same spirit) of effecting some sorely-needed, socially positive and
lasting change in global financial systems.  Nothing can be all things
to all people (especially X.509, which can be completely different
kinds of pain to all who come in to contact with it) - but at least
with an open, platform neutral financial transaction oriented protocol
outside of individual settlement system, currency and commodity
projects, each new system can stand on its own merit and support the
others, deriving shared fruits of increased user base, usability and
liquidity through heterogeneous interoperability.

Sincerely, hoping to work together with interested parties to move
forward in this area (come issue/fork the github repo!), and with the
utmost respect for all of the valuable work of the Bitcoin community
(though scratching my head a bit on the lack of an April 1 date or
punchline for this X.509 stuff!!), and, and, out of breath,
Walter Stanish


-------------------------------------

There are several reasons for this:

1) P2P network sockets are a limited resource and bringing up
connections to the network, whilst somewhat fast today, is not
guaranteed to be fast in future. Passing transactions to the merchant
for broadcast reduces the load on the P2P nodes because lots of thin
clients aren't any longer connecting and disconnecting when sending.
They only need to talk to the network when the user has received
money.

2) Some users may not have network connectivity at all. For example,
this happens quite often whilst traveling at Bitcoin conferences ;)
The solution, which Andreas and I prototyped in Berlin together, is
for the buyer to communicate only with the seller which can be done
over Bluetooth or WiFi Direct or some other mobile radio protocol.
Again, send only, but for the common case where you load up your
wallet before setting out and then buy things, it works OK.

4) A longer term reason - in time, people may choose to not broadcast
transactions at all in some cases. I think how network speed will be
funded post-inflation is still an open question. Assuming the simplest
arrangement where users pay fees, getting transactions into the chain
has a cost. In cases where you trust the sender to not double spend on
you, you may keep a fee-less transaction around "in your pocket". Then
when it's your turn to pay, you use some unconfirmed transactions to
do so. People pass around longer and longer chains of un-broadcast
transactions until a payment crosses a trust boundary, at which point
the receiver adds on their own transaction that spends back to himself
but with a fee, and broadcasts them all together as a unit. In this
way only people who genuinely need to fear double spends pay for
security.


-------------------------------------
Hi Michael!

 I just run "bitcoind", from libcoin ("sudo make install") sources, with
empty ~/.bitcoin directory and:

Terminal 1: bitcoind # apparently okay

Terminal 2:

$ bitcoind getinfo # okay
{
    "version" : 40001,
    "blocks" : 57733,
    "connections" : 8,
    "difficulty" : 11.84622815,
    "testnet" : false
}

# sleep a couple minutes

$ bitcoind getinfo # ok
{
    "version" : 40001,
    "blocks" : 67527,
    "connections" : 8,
    "difficulty" : 45.38582234,
    "testnet" : false
}


But...


$ bitcoind help
HTTP error code: 404
JSON RPC Error code: -36001
Method not found.

$ bitcoind getaccountaddress ""
HTTP error code: 401
Error: couldn't parse reply from server

$ bitcoind listaccounts
HTTP error code: 401
Error: couldn't parse reply from server


 Any tips?! lol

Thanks!
Thiago

2012/2/23 Martinx - ジェームズ <thiagocmartinsc@gmail.com>

-------------------------------------
Hey,

I just saw this added to the clients page. One of the conditions we set for that page was that all the clients must have the entire sourcecode available for review, and users should be able to run it from the sourcecode. Is the sourcecode for this client available for review? I couldn't find it.

Otherwise, we should make a separate section for non-opensource clients.



-------------------------------------
Copying from a response posted to "Bitcoin software testing effort"
https://bitcointalk.org/index.php?topic=117487.0 as it is relevant to
a recent thread here...

Any level of testing is useful and appreciated.  Various types of
testing that are helpful:

* "it works" testing:  Simply run the latest Release Candidate (or
latest version, if released).  Make sure all the basics work (for
whatever definition of "basics" you desire).  This is the level most
accessible to casual users.
* Major features testing:  Develop a short checklist of must-work
features, and organize volunteers to work together and go through that
checklist, item by item.  Test each major feature on each major
platform.
* Stress and fuzz testing:  Attempt to "stress" the system somehow, or
randomly corrupt bits of data.  See what breaks.
* Regression testing:  Record bugs fixed, and develop automated test
cases that successfully reproduce the bugs on older versions, and
verify newer versions remain fixed.
* Unit function testing:  Rigorously exercise each C++ class to ensure
it behaves as expected at a micro level.
* Full peer automated testing:  Automated testing of RPC and P2P
functions is non-existent, because of the difficulty in doing so.
Find a solution to this problem.
* Data-driven tests: If possible, write software-neutral, data-driven
tests.  This enables clients other than the reference one (Satoshi
client) to be tested.  Embed tests in testnet3 chain, if possible.


The community at large can be a big help simply by doing the first
item:  download and run the Release Candidates and the latest version,
and report any problems.  Even reporting success is fine by me, for
example: "Version 0.7.1 works for me on Windows 7/32-bit" posted on a
forum thread.

It is always very difficult to organize any sort of testing regime
with open source volunteers that come and go.  Each volunteer chooses
their level of involvement.  Any amount of testing and test-case
writing, large or small, is helpful to bitcoin.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hi!

 I'm trying to compile libcoin again and I'm seeing the following error:

libcoin@xapado:~/libcoin$ make
Scanning dependencies of target coin
[  1%] Building CXX object src/coin/CMakeFiles/coin.dir/util.o
In file included from /home/libcoin/libcoin/include/coin/serialize.h:22:0,
                 from /home/libcoin/libcoin/include/coin/uint256.h:8,
                 from /home/libcoin/libcoin/include/coin/util.h:10,
                 from /home/libcoin/libcoin/src/coin/util.cpp:6:
/home/libcoin/libcoin/include/coin/Version.h:5:25: fatal error:
coin/export.h: No such file or directory
compilation terminated.
make[2]: *** [src/coin/CMakeFiles/coin.dir/util.o] Error 1
make[1]: *** [src/coin/CMakeFiles/coin.dir/all] Error 2
make: *** [all] Error 2

 Any help?!

Thanks!
Thiago
-------------------------------------
On Tue, Feb 14, 2012 at 7:09 AM, slush <slush@centrum.cz> wrote:


I have a girlfriend but she hates valentines day so it is ok with me:-)

Wladimir


-------------------------------------
[I originally sent an earlier version of this message to Mike off
list, but I figure it's worth adding to the public discussion]

On Fri, Jun 15, 2012 at 7:29 AM, Mike Hearn <mike@plan99.net> wrote:

By itself letting the size float has non-trivial existential risk.  A
Bitcoin with expensive transactions due to competition for space in
blocks can be front-ended with fast payment systems and still provide
the promised decentralized currency. Bitcoin with a very large
blockchain and blocks does not.  It would do the bitcoin users no good
to increase the transaction volume while concurrently making Bitcoin
more or less pointless over the alternatives.

Scalability must be improved, we can unite on that opinion.  But
scalability can't come at the expense of what made Bitcoin worth
having in the first place.

Fortunately it appear to be possible to greatly increase the
scalability without compromising on keeping the costs of operating a
fully validating node very low,  for example Pieter's experimentation
with txout+txid indexing (for the 'flip the chain' proposals)
indicates that the data required right now to validate further
transactions is only about 85MiB— and that would be somewhat smaller
with compression and with clients which intentionally try to reduce
the set of unspent transactions.   Commitments to these indexes in the
chain would allow almost-full validating nodes with fairly limited
resources.  (Almost-full meaning they would not validate the history
long before they started, they'd trusted header difficulty for that. They
could still mine and otherwise act as full nodes).

Achieving scalability improvements without breaking the radical
decentralization will be a lot harder than just improving scalability
but it's effort that is justified if the scalability is actually
needed.

How much decentralization is needed in the end?  That isn't clear— "As
much as possible" should generally be the goal.  Modern currencies
aren't controlled by single parties but by tens of thousands of
parties locked in economic, legal, and political compromise that
limits their control.  In Bitcoin the traditional controls that keep
parties honest are non-existent and if they were just directly applied
we'd potentially lose the properties that make Bitcoin distinct and
useful (e.g. make all miners mine only with FED permission and you
just have a really bandwidth inefficient interface to the dollar).
Instead we have aggressive decentralization and autonomous rule
enforcement.

Mike pointed out that  "Before he left Satoshi made a comment saying
he used to think Bitcoin would need millions of nodes if it became
really popular, but in the end he thought it could do fine with just
tens of thousands"    I'm not so sure— and I think the truth is in
between.  Tens of thousands of nodes— run by a self-selecting bunch of
people who reap the greatest rewards from controlling the validation
of Bitcoin, who by that criteria necessarily have a lot in common with
each other and perhaps not with the regular users— could easily be an
outcome where control is _less_ publicly vested than popular
government controlled currencies.   We probably don't need the raw
numbers of nodes, but we need a distribution of ownership and a
distribution of interest (e.g. not a system by bankers for bankers) of
those nodes which I think can only be achieved by making them cheap to
operate and having a lot more than we actually need. — though not so
much that it has to run on every laptop.

The core challenge is that the only obvious ways to justify the cost
of maintaining expensive validation infrastructure is because you
intend to manipulate the currency using it or because you intend to
prevent other people from manipulating the currency.  The latter
motivation is potentially subject to a tragedy of the commons— you
don't need to run a full validating node as long as 'enough' other
people do, and enough is a nice slippery slope to zero.   Right now
just the random computers I— some random geek— had at home prior to
Bitcoin could store over a hundred years of max size blocks and
process the maximum rate of transactions.   With the costs so low
there isn't any real question about a consolidation of validation
making Bitcoin pointless.  You could probably increase the scale 10x
without breaking that analysis  but beyond that unless the
cost-per-scale goes down a highly consolidated future seems likely.
40 years from now why would people use Bitcoin over centralized
private banknotes like paypal or democratic government controlled
currencies?

Perhaps Bitcoin transaction could transition to being more of the
same— controlled by a consortium of banks, exchanging gigabyte blocks
over terabit ethernet, but I think that would be sad.  An alternative
which was autonomous and decentralized even if the transactions were
somewhat slow or costly would be excellent competition for everything
else, and it's something I think man kind ought to have.


-------------------------------------
I want to follow up on BIP 21 (URI scheme), which I have recently 
implemented in Armory and I have become a huge fan of it.  But I've got 
a couple gripes:

*(1) *What is the status & plans for supporting "bitcoin:" URIs in the 
Satoshi client?  My understanding is that it currently creates URIs, but 
does *not* register itself with the OS to handle such links.  Is this 
accurate?  This seems like a very high-value feature, and I'd recommend 
that we consider it a priority -- I can't think of any other upgrade 
that can improve usability so dramatically on the desktop.

After implementing it all in Armory, I wrote up a walk-thru 
<https://bitcointalk.org/index.php?topic=79010.msg879804#msg879804> 
recounting how I did the OS-registration in Windows and gnome-based *nix 
systems.  Perhaps it can give the Bitcoin-Qt devs a jumpstart on getting 
it implemented.  (and then I can get feedback about doing for generic 
Linux and Mac/OSX)


*(2) *I need to understand better what the intentions were behind 
"label=" and "message=".  The way I understand it is that Bitcoin-Qt 
uses and stores only address-labels, and no other transactional info is 
stored in the wallet.  As such, the "message=" field would be displayed 
to the user when a "bitcoin:" link is clicked, but that message wouldn't 
be saved anywhere.

However, I think, especially if a new wallet format is in the works, 
that both should be supported:  "Address Labels" *and *"Transaction 
Labels".  The real difference is that merchants can include things 
Order#, purchase information, etc, in the "message" field, and then put 
only their business name in the "label" field.  This means that when the 
user is looking at their address book, they see just the owners of the 
addresses.  When they look at the transaction ledger/history, they see a 
full list of everything they purchased, prices, contact info, etc.   The 
distinction is much more important for persistent addresses, but still 
important.

This is exactly how I did it in Armory, but if Bitcoin-Qt won't do it 
that way, I should be promoting all important information be jammed into 
the "label" field.

*(3) *How are the other clients implementing this?  Do you make any 
distinction between "label" and "message"?

-Alan
-------------------------------------

The purpose is to comply with the "a block shall not contain more than
MAX_BLOCK_SIGOPS (20,000)" rule, under both the old way of counting
(look at the scriptPubKeys and count CHECKMULTISIGs as 20 sigops no
matter what) and the new way (look at both scriptPubKeys and
pay-to-script-hash scripts in the scriptSig, but count CHECKMULTISIGS
preceded by OP_1/2/3/... as 1/2/3 operations).

RE: too late:

Excellent point. I'll refactor ConnectInputs further, and do something like:

FetchInputs()
AreInputsStandard() <-- reject from memory pool if nonstanard
ComputeSigOps()
ComputeFees() <-- reject if too little fees per byte / sigop
ConnectInputs()

Pieter's compressed-public-keys patch (which was just pulled)
interacts with pay-to-script-hash to make ECDSA denial-of-service
attempts less expensive; I think we need to think hard again about
transaction fees before releasing 0.6, and maybe tweak the fee policy
so denial-of-service attacks using compressed public keys and 1-of-3
CHECKMULTISIG transactions is expensive enough to deter would-be
attackers.

-- 
--
Gavin Andresen


-------------------------------------
On Mon, Jan 16, 2012 at 9:37 PM, Kyle Henderson <k@old.school.nz> wrote:

In addition to the concerns about internet freedom and domain name
system filtering which are against the interests of bitcoin users and
the bitcoin system generally, SOPA contains new requirements for
payment networks which may adversely impact Bitcoin services
businesses and limit their ability to do business in the US and other
places where similar legislation is adopted.  There are many millions
of potential Bitcoin users in the US, so US law matters for our
ecosystem even though far from all Bitcoin users are in the US
themselves.

(21) PAYMENT NETWORK PROVIDER-
            (A) IN GENERAL- The term `payment network provider' means
an entity that directly or indirectly provides the proprietary
services, infrastructure, and software to effect or facilitate a
debit, credit, or other payment transaction.
[...]
                (i) PREVENTING AFFILIATION- A payment network provider
shall take technically feasible and reasonable measures, as
expeditiously as possible, but in any case within 5 days after being
served with a copy of the order, or within such time as the court may
order, designed to prevent, prohibit, or suspend its service from
completing payment transactions involving customers located within the
United States or subject to the jurisdiction of the United States and
the payment account--
                    (I) which is used by the foreign infringing site,
or portion thereof, that is subject to the order; and
                    (II) through which the payment network provider
would complete such payment transactions.

If you really want to go for the more extreme interpretation, it's not
hard to conclude that the Bitcoin system itself is a "payment network"
by the definition under the act, and if so in theory the AG's office
could— without due process— order miners and mining pools located in
the US to, for example, not process transactions containing the well
known addresses of targeted infringing sites (e.g. The Wikileaks
donation address).  Though I personally think this is far out.

I also think that other people will covered the SOPA/PIPA awareness
(e.g. Wikipedia is shutting down for 24 hours) more than we could
possibly do with our own resources.

But this attitude of it being someone elses problem? I think thats
nonsense. We live in _one world_, one world which is getting smaller
every day.  The value of a network—or of a economy— comes from the
number of potential connections it can make. One reason Bitcoin is
good is because it deconstructs some of the old barriers and anything
that risks imposing new ones is a threat to us all.

So, don't participate because bitcoin.org's help would be so small as
to be pointless— sure.  But because it doesn't matter? hardly.


-------------------------------------
On Sun, Jun 17, 2012 at 2:04 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:

To prevent surprises in the future, in case OpenSSL decides to add more,
can we disable all other key formats in advance?

Wladimir
-------------------------------------
On Mon, Feb 6, 2012 at 5:07 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:


I think we should go with (2), changing the maximum address length and
validation is very easy. We'd need to

   - Change BitcoinAddressValidator::MaxAddressLength to 35
   - The addresses are validated with walletmodel->validateAddress which in
   turn calls CBitcoinAddress addressParsed(addr) and then isValid(). Does
   this work for the new addresses?

The set of allowed characters is still the same, so BitcoinAddressValidator
doesn't have to be changed.

Advanced dialogs for constructing the addresses / adding them to the
address book could wait for 0.7.0.

Wladimir
-------------------------------------
Just posted this on the wiki BIP-13 discussion - should I make it into a BIP of its own ?

---
The "version" portion of the address has so far been labeled "network id", and indicates from which network and which chain the address can be used for. I think that this change from network id to version is much more fundamental and should not just be squeezed in along with bip16/17. The right way to do this is to structure the bitcoin address into:

base58-encode: [one-byte network ID][20-byte hash][one-byte address class][3-byte checksum]

This will move the possibility of using a faulty address from 1 to 4bill to 1 to 24mio. Recall that for most other payment systems this checksum is 1 to 9! So it should be sufficient. An old client will then render the new addresses as useless and they will still maintain their old familiar 1xxx look - the whole point in multisig is that it should not be a matter of the paying party to worry about securing wallet of the receiver, hence he should not be bothered with a new "3" kind of address now... --Michael Gronager/libcoin 10:49, 20 February 2012 (GMT)




-------------------------------------
On Tue, Nov 6, 2012 at 7:47 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Ok, good.

-- 
Pieter


-------------------------------------
Hi,

Can I remove the hackathon from bitcoin.org and put up the conference instead?



-------------------------------------
On 02/28/2012 05:48 PM, Pieter Wuille wrote:

Hi,


I don't know whether I understand this correctly, but there should be no 
duplicate transaction hashes at all. So the rule should be: Do not allow 
blocks to contain transaction hashes which are already present in that 
branch.

If by a freak accident a transaction has the same hash as another 
transaction in the chain, shouldn't the transaction be "tweaked" in some 
way to avoid collision (generate a new target address for it or 
something)? In any case this seams very-very unlikely to happen, or am I 
missing something?

Robert.


-------------------------------------
Hey, guys.

I've been writing a number of apps that require realtime event
notifications, where the JSON-RPC API clearly doesn't suffice.

There are two approaches I've been taking to this end:

1) Writing my own library for dealing with raw bitcoin structures and
connecting to bitcoin nodes via the bitcoin protocol.
2) Making custom builds of the satoshi client putting callback hooks
in key points.

Neither of these two approaches is ideal. (1) involves a lot of code
duplication, (2) involves patching the satoshi client source
each time I grab a later version, with the everpresent risk of
something breaking and the need to continue maintaining these patches.
Moreover, unfortunately many of these key points happen to be in files
like main.cpp which see frequent changes.

I would like to propose adding these callback hooks to the main
branch. I am willing to help locate these key points, reorganize the
code
to place these methods in separate source files, define a callback
mechanism, and contribute source code.

-Eric Lombrozo


-------------------------------------
Please review and comment/critique:
    https://en.bitcoin.it/wiki/BIP_DRAFT:_getmemorypool


-------------------------------------
On 2012 January 31 Tuesday, Gregory Maxwell wrote:


Well that's good that there is no real problem.


To be brutally honest; I don't see how the BIP16/17 changes are any less 
"breaking" than what I proposed (I'm not trying to push mine; forget it, the 
last thing bitcoin needs is another proposal if there is no real argument).  
I will agree the changes are smaller for BIP16, since the transactions are 
left as they are.

If BIP16/BIP17 were being honest they would too increase the version number 
of the transaction structure.  The new transaction type is not supported by 
the old client... that's a break.  My argument would be that once you're 
going to break the old clients anyway, go the whole hog and fix some other 
stuff as well.


I'm glad I wasn't talking rubbish then.
 

Me too.  Which is a shame; as it means we're locked into quite a fair number 
of earlier decisions that will now never be changed.


Again: I don't see how BIP16/17 aren't "breaking" as well; but perhaps I'm 
just not familiar enough with the conventions.  As far as I understand; no 
pre-BIP16 miner is going to allow BIP16 into the blockchain because it's not 
going to pass the IsStandard() test.

I'd repeat: the reasonable thing to do is to increase the version number of 
the transaction structure to indicate that they are being processed 
differently from old transactions.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------

Sure, here's one:

Green address provider give a REST-ful API, that provides the
following functionality:

+ Give transaction ID and credentials, request that the transaction be
declared "green"
  (sender's wallet site/software would do this)

+ Give transaction ID, return boolean "has this transaction been
deeclared green?"



As I said, I think any design that relies on clients recognizing two
variations of a transaction is a very bad idea.

-- 
--
Gavin Andresen


-------------------------------------
On Mon, Dec 3, 2012 at 2:35 PM, Mike Koss <mike@coinlab.com> wrote:

Because the results from standard JSON parsers are undefined if I give
you an "envelope" JSON that has repeated keys.

For example:

{
  "pki_data" : "...hex-or-base64-encoded certificate chain...",
  "signature" : "....hex-or-base64-encoded-signature-bytes",
  "message" : "....string-encoded-utf8-JSON",
  "message" : "....another string-encoded-utf8-JSON",
  "signature" : "....more hex-or-base64-encoded-signature-bytes",
  "pki_data" : "...another certificate chain...",
}

The JSON spec doesn't say what you'll get when you decode that mess.
Maybe the first instance of each field, maybe the last, maybe one
picked at random...

The JOSE (Javascript Signing and Encryption) spec says "Thou Shalt Use
A JSON Parser That Treats Multi-defined-keys As An Error."

I expect that most developers will be lazy and will just use whatever
JSON parser is convenient, no matter how much the spec/documentation
warns them not to. And that makes me nervous, because I can imagine
attackers taking advantage of mismatches between (say) the JSON
parsing software used by some back-end server process and a front-end
JavaScript web wallet UI.

-- 
--
Gavin Andresen


-------------------------------------
On Wednesday, April 11, 2012 11:32:18 AM Mike Hearn wrote:

I thought we were going with 60001 for the protocol version bump?


-------------------------------------

Forum private message may work better.


Yeah, but that's only an issue if it ends up being an intractable
disagreement between the people who are reviewing changes to the core
site. The clients page itself was contentious but we still arrived at
something reasonably professional looking and moved on.


I don't think it should be removed. At most the description should be
updated to point to a discussion of the tradeoffs of that class of
apps (same for BitcoinSpinner).


-------------------------------------
Thank you for practicing responsible disclosure.

Now the vulnerability is out in the open, could the code please be updated
to contain the information here, but in the comments? Gavins commit merely
mentions there is a DoS attack without discussing further what it involves,
also, the vulnerability of the merkle hash function should ideally be noted
inside it.
-------------------------------------
I'm not sure what "designed for occasional use" means.   Many users of
other clients use them exclusively without touching other clients.  Armory
is designed to be your only wallet (if bitcoind[d/-qt] is running in bkgd).
 I'm sure the other clients are the same.

Instead, I think that line would be replaced by a blurb about the target
audience.  "Designed for Advanced Users".  "Designed for Quick Setup and
Instant usability".

Btw, Armory now has full installers for both Windows and Linux
(Ubuntu/Debian), with uninstallers and automatic URI registration



On Wed, May 2, 2012 at 3:34 PM, Gary Rowe <g.rowe@froot.co.uk> wrote:

-------------------------------------
OK, so I just did some heavy changes to the methods for forward
compatibility in BIP 21.  Instead of a version number, now new variables
will be added either as-is or with a mustimplement: prefix.  If a
clients does not know what the variable is that is after mustimplement:,
it should consider the entire URI invalid and either notify the user or
just drop it silently.  That way things like expiretime can be added
without worrying about old clients ignoring the field.  

All that said, I dont think its an ideal solution, depending on the
names of variables to provide information is ugly.  If anyone has a
better idea on how to do backward compatibility, please suggest it.

In terms of the expiretime field being implemented now, I dont think its
appropriate.  Because some clients already have an old implementation,
the possibility of it getting ignored is too large.  The BIP now states
that "It is recommended that additional variables prefixed with
mustimplement: not be used in a mission-critical way until a grace
period of 6 months from the finalization of this BIP has passed in order
to allow client developers to release new versions, and users of old
clients to upgrade."  Mostly, however, I want to keep the list of
changes from the Bitcoin-Qt implementation to this BIP very, very
minimal this late the 0.6 release cycle (I want to get this BIP
finalized and implemented for 0.6, so that at least Bitcoin-Qt will have
no version which support OS URI opening with a broken implementation).

Matt

On Tue, 2012-01-31 at 11:04 -0500, Matt Corallo wrote:



-------------------------------------
An IRC discussion today covered additional needs of lightweight
clients.  Here is a draft of proposed new P2P commands, and associated
behavior changes.  This is not meant to be a formal, detailed
specification but rather rough picture of the preferred direction.

     -----

filterinit(false positive rate, number of elements): initialize
per-connection bloom filter to the given parameters.  if the
parameters create a too-large table, the operation fails.  returns a
'filterparams' message, with bloom filter construction details.

filterload(data): input a serialized bloom filter table metadata and data.

filterclear(): remove any filtering associated with current connection.

filteradd(hash data): add a single hash to the bloom filter.  WARNING:
although easier to use, has privacy implications. filterload shrouds
the hash list; filteradd does not.  it is also less efficient to send
a stream of filteradd's to the remote node.

mempool():  list TX's in remote node's memory pool.

     -----

'filterload' and 'filteradd' enable special behavior changes for
'mempool' and existing P2P commands, whereby only transactions
matching the bloom filter will be announced to the connection, and
only matching transactions will be sent inside serialized blocks.

A lightweight ("SPV") client would issue 'filterload', sync up with
blocks, then use 'mempool' to sync up to current TX's.  The
'filterload' command also ensures that the client is only sent 'inv'
messages etc. for the TX's it is probably interested in.

The 'mempool' command is thought to be useful as a diagnostic, even if
a bloom filter is not applied to its output.

A bloom filter match would need to notice activity on existing coins
(via CTxIn->prevout) and activity on a bitcoin address (via CTxOut).

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

Ah ok, coming from cvs/svn, it's a bit different to find things.
There's something to be said for maintenance of pior branches.
Though I see some things I can use in github and my work would
be more useful there, so maybe I'll stwitch to that from gitorius/0.6.x.

Presumably the github/0.6.2 branch is safe for production?

What degree of caution about wallet eating should be
made for those using github/master?


-------------------------------------
Hi,

Please check out my proposal,

https://en.bitcoin.it/wiki/BIP_0033

I want to use the existing Bitcoin protocol to provide this functionality in order to maintain compatibility. This proposal does not affect current Bitcoin clients, but allows the parallel system to operate alongside and sometimes intersect with the main Bitcoin network in a positive way.



-------------------------------------
Hi Amir,

reason for breaking with tradition.

excuse me if it was already discussed, but maybe using satoshis instead of
decimal bitcoin would be better choice? We all know about pains with proper
handling decimal numbers across of all implementations - and it's not only
about json-rpc.

Otherwise I agree, BIP 21 is better than BIP 20 because it's easier to
implement all points of the standard.

Best,
slush

On Tue, Jan 31, 2012 at 3:27 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
We're debating the descriptions on the thread. I provided rewritten
descriptions that try and keep with the "theme per client" goal, whilst
being less technical.

I think it's unclear how best to run this page. It's clear we need one
though. If everyone can just submit whatever they like then we'll end up
with 4 or 5 "pick me! pick me!" type descriptions, which avoids a lot of
arguing but doesn't really help our users make a decision. If we have a
Benign Dictator model we might end up with descriptions that are wrong or
don't highlight the strengths / weaknesses of each client properly.

So although it's messy I think the right path is probably the middle one -
have some descriptions that try to be neutral, then improve them based on
feedback from users and developers. They need to be flexible and evolve
over time as the clients evolve too. At some point every client will
support deterministic wallets so "easy backups" won't be worth mentioning
any more, but there'll be new distinguishing features. And we all need to
try and be honest about our own work.

Here is the current content. Like I said, the descriptions are *not* set in
stone at all.



Bitcoin-Qt <http://bitcoin.org/>

The original software written by Satoshi Nakamoto, the project's founder.
If you aren't sure which program to pick, this is a good bet. This
application is a peer-to-peer client that builds the backbone of the
Bitcoin network. It is suited for enthusiasts, merchants, miners,
developers and people who want to help support the project. People who run
Bitcoin-Qt are first class network citizens and have the highest levels of
security, privacy and stability. However, it can be very resource intensive
and you should be willing to leave it running in the background so other
computers can connect to yours. If your computer is low powered or you
aren't willing to tolerate a 24-hour+ initial start time, you should
consider other clients. Cutting edge features tend to be implemented in
other clients first.

Website: bitcoin.org

Platforms:
MultiBit <http://multibit.org/>

MultiBit's primary focus is being fast and easy to use, even for people
with no technical knowledge. It has a YouTube channel to help you learn the
software, and includes helpful features such as an exchange rate ticker.
MultiBit supports many languages such as German, Spanish and Greek.
MultiBit synchronizes with the network much faster than Bitcoin-Qt and
should be ready for you to use within a few minutes. This is a good choice
for non technical users who want an easy to use experience, especially if
you use a Mac.

Website: multibit.org

Platforms:
Armory <http://bitcoinarmory.com/>

Armory focuses on advanced wallet management features, such as the ability
to construct transactions whilst disconnected from the internet. It
operates in conjunction with a Bitcoin-Qt install. It requires a large
amount of RAM to operate and if you use Windows, it requires a 64 bit
version. It is a good choice for tech-savvy enthusiasts or merchants who
want to try out cutting edge ideas in the Bitcoin world. Armory was partly
funded by a community donation drive which raised over $4000.

Website: bitcoinarmory.com

Platforms:

Electrum <http://ecdsa.org/electrum>

Electrum's focus is speed, with low resource usage and making wallet
backups easy. It operates in conjunction with remote servers that handle
the most complicated parts of the Bitcoin system, which is why it's fast.
However, by running this client you don't contribute your computer's
resources to the core network, and the remote servers that help give it
good performance have the ability to see all your transactions and tie them
together. Whilst you need provide no personal information to use Electrum
(as is true for all Bitcoin clients), this means the privacy level is lower
than for other clients. Merchants are recommended to use other p2p clients.
Electrum is not quite user friendly yet - currently it is more suited for
tech-saavy individuals.

Website: ecdsa.org/electrum

Platforms:
-------------------------------------
Hi,

I got sent this BIP:

https://en.bitcoin.it/wiki/BIP_DRAFT:_getmemorypool#JSON-RPC_Method:_getmemorypool


What is your opinion on this? Is it BIP related?

It is a implementation-specific non-bitcoin-protocol proposal. My understanding of BIPs is that
they apply across bitcoin implementations and largely focus on the most generic use-cases
(like the URIs) and the protocol. Things which affect all clients, and allow the system to function
as a united whole.

That BIPs especially focus on the protocol, and that something like this is outside the mandate
of the BIP process.

For instance, we could imagine a future scenario. Bitcoin-Qt is currently based off bitcoind's
codebase. However wumpus built the client in mind with an abstraction layer to enable multiple
backends (a good design). In our hypothetical situation, there are 3 different backend codebases
usingBitcoin-Qt. I do not think a proposal to mandate a changing to Bitcoin-Qt's abstraction
layer or a change in the UI placement would be appropriate BIP material.

OTOH, many clients do need to make use of URIs and the BIP process is totally correct, as it
standardises a behaviour which is needed for interoperability of the network and community.

Thoughts?
-------------------------------------
on 02/19/2012 04:32 PM grarpamp said the following:
Some time ago i started a googlegroup mailing list, bitcoin-discussion.
It's been pretty low-volume... but it's something. :)

http://groups.google.com/group/bitcoin-discussion

or we could try to revive the bitcoin-list ml on sf.


-------------------------------------
https://github.com/bitcoin/bitcoin/pull/932 adds a "pong" message that
echoes back a 64 bit nonce contained in the ping, if the protocol
version is new enough.

The goal of this is to make it easier for clients, especially mobile
clients, to quickly check if a connection is stale, and also to see if
a remote node is overloaded so we can avoid talking to it. A common
case where this happens is if the remote node is itself downloading
the block chain or doing something equally intensive.

Any objections?


-------------------------------------
I'm not sure. What if they use a coinbase of a block that has already matured?

On Wed, Feb 29, 2012 at 10:46 PM, Gavin Andresen
<gavinandresen@gmail.com> wrote:


-------------------------------------
On Wed, Feb 29, 2012 at 11:00:42PM +0000, Ben Reeves wrote:

Indeed; duplicate an old coinbase, fork chain without dupe, and spend the old coinbase.
The 100-blocks maturity will not help against is.

I'm not sure how you intend to fix DisconnectBlock() to prevent this in a backward-
compatible way, though.

-- 
Pieter


-------------------------------------
Andreas has a good point. See RFC 3986 on URI schemes:
http://tools.ietf.org/html/rfc3986#page-12

The colon is a reserved general delimiter (similar in use to the / in a
typical URL, but applies to URNs etc). As suggested, we get req:something
being changed to one of the unreserved characters that do not have to be
URL encoded. Again, from the RFC these are

* Option A: req_something (underscore)
* Option B: req-something (hyphen)
* Option C: req~something (tilde)
* Option D: req.something (period)

Personally, my eye likes Option B, the hyphen.

On 31 January 2012 22:14, Andreas Schildbach <andreas@schildbach.de> wrote:

-------------------------------------
#220 0x00007ffff5d021a6 in QApplicationPrivate::notify_helper(QObject*,
QEvent*) () from /usr/lib/libQtGui.so.4
(gdb)
#221 0x00007ffff5d086fb in QApplication::notify(QObject*, QEvent*) ()
from /usr/lib/libQtGui.so.4
(gdb)
#222 0x00007ffff582f06c in QCoreApplication::notifyInternal(QObject*,
QEvent*) () from /usr/lib/libQtCore.so.4
(gdb)
#223 0x00007ffff5d4da05 in QWidget::setToolTip(QString const&) () from
/usr/lib/libQtGui.so.4
(gdb)
#224 0x0000000000589e43 in
GUIUtil::ToolTipToRichTextFilter::eventFilter(QObject*, QEvent*) ()
(gdb)
#225 0x00007ffff582e54b in
QCoreApplicationPrivate::sendThroughApplicationEventFilters(QObject*,
QEvent*) () from /usr/lib/libQtCore.so.4
(gdb)
#226 0x00007ffff5d021a6 in QApplicationPrivate::notify_helper(QObject*,
QEvent*) () from /usr/lib/libQtGui.so.4
(gdb)

The above is the loop that bitcoin seems to be stuck in. I ran
git-bisect and it looks like the first bad commit is
3793fa09ff920fc720dfad3738f105d2c9563662

My QT version is 4.6.2

Give me a shout if there are any other tests you want me to run.

-- 
http://petertodd.org 'peter'[:-1]@petertodd.org
-------------------------------------
is it just me, or did peter not send his message to anyone but steve -
twice? all i see is his "and finally..." then this from steve.

Arklan

----------
As long as there is light, the darkness holds no fear. And yet, even in the
deepest black, there is life. - Arklan Uth Oslin

I want to leave this world the same way I came into it: backwards and on
fire. - Arklan Uth Oslin



On Wed, Oct 3, 2012 at 10:06 AM, steve <steve@mistfpga.net> wrote:

-------------------------------------
I have to say, I agree with Luke here, this was Finalized a long time
ago.  The version that was agreed on can be seen at
https://en.bitcoin.it/wiki/BIP_0021

Also see https://bitcointalk.org/index.php?topic=6205.0 and Luke's three
biased polls at 
https://bitcointalk.org/index.php?topic=6206.0
https://bitcointalk.org/index.php?topic=6207.0
https://bitcointalk.org/index.php?topic=6208.0

Matt

On Sun, 2012-01-29 at 14:40 -0800, Amir Taaki wrote:




-------------------------------------
Too technical if you ask me. We want a webpage for the dumbest end-user 
I think.

Java? C? What the heck is this? Blockchain? Qt?

Regards,
Raphael

On 05/02/2012 09:34 PM, Gary Rowe wrote:
-------------------------------------
On 1/02/2012 00:12, Gavin Andresen wrote:

If we had a self signed URI, we could just pay directly to the public
key (or calculate the bitcoin address from it).  It
would no longer require a bitcoin address in the URI.
-------------------------------------
Cool, will check it out soon.


FYI, Windows has quite good sandboxing support. You could implement
the same thing later with Win32 if you want.


-------------------------------------
On Mon, Apr 30, 2012 at 6:40 PM, Rebroad (sourceforge) <
rebroad+sourceforge.net@gmail.com> wrote:


I suppose it would make sense for clients to be able to reject blocks that
they already have, if that's not currently possible.

The other part of the proposal is to allow nodes to request upload and

You don't need a BIP if you want to somehow fetch the (initial) block chain
outside the bitcoin protocol. You could download it from some http server
or even pass it along on an USB stick. Then with a simple client change you
can import it: https://github.com/bitcoin/bitcoin/pull/883 .

Currently, without this functionality, nodes with restrictive (or

If you're behind such a slow internet connection, and concerned about every
bit of bandwidth, it is better to run a lightweight node. For example,
Electrum.

Even if you could reduce the wasted bandwidth a bit by puzzling around with
partial blocks, the download will still be substantial (and that's going to
get worse before it gets better).

Wladimir
-------------------------------------
This is happening in Berlin if anyone is around: http://bitcoin-hackathon.com/

I am happy to host if space is needed.



-------------------------------------
I disagree with a bunch of your points, but I'll wait on others to comment,
except I will say that I don't understand what the 20 byte keyhash is. Can
you elucidate?

I am assuming major mining folks have written their own coinbasing
facilities, but perhaps this is not the case -- if so, I agree that some
work is necessary for such miners.

Finally I will just comment that I am guided by the general perspective
that many things about bitcoins are opt-in; therefore it makes sense to me
put difficult work onto those who are motivated to do it, and keep things
as easy as possible for the 'maybes' to participate -- hence small
courtesies like allowing text/plain or text/html.

Peter

On Tue, May 29, 2012 at 11:18 AM, Luke-Jr <luke@dashjr.org> wrote:




-- 
Peter J. Vessenes
CEO, CoinLab
M: 206.595.9839
Skype: vessenes
Google+ <https://plus.google.com/112885659993091300749>
-------------------------------------
On Thu, Feb 02, 2012 at 09:32:24AM +0100, Michael Gr?nager wrote:

This should probably be

*    server.registerMethod(method_ptr(new ExtraGetBalance(extrawallet)));
*    server.registerMethod(method_ptr(new ExtraSendToAddress(extrawallet)), Auth("username","password"));

right?  Easy to miss if both wallets were empty in your quick test...  Awesome job with libcoin, BTW!

 -Craig


-------------------------------------

Because people are making 1 satoshi bets, or is this part of their
messaging system?

Pieter is right, getting consensus behind your proposal is too hard
and it's not likely to ever happen (I wouldn't support it, for one).

Outputs that never get spent are simply using disk space, the working
set is really defined by the coins that are moving. Disk space is
cheap. So this problem doesn't feel that urgent to me. Now if people
were routinely spending those 1 satoshi outputs, it'd be less great as
it'd increase the working set size.

I suspect some of these coins can be cleared over time by adjusting
wallets to consolidate outputs into the change outputs when a
transaction that has spare space before reaching the next size/fee
level takes place.


-------------------------------------
Hi,
Looking at:
https://github.com/bitcoin/bitcoin/commit/3e52aaf2121d597ab1ed012b65e37f9cb5f2754e#src/main.cpp-P52

It appears that 8 months ago the code was changed to DoS(100) nodes sending
on txs that use individual txs as the coinbase. Does this mean txs that are
0 confirmed?

If so, then, is this a risk of a network split, as I'm sure I've read about
services popping up using bitcoin that are specifically allowing 0
confirmed transactions, and therefore there must be peers around that
accept these.

Or have I misread the code?

Cheers,
Ed

PS. Would a BIP have been applicable for the above-mentioned change?
-------------------------------------
On Thu, 2012-06-14 at 13:52 +0200, Mike Hearn wrote:
I believe its because it allows the node which will have to use the
bloom filter to scan transactions to chose how much effort it wants to
put into each transaction on behalf of the SPV client.  Though its
generally a small amount of CPU time/memory, if we end up with a drastic
split between SPV nodes and only a few large network nodes, those nodes
may wish to limit the CPU/memory usage each node is allowed to use,
which may be important if you are serving 1000 SPV peers.  It offers a
sort of negotiation between SPV client and full node instead of letting
the client specify it outright.
A series of CMerkleTx's might also end up redundantly encoding branches
of the merkle tree, so, yes as a part of the BIP/implementation, I would
say we probably want a CFilteredBlock or similar



-------------------------------------

Ok, ok. but only because this reminds me of the
top-posting and formatting advice page that
I can't seem to find right now.

But I'm not munging what my client decides to
put in to/cc on a g reply either :)


-------------------------------------
Hey,

I heard there is a fuzzer in the works? Where can I find more details of this? I'm going to write one for libbitcoin, but if one already exists then I'd rather build on and use that.

Something simple like:
- Set previous block hash, set current target
- Start hashing
- Connect and send to specified host (i.e localhost)

That way I can force re-organisations and stress the blockchain algorithm. Should be trivial for me to build, but worth asking anyway :)

Thanks


-------------------------------------
On Thu, May 3, 2012 at 6:28 AM, Alan Reiner <etotheipi@gmail.com> wrote:


It is already implemented for Linux (Gnome) and Windows, but there is an
issue with boost::ipc that crashed bitcoin at startup on windows, so it's
temporarily disabled on Windows.



Label is a label for the destination address, message is a freeform message
describing the transaction.

I don't think the message is currently stored in the Satoshi client. That
feature is somewhere on our way-too-long issue and todo list.

But I understand that you want to add transaction meta-data fields such as
contact information, bought items, item prices?

Wladimir
-------------------------------------
Hi all,

Speaking on behalf of the MultiBit team (Jim's currently on holiday), we
will not be supporting Tonal Bitcoins anytime soon. Therefore we back the
BIP 21 proposal.

At present MultiBit does not support the "message" or "send" fields but we
would be happy to add this functionality as required.

Regarding the idea of a signed URI, it is appealing, however, it may not
work. If I understand it correctly, the main idea appears to be to protect
a URI from malicious replacement (at MultiBit we were concerned that a
Bitcoin "swatch" would be subjected to the same attack vector and we came
up with the term "swatch swabbing"). If a Bitcoin URI is served up from a
trusted source (e.g. a merchant site over HTTPS) then there is no need for
signing. It should be assumed that the merchant will offer a clean room
payment area so that no untrusted JavaScript will creep into the final page
and wreak havoc.

It would seem that in any situation where the attacker has complete control
over the content of the URI they will be able to successfully swab it to
match their own fraudulent address. Imagine attempting to protect a QR code
posted against a pole attempting to get BTC donations for a charity. How
long before that was replaced by a different version operated by the
thieves with good signatures all round?

Of course, I may have misunderstood so I would welcome further discussion.

One field that the MultiBit team would like to add to the BIP 21 proposal
is "expires" which would contain an ISO8601 formatted date/time in UTC
(e.g. "2000-01-01T23:59:59Z"). This would allow merchants to issue Bitcoin
URIs that would expose them to a currency/inventory risk for a defined
period of time.

Kind regards,

Gary Rowe


PS First post to this list
-------------------------------------
On Tue, Feb 28, 2012 at 01:23:01PM -0500, Luke-Jr wrote:

Yes, he tried it on testnet against a patched node.


I prefer to avoid this if possible, as it increases the size of the patch
significantly. In particular, it would require the discouragement-system to
be backported to whatever versions pools are running. The current proposal
only requires adding 6 lines of code.

-- 
Pieter



-------------------------------------
Re: the newest spec. Rather than make the signature over the
"concatenation of", why not just make it a signature over the
serialized protobuf minus the signature field (as I did in my demo
code). Otherwise it seems like we'd need more code than really
necessary. We can state explicitly tags must be ordered if you want,
even though all implementations should do that already.


Yeah, that sounds reasonable. Not that we should really design it now,
but let's use the term "mediation" rather than "escrow", which has
connotations of depositing funds with the escrow service.

I think it's best to see the existing payment messages as structures
that'll get filled out with more features over time. So rather than
have a separate EscrowProposal message, you would integrate it with
payment requests. Older clients that don't understand mediation would
just ignore the extra data they don't recognize.

message PaymentRequest {
   ....

  // One per mediator acceptable to the seller.
  repeated MediationProposal mediation_data = 10;
}

message MediationProposal {
  required SignedMediatorIdentity identity = 2;

  // Opaque bytes that the mediator can be asked to turn into a human
readable description
  // of how disputes will be mediated. The merchant sets this to
describe whatever policy it
  // is willing to go along with, so policies may be arbitrarily complicated.
  required bytes policy = 3;
}

message SignedMediatorIdentity {
  required MediatorIdentity identity = 1;
  // If the identity data is signed ...
  optional string pki_type = 2;
  optional bytes pki_data = 3;
  optional bytes pki_signature = 4;
}

message MediatorIdentity {
  // Name of the mediator to be displayed to the user.
  required string friendly_name = 1;
  // PNG image that can be used to represent the mediator to the user.
  optional bytes logo = 2;
  // Some text shown to the user under the name explaining the
mediators policies, why they should be chosen, etc.
  optional string blurb = 3;

  // An HTTP URL where a mediator can be reached to do things like
prove ownership of pubkeys, initiate the protocols, etc.
  required string contact_url = 4;
}

... etc ....

So the user experience would be that when a payment request is received:

- older clients ignore the mediation_data field and do a direct
payment as normal
- newer clients ask the user to pick a mediator (if they want to) and
if mediation is requested, the PaymentRequest is then discarded and
the next step of the mediation protocol begins.

The old request has to be discarded because the outputs would have
been written on the assumption of no mediation being in use (for
backwards compatibility).

Anyway, though I'm awfully guilty, let's not get off track. Just that
this is how I imagined new payment features being done - as new
extensions to the payment protocol, which would be a living document
amended by BIPs.


-------------------------------------
I'd like version 0.6 to get lots of review, "soak time" and testing, so
please download and run release candidate 1 from:
http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/

You can review the code changes using github's compare feature:
 https://github.com/bitcoin/bitcoin/compare/v0.5.2...v0.6.0rc1

Please report bugs using the github issue tracker.


Release notes:

NEW FEATURES SINCE BITCOIN VERSION 0.5
--------------------------------------
Bitcoin-Qt can display and save QR codes for sending
and receiving addresses.

New context menu on addresses to copy/edit/delete them.

New Sign Message dialog that allows you to prove that you
own a bitcoin address by creating a digital
signature.

Wallets created with this version of bitcoin will
use 33-byte 'compressed' public keys instead of
65-byte public keys, resulting in smaller
transactions and less traffic on the bitcoin
network. The shorter keys are completely
compatible with older versions.

New command-line argument -blocknotify=<command>
that will spawn a shell process to run <command>
when a new block is accepted.

validateaddress JSON-RPC api command output includes
two new fields for addresses in the wallet:
pubkey : hexadecimal public key
iscompressed : true if pubkey is a short 33-byte key

New JSON-RPC api commands for dumping/importing
private keys from the wallet (dumprivkey, importprivkey).

New JSON-RPC api command for getting information about
blocks (getblock, getblockhash).

New JSON-RPC api command for getting extra information
related to mining (getmininginfo).


NOTABLE CHANGES
---------------

The -nolisten, -noupnp and -nodnsseed command-line
options were renamed to -listen, -upnp and -dnsseed,
with a default value of 1. The old names are still
supported for compatibility (so specifying -nolisten
is automatically interpreted as -listen=0; every
boolean argument can now be specified as either
-foo or -nofoo).

The -noirc command-line options was renamed to
-irc, with a default value of 0. Run -irc=1 to
get the old behavior.


PRELIMINARY SUPPORT FOR MULTISIGNATURE TRANSACTIONS
---------------------------------------------------

This release has preliminary support for multisignature
transactions-- transactions that require authorization
from more than one person or device before they
will be accepted by the bitcoin network.

Prior to this release, multisignature transactions
were considered 'non-standard' and were ignored;
with this release multisignature transactions are
considered standard and will start to be relayed
and accepted into blocks.

It is expected that future releases of Bitcoin-Qt
will support the creation of multisignature transactions,
once enough of the network has upgraded so relaying
and validating them is robust.

For this release, creation and testing of multisignature
transactions is limited to the bitcoin test network using
the "addmultisigaddress" JSON-RPC api call.

Short multisignature address support is included in this
release, as specified in BIP 16. Run with -bip16=0 to
turn off support for BIP 16.


-- 
--
Gavin Andresen


-------------------------------------
Hi Steve,

This looks like a good idea to me. The test suites could act similarly to
the 100% Pure Java approach that successfully fended off a lot of
corrupting influences to Java over the years.

Maybe it's worth putting together a small starter suite of tests and
showing them to the community then providing a suitable process, perhaps
through BIPs, to allow tests to be created, reviewed and updated before
getting incorporated into a reference. I imagine a BIP would cover an
aspect of the blockchain rather than a single test or test suite since
having that many BIPs would get onerous fast.

Kind regards,

Gary

On 1 August 2012 12:38, steve <steve@mistfpga.net> wrote:

-------------------------------------
After doing more thinking, what about letting a spend sign more information
associated with the transaction, such as a transaction ID provided by the
merchant? This seems to solve a lot of the problems being put forward, with
much less complexity.
-------------------------------------
on 02/19/2012 07:13 PM grarpamp said the following:

That's exactly what i said above, in a more euphemistic fashion :D


indeed.


i'm sure that with the list being unused, we could change the charter
and do whatever with it, and the people who matter probably won't object.


Indeed, good points on all counts.


good points. re 1), i'm pretty sure that -dev is the most active
bitcoin-related public mailing list. things may have changed in the past
half-year, but it seems unlikely.


charter can be changed if needed. creator/maintainer, that being me, is
generally known to be a pretty decent guy :). i'm not attached to this
particular list though, but whatever happens, i'd hope that there will
be more people willing to share administrative duties. not sure if
googlegroups is the best interface, if we can find some good free host
with mailman, downloadable archives, the works, that may be preferable.
i started that group on gg simply because it was free and easily
available and easy to set up.


-------------------------------------

That puts the sender in 'to' and list in 'cc',
which dupes to the sender and eventually
blows out the to and cc lines as everyone
chimes in and doesn't trim. 'reply to' solves
most of that. assuming the list sw can do it.


-------------------------------------
On Mon, Jun 11, 2012 at 08:10:22PM +0200, thomasV1@gmx.de wrote:

Please. This is not about whether getmemorypool is useful (at least I am
a big fan of BIP22's big picture). It's about whether it needs 20 optional
features.

-- 
Pieter


-------------------------------------
It recently occured to me that we can use the public nature of the block
chain to create trusted identities, for a specific form of trust.

Lets suppose Alice has some bitcoins held at bitcoin address A. She
wants to establish trust in the "identity" associated with the ECC
keypair associated with A, for instance for the purpose of having other
users trust her not to attempt to double spend. Since the trust she
seeks is financial in nature, she can do this by valuing the identity
associated with A, by delibrately throwing away resources. A simple way
to do this would of course be to transfer coins to a null address,
provably incurring a cost to her.

A more socially responsible way would be for her to create a series of
transactions that happen to have large, and equal, transaction fees.
Bitcoin makes the assumption that no one entity controls more than 50%
of the network, so if she makes n of these transactions consecutively,
each spending m BTC to transaction fees, there is a high probability
that she has given up at least n/2 * m BTC of value. This of course is
all public knowledge, recorded in the block chain. It also increases the
transaction fees for miners, which will be very important for the
network in the future.

Now Bob can easily examine the block chain, and upon verifying Alice's
trust purchase, can decide to accept a zero-confirmation transaction at
face value. If Alice breaks that promise, he simply publishes her signed
transaction proving that Alice is a fraudster, and future Bob's will
distrust Alice's trusted identity, thus destroying the value needed to
create it.

In effect, we now have a distributed green address system.

Now Alice could try to mount a double-spend attack on a whole bunch of
people at once, hoping to have them all accept the transaction. However
as it is the "just trust them" model works pretty well already.


A good usecase for this idea, beyond the obvious fast payments
application, is a distributed anonymizer. Alice can now publish her
request to anonymize coins, and other trusted identities can make their
bids. If Alice accepts a bid from Bob, she will want Bob to send her the
anonymized coins *prior* to her transaction going through, thus breaking
the temporal connection between the transactions. Now Alice can give Bob
the signed payment transaction, and Bob can submit his payment
transaction to the network first, knowing that Alice isn't going to try
to rip him off. Bob can also have a trusted identity which signed the
contract for the anonymizer transaction, and similarly if he rips Alice
off, she can publish it for the world to see.

A more subtle effect, is this makes sybil attacks more difficult. To
pretend to be a thousand identities is going to now require 1,000 * n
coins, and attempting to pull this attack off inherently strengthens the
bitcoin network. Obviously we can apply this principle to other things
like tor nodes as well.

-- 
http://petertodd.org 'peter'[:-1]@petertodd.org
-------------------------------------

I also wondered this. My first thought was that it's basically the same as
the PING message, a nonce that is repeated immediately on reply. This makes
it easier to multiplex operations over a single channel. I'm not against
this basic idea, and it is easy to ignore for clients that don't want to
use it.

I think the state comes in here:

      - inv sends back the requestid given in getblocks or a special value
in case of a notification.
      - addr sends back the requestid given in getaddr or a special value
in case of a notification.

"*command1* sends back the requestid given in *command2*".

This requires keeping state on the connection between command1 and
command2. Arguably, this state already exists in the current protocol, but
I'd rather see it reduced than extended.

Also... Many of the described commands don't need this as they already have
a natural "nonce". For example, the id of the requested block header. If
this is passed in the reply, and the caller can correlate the request and
reply without a special nonce administration.

Wladimir
-------------------------------------
So,

The proposal is simple, and it's a small change for miners, I imagine.

My question is: why?

I worry about stuffing too many requirements on the coinbase. I suppose the
coinbase is easily extendible if we run out of bytes, but I think I'd like
to see some more discussion / good / bad type cases for making this change.
What do we get over just the prev_hash by doing this?

If this is just a voting mechanism for moving to v2 blocks, that's cool,
but it would be nice to codify voting in the coinbase a bit? Maybe? We've
now once voted with /p2sh/ and this is a different mechanism now, if I
understand it properly.

Anyway, some background would be great; if I missed it, I'm happy to go
read up, but I didn't see any links on the wiki.

Peter

On Fri, Jul 6, 2012 at 8:10 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:




-- 
------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter@coinlab.com * /  206.486.6856  / SKYPE: vessenes
811 FIRST AVENUE  /  SUITE 480  /  SEATTLE, WA 98104
-------------------------------------
