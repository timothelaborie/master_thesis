On 03/06/2014 02:44 PM, Mike Hearn wrote:


Ok, that would be an option.


The memo field (and its logical evolution, an invoice) also needs to be
verified, since its part of the contract. Imagine sitting in a
restaurant and you're being presented the bill, most people will do a
quick scan of the meals and drinks consumed (and non-malignant errors
are frequent in that business).


Everything except Beam bypasses Beam (-:  Beam is an Android-specific
protocol. I assume it would also be possible to write an own NDEF
implementation on top of the low level NFC APIs. I want to try as soon
as I have a second NFC-capable phone, preferably Android 4.4.


You can't really blame the subway for a broken payment process.


Yes, it was a complete disaster. Obtaining a ticket took even longer --
ca. 45 minutes. Boarding the train took some additional seconds,
compared to no overhead in Germany where we simply don't have any gates.

On top of that, you walk more (in tunnels) than you get driven around,
get tracked on each movement and if you want to get your (monetary)
change, you need to wait for another 45 minutes.

The upside is, when going by public transport in England I always feel
like Mr. Freeman in City 17  (-:




-------------------------------------

As long as miners stick to Satoshi's first seen rule, which is the default,
it's useful:

https://bitcointalk.org/index.php?topic=423.msg3819#msg3819

(this is the famous "snack machine" thread from 2010)

If they decide to change to something like highest-fee-always-wins, then
they (again) centralise things by forcing all instant transactions to pay
GreenAddress and its competitors money - much though I like your product
Lawrence, let's hope they don't collectively lemming us all off a cliff by
doing that ;)
-------------------------------------
Indeed. And users were crying for mBTC. Nobody was asking for µBTC.

I must admit I was not aware if this thread. I just watched other
wallets and at some point decided its time to switch to mBTC.


On 03/13/2014 02:31 PM, Mike Hearn wrote:




-------------------------------------
On 1/10/14, Peter Todd <pete@petertodd.org> wrote:

You don't have to MM from birth. That I've already agreed is
dangerous. But if you start with SHA256, then merged mining is a
trivial fork at least 3 currencies have done successfully.
As said we plan to make Freicoin merge-mineable in the future, and we
expect to get much more security after we do.
The only "adverse" effect may be a temporary drop in price due to the
new miners selling all the frc they get until a new price equilibrates
with the demand. But that's not really "bad for the currency", just to
the holders at that moment.


If a system doesn't compensate its miners in a liquid enough way, the
system will probably be insecure, but that's another topic...


-------------------------------------
It's not quite accurate that the Tor node's throughput is 'mostly'
plaintext Bitcoin traffic. The node will only exit bitcoin traffic (or
anything else on port 8333) but most of the bandwidth is probably used
in being a Tor relay where there can be no port number discrimination.

However by providing so much bandwidth to the Tor network (maybe
record-setting?) and providing exit service for 8333, the node puts
itself in a strong position to do any or all of the following:

(a) Observe a lot of Bitcoin traffic from users connecting with Tor.

(b) Tamper with said traffic in some way.

(c) Hide the administrator's self-generated Bitcoin traffic in a crowd
of other Bitcoin traffic emitting from the same IP address.

Any of those possibilties might be intriguing.

Anatole


On Sun, Jul 27, 2014 at 10:17:19PM -0400, Jeremy wrote:



-------------------------------------
On Fri, Mar 21, 2014 at 11:59 AM, Adam Back <adam@cypherspace.org> wrote:


If you want to create and run a new CA, by all means. But I bet you don't.
So we're stuck with the current system for now.




But you have to chain up to the root.

The only reason more certs aren't ECC is backwards compatibility. Some old
browsers don't know how to handle them. It wasn't so long ago that Fedora
and Android were deleting ECC code from upstream libraries before shipping
them, either for patent reasons for disk space saving measures.

But it's possible to get ECC certs if you want. For example, Entrust is
starting to sell them:

http://www.entrust.net/ecc-certs/index.htm

But their intermediate cert is still RSA. My understanding is that ECC
roots for many CA's have been submitted and are now included, but of course
"give up compatibility with lots of users" vs "save a bit of cpu time and a
handful of bytes" is no real competition so it will be a long time until
most websites are using ECC certs.

Regardless, it's all irrelevant. Who knows when we might want to add
another feature that uses some bytes into PaymentRequests. Stuffing them
into a QR code will never make much sense IMO - it's far more sensible to
just use Bluetooth where the data size constraints are so much easier.
-------------------------------------
Hi,

On Mon, Feb 10, 2014 at 12:28 PM, Drak <drak@zikula.org> wrote:

this seems a fair explanation of what happened:

http://www.reddit.com/r/Bitcoin/comments/1x93tf/some_irc_chatter_about_what_is_going_on_at_mtgox/cf99yac


-------------------------------------
Does't BIP70 cover this already via Certificate Authorities?

On Mon, Mar 31, 2014 at 12:21 PM, vv01f <vv01f@riseup.net> wrote:


-------------------------------------
I remember the wordlist choice getting bikeshedded to death a month ago.

I would just include the wordlist as part of the standard (as a
recommendation) so that fully compliant implementations can correct a
user's typos regardless of the original generator.

Those who don't like it will have to deal with the compatibility
concerns themselves, or get an alternate wordlist approved as a BIP.
Odds are no one will go that route.

On Mon, Jan 20, 2014 at 5:35 PM, Peter Todd <pete@petertodd.org> wrote:


-------------------------------------
Due to "popular" demand, I have created a BIP for cross chain atomic
transfers.

Unlike the previous version, this version only requires hash locking.   The
previous version required a "selector" transaction based on if statements.

    OP_HASH160 OP_EQUAL_VERIFY [public key] OP_CHECKSIG

    OP_HASH160 OP_EQUAL_VERIFY OP_N [public key 1] ... [public key m]
OP_M OP_CHECK_MULTISIG

https://github.com/TierNolan/bips/blob/bip4x/bip-atom.mediawiki
-------------------------------------
Hi Mike, Jeremy, Drak,

Before going through your questions, I would like to bring some clarity on a few key elements in that protocol. There are really two aspects to it:
The contract negotiation; when the user first subscribes, it is prompted by a contract that will define the payment bounds associated with that subscription. 
Once accepted, the wallet is in charge and the user does not have to interact anymore -- this is the point of the recurring payment protocol. The wallet will poll the merchant and issue payments as they are requested by the merchant as long as they stay within the bounds of what was specified by the contract (and accepted by the customer).

I think it would help to explain how we ended up with the type of contract we introduced in that protocol. In an ideal world and in a NON recurring scheme, the contract should simply be the exact amount to be paid. In our case the exact amount may not be completely known in advance -- for e.g taxes, shipping, pro-rations,  and so we decided to introduce first a max amount per payment, and also a max amount per period. It is up to the merchant to decide whether to specify none, any or both bounds (max amount per payment and max amount per period). By specifying both, the contract is tighter and the client would feel safer to accept it. In the extreme case, by specifying none, the client would be presented with a contract to pay whatever is requested -- probably not a good option in the Bitcoin world unless there is a high sense of trust with the merchant.   

From reading your comments, it appears we have not been clear on how that frequency (PaymentFrequencyType) is being used. Its sole purpose is to define the max amount per period in the contract. The frequency of the payment is implicitly dictated by the merchant but not specified in the protocol by design: the wallet has to poll with a fine granularity (ideally each day when it is up) to understand if there is something pending. In the same way, a specified amount was not enough in the contract, we feel it would be restrictive to specify in advance when payments are due. There are a lot of complex scenarios in the billing space, and having the wallet poll the merchant to inquire for pending payments is the most flexible option and the contract is there to ensure the client will not be abused. To give a concrete example, imagine a data plan where you pay a base recurring price of $70 per month, but you are charged $10 per GB of data used beyond your included limit. If you exceed your limit on the 15th and the 23rd of a given month, two extra payment attempts will be requested by the merchant, that you couldnt predict (this scenario is often referred to as usage billing with Prepay Credits and Top-up, where the customer pays in advance for blocks of N units, and once they are consumed another N are purchased).


See answers in your questions inlined below:


OK, we'll fix it.



I hope the explanation above answers the questions.


Yes.


As explained above, contract would define none, 1 or both conditions.  First the merchant should not return such 'conditions' but if it does the client should not accept the contract. If the client decides to accept it anyway, then the wallet just verifies both conditions are met separately regardless of whether there is such violation and if so, makes the payment.


I agree, we can easily get rid of it.


In an ideal world the merchant should return unique subscriptionId (UUID for instance). That subscriptionId is used in the code to identify the contracts associated with the subscription. The merchant_data if i understand correctly the payment protocol is opaque from the client point of view, so it cannot be used by the client for that purpose. 


There are many example where that could  happen; for instance if you subscribe to a service,  then later decide to downgrade to a lower product. The merchant may decide to only let you downgrade at the end of your paid period-- to avoid generating extra credit-- and in that situation you end up with two contracts: One for the current product you are in and one for the future product you will end up on when the downgrade becomes effective.



As outlined above in the introduction, the protocol is designed in such a way that the wallet does not have to know what is the exact date when payment should occur, but instead polls the merchant for pending payments. There are many situations when specifying an exact payment date is not an option so that flexibility is essential. A simple example would be for a customer who started subscribing on the 31th of a month. Since there will be months with 28/29/30 days, the payment date would change depending on the month.





Fine.




We are totally open to receive feedbacks from them.. How do we bring them in the discussion?


Ok that makes sense.


Great to know.



-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On 08/23/2014 04:17 PM, xor wrote:

The packet size and timing issue will become less of an issue as the
network grows anyway.

One transaction inserted into a 3 transaction-per-second encrypted
stream is more obvious than the same transaction inserted into a 100
or 1000 TPS stream.

- -- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCAAGBQJT+MZWAAoJEMP3uyY4RQ21tDoH/0SPYQcUkYJcuDhTkJCFWdyx
ob3H7ITEcqD0UZ3n3QHdxHfCDlP2srL0EcfjbNceRX5inP47jdoGj7uIkY/NRHQ0
4J2WCIrcu1Bj3ZxXG59PtfUzMjxhMGDMSk5eE+6BjVQILrkxxrqSpVjykfoq5s6Y
EBdT2Pf4djQ5k2fQ2PX1dTt5iCvFh0ufq3McrYsciRzguRwlelw1W34tPBqGSv0n
LScgvqYUTGC7otUdA5K/3WBq6SSo7E13hJxiLKQZMQ4CPpSlsiAhI5fuhl0OBljC
hCtS+eugFmvMICQt0ELds++nnA5WN/Yjx1WIrnLA1EmNiAkS9RSEVMcyab0TtdI=
=0sjO
-----END PGP SIGNATURE-----
-------------------------------------

So the idea here is that the recipient wallet both uploads to the internet
and exposes the payment request over Bluetooth simultaneously, then let's
the sending wallet pick whatever radio layer works best in its current
conditions?

I think having multiple r= params is reasonable, but the Bluetooth support
is not specced in any BIP anyway. And if it were to be, people would point
out the lack of link-layer encryption.

So this is a bit tricky, overall. Right now I'd say things are kinda half
baked: not only is bluetooth not standardised nor encrypted (my fault, I
prototyped this code during a hackathon), but Bitcoin Wallet doesn't
properly implement BIP 72 either. To push this work forward I think we need
to sit down and do some more spec and implementation work :/
-------------------------------------
I think there are three typical uses:

1. Building consensus on the block chain. This is what the core is for.
2. Single user wallets. This is where SPV alone is good.
3. Services e.g. exchange, payment processor .... This is where core + indexing server talking SPV to core is the right choice

Regards,

Tams Blummer
Founder, CEO

http://bitsofproof.com


-------------------------------------
On Mon, Aug 18, 2014 at 1:33 PM, Ivan Pustogarov <ivan.pustogarov@uni.lu> wrote:

I'm afraid I'm losing you here.  The node advertises himself to
everyone he is connected to and in/or out, those nodes pass along
those advertisements.  When I receive an advertisement from a node I
do not know how far away the advertised peers is, presumably I can
accurately exclude it from being 0-hops— itself—) 1 or more should be
indistinguishable. Is there a reason that they're distinguishable that
I'm missing?

Can you explain to me how you propose to produce this mapping?


-------------------------------------
A new practical technique has been published that can recover secp256k1
private keys after observing OpenSSL calculate as little as 200 signatures:

http://eprint.iacr.org/2014/161.pdf

This attack is based on the FLUSH+RELOAD technique published last year. It
works by observing L3 CPU cache timings and forcing cache line flushes
using the clflush opcode. As a result, it is applicable to any x86
environment where an attacker may be able to run on the same hardware i.e.
virtualised hosting environments where keys are being reused.

I am not currently aware of any efforts to make OpenSSL's secp256k1
implementation completely side channel free in all aspects. Also,
unfortunately many people have reimplemented ECDSA themselves and even if
OpenSSL gets fixed, the custom implementations probably won't.

So, IMHO this is a sign for hot wallet users to start walking (but not
running) towards the exits of these shared cloud services:  it doesn't feel
safe to sign transactions on these platforms, so hot wallets should be
managed by dedicated hardware. Of course other parts of the service, like
the website, are less sensitive and can still run in the cloud. I doubt the
researchers will release their code to do the side channel attack and it's
rather complex to reimplement, so this gives some time for mitigation.
Unfortunately the huge sums being held in some "bitbank" style hot wallets
mean that attackers are well motivated to pull off even quite complex
attacks.
-------------------------------------
On Fri, Mar 28, 2014 at 9:18 AM, Tamas Blummer <tamas@bitsofproof.com>wrote:


It doesn't.

"walk before you run" and all that; lets see what problems we run into with
the minimal payment protocol we have now (like refund outputs you have to
remember forever) before we create an insurmountable set of problems by
trying to solve everything we can think of all at once.

-- 
--
Gavin Andresen
-------------------------------------
use the blockchain as a convenient transport channel

The number one user of the blockchain as a storage and transport mechanism
is Counterparty, and limiting OP_RETURN to 40 bytes didn't prevent them
from doing so. In fact they use multi-sig outputs which is worse than
OP_RETURN since it's not always prunable, and yet let them store much more
than 40 bytes.

For Open Assets <https://github.com/OpenAssets/open-assets-protocol>, we
need to store a URL in the OP_RETURN output (with optionally a hash) plus
some bytes of overhead. 40 bytes comes really short for that. The benefit
of having a URL in there is that any storage mechanism can be used (Web,
FTP, BitTorrent, MaidSafe...), whereas with only a hash, you have to
hardcode the storing mechanism in the protocol (and even then, a hash is
not enough to address a HTTP or FTP resource). Storing only a hash is fine
for the most basic timestamping application, but it's hardly enough to
build something interesting.

I've counted the number of OP_RETURN outputs in the blockchain for the
month of October 2014. There were 1,674 OP_RETURNs for a span of 4,659
blocks. Assuming they were all 40 bytes (the average is probably less than
half of that), that means an increase of 14.37 bytes per block. Considering
a 1 MB block, that's about 0.0013% of the block used up by OP_RETURN data
in average.

Increasing to 80 bytes will have a negligible impact on bandwidth and
storage requirements, while being extremely useful for many use cases where
a hash only is not enough.

Flavien

On Mon, Nov 17, 2014 at 10:35 AM, Pieter Wuille <pieter.wuille@gmail.com>
wrote:

-------------------------------------
Works fine for me


; <<>> DiG 9.8.1-P1 <<>> ANY testnet-seed.bitcoin.petertodd.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 40809
;; flags: qr rd ra; QUERY: 1, ANSWER: 22, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;testnet-seed.bitcoin.petertodd.org. IN ANY

;; ANSWER SECTION:
testnet-seed.bitcoin.petertodd.org. 40000 IN NS
testnet-seed-ns1.bitcoin.petertodd.org.
testnet-seed.bitcoin.petertodd.org. 40000 IN SOA
testnet-seed-ns1.bitcoin.petertodd.org. root. 1401048038 604800 86400
2592000 604800
testnet-seed.bitcoin.petertodd.org. 60 IN A     54.208.21.132
testnet-seed.bitcoin.petertodd.org. 60 IN A     5.9.119.49
testnet-seed.bitcoin.petertodd.org. 60 IN A     54.221.156.77
testnet-seed.bitcoin.petertodd.org. 60 IN A     37.34.60.19
testnet-seed.bitcoin.petertodd.org. 60 IN A     46.105.173.28
testnet-seed.bitcoin.petertodd.org. 60 IN A     95.78.127.77
testnet-seed.bitcoin.petertodd.org. 60 IN A     208.111.49.42
testnet-seed.bitcoin.petertodd.org. 60 IN A     94.102.53.181
testnet-seed.bitcoin.petertodd.org. 60 IN A     85.153.13.35
testnet-seed.bitcoin.petertodd.org. 60 IN A     85.25.198.97
testnet-seed.bitcoin.petertodd.org. 60 IN A     217.46.198.163
testnet-seed.bitcoin.petertodd.org. 60 IN A     192.187.125.226
testnet-seed.bitcoin.petertodd.org. 60 IN A     37.187.40.137
testnet-seed.bitcoin.petertodd.org. 60 IN A     37.187.179.66
testnet-seed.bitcoin.petertodd.org. 60 IN A     93.93.135.12
testnet-seed.bitcoin.petertodd.org. 60 IN A     144.76.175.228
testnet-seed.bitcoin.petertodd.org. 60 IN A     74.207.241.92
testnet-seed.bitcoin.petertodd.org. 60 IN A     85.17.26.225
testnet-seed.bitcoin.petertodd.org. 60 IN A     148.251.11.118
testnet-seed.bitcoin.petertodd.org. 60 IN A     137.117.202.26

;; Query time: 569 msec
;; SERVER: 109.74.194.20#53(109.74.194.20)
;; WHEN: Sun May 25 21:00:35 2014
;; MSG SIZE  rcvd: 443



On 25 May 2014 20:12, Andreas Schildbach <andreas@schildbach.de> wrote:

-------------------------------------
A few months ago I had a conversation with an executive at a Bitcoin
company, and I suggested their developers should get involved with the
development list. I was told that they are all subscribed but refuse to
post. Puzzled, I asked why, maybe the process isn't clear or we didn't talk
about what they were interested in? No, it's because in that executives
words "They see how Peter Todd shoots people down in flames and want
nothing to do with that".

Peter, you were named explicitly as the source of the problem. Your
immediate knee-jerk reaction to anyone who disagrees with you is making
this forum aggressive and ugly - it puts other people off from
contributing. For what it's worth, if I were the moderator of this list I
would have banned you a long time ago because I value a friendly atmosphere
more than your "insights", which are often deeply suspect (as in this case).

Besides, ground up redesigns of Bitcoin like what you propose are more
appropriate for bitcointalk. So please take it there.
-------------------------------------
But miners dont want to run full nodes, its better to develop some SPV like
that connects to some nodes.

Also I believe that stratum mining protocol improves some performance
things that GBT lacks.

If a new protocol that requires blocks created by miners is developed and
named in a cool way, miners could ask for protocol support to his favourite
pool.
El 17/06/2014 20:26, "Karel Bílek" <kb@karelbilek.com> escribió:

-------------------------------------
Hi guys


Just wanted to let you know that Andreas' testnet Bitcoin Wallet doesn't
work because of fail in the peer discovery, and this caused us problems as
we cannot properly demonstrate my XBTerminal POS on the Bitcoin Conference.

Right now I'm booting up an own full node that I will set as trusted peer
in the Wallet settings, hopefully this will work. However this DNS
discovery problem is really a problem, even for testnet. Btw, I had
problems firing up the full bitcoind node also, of the same reason -
discovery failed. I had to ask Andreas to paste me his node list to
manually seed the nodelist.

So I've set up and will run a well connected testnet node, as we need it
for the XBTerminal.
Please let me know if I can somehow help to fix the DNS discovery issue
also.


Best regards,
Alex Kotenko


2014-05-16 17:46 GMT+01:00 Laszlo Hanyecz <laszlo@heliacal.net>:

-------------------------------------
On 09/12/2014 12:11 PM, Mark van Cuijk wrote:

Hard to say, but here is my last assertion:

- Bitcoin Wallet
- Hive Bitcoin Wallet (checked by source)
- countless (> 300) forks/clones of Bitcoin Wallet

Since you're planning an advanced BIP70 usecase, you'll also have to
deal with the many wallets that don't support BIP70 at all.




-------------------------------------
Okay awesome. It seems like I set up a Litecoin node without knowing it
(because it was like this:
https://bitcointalk.org/index.php?topic=128122.0) I was able to bootstrap
it (https://litecoin.info/).


On Mon, Apr 7, 2014 at 12:40 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------

That's certainly a useful improvement. It won't help the existing userbase
though - assuming CHECKLOCKTIMEVERIFY is to go in to the next major
release. If there's going to be an intermediate release (6 months?) which
lays the groundwork for future rule changes, it helps more.

It would be good if getblocktemplate was updated at the same time to serve
errors if the fork warning is active. I'd hope miners have some way to
automatically handle IBD/getting forked off the chain, but I guess some
(newer) pools might not, and refusing to serve work should be the safest
option that shuts them down.

I don't have any opinion on the hard- versus soft- fork debate. I think

P2SH was a soft fork and the sky did not fall, but miners did lose money
and waste electricity mining blocks on the wrong side of the chain:

https://bitcointalk.org/index.php?topic=75294.0

Presumably they didn't notice for longer because it looked like a run of
unusually bad orphaning luck. It seems safer to have a clean fork, with
alerts telling people during the lockin period before new rule enforcement
starts (and possibly automated termination if there's no upgrade by the
flag day?). Miners who ignore it would still risk losing money, but
merchants who wait for a block at least would not be at risk.

One open question is how can you actually trigger a hard fork? Coinbase
scriptSigs are not executed, so putting some ignored but failing opcode
sequence there wouldn't work. One possibility would be to have a special
invalid tx in the block that marks the start of new rule enforcement. New
nodes would know to ignore it. But this risks corrupting block explorers.
Alternatively the coinbase outpoint structure could have its hash set to 1
instead of 0.
-------------------------------------
On Wed, Apr 30, 2014 at 11:00:06PM +1000, Gareth Williams wrote:

As an end-user of Bitcoin, the whole possible value of a set of mathematical
rules has become completely trashed by the imprecise and unpredictable behavior
of buyers and sellers.

If the rules are not responsive to real human needs, bitcoin is worthless
as a long-term store of value because **my idea of value** changes over time.
This implies, in my mind, an absolutely requirement to attempt to gather 
some useful signal from the human political noise.

How do you determine what that signal is, so you can **change the rules**
and the mathematics so it makes more sense?

You've got to deal with politics, one way or another.


-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
On 03/28/2014 07:19 PM, Mike Hearn wrote:


It depends on usage stats, script size, etc...


Usually yes. The next smaller "unit of time" in Germany would be two
weeks, the so-called "Fernabsatzgesetz". It allows you to send back
mail-orders and usually you want the money back. Don't know if that made
it into EU law or how it applies to other countries.





-------------------------------------
This is toying with the economics of cryptofinance in a way that needs to
be understood before being put under consideration for implementation in
Bitcoin.  This is an opportunity for an altcoin to explore the implications
of these proposals prior to changing the properties of an already
precarious system.

Eric Martindale
Developer Evangelist, BitPay
+1 (919) 374-2020
On Apr 7, 2014 2:55 PM, "Ricardo Filipe" <ricardojdfilipe@gmail.com> wrote:

-------------------------------------
The merchant can always act maliciously by simply not delivering the
goods. The only recourse the payment protocol provides at that point
is that you have proof the merchant is acting maliciously (or at the
very least his payment system is broken).

Your scheme just adds an ACK of the specific unsigned transactions
before the payment is effectively irreversible.

I can't come up with a situation where the combination of signed
request and blockchain entry aren't enough evidence, yet where adding
an ACK by the merchant of the unsigned transaction tips the balance
the other way. If you know of such a possibility, I'd love to hear it,
because we'd know what we're trying to fix.

The only way I can see a malicious merchant exploiting wallet
behaviour around PaymentACK is by accepting the Payment message, not
broadcasting it, not returning an ACK, and hoping the wallet/user
retries paying with a new, non-conflicting transaction. Then he can
try milking multiple small payments out of the user before they
realize what happened, and broadcast them all at once, stealing more
funds than the user ever was willing to risk in the transaction. But
this is trivial to guard against at the wallet level (by making every
new payment conflict with all previous non-acked payments).

The non-reliability of getting memo/refund fields is a separate
problem, but it seems BitcoinJ's approach addresses that nicely.

On Thu, Jan 30, 2014 at 11:16 PM, Chuck <chuck+bitcoindev@borboggle.com> wrote:


-------------------------------------
You may have seen my reddit post of the same title a few days ago:

http://www.reddit.com/r/Bitcoin/comments/239bj1/doublespending_unconfirmed_transactions_is_a_lot/

I've done some more experiments since, with good results. For instance
here's a real-world double-spend of the gambling service Lucky Bit:

Original: 7801c3b996716025dbac946ca7a123b7c1c5429341738e8a6286a389de51bd20

01000000012a14c8e6ce1e625513847b2ff271b3e6a1849f2a634c601b7f383ef710483f79000000006a4730440220692d09f5415f23118f865b81430990a15517954fd14a8bda74a5a38c4f2f39450220391f6251e39cdd3cab7363b912b897146a0a78e295f6ecd23b078c9f64ca7ae8012103a11c09c09874833eedc58a031d01d161ab4d2eba3874959537c5609ef5d5401fffffffff030c4d0f00000000001976a914d5245b64fcf8e873a9d1c0bfe2d258492bec6cc888ac400d0300000000001976a914da5dde8abec4f3b67561bcd06aaf28b790cff75588ac10270000000000001976a914c4c5d791fcb4654a1ef5e03fe0ad3d9c598f982788ac00000000

Double-spend: f4e8e930bdfa3666b4a46c67544e356876a72ec70060130b2c7078c4ce88582a

01000000012a14c8e6ce1e625513847b2ff271b3e6a1849f2a634c601b7f383ef710483f79000000006a473044022074f0c6912b482c6b51f1a91fb2bdca3f3dde3a3aed4fc54bd5ed563390011c2d02202719fe49578591edfbdd4b79ceeaa7f9550e4323748b3dbdd4135f38e70c476d012103a11c09c09874833eedc58a031d01d161ab4d2eba3874959537c5609ef5d5401fffffffff01d9c90f00000000001976a914d5245b64fcf8e873a9d1c0bfe2d258492bec6cc888ac00000000

The double-spend was mined by Eligius and made use of the fact that
Eligius blacklists transactions to a number of addresses considered to
be "spam" by the pool operators; affected transactions are not added to
the Eligus mempool at all. Lucky Bit has a real-time display of bets as
they are accepted; I simply watched that display to determine whether or
not I had lost. With Eligius at 8% and the house edge at 1.75% the
attack is profitable when automated. My replace-by-fee patch(1) was
used, although as there are only a handful of such nodes running - none
connected directly to Eligius from what I can determine - I submitted
the double-spend transactions to Eligius directly via their pushtxn
webform.(2)

Of course, this is an especially difficult case, as you must send the
double-spend after the original transaction - normally just sending a
non-standard tx to Eligius first would suffice. Note how this defeats
Andresen's double-spend-relay patch(3) as proposed since the
double-spend is a non-standard transaction.

In discussion with Lucky Bit they have added case-specific code to
reject transactions with known blacklisted outputs; the above
double-spend I preformed is no longer possible. Of course, if the
(reused) Lucky Bit addresses are added to that blacklist, that approach
isn't viable - I suggest they switch to a scheme where addresses are not
reused. (per-customer? rotated?) They also have added code to keep track
of double-spend occurances and trigger human intervention prior to
unacceptable losses. Longer term as with most services (e.g. Just-Dice)
they intend to move to off-chain transactions. They are also considering
implementing replace-by-fee scorched earth(4) - in their case a single
pool, such as Eligius, implementing it would be enough to make the
attack unprofitable. It may also be enough security to allow users to
use their deposits prior to the first confirmation in a Just-Dice style
off-chain implementation.

1) https://github.com/petertodd/bitcoin/tree/replace-by-fee-v0.9.1

2) http://eligius.st/~wizkid057/newstats/pushtxn.php

3) https://github.com/bitcoin/bitcoin/pull/3354 and
   https://github.com/bitcoin/bitcoin/pull/3883

4) https://bitcointalk.org/index.php?topic=251233.msg2669189#msg2669189

-- 
'peter'[:-1]@petertodd.org
000000000000000024abc60eebba42333d74b30635ca5fb0b7c776a579c307a8
-------------------------------------
On Sun, Mar 2, 2014 at 7:34 PM, James Hartig <fastest963@gmail.com> wrote:


Sounds very unlikely that bitcoind would connect to port 443, let alone
'attack' anything.

Anything in debug.log regarding that IP?

Wladimir
-------------------------------------
Maybe the solution is to have a defined way to import an unknown wallet?

This means that the gap space and a search ordering needs to be defined.

Given a blockchain and a root seed, it should be possible to find all the
addresses for that root seed.

The hierarchy that the wallet actually uses could be anything.


On Sat, Apr 26, 2014 at 11:36 AM, Thomas Voegtlin <thomasv1@gmx.de> wrote:

-------------------------------------
On 23 August 2014 12:38, Pieter Wuille <pieter.wuille@gmail.com> wrote:



I'd also like to point out the obvious: git uses the previous hash as part
of the formula to generate the current commit hash thus tampering with
history while possible would be instantly noticed because we all have
copies of the repository. Tampering would be completely evident (pushes
would fail for a start, and even simple merges would bork). It's just not
possible to tamper with the repository without it being discovered, even
with collusion (or strong arming) of github.

The social benefits of github make it idea for open source projects that
want community participation. The barrier to entry is low. The only "weak"
spot of github is the releases section, but since we don't actually
distribute Bitcoin from github the point is moot.

I think github haters fail to see the vast benefits of a social hub like
github. Their issue tracker may not be as sophisticated, it serves well and
the project is extremely productive.

Don't shoot yourself in the foot - a move away from github would be a
disaster for the project.

When you look at the attack surface of using github, it's pretty small and
would not go unnoticed, thus nullifying concern.
-------------------------------------
Yeah. Though there's actually a proposal for recurring payments from the
KillBill folks. I keep bugging BitPay to review it but it seems they're
lagging behind there, so perhaps we should just move ahead with that
candidate extension.


On Fri, Mar 28, 2014 at 3:01 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:

-------------------------------------
Hi slush,

Thank you for your new proposal; it seems to be a compromise.

@Christophe Biocca:
If the wordlist becomes part of the standard, then we will run into
problems of collisions once users ask for wordlists in every language.

IMO the right approach is to implement checksums that do not depend
on the wordlist (eg the 'brute force' method, Hash(mnemonic||1) mod 2^k 
== 0 )
this would also allow us to implement sipa's variable stretching proposal.

I understand this is not possible because of the computational
requirements of devices such as trezor.

I am leaning toward considering these devices as a nonstandard case,
instead of enforcing a given wordlist in the standard.

Thomas






Le 21/01/2014 00:18, slush a crit :

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 7/28/2014 6:44 AM, Gregory Maxwell wrote:
Infragistics Professional
_______________________________________________


The thing is, if it doesn't have the exit flag it cannot generate lots
of traffic from real good-intended clients, because it's quite hard
for clients to choose this Node as ËXIT in their path if it doesn't
have the exit flag. So the traffic comes from clients who specifically
added "ExitNode <fingerprint>" in their torrc and only use that Tor
instance for Bitcoin. So, someone build this custom Tor node for
themselves only, for plausible den. A pool could be the cause as it
was earlier discussed here...

The thing is I cannot find this node on atlas, globe or blutmagie can
you please provide fingerprint and IP address again? So I may ignore
it on my relays and talk to some people about it?
- -- 
s7r
PGP Fingerprint: 7C36 9232 5ABD FB0B 3021 03F1 837F A52C 8126 5B11
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJT1jXjAAoJEIN/pSyBJlsRjqgIAIFxHcypU6KUaNdSvESADilM
kFiitf00f4Uy9tBwSLVPQw+I2L1EmMiCNvqG4RRjV2+/PS696HCz0Jt0gVaGlMPl
DHQSHsozx3BaXi5PpGeLl7uSNLHlEdytytZ8xb08I4IuqcNNHzvxnou7gXapeezC
PuSABsxVLpDn+OP7QLRy/PlL948Yfgbxwb9dcn+lUdgDlByxxhMmOrk+o/VdGfnh
cL/C+qgpuJiI/wrQridtBmxU8h7Z6TKKua7eWONyg6MrnjwWuZTumhAGO2H4X1Na
IZiCmhEwtxb97TMG0EvgcZTeRzfzoddTnOe6ZEsiqOZ7qPNjFJ2i8RoSOI3gUCQ=
=t3Mb
-----END PGP SIGNATURE-----


-------------------------------------
On Fri, Apr 25, 2014 at 11:06:37PM +0300, Alex Mizrahi wrote:

Actually I did some work looking at this problem a few months ago and
other than somewhat larger transactions it looks like implementing
oracles by having the oracle reveal ECC secret keys works better in
every case. Notably the oracle can prove they really do have the key by
signing a challenge message, and with some ECC math the transaction can
include keys that have been derived from the oracle keys, blinding what
purposes the oracle is being used for from the oracle itself.

-- 
'peter'[:-1]@petertodd.org
0000000000000000852baa93672889c1cc0ebe0b886b153410529d6bf404b835
-------------------------------------

Hi Francis,

Here are some rough guidelines for you, based on the statistics from my
node:

disk usage: about 30GB currently for the blockchain data. It'll only
keep growing from here, but relatively slowly.

cpu usage: pretty much nothing, after you have synced the blockchain.

ram usage: after it runs for a few months, my node gets up to using 1.5
GB of ram or so.

bandwidth usage: my node averages about 500GB of traffic per month, most
of it outgoing.

Hope that gives you a rough idea of what you can expect for running full
node.

Best,
Daniel



-------------------------------------
On Sun, Dec 21, 2014 at 03:11:32PM +0800, Mark Friedenbach wrote:

Sybil attacks leading to front-running.

You may not be aware of this, but not being able to get the best price
due to a sybil attack *is* considered to be a security issue by the
users of these systems.


It's superfluous until you have real businesses actually using these
systems.


Among other things, ever noticed how this incentivises people to sybil
attack the entire system? Not good.

-- 
'peter'[:-1]@petertodd.org
000000000000000012f5511833a1304a72a754df8afef26f5712438bcc40826b
-------------------------------------
On Wed, Jun 18, 2014 at 08:52:22AM -0400, Gavin Andresen wrote:

Well, just doing one and not the rest isn't necessarily a good idea. The
malleability protection definitely seems like a good idea, and has had
quite a bit of review.


Do we have consensus that future soft-forks to add new opcodes will
always be done in conjunction with a transaction nVersion bump? If so,
then that's ok, if not, then we should have a whitelist.

The code to restrict the opcodes to the softfork-safe subset is trivial,
a GetOp() loop and a switch statement. It can always be removed later.

Something that comes to mind is if we do always bump nVersion then
OP_NOPx always will have a parallel "do-nothing" behavior, which means
EvalScript() will always have to have code enabling that backwards
compatible behavior.

-- 
'peter'[:-1]@petertodd.org
000000000000000004e51d8d00eedb31ec1505d245f48960896b79f0e7193c2a
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 6 August 2014 10:30:11 GMT-07:00, Mark Friedenbach <mark@monetize.io> wrote:

The general case is all committed information is included in the transaction; the merkle tree is a compatibility path, as well as an optimisation for lite clients and applications.

You should read more about soft-forks; see the BIP. Remember that Bitcoin protocol development and deployment is not a centrally controlled activity.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJT4mgPMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhSYlCAC1ncAGQt53HKS+8/rq
OG0RGrqE2l2/qCM/ybd9M8TkwxaI3NB5bqfIus8dB5MnyiTBFS3ooN54kNNOHtSX
2rEzPJphtOj46tk3nqe1QO3cbFJPjBCtxZff51DWZckhCiO2Iy1Br3fK3v55iscp
1jxyZnpfgUG/Ivfx+h6vkisucBXgXJ82d5vzvMIMxixh4v2+4/SAcSY6HCLIpxmV
Z3l0NcGllnmWe5B6eftpWYUAREuoCNk/671jHmwu0cqk2u/Egrp776zxkEO1xivH
d0EWjJmlDLmQ2hEhkpBq46ji/2m4EWPLqTW/EXf3RzwU8uCEldbxEe2tyZ0d6oBt
NnTE
=AhV7
-----END PGP SIGNATURE-----



-------------------------------------
I see the problem.

However, I don't see how PaymentDetails can be an answer. None of the
fields (other than outputs and network) can be known in advance (at the
time of the initial payment).

You're probably aiming for an expires field? How would you refund a
payment after expiry? Note its not your choice wether to refund a
payment -- it can be ordered by a court years after the payment happened.

Btw. another problem is that the refund address is currently unprotected.


On 03/28/2014 12:07 PM, Mike Hearn wrote:




-------------------------------------
Okay, why the everloving FUCK is there not someone on this list with a
@mtgox.com address talking about this?

I started using bitcoin because I could audit the code, and when the
developer cabal does stuff 'off-list' what you do is hand over market 
manipulation power to the selected cabal of company insiders who are
discussing things 'off-list'. 

The people having a 'private' discussion about how to solve this are
TAKING MONEY from everyone else, by having access to insider information.

I don't think any of the developers actually have a clue this is the 
result, because a good chunk of them are employed by for-profit companies
funded by venture capital, and VC lawyers are very good at writing 
employment contracts that provide plausible deniability of insider 
trading.

The press MAKES MONEY (okay, takes money) by manipulating markets,
and venture capitalists pay lots of money to ensure the market is
manipulated in ways they can profit from.

Private market manipulation is one of the costs of anonymity and privacy,
and I don't really like paying for some off-list discussion of what appears
to be a serious scalability and usability problem.

Bitcoin is such a powerful tool because it broadcasts transactions to
the network for everyone to see. 

Can we please broadcast some more technical details to this mailing list,
including exactly what MtGox is doing, and how they wish to resolve it?

If you gave me the entire code stack that MtGox runs on under an AGPLv3
license, I'm pretty sure I, along with everyone else here could come up
with a workable solution. I think a code release would be a huge win 
for MtGox as well, and would cement their position as market leader in
transparent cryptocurrency trading.

Otherwise we are just a bunch of dinghys getting capsized one by one
in a sea of market-manipulating white whales. Isn't the closed door
market manipulation of the big banks one of the reasons we all started
using Bitcoin in the first place?

Why do revolutions always put the same old bullshit back in power?

What we need is some transparent code evolution.

On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:


-------------------------------------
Hello,

I had the pleasure to meet some of you in Amsterdam and/or to speak on
#bitcoin-dev but this is actually my first message to the mailing list - I
feel a bit clumsy so apologies in advance if I make any mistake :)

Quick introduction/background: my name is Lawrence Nahum and I'm the
founder of GreenAddress, a BIP32 multisignature service and instant
confirmation platform available in form of web socket APIs and Wallet for
mobile, desktop and web. My background is in CS with distributed systems
and I've worked most of my career in the City on OTC financial services
like confirmation and clearing platforms.

This post is to gather feedback, comments and reviews about a BIP70 payment
protocol proto buffer extension proposal.

https://github.com/greenaddress/bips/blob/bip-payment-request-instant-confirmations/bip-payment-request-instant-confirmations.mediawiki

If you are interested in GreenAddress design or for more information on
GreenAddress you can find the white paper here
http://ghgreenaddress.files.wordpress.com/2014/04/greenaddressp2sh2of2hd-61.pdf
and our homepage on https://greenaddress.it

Cheers,
Lawrence
-------------------------------------
It is a very bad idea to delay relaying/accepting blocks based on
information which is only local to your node (ie would create the
ability for people to split the network by sending out lots of
double-spends to different parts of the network at the same time). Thus,
miners are incentivized to go connect to everyone on the network and
look for double-spends, not including them in their blocks to avoid
being delayed (which is OK, except having to connect to everyone is bad).
There is a related concept of "discouraging" blocks which generally only
refers to mining on a previous block, but you have to be careful doing
that so you dont break consensus.

On 10/27/14 19:58, Tom Harding wrote:


-------------------------------------
On Mon, Jan 27, 2014 at 5:17 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:


Is this truly the intent?  That the merchant/processor takes full
responsibility for getting the TX confirmed?

It is within the customer's economic incentive -- and right as a free
person -- to work to get their transaction relayed to the network and
confirmed in parallel with whatever the merchant is doing.

BIP 70 states that the customer broadcasts the transaction, in
addition to sending the Payment message.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
They would just encode the OP_RETURN script into an Output structure. I'm
not sure about the question - you seem to give the answer yourself in the
first paragraph?
-------------------------------------
On 4/16/2014 5:10 PM, Laszlo Hanyecz wrote:
Okay, so how about an autoupdate function which pulls a work around off 
the server?  Sooner or later, the vulnerabilities must be faced.


-- 
Kevin



-------------------------------------
A fork is not necessarily required, if you are talking about information
that deals primarily with pre-consensus mempool behavior.  You can make a
"network TX" with some information that is digitally signed, yet discarded
before it reaches miners.


On Wed, Aug 6, 2014 at 11:42 AM, Peter Todd <pete@petertodd.org> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------------------------------
Mutual CHAP could work.  This is commonly done in PPP and iSCSI.  The idea is simply that both sides authenticate.  The server expects the client to provide a password, and the client expects the server to provide a (different) password.  If you masquerade as the server, you won't be able to authenticate because every client has a different password they expect from the server, so they won't do work for you. MITM on the server can capture the exchange but CHAP protects against replay.

https://en.wikipedia.org/wiki/Challenge-Handshake_Authentication_Protocol

-Laszlo


On Aug 8, 2014, at 6:21 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:




-------------------------------------
On Fri, Mar 28, 2014 at 12:25 PM, Andreas Schildbach
<andreas@schildbach.de>wrote:


Communication between the merchant and buyer would be needed in this case.

I'd say that would be not unreasonable if something is to be refunded after
a year or more. After all, people may have moved, bank accounts changed,
even outside the bitcoin world.

It should probably not be accepted to set a very low expiration time for
the refund address, like <3 months, as it's as bad as not providing a
refund address at all and brings back all the pre-BIP70 confusion.

Wladimir
-------------------------------------
On Friday, 13 June 2014, at 9:24 pm, xor wrote:

Agreed. Does Bitcoin Core not have a release cycle policy? Typically mission-critical projects will enter a code and resource freeze prior to tagging a release candidate, after which point only critical bugfixes are allowed into the release branch. A language translation update does not qualify as a critical bugfix and should be merged during the next release cycle.


-------------------------------------
Setting aside all security benefits (which the user can obviously choose to
implement or ignore), a major benefit here is being able to have multiple
wallets use the same blockchain process. I have 3 different bitcoind
processes running on the same server to utilize multiple wallets. Using
them serially isn't an option in my case. Also, peers can run the cheaper
process instead of having the wallet functionality which isn't even used.

On the security front, this doesn't seem to be any less secure and it gives
the user the flexibility to make it as secure as they feel comfortable. If
they want to run them both as the same user with no SELinux or file
protections (this isn't stopping or encouraging that) they're already doing
that now with bitcoind, albeit with possibly a larger attack surface.

Thanks,
--
James Hartig
Software Engineer @ Grooveshark.com
http://twitter.com/jameshartig





On Sat, Feb 22, 2014 at 1:53 AM, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------
On 03/20/2014 01:12 PM, Adam Back wrote:


Technically 3 KB. In my experience codes above 1.5 KB become impossible
to scan (ZXing scanner, 3 years ago). You will want to stay below 500
bytes for convenient scanning. That said, I'm convinced there is a lot
of room for scanning improvements.


As said in the OP, a minimal PR uses 50 bytes. X.509 seems to put about
4000 bytes on top of that.

As you can see, we have quite some room for improvements to PR payload
(PaymentDetails). X.509 certification will probably not be possible via
QR, at least not until specialized CA's will issue space-efficient certs
(using ECDSA?).




-------------------------------------
Does this fix it?  https://github.com/bitcoin/bitcoin/pull/4282


On Tue, Jun 3, 2014 at 12:47 PM, Toshi Morita <toshi@peernova.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:


I'd be in favor of bringing it down to 40 for 0.9.

That'd be enough for <8 byte header/identifier><32 byte hash>.

80, as the standard line length, is almost asking for "insert your graffiti
message here". I also see no need for 64 bytes hashes such as SHA512 in the
context of bitcoin, as that only offers 256-bit security (at most) in the
first place.

And if this is not abused, these kind of transactions become popular, and
more space is really needed, the limit can always be increased in a future
version.

Wladimir
-------------------------------------
someone recently wrote (not pointing fingers, nor demanding a spirited
defense from that person, its a generic comment):

btw about patents, I wonder if people who feel the need to do that, would
you consider putting those patents into like a linux foundation defensive
pool?

I imagine a number of other bitcoin companies have patented things, but if
you think ahead a little bit, or look at prior ecash history, patents held
by individuals or companies can be outright dangerous.  

We saw this in the past eg the digicash patents after the company went
bankrupt were sold by the investor to some random large company that parked
it in its huge pile of patents, didnt use it, and prevented anyone else from
using it - stalling Chaum dependent payment innovation for perhaps 5 years
until the thing expired, and a Chaum patent expiry party was held.

Just some food for thought.

hmm Yes and this topic now is more than a bit non dev related.  Sorry about
that.  There seems to be no convenient mailing list format for non-dev stuff
or I would Cc and set Reply-To for example?  (Web forums somewhat suck IMO). 

Adam


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On 09/26/2014 01:53 AM, Gregory Maxwell wrote:

Regarding the BIP process itself, I rather think it's broken in the
case of informational BIPs.

Proposals that require explicit action on the part of others do not
logically belong in the same process as purely information proposals
that do not require any explicit action by others are going to be
carried out regardless.

The only reason we proposed these as BIPs at all was to support the
intent of BIP43.

- -- 
Justus Ranvier                   | Monetas <http://monetas.net/>
<mailto:justus@monetas.net>      | Public key ID : C3F7BB2638450DB5
                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCAAGBQJUJMrzAAoJEMP3uyY4RQ217DMH/1oGHayVo4smLM/OKeu1qqXC
Xex4NNh6g7Jsu2ulfJ5ow3g7jHEDzTBp33THhUv6cnV7CpDvTC+Y24LDRrYwOBQo
YuQ9u0NNtrcgoi+6vs8NuGO+yZyTyBYs1emOipsICsg42H8yhEHlrMyfOTJsO6r/
nAiqR+QH6isNOjQerd9Fs0nYQ6VANs8IksL41L8ch9YAvgKx7C8WxdcQrk/S2pNL
JwD7Q729J34x34HPnOb5j5Rfm1gvQInYELBu0YBaCy7D05PZd5nPSYqUC3n35hUA
AMvVf65jdQVBjvjlcqDPAPdBTQ3qjhQ+7EAWKJrwlrzhGXaWA3HpipRDUSyqzBg=
=OhH8
-----END PGP SIGNATURE-----
-------------------------------------
I wrote down a really short description in code comments for
breadwallet, based on what I figured out:

https://github.com/voisine/breadwallet/blob/master/BreadWallet/BRPeer.m#L318


Aaron Voisine
breadwallet.com


On Tue, Jul 8, 2014 at 1:04 PM, Matt Whitlock <bip@mattwhitlock.name> wrote:


-------------------------------------
Ok, what do I need to do? How do I host a testnet seed myself?

Best regards,
Alex Kotenko


2014-05-16 23:02 GMT+01:00 Jeff Garzik <jgarzik@bitpay.com>:

-------------------------------------
On Saturday, 14 June 2014, at 1:42 pm, Un Ix wrote:

I think it's more an issue of accidental breakage than any maliciousness. One character in the wrong place in a language bundle somewhere can make the difference between success and runtime failure, and it may not be immediately apparent when running in unaffected locales. This kind of problem isn't likely to result in data loss (or money loss, where money is data, is in Bitcoin), but it could be enough to necessitate scrapping the whole release, which would look bad and prompt users to question the dev team's quality control process.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 04/23/2014 05:57 PM, Mike Hearn wrote:


The integrity of Bitcoin is more important than you and your personal
preferences.


You don't have the right to decide which valid scripts in the
blockchain will be disregarded, and neither does anyone else.


If you don't like what's in the blockchain, you and everybody else can
work within the protocol to orphan the offending block.


But if you fail, then what's written in the blockchain is final and
the sole purpose of the network is to enforce it - deal with it.


PS: We don't even know who runs BitUndo. They seem to have lots of
money to spend on web design - I wonder where it came from?


- -- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQEcBAEBAgAGBQJTWADBAAoJECoisBQbQ4v0A/0H/25j9bvZaEqfyLJSHNh7PGwC
TpMu0s8D94nX/ipwaOjeY1QMtnWnX9b2H/lDZSnk1rm7IXJTq1c+R/50Uqx5U9QI
oYnsKX1TiB+T5Uv0C5PaIptEMgPkcNyHwsdXyaaUcu2djB0/YhFRlWR7WCH2QyNG
3LR5XWLGJz7v6rDxwvMXEHJWO5950bASP1xCVLc/N0PI7BoEUmeRzAoDa1mGJ9yw
XkVUVDV03B85uTSEriBuQ49ASvv9faAhcehwRwvFFp2krVz6Ov5Jxrv7UN+B61R2
sgZhI3vaTsyRf+8+pkp0dvSpbwwJ7ESBm+BRMPGTnV1AlwJKqjzDYHgowSe01Nw=
=COsH
-----END PGP SIGNATURE-----
-------------------------------------
On 10/03/2014 02:49 PM, Mike Hearn wrote:

Congratulations on this release and I am quite happy that bitcoinj now
fully supports BIP32 and BIP39!

Does it also support various HD wallet structures such as BIP44 for example?

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
On Sun, Feb 09, 2014 at 01:04:58PM -0500, Peter Todd wrote:

I'm told there's probably at least one if not more earlier
attributions/reinventions for the 2-step-trade protocol using
SIGHASH_SINGLE. Please reply with them if you have them so we can give
credit where credit is due.

-- 
'peter'[:-1]@petertodd.org
0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1
-------------------------------------
On 09/15/2014 03:08 PM, Jeff Garzik wrote:

I wrote up an example of how the WoT and the behavior signature might be
combined via a game:

http://bitcoinism.blogspot.ch/2013/09/building-pgp-web-of-trust-that-people.html

tl;dr: "Identity" is not a name - it's a set of shared experiences with
other people. Identity systems that want to be successful should focus
on those shared experiences rather than names.

-- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-------------------------------------

I agree. It would be even sillier to start specifying container formats for random one-off "that would be kind of nice, I guess" features. 

How about exchange rate? Sharing links? Referral information? Any of these things are just as deserving of specification (and just as arbitrary). 
-------------------------------------
I posted some code on Reddit a while back around adding a simple x509
digital signature to a Bitcoin address URL, since you could gain the
benefit of an x.509 authenticated Bitcoin address without having to do a
full BIP70 implementation.  It's not WoT, but x509, for all its flaws,
works very well in the real world almost all of the time.

For added authentication, one could always wrap the URL with a PGP
signature.

After lurking on this list for a while, I assumed there's some reason this
hasn't already been implemented, likely based in the general disgust around
x509.

Anyway, here's my idea (complete with working Java source):

http://www.reddit.com/r/BitcoinSerious/comments/1sebj0/proposal_bitcoin_invoice_signatures/

FWIW.

--Daryl



On Tue, Apr 1, 2014 at 7:20 AM, Chris D'Costa <chris.dcosta@meek.io> wrote:

-------------------------------------
From what I have seen so far, there seems to be an agreement that this is a nice feature to add. We are pretty new to that community and so we don't know exactly what the process is, and in particular how we reach consensus via email. I am certainly open to follow 'the way' if there is one, but one solution would be to follow Mike's suggestion on providing a (prototype) implementation first and then defining/refining the BIP. Odinn also suggested a possible retribution for our time through crowd-sourcing which I am interested to pursue if that makes sense.


We have quite some experience on the subscription side of things and while we are growing our knowledge on the Bitcoin technology (and ecosystem at large) we would benefit from:
* some feedbacks on the high level proposal
* additional requirements we might have missed

So, below is a high level description of what we have in mind. If this sounds reasonable, we could start working on an implementation.


 
I. Abstract
---------------

This describes a protocol to enable recurring payments in bitcoins and can be seen as an extension of BIP-0070. The main goal here is to have the customer subscribe to a service of some kind (that is, agreeing on the terms of that subscription contract), and then have the wallet make recurring payments without any intervention from the customer as long as the payments match what the customer agreed on paying.

An example of such service would be an online streaming website, to which a user pays a fixed recurring monthly fee to access videos (a.k.a. resources). Note that there is also usage based billing: for example, the user may need to purchase additional access for premium videos (overage charges). This type of billing is more complicated and there are many variations to it used in the industry (pre-paid, ). For the sake of discussion, well focus on fixed recurring payments only, but we will keep usage in mind to make sure the protocol will be able to support it as well.


II. Motivation
------------------

Subscription based services have been growing in the past few years and so the intent it to make it possible for customers to pay in bitcoins. 

Bitcoins push model presents new advantages for the customer compared to traditional payment methods: the user has control over the subscription (for example, there is no need to call the merchant to explicitly cancel the credit card payments). It also opens the door to subscription management tools in wallets (e.g. Hive apps), which would give user an overview of what they are paying each month.


III. Flow of Operations
----------------------------------------


Creation of the subscription:
- - - - - - - - - - - - - - - - - - - - - - 

1. The customer clicks 'subscribe' -> A message is sent to the merchant.
2. The merchant sends back a message to the wallet with the details of the subscription such as the amount to be paid. In reality, there will be more information but for the purpose of the prototype implementation this is sufficient.
3. The wallet prompts the customer for authorization.
4. The customer authorizes (or denies) it.
5. The wallet sends the confirmation to the merchant.
6. The merchant confirms the subscription was created.

Ongoing payments:
- - - - - - - - - - - - - - - -

From that time on and since Bitcoin is a 'push' model, the wallet is responsible to poll the merchant for due payments associated with that subscription. Note that the merchant could specify hints to the wallet on when to poll (specific dates) or not during the registration of the subscription.

Note that we can't simply have the wallet push X bitcoins every month: the user account on the merchant side may have gotten credits, invoice adjustments, etc. since the last invoice, so the amount to pay for a given billing period may be lower than the regular amount. It could even be zero if the user decides to make a one-time payment to the merchant directly using a different wallet. Hence, the wallet needs to get the latest invoice balance to make sure how much it should pay. This also opens the door for the support of overage charges.


Quick note on the implementation on the merchant side: an entitlement system is a piece of logic on the merchant side which grants the user access to certain resources depending on the account status (unpaid invoices, etc.). This goes often hand in hand with a dunning system, which progressively restricts access as the user's account is more and more overdue. Since wallets can be offline for an extended period of time, payments may be missed and lead to an overdue state (e.g. extra fees, service degraded). It is the responsibility of the customer to ensure the wallet is up often enough for payments to happen.


In that recurring phase where the wallet polls the merchant, the wallet is responsible to check that payments match the subscription contract; that is, the amount, frequency of payments,  match what the customer agreed on. If so, the payment is made without asking for explicit approval from customer, and the flow is similar to BIP-0070: The message is sent to the merchant, and in parallel, a transaction is sent to the btcnet. The merchant sends an ACK to the wallet and of course checks the states of the transactions on the btcnet to mark that payment as successful.

Subscription change (optional):
- - - - - - - - - - - - - - - - - - - - - - - - 

Optionally we could implement a change in the ongoing subscription to address the upgrade/downgrade scenarios. Of course, we could also simply support a cancellation followed by a creation of a new subscription, but having that as a one atomic message is probably better. The steps are very similar to the initial registration.

1. The customer clicks 'upgrade', 'downgrade',  -> A msg is sent to the merchant.
2. The merchant sends back a msg to the wallet with the detail of the NEW subscription. 
3. The wallet prompts the customer for authorization.
4. The customer authorizes (or denies) it.
5. The wallet sends the confirmation to the merchant.
6. The merchant confirms the change in the subscription.

Cancellation of the subscription:
- - - - - - - - - - - - - - - - - - - - - - - - - 

The cancellation is initiated from the customer:

1. The customer clicks 'cancel' -> The wallet is informed that it  should not accept any new payment associated to that subscription.
2. The wallet sends a message to the merchant to inform about the cancellation.
3. The merchant confirms the subscription was cancelled.


-------------------------------------
On 6/24/14, Justus Ranvier <justusranvier@gmail.com> wrote:

I think he means that the wallet shouldn't be running as much as it is
currently doing.
But yes, I think you're right about wallets and GUIs not necessarily
mapping 1:1.


-------------------------------------


I'd hope that people can get certs for their actual business name, but
sometimes it does differ yes.

However remember that signing in BIP70 is about more than just security,
though that's the driving factor. It's also needed for things like dispute
mediation, receipts, etc.
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

I host charts of my node's system metrics at http://statoshi.info/#/dashboard/db/system-metrics

Note that the CPU spikes are abnormal as I'm making automated RPC calls to query the UTXO set.

My node's bandwidth usage chart can be found at http://statoshi.info/#/dashboard/file/default.json?panelId=1&fullscreen

- - Jameson

On 11/08/2014 12:44 PM, Melvin Carvalho wrote:
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAEBAgAGBQJUXo9XAAoJEIch3FSFNiDcl20H/0/MrFt0SfR5G5S0m4sLMUdP
5/sveDnVjCBBmcoCKvH3XKchT7fVA6C4N1+dUYDJhlOaZhXegdY3saHdIP/sFzkF
38JBdoqWm4IysAC9gmtn/jRSrxh0wC780zVcLe2EgI7n+1ZOOqCaud28gX+ukoq5
dsU/B8bPEZ/2E7WbaXRcJJGqPdP03H2VXEkKxTWacBYFGVd6RhP9ieFHS3TyctNb
A0g02l1OmymnSSP6ze32ne+G4RgPdbvYhevW8vay1P4ATgBSnB2sitawRXJjsxMy
+d4Fqg+xYRMx3l8lamb7OLSi9rMe6GNEKyML4/Gu24JPSjlmQLXRJE/aS3oMyZc=
=zXHK
-----END PGP SIGNATURE-----


-------------------------------------
On 03/06/2014 07:03 PM, Alex Kotenko wrote:


Sure, take all the time you need.

All I wanted to say is you don't need to break Bitcoin URI compatibility
in order to support direct payments via Bluetooth. It's simply an
add-on, both in the BIP21 and the BIP70 cases.



-------------------------------------
On Friday 04 July 2014 04:37:26 Gregory Maxwell wrote:

[excellent explanation removed for brevity]


Thank you for the very thorough and courteous response.  I'm sorry that I 
suggested something that had been thought of before (seems to be the case on 
every great idea I have for Bitcoin) and was not practical; but I'm glad to 
have had your response which was certainly educational for me.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com



-------------------------------------
I will just chime in that I've been working on a similar spec for Armory
to implement P2SH multisig and I came up with basically an identical
scheme.  I think you covered most of what is needed.   The one thing I
did differently was try to match the BIP 32 structure, by keeping the
original 3 levels (wallet, chain, addresses), and use 2*N chains to
handle the N different parties generating receiving and change
addresses.  It's not necessary, but it follows more closely the
three-level scheme that BIP 32 originally envisioned.  I also concluded
that the chain indices are ordered by lexicographical sorting of root
public keys, but resorting each individual address.  There are use cases
where it will be necessary for parties to know how to combine public
keys into a multi-sig address without knowing the root keys.

Also, for the purposes of one-off types of escrow multi-sig, we have
included a "wallet locator" field in the transaction that must be passed
around.  This "wallet locator" is stored with each key (perhaps at the
time public keys are collected and merged), and passed around with
transactions to be signed.  This allows lightweight devices like
hardware wallets, to recognize their own keys.  It would encoded in a
VAR_STR, and doesn't have to be meaningful to the other participants --
each device would look at all signing slots in a transaction (either
singlesig or each key in a multisig) and would generate a public key
along each path, and see if the result matches.  If so, it can sign it. 
If not, it must be someone else's.

I bring this up, because this multisig wallet structure you're talking
about has a very simple "wallet locator" scheme -- all parties will use
the same locator for a given receiving address.  But that field should
remain part of the data structure for each key, to accommodate all types
of multisig, not just linked/parallel tree schemes. 

-Alan




On 04/25/2014 06:27 PM, Manuel Araoz wrote:

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512



On 9 April 2014 13:33:19 GMT-04:00, Alex Mizrahi <alex.mizrahi@gmail.com> wrote:

Yup, that's part of the idea behind partial UTXO set mode. You could have a model where your node starts with no data at all, and hence SPV security. You tell your node what the oldest key birthday is that your interested in and it downloads the full block chain starting at that date, giving you your txs w/ SPV security and full node privacy.

What partial UTXO would add on top of that is then your node would gradually scan backwards until block zero, at which point it has a complete UTXO set and is a full node.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCgA6BQJTRYWUMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhaHEB/0Q0P544nJrtapnzogG
QpREeBlwR5I8fZ+BCbNcAk6afk9KLOFIsLBW0bFvFXfSO1TiyCLMezLkvhuDC5lM
vrCBKdmaXhwMaTGppgFNl9adu8yBRQ6I2BN21hQejyfmCvHTsoN6u1oeYccL+K+D
lTK2dMCmXLixcQIJjS9sGA8/TXjmiY65RzIdXl0UHeV4JUtRREMUB1HeXJWCxMEt
4KQXb5tk21vZ+BTf9kRirnCtFT+Wudyo73M2XGKbR3mzHc2jY+RjEb71J0hUmh8s
h4kVhuMMkEFjNUwU017kEYQpmXMMRwCyUydc7BoV6hZXnUx4ROTpc6pDv2IZkeLB
bGiE
=adiR
-----END PGP SIGNATURE-----



-------------------------------------
On Tue, Aug 19, 2014 at 10:11 AM, Justus Ranvier <justus@monetas.net> wrote:

I've pinged some people privately but also pinging the list… no
commentary on this proposal?


-------------------------------------
Looks like Matt just pushed out new builds to the Ubuntu PPA, so this issue should resolve itself shortly.

- Jameson

On 04/19/2014 05:39 PM, patrick wrote:


-------------------------------------
Having explored more drastic approaches, it looks like Kaz' basic idea 
stands well.  His #1...


is already implemented in bitcoin-qt #2340, and a "final call" on 
merging it was already sent to this list.  After some thought I agree 
with its policy of eventually setting nLockTime at current-height + 1 by 
default.  This is the "best reasonably expected height" of any tx 
created right now.  It discourages fee-sniping, and if a reorg happens 
anyway, it won't actually delay inclusion of tx beyond the reasonable 
expectation sans reorg.

However right now, #2340 takes a very cautious approach and sets to 
current-height - 10 by default, with randomness to mitigate worries 
about loss of privacy.

Kaz' #2, #3 and #4 are future actions.  #4 only goes most of the way ...


... a janitor mechanism is desirable to purge mempool of txes more than 
N behind current-height.

Nodes dropping a tx N blocks after they became eligible to be mined (the 
meaning of nLockTime) makes sense.  It is not an overloading or new use 
for nLockTime, but a logical extension of it.  As Kaz pointed out, this 
solves a big problem with expiring by locally measured age: 
unintentional resurrection.



-------------------------------------

On Jan 27, 2014, at 9:39 AM, Andreas Schildbach <andreas@schildbach.de> wrote:


Same mechanism for both, of course. Sorry, that was obvious. :)


-------------------------------------
It seems to me that xbit is no more distinct or intuitive than µbit. In
either case it's simply an arbitrary character in front of the word "bit".
Of course, for the majority of the world familiar with SI, the µ actually
adds additional meaning that is lost with the x.

Furthermore, given the multiple concerns voiced about the overuse of the
word "bit", µBTC seems to solve the problem.

Since we are talking about how it would be displayed in software, we don't
need to be concerned about how people will pronounce it, or what the
nickname will be.  If most of the wallets start displaying amounts in µBTC
quantities, it will be obvious that a µBTC is a different magnitude than a
BTC.  Nobody is going to look at their 100,000 µBTC balance and think they
have 100,000 BTC. People will immediately make the mental adjustment to the
new order of magnitude even if they don't specifically know that µ means
micro, or that micro means 1e-6.

Nicknames will form organically (much like buck, fin, large, k, grand, and
benny for U.S. currency), I've always been partial to milly (or millie) and
mike (or micky) as nicknames for mBTC and µBTC.  I've personally used those
when speaking with people, and they seem to catch on pretty quickly.

As has already been mentioned, you're going to be hard pressed to find
software that denotes U.S. balances in "bucks".  There isn't any good
reason to be coding a nickname like "bit", "xbit", or "mike" into wallet
software.

-  Danny Hamilton


On Tue, Apr 22, 2014 at 8:51 AM, Aaron Axvig <aaron@axvigs.com> wrote:

-------------------------------------
On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:

The above makes for a great homework problem for budding cryptographers:
Why did the three forms of signature, DKIM, long-lived bitcoin address,
and Official Swiss Government Identity fail to let you actually verify
you have the right code? (but make for great security theater)

Bonus question: Who has the smallest work-factor for such an attack?

Two rewards of 25mBTC for correct responses to each question from a
crypto newbie.


Thanks


Soft-forking rule change.

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------------------------------
okay, I've set it up with bind forwarding requests to two dnsseeds running
on separate ports. Though I see a problem with testnet DNS seed itself. It
runs, but somehow it only returns one IP address. Exactly same DNS seeder
looking for mainnet nodes is working fine.

You can reach seeds through
mainnet seed:
dig @node.alexykot.me bitcoin-seed.alexykot.me A
or directly
dig -p 8353 @node.alexykot.me bitcoin-seed.alexykot.me A

testnet seed
dig @node.alexykot.me testnet-seed.alexykot.me A
or directly
dig -p 18353 @node.alexykot.me testnet-seed.alexykot.me A

So what can be the problem with testnet DNS seeder?


Best regards,
Alex Kotenko


2014-05-20 1:50 GMT+01:00 Robert McKay <robert@mckay.com>:

-------------------------------------
The term bit is really only overloaded for those who are techy. 95% of the
population never uses the term bit in their daily lives and I doubt most
could even name one use of the term.
Plus bit used to be a unit of money way back when, so this is kind of
reclaiming it. I think it's a great fit.
On Apr 20, 2014 11:52 AM, "Alan Reiner" <etotheipi@gmail.com> wrote:

-------------------------------------
On Tue, Jun 17, 2014 at 9:23 AM, Peter Todd <pete@petertodd.org> wrote:


Yes, as I said in the github topic
(https://github.com/bitcoin/bitcoin/pull/4351) I suggest we adapt a
string-based name space for extensions.

A new network version could add a command 'getextensions' to query the
supported extensions, returning a list of extension strings or
(extension,version) pairs. For BIPs some something like 'BIP0064'
could be defined, but for an experiment for example
'experimental-getutxo'. This would be easy to implement and specify.

Unlike with the 64 service bits it does not require (as much) central
coordination to assign as there is no real danger of collisions. It
takes the political aspect out of P2P network extensions, and gives
more freedom to alternative implementations to experiment with their
own extensions. And no more need for bitcoin core to drive what must
be supported with increasing network versions.

Wladimir


-------------------------------------
What's to stop an attacker from broadcasting millions of spends of the same output(s) and overwhelming nodes with slower connections? Might it be a better strategy not to relay the actual transactions (after the first) but rather only propagate (once) some kind of double-spend alert?


On Thursday, 25 September 2014, at 7:02 pm, Aaron Voisine wrote:



-------------------------------------
That claim is horse manure :)  He never signed private emails sent to
me, nor the forum posts.

He -might- have signed the occasional thing related to releases, I'm not sure.


On Sat, Sep 13, 2014 at 9:55 AM, Peter Todd <pete@petertodd.org> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
BitPay should use mBTC as well. Unless you can point to any major wallets,
exchanges or price watching sites that use uBTC by default?

I think it is highly optimistic to assume we'll need another 1000x shift
any time soon. By now Bitcoin isn't obscure anymore. Lots of people have
heard about it. Getting from $1 to $1000 was amazing, but it was possible
through huge media coverage. Getting from $1000 to $1,000,000 would take
massive adoption of the kind Bitcoin isn't ready for yet.



On Thu, Mar 13, 2014 at 2:45 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
I spoke briefly with Peter (sipa). He recommend I forward this post to 
the mailing list for further discussion.

My apologies if this has been discussed before, but I was curious about 
some things re BIP70 message delivery.  In particular, I don't clearly 
see the value of the PaymentACK message.  Allow me to explain...

The current BIP70 workflow designates PaymentACK as the final message in 
a payment exchange. However, it doesn't appear that any mention is made 
of what happens if that delivery fails. I assume that re-delivery is 
left as a detail to the implementation, actually.

For sake of argument, let's assume that PaymentACK is never delivered 
either because of a network outage or a malicious merchant or 
incompatible software between wallets or a bug.  I ask myself: what 
would be necessary for sufficient proof of payment, say, to an arbiter?  
I presume the receipt R=(PaymentRequest,[transactions]) would suffice.  
Am I correct there?

But if the PaymentRequest and broadcasted transactions are enough to 
prove payment, what's the point of the Payment message? The merchant 
never has to verify the Payment message, possibly maliciously ignoring 
it.  In the well-behaved case, I presume the point is to help the 
merchant associate some arbitrary data with the purchase as well as 
provide a refunding address for the customer.  If that's the case, 
couldn't this protocol be slightly improved like so:

Required steps:
1. Customer clicks "pay now"
2. Merchant sends PaymentRequest/PaymentDetails, which should be signed
3. Customer builds a set of transactions and sends a new 
PaymentApprovalRequest message which includes a refund address and the 
unsigned transactions and their associated fully-signed transaction 
hash, the whole message signed with the private key of the refund address.
4. Merchant responds with PaymentApproved message, signing the 
PaymentApprovalRequest message with the same key from step 2.

Optional steps:
5. The customer can send a Payment message, which is only a set of 
signed transactions.
6. The merchant can respond with a PaymentACK message.

In Step 4, the merchant is acknowledging that if the transactions 
provided PaymentApprovalRequest are broadcast, then payment is complete 
and no other steps are required. Steps 5 and 6 aren't required but are 
considered considerate:)

After step 4, all the merchant needs is to do is watch for the 
transactions that were listed in PaymentApprovalRequest.  The 
(PaymentApproved,[signed transactions]) pair is the customer's proof of 
payment and this proof of payment includes a refund address that the 
merchant has agreed to prior to payment, instead of after.  Step 3 & 4 
also allow the merchant to verify transactions, providing an extra layer 
of redundancy.  The merchant will also be able to ack on fees, time lock 
(time sensitive purchases?), sequence numbers, etc.

In Step 3, it's critical the customer sign the message with the private 
key of the refund address, so that the merchant can be confident the 
refund address is correct.

In each step along the way until step 5, if a message delivery fails 
nobody is harmed because the purchase is incomplete.

Thoughts?

Chuck


-------------------------------------
On Wed, Apr 23, 2014 at 12:59 PM, Mike Hearn <mike@plan99.net> wrote:

The difference is when you transact.  In the attack Hal described you
transact with your victim only after finding a block but before
announcing it.


Right, this works in the Bitcoin network today absent any collusion by
the miners. You give one miner a transaction and you give every other
node you can reach another transaction.  You then hope your selected
miner finds the next block and 'undoes' the transaction you gave the
rest of the network.


But it isn't at all the same thing.  Miners select themselves based on
controlling hash-power. You can distrust a miner all you like but all
your distrust does not prevent him from participating in the
consensus, potentially to your detriment.  Moreover, the set of miners
has to be the same for everyone or otherwise the network doesn't
converge. There are miners I _know_ to be scoundrels, but there is
nothing I can do about it.

Someone you ask to not double spend is an entirely separate matter.
They aren't self-selecting: you select who you trust to not make
double spends and there is no need for this trust to be globally
consistent. If they behave in an untrustworthy way you can instantly
stop honoring them because the bad action is provable beyond any doubt
and never trust them again (unlike mempool consistency)... and you can
do this even if everyone else is too foolish to do so for some reason.

The trustworthness of oscars needs only be limited and is different in
kind from the kind of 'trust' we need over the history— they
arbitrating over the ordering of some subset of transactions right at
the tip of the chain, and only those transaction of people who have
specifically chosen to use them, of lower value transactions where you
need instant settlement.  Why pay twice? Because you're actually
getting a different part of your security from each, and the result is
additive.

There is no such thing as an uncorruptable party, invoking that is a
useless strawman. Instead we can consider how difficult the corruption
is and what can happen if they're corrupted and hope to balance the
risks and the controls for those risks.  Any self-selectingness as
anonymity (in the not-previously-enumerated sense) of mining is
important for censorship security but it's terrible for other things
like getting reliable mempool behavior.


Because you can choose to stop trusting an oscar while you—
individually— can't choose anything about ghash.io.  To stop GHash.io
we would have to take away their hardware or change the Bitcoin
protocol to make their hardware useless, and in the latter case we'd
_all_ have to agree to do this not just some (perhaps quite large)
subset of us who doesn't want to trust them, and even though it is
quite apparent what they did there is still some room to claim doubt.


Mining is universal— everyone must use the same miners, trust seldom
is seldom universal and shouldn't be. The trust we have in mining is
exceptionally limited, I think any effort to increase it is doomed to
fail— both because trust heavy systems stink, because mining is a bad
fit for trust, and because increasing the requirements create other
exposures and vulnerabilities.


-------------------------------------
This is a pretty good example about refactoring discipline as well as
premature/over optimisation.

We all want to see more modular code, but the first steps should just be to
relocate blocks of code so everything is more logically organised in
smaller files (especially for consensus critical code). Refactoring should
come in a second wave preferably after a stable release. Refactoring should
be in the pure sense, optimising code with absolutely no change in
behaviour.

When it comes to actual API changes, I think we need to be a lot more
careful and should be considered feature requests and get a lot more
scrutiny as we are essentially breaking backwards compatibility. #4890 was
pretty much merged with no discussion or thought yet other really simple
and uncontroversial PRs remain unmerged for months. A key question in the
case of EvalScript() would have been, "why are we passing txTo and nIn
here, and are there any future use cases that might require them? Why
should this be removed from the API and the entire method signature
changed?". BC breaks always need strong justification.

So I've expressed my concern a few times about the speed and frequency of
refactoring and also the way it's being done. I am not alone, as others not
directly connected with the Bitcoin Core project have also expressed
concerns about the number of refactorings "for the sake of refactoring",
especially of consensus critical code. Careful as we may be, we know from
history that small edge case bugs can creep in very easily and cause a lot
of unforeseen problems.

BtcDrak


On Mon, Dec 15, 2014 at 12:47 PM, Peter Todd <pete@petertodd.org> wrote:
-------------------------------------
On Mon, Nov 17, 2014 at 1:31 PM, Chris Pacia <ctpacia@gmail.com> wrote:


That is inevitable for any wallet that offers any functionality beyond
just maintaining a balance and the ability to send coins. In
particular, anything that wishes to list previous transaction (with
timestamps, history, metadata, messages sent using the payment
protocol, ...) needs backups.

What HD wallets (or any type of deterministic derivation scheme) offer
is the fact that you can separate secret data and public data. You
only need one safe backup of the master secret key - all the rest can
at most result in privacy loss and not in lost coins.

-- 
Pieter


-------------------------------------
Thanks Andreas.

For BIP standardisation, I think the VIEW intent seems like an obvious one.
Bluetooth support probably should come later if/when we put encryption/auth
on the RFCOMM link (probably SSL).
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Proper Unicode handling is a serious issue however. You don't want
someone to move from one input method / machine to another and
suddenly find that their coins are inaccessible, because of an issue
of decomposed vs. compatibility forms or whatever.

On 01/20/2014 03:14 PM, Adam Back wrote:
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJS3a7MAAoJEAdzVfsmodw4/MAP/3Rk4sbQBv5aGqM2iAMBZkjq
CxGNSrzxKKgAYf+aFka6FVrBZJRHU39mEon53H0DR92+3vA2BHns8YEKH18LneQ9
16qJAp4y+ml5jbdCI6TY1JCM4ObmXsZbsPF17lKdVPISkz8DhUMUNLHdOx8cZHkw
Kj5RXuLBFwqFiCcAqYdoIpFmDpfaJfZ3k9OHzPRsto1oyOrXdwc+TK8YZHISWR3M
nzsMcp2z9Uu8M/NeDo4gM0WFpIZ41W9JsYeMeJzdU6xd1HKdmC0CZCyc8EmAre58
XGc2gtc9PjXIwWW+FTkZ5pYJz718WBq4Wja1hir5eaTJZurs1fp+1iJ7jiDkloJH
h/pWp8wcXVaAklaImota3PASr5qnP8zjzaKZALn/0gJEkIKnIJz3N32BLw7QsoEL
k5VaMQ5x7/9zK+Qc5kWvtTjleRO23DnW+XVud0jbAHTM1wfTQH0dJIgEpe3HQZOR
9a09/ZKN8kC+2fj/u6EjkVh5RvwTv0iq+RvBDmsFjaVOfBzRL1LVKgKJvdG+0hix
XyPtnBflC1uNLNg/yjBEP7/cKePJVMcDzVBwjpbnEOo9ZGO2ixSh8qMQ/nn6V96R
hZZv8mVI1bGhWlvQEoMw5X7M4xyP25GboCv4wJrYT/8VQfe56BSKXS+AHfl+hIoa
Jjmcqvm+sfk/0awxj4Ce
=1crJ
-----END PGP SIGNATURE-----


-------------------------------------
Hi Melvin / Mike,

Ive been working on Bitcore and Insight next to a BitPay team for the last
few weeks. We are happy to receive patches, suggestions and bug reports
from you guys at:

https://github.com/bitpay/insight

Insight also provides some blockchain query capabilities at its
REST/Websockets API described on the Readme document.

Please note that Insight is meant as a software package that you can
download, install and use next to a trusted bitcoind instance.
live.bitcore.io / test.bitcore.io are just demo installations.

best,
matías




On Sun, Feb 16, 2014 at 10:45 AM, Melvin Carvalho
<melvincarvalho@gmail.com>wrote:



-- 
Matías Alejo Garcia
CinemaKi.com
Skype/Twitter: @ematiu
Roads? Where we're going, we don't need roads!
-------------------------------------
Necessary Shares = M+1, not a problem

I would probably encode N-of-M in 1 byte as I don't see good use cases with
more than 17 shares. Anyway, I am fine with it as it is.


On Tue, Apr 22, 2014 at 10:29 AM, Matt Whitlock <bip@mattwhitlock.name>wrote:

-------------------------------------
+1 on setting up the payment protocol extensions process more formally.
On the feature itself, it is interesting to note that some
complementary currencies backed by national currencies offer a
discount when converting from fiat to complementary, which has an
equivalent effect to this "discount for paying with btc". The main
difference is that in local currencies the merchants are a relatively
small group and the discount is uniform whereas here each merchant can
set his own discount. There's scientific studies on how different
currency features like these discounts affect adoption, velocity and
other variables. I can ask for them if anyone is interested.

On the implementation, I think a percentage/proportion would be
preferable over an amount in satoshis.
Let's imagine for a second that the bitcoin payment protocol ends up
being a generalized and universal payment protocol. The field would be
really something like "discount/additional_charge for paying with the
chosen currency/payment_method".
You could have 0.95 for a 5% discount or 1.05 for a 5% additional
charge. Mhmm, maybe a flat discount/charge in addition to the
proportional one...

On security, being an optional field, I don't see how can it harm anything.
It is true that the merchants can lie about the discount, but wallets
can be smart or stupid about it, or just completely ignore the field
as they wish.

Anyway, it feels like a random simple extension as an excuse to
develop the extension process. If it gets too complicated we can start
with a simpler and less critical one but it's hard for me to imagine
it.


On 6/25/14, Mike Hearn <mike@plan99.net> wrote:


-- 
Jorge Timón


-------------------------------------
I've heard about this idea from TierNolan. Here's some quick an dirty
analysis:

Suppose the last known block claimed a large tx fee of L. A miner who owns
1/N of the total hashrate needs to choose between two strategies:

1. Mine on top of that block and win usual reward R with probability 1/N.
2. Mine on top of the previous block, trying to make two blocks in a row,
might get reward L with probability 1/N^2.

Thus for the first strategy expected payoff is R/N, and for the second the
expected pay-off is L/N^2.

Second strategy is viable if R/N < L/N^2,
 R < L/N.

Now suppose the miner who claimed the unusually large reward will share it
with the next miner, for example, using coinbase output with OP_TRUE. If
that shared reward Rs is higher than L/N^2, then the next miner will be
better off mining on top of that block.

This doesn't require protocol changes(*) and can be simply incorporated
into a piece of code which decides what to do when a transaction with
unusually large fee appears. (I.e. it will automatically share the fee, and
others will recognize that). And if the biggest miner has 25% of all
hashrate, sharing 25% of your loot doesn't sound that bad.

(*) Except one problem: coinbase maturity rules won't allow one to share
the fee with the next miner.
So some protocol changes are required. But changes which affect coinbase
maturity and sharing are probably going to be simpler and smaller than what
Sergio have proposed.
-------------------------------------
I read the post in this threads about Compact SPV proofs via block
header commitments (archived e-mail in
https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg04318.html).
I was working on the same problem almost at the same time, which is
something that's becoming very common nowadays..

The proposal starts with the following claim:

"In simple payment verification (SPV) proofs it is currently necessary
that every intervening block header be provided between two blocks in
order to establish both connectivity and proof of work."

I think this is false. Let's first assume that at the time of an attack
we're connected only to the attacker (no honest nodes). An
non-interactive SPV proof needs to prove that a transaction belongs to
the best chain because creating a counterfeit proof cost more than the
amount of money involved in the proof. Suppose that the proof consist at
least of a block header and a merkle branch to the claimed transaction.

Do the proof need connectivity with the last checkpoint known by the
verifier? (here checkpoint is any block known for sure to be in the best
chain)

Not much, because connectivity only proves that the proof was not
pre-computed before the checkpoint. Only if the checkpoint is very near
(say 10 blocks back) it brings some practical evidence that the attacker
did not have much time to prepare an attack.
 
Do the proof need to know the interleaving proof-of-work?

Not much. If the distance between blocks is less than 2016 blocks, then
the difficulty may have change only by a factor of 4. Currently
difficult adjustments are much lower (I suppose that about 1.1 or so).
Then one can assume that the proof block target difficulty is almost the
same as the last known difficulty if the block distance is less than
2016. If the distance is more, we just load all the interleaving
re-target blocks to detect the actual difficulty.

Do the proof need to have a certain number of  confirmations?

Yes and no, because this is the only evidence that the prover has either
spend money in creating the fake block or took a genuine block.
The cost of creating a fake block can be approximated as the minimum of:
- The current reward of the block (since currently fees are much lower
than the reward)
- The average block fees (when the reward goes to zero)
- The minimum electricity cost of mining the block.

As time passes one could assume that the electricity cost of mining will
approach the other two. 

But there is the problem of parallel synchronized attacks: if an
attacker can reuse the same fake SPV proof to attack several victims,
then the reward for cheating increases proportionally but the cost stays
the same.
For instance, if 6 confirmations are required, and each block can hold
2000 transactions, the attacker can find 2000 victims and re-use the
same 6 block chain to "prove" payments to 2000 victims. Also the cost of
mining 6 blocks can be amortized by mining 7, and attacking in the first
two 4000 victims, etc...

Any scheme than relies on non-interactive SPV proofs will fail if
Bitcoin will scale up-to a point where victims can be easily found and
synchronized.
So I think one should assume that at least one peer is honest...

But if we assume than during the attack least one peer is honest, then
we could directly ask every peer to give us the blocks of their
best-chains at the same heights of the presented proof.  No back-links
are necessary.  If any peer shows a different block, then we should
carefully detect which of the two nodes is the one attacking us and ban
it, by downloading the best-chain headers from the last checkpoint to
the block of the proof.  This would be rare so I don't see when the
back-links can help.

The use case should be:

==Use cases==

For SPV client that has just come online asks peers what is the last block height/time. 
If a peer replies with an old block, then that peer is still downloading the block-chain and it's ignored.
For the remaining peers, the client starts asking for parents blocks until all parents agree (this is the last common parent). 
If (U)TxO hash-tree commitments are available, then the wallet is updated using this data from the common parent block. 

At the same time the client retrieves compact non-interactive proofs-of-inclusion (possibly orphan) for its transactions 
without having to download every intervening block header.

Is there something wrong with this?
 
Best regards,
Sergio.


-------------------------------------
Just some general comments on this topic/discussion.

I suspect that there exist no algorithms which cannot be done better in 
an application-specific device than in a general purpose computer.  And 
if there is such a thing, then it must necessarily perform best on one 
specific platform, making that platform the de facto application 
specific device.

I'm not sure how one would go about proving or disproving that, but it 
seems very likely to be true.

IO-bound is exactly the same as memory bound, for devices that have 
enough memory.  20 GB is already trivial today, and you don't really get 
into ask-the-wife-for-permission money until you cross 128 GB. The 
exception would be if the IO was to an oracle outside of the device's 
control, and artificially limited in throughput.  Such a centralized 
oracle would be contrary to the goals usually stated by people thinking 
about anti-ASIC designs, so there isn't much point.

Keeping the algorithm simple, and ASIC-easy, has one other advantage.  
Just about anyone can sit down and design an ASIC for SHA, for example, 
leading to diversity in the marketplace.  A harder algorithm can still 
be made into an ASIC (or more generally into an ASD), but will require 
more skilled designers, more expensive fabrication, etc.  This actually 
concentrates the ASIC advantage into the hands of fewer people, which 
again, is contrary to the stated goals.


-------------------------------------
On Fri, Nov 7, 2014 at 12:30 PM, Clément Elbaz <clem.ds@gmail.com> wrote:

Yes, we're moving in that direction. First with a script verification
library in 0.10, which will be extended to other parts of the
consensus by 0.11 and after that.

Wladimir


-------------------------------------
I thought I'd chime in and point out some research results that might help.
Even if they don't, there is a cool underlying technique that some of you
might find interesting.

The problem being tackled here is very similar to "set reconciliation,"
where
peer A thinks that the set of transactions that should be in the block is
S_A,
and peer B has actually included set S_B, and S_A and S_B are expected
to not differ much. Ideally, one would like the communication complexity
between A and B to be O(delta), not O(S_B) as it is right now. And ideally,
one would like B to send a single message to A, and for A to figure out the
difference between the two sets, without any lengthy back and forth
communication. In essence, I would like to give you some magical packet
that is pretty small and communicates just the delta between what you and
I know.

This paper from Cornell describes a scheme for achieving this:
   Yaron Minsky, Ari Trachtenberg, Richard Zippel: Set reconciliation with
nearly optimal communication complexity. IEEE Transactions on Information
Theory 49(9): 2213-2218 (2003)
   http://ipsit.bu.edu/documents/ieee-it3-web.pdf

Those of you looking for a TL;DR should read the intro and then skip to
page 8 for the example. The underlying trick is very cool, comes from the
peer-to-peer/gossip literature, and it is underused. It'd be really cool if
it
could be applied to this problem to reduce the size of the packets.

This approach has three benefits over the Bloom filter approach (if I
understand the Bloom filter idea correctly):

(1) Bloom filters require packets that are still O(S_A),

(2) Bloom filters are probabilistic, so require extra complications
when there is a hash collision. In the worst case, A might get confused
about which transaction B actually included, which would lead to a
fork. (I am not sure if I followed the Bloom filter idea fully -- this may
not happen with the proposal, but it's a possibility with a naive Bloom
filter implementation)

(3) Bloom filters are interactive, so when A detects that B has included
some transactions that A does not know about, it has to send a message
to figure out what those transactions are.

Set reconciliation is O(delta), non-probabilistic, and non-interactive. The
naive version requires that one have some idea of the size of the delta,
but I think the paper has some discussion of how to handle the delta
estimate.

I have not gone through the full exercise of actually applying this trick to
the Bitcoin p2p protocol yet, but wanted to draw your attention to it.
If someone is interested in applying this stuff to Bitcoin, I'd be happy
to communicate further off list.

- egs



On Fri, Jul 18, 2014 at 6:44 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
Thanks, that makes sense, just wanted to make sure this what the problem
was.


On Sun, May 4, 2014 at 6:15 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
On 12.10.2014 01:34, Pieter Wuille wrote:

Will this slow down reorgs after a fork, compared to today?

Regards,
Geir H. Hansen, Bitminter



-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 19 August 2014 19:40:39 GMT-04:00, Jeff Garzik <jgarzik@bitpay.com> wrote:

That is simply incorrect. The resources required to do that kind of monitoring are very high; even the NSA can't pull it off consistently for non-targetted operations due to limitations on upstream bandwidth and other resources. (remember that many of their taps are non-cooperative ones, obtained by breaking into routers at ISP's) This I've confirmed with direct conversation with Jacob Applebaum and other Tor devs. Every additional bit of encrypted information flowing over the internet increases the work they need to so to deanonymize you. This is not unlike how CoinJoin, while not providing guaranteed anonymity, makes the job of attackers significantly more difficult by creating large amounts of statistical noise. In addition the Bitcoin P2P protocol has natural anti-traffic analysis properties due to its asynchronous nature.

Re: MITM attacks, again, the resources required to conduct them on a large scale instead of passive attacks just don't exist. For instance the NSA has to be relatively selective in using them for fear of being detected; being able to detect attacks is a huge improvement over the status quo anyway.

Having said that using Tor by default in Bitcoin Core is an even easier way of enabling encryption and authentication, and would help protect all Tor users from surveillance. The easiest way to do this would be to make the Debian/Ubuntu packages depend on Tor, and include a install-time script to setup the hidden service. I've verified with the Tor devs that they would welcome the additional load on the Tor network that Bitcoin would add.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJT8+jcMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhU2WB/9XE6BFxTkbjIfVn46U
uH7HCV/FSgCeSConO7LbFR2m6hN5eZ4oKcLzIi65SqRUol2eCGWVoJDsl3vuTmwF
c4gOqdieJQ6SOdHAzcolf+b3p+VwIXXUMMsO2vI6UGZvV6gFJXnZ17GASdSo9+f8
x4VxgLSunZD0xRMiMntaqPMFu1MyplomimQadW5MDt3QTa2BrOsDMwNS10NSQIAL
8ywHSKh8UddVL8ZeinE/Bhf3T1OnDVBIUCVHhhEYnKLqCnwmyY3NXH4lzXpPvo+e
LhzF7HzB5tE22vIQNb/3RimoN5FV7p4FEvgsGwT/kjjUAxgg6/LpNY5WQG6FL8nJ
/8F3
=t4/7
-----END PGP SIGNATURE-----



-------------------------------------
It would be nice if the issues and git repo for Bitcoin Core were not
on such a centralized service as github, nice and convenient as it is.

To that end, I note that Linux does its own git repo, and now requires
2FA: http://www.linux.com/news/featured-blogs/203-konstantin-ryabitsev/784544-linux-kernel-git-repositories-add-2-factor-authentication

As a first step, one possibility is putting the primary repo on
bitcoin.org somewhere, and simply mirroring that to github for each
push.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
I have several Bitcoin contributions I would like to make, mostly for
learning purposes to get started:


   1. I would like to contribute to unit and/or other types of tests
   (code), not production code.
   2. I would like to understand the Bitcoin code (as much as possible from
   top to bottom)
   3. I would like to write a Bitcoin wallet in another language (so would
   like to know where to get the "Bitcoin - Core Wallet" code, but not sure
   where it resides.

I am a seasoned software developer, but I do need direction on where to get
started.  If there is a wiki doc for new developers that would reduce my
searching and experimentation that would be great.

For each of the three items above, I would like to know the tools and
frameworks I would need to understand and initially work on tests ( how to
run the existing tests to get code coverage and find where coverage is
needed, what is the preferred IDE and full development stack etc ), and
also where to get started looking at the bitcoin core code and also the
wallet code (where is the initial starting point and then I could trace
from there ).

Is there a separate area (github & mailing list) for core wallet
development?

Sincerely,


-- 
Caleb
-------------------------------------

Right, gotcha. Had forgotten about that.

Indeed there is another signature, which is to authenticate the payment

Yes, I see now, you are right. A mandate type system is probably simpler
indeed.

So what now? To be honest my next priority with BIP70 was to formalise the
extensions process, I've been dragging my feet over that because I'm
working on other things. And then after that to knock some heads together
over at BitPay/Coinbase and get them to put useful text in the memo field
instead of random numbers. Baby steps ....
-------------------------------------
On Thu, Feb 20, 2014 at 7:11 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

62 assigned.


-------------------------------------
I don't see how set reconciliation alone would be practical for
condensed block exchange -- if the keys are txids it'd require a round
trip to request the missing tx; if we could somehow get the "What's
the Difference" approach to effectively operate on full transactions
instead, the log(keysize) factor overhead would make any transactions
not mutually-known very expensive to exchange (at keysize=32b, data
would need to be 80% mutually-known just to break even). There's also
the complication and/or overhead of establishing an "expected block"
to reconcile with the actual block.

The approach of remembering what invs have been transmitted both
directions along each connection is less elegant; it requires
remembering a lot of communication history, introducing a major point
of statefulness to the protocol, and custom-compacting blocks for each
peer. But it is also very effective at squeezing bytes, cheap in cpu
cycles, and the implementation is fairly simple. The wealth of mutual
knowledge already available in the current protocol allows
accomplishing the goal of exchanging blocks efficiently by solving a
much easier problem than its context-less cousin. I have my doubts
that it is possible for even an optimal contextless solution to do as
well as channel memory in terms of bytes exchanged or computational
complexity -- you can't beat making use of the available information.

I have an implementation of inv-history-tracking that uses a 2b/tx
alternative to getdata for tx, and I've had that running between two
nodes for ~2 weeks now. I've been working on a better implementation
of that plus the sparseblock messages, and I'll have the sparseblock
prototype (suitable for something like Gregory's remember-last-N
approach) up and running in a couple of days or so. The prototype
handles assigning compact identifiers to transactions and using those
in block messages; there's a lot of bit-packing sort of tweaks that
can be done that I'm not including in the initial prototype. The
prototype will be able to log history-hit rates, so if we run a few
sparseblocks nodes connected to each other for a while we should get a
good idea of how much efficiency gain this provides, and how it can be
improved. This approach even without the intensive bit packing has a
total vtx transmission size of 2*nTxKnown + 1*nTxUnknown +
nBytesTxUnknown, where only a small window of very recent transactions
and any transactions that have fallen out of the history limit would
be mutually known but not known to be known.

It would be possible to nearly eliminate even that overhead for both
known and unknown transactions with compact descriptions of block tx
inclusion and ordering policies as Gavin brought up, for which
something like scripts defining priority formulas would be a possible
implementation (https://gist.github.com/kazcw/43c97d3924326beca87d#ordering-policy
-- n.b. most of the rest of the gist is currently outdated). But since
priority scripts are themselves more complicated than the rest of the
sparseblock implementation, and basic sparseblocks achieve the vast
majority of bandwidth savings, I think it's worth implementing
sparseblocks without priority scripts now and then using priority
scripts for sparseblocks2 along with all the other things they can do
later.

Set reconciliation does look like a great way to synchronize mempools.
I've been thinking, contextless low-cost mempool exchange would enable
a node to have one or more "roaming" peer slots -- connect to a node,
fill in each other's mempools, move on to another peer. It seems like
this would go a long way to mitigate potential pathological network
topologies -- it would make it very difficult to sybil attack a node
(barring an attacker in a position to spoof IP addresses), and if a
serious bug or DoS attack caused the network to start to partition
itself due to DoS bans, it only takes occasional roamers crossing the
partition to keep both sides generally in sync.
Efficient mempool synchronization would also increase the efficacy of
channel-memory sparseblocks: it picks up transactions too old to have
been exchanged via invs, and could also allow nodes to know exactly
what transactions their peers have discarded.



On Thu, Jul 31, 2014 at 8:31 AM, Gavin Andresen <gavinandresen@gmail.com> wrote:

On Thu, Jul 31, 2014 at 12:10 PM, Emin Gün Sirer <el33th4x0r@gmail.com> wrote:


-------------------------------------
Introduction
------------

In the wake of the Mt. Gox debacle merkle-sum-trees for
proof-of-reserve(1) have been getting attention again. A serious
objection to using them is exchange privacy as the merkle-sum-tree
inherently reveals the sum total of all deposits held by a given
service. A second, lesser, consideration is the privacy of the users'
balances, as changes to those balances are reflected in the tree and
various levels of aggregate information can be extracted from the
solvency proofs. For instance consider how an attacker who had knowledge
of a few balance changes to a particular user's account - perhaps
because that attacker had deposited funds themselves - could then
corrolate those balance changes with changes in merkle path proofs to
determine an upper bound on the victim's total balance. With some effort
and/or luck that upper bound could be even improved to the exact account
balance by obtaining a solvency proof from an account adjacent to the
victim's account.

Real or imagined the privacy problems with merkle-sum-trees pose a
barrier to adoption. Jesse from the exchange Kraken stated recently(2)
on reddit:

    This is asking a lot of an exchange, and I don't think information
    is worth the price you're paying in security and privacy. Your
    interests would be better served by a private auditor's report.

While there has been much discussion recently on #bitcoin-wizards and
other places about applying advanced cryptographic techniques - so
called "Moon Math" - generate zero-knowledge-proofs of blinded account
sum trees so as to not leak any information, these techniques all suffer
from implementation complexity. Fortunately private proof-of-solvency
without moon math is possible without significant increase in
complexity.


Objectives
----------

First let's look at what exactly it is that our proof-of-solvency is
supposed to achieve. For expediency we'll refer to the third-parties
proving solvency as 'banks' and start with the big picture:

0) No more banks stealing everyone's money!

Of course, since the banks have the private keys to the bitcoins in
question the best we can actually do is much weaker:

1) Prove that at some point in the past, the bank had access to a
   private key that can be used to spend unspent txout(s) that still
   exists now.

Note how the bank may have since lost that key! But objective #1 isn't
good enough by itself; we also need to:

2) Prove that those txout(s) have no been re-used in any other proof of
   solvency or ownership.

Most discussions about merkle-sum-trees miss this critical point. To see
why it matters, consider the example of BigBank. They have a very simple
proof-of-solvency scheme where they simply allocate one address per
customer, holding at least their entire balance. To prove their solvency
to Alice they simply sign a message:

    $ btc verifymessage 13pPCfupiDhWadEXTZDnqSHm5Cy2rdUDho \
      ID6Wk3SDsg3os4cSWRtG13lODY84zoVYpfEC2Y4kfHqGqqZV9hy1xD5yRKCyjL0II3UwPirEVKxm5meJ3VVDW/0= \
      "Hi Alice"

    true

Alice checks that the txouts with that address sum up to at least as
many Bitcoins as her balance, sees that it does, and is satisfied
BigBank is solvent.

Meanwhile LittleBank is running short of funds, so they decide to
"borrow" some from BigBank. One of their customers, Bob, asks for a
proof-of-solvency for his balance, and LittleBank happily obliges:

    $ btc verifymessage 13pPCfupiDhWadEXTZDnqSHm5Cy2rdUDho \
      H9af7wCdJrVIPG5Z0qrSviwAsElPkGw9v5FrUBAdaBtpeEtP/G8UdwN6KxKOytqyU7ObzcQs3qa6urHceZIXDg4= \
      "Hi Bob"

    true

It's rather unlikely that Alice and Bob will compare notes so this
reuse-fraud goes undetected.


Solving txout reuse-fraud with per-txout commitments
----------------------------------------------------

By committing the txout to one and only one purpose we can ensure that
they can't be reused for more than one proof-of-solvency. Take the
following scriptPubKey:

    H("bigbank.com") DROP <pubkey> CHECKSIG

LittleBank in our above example can't reuse that txout as it is
obviously not committed to them. The additional data is kinda ugly and
lacks privacy but can be replaced with the same math used in BIP32 HD
wallet derivation:

    <pubkey + H(domain)*G> CHECKSIG

or in the multisig case:

    n <pubkey_1 + H(domain)*G> ... <pubkey_m + H(domain)*G> m CHECKMULTISIG

The "domain" must be provably globally unique; the URL of the third-party
would be appropriate in most cases. A simple random UUID is *not*
sufficient as there is no good way to be sure that these UUIDs have not
been reused.


Internal reuse-fraud
--------------------

Suppose BigBank gains a second customer, Bob. After depositing some
funds he asks for a proof-of-solvency. BigBank has since added
anti-reuse-fraud to their very simple one-address-per-customer scheme:

    $ btc verifymessage 1HHuBBExHYqPwfgmKiBEHAGFSaLSdVayh5 \
      H6IJztw/QM4WjbtHl51WFo5L8rXn5aONZZvpQIo/8ORz7Yx0puLD68Z2WOCmAEvFQfpz0wYSX3D28RhevYBexpQ= \
      "Hi Bob"

    true

Bob then goes and verifies that the address 1HHuBBE was derived from the
domain "bigbank.com", and finally verifies that the funds held at that
address are sufficient to cover his balance.

Alice does the same thing:

    $ btc verifymessage 1HHuBBExHYqPwfgmKiBEHAGFSaLSdVayh5 \
      H5Z1LEwagAx7s1Kj21sy98/i6/DEZpyyGDfauDVfwOUE2ewsuHqSAE1txRi5VltBs5zVoMExxMw/m4JAyXBSa+s= \
      "Hi Alice"

    true

Note that the addresses are the same! Again, BigBank has committed
re-use fraud, this time internal to the service. In our simplistic
example of one address per customer the domain the funds are committed
to could be extended to include Alice and Bob's usernames or email
addresses. Again, most discussions of merkle-sum-trees gloss over this
important point, and assume that "somehow" the bank will publish the
merkle root publicly, e.g. at a URL.


Merkle-sum-forests for proof-of-solvency
----------------------------------------

Rather than having a single massive tree for all accounts we can instead
use a forrest of merkle-sum-trees, each committed to by a single txout.
The leaves of that tree are still the hash of a customer ID and nonce,
and a balance. However now the root of the tree and the bank domain is
committed to in a txout. To prove solvency the bank gives the customer
multiple merkle-paths that together sum up to the total balance held on
their behalf. Both internal and external reuse-fraud are impossible as
the funds are committed to the customer in question on the blockchain.
Privacy is protected for both the exchange and the customer. The former
because there is no need to reveal total holdings. The latter by
splitting up the holdings among multiple tree - in many cases a given
tree might only have one or two customers funds committed by it as well.

However the requirement to actually make a transaction to change the
balances committed to is inconvenient, potentially expensive, and makes
the so-called "cold storage" warmer.


Indirect merkle-sum-forest solvency proofs
------------------------------------------

By adding indirection we can get the privacy of the merkle-sum-forest
approach without the requirement of creating blockchain transactions on
every proof. Simply stated, if the above merkle-sum-forest is just
committing to arbitrary nonces, we can create a second, ordered,
merklized binary radix tree whose keys are those nonces, and whose
values are what customers have been assigned to the funds committed to
by the txouts associated with the nonces. Proving to the customer their
funds are backed by actual Bitcoins is then a matter of given them a
list of nonce inclusion proofs, as well as the merkle-paths proving
those nonces lead to actual blockchain funds. Since the lookup tree is
ordered each nonce may only be assigned to one specific customer.

Lets look at this in detail with BigBank as the exchange, and Alice and
Bob as the customers. For clarity we'll use OP_DROP as before. We'll say
BigBank has one txout:

    <h1> DROP <pubkey1> CHECKSIG

Where h1 commits to (v1,H(n1 | 'BigBank')), (v2, H(n2 | 'BigBank')),
(v3, H(n3 | BigBank)) with v's being values and n's being nonces.
Alices's total balance is equal to v1+v2, and Bob's equal to v3, so she
creates nonce->customer radix tree mapping n1->Alice, n2->Alice, and
n3->Chalie. She publishes the root of this tree publicly and
non-repudatably.

BigBank's proof for Bob is now the two following subproofs:

    Merkle path proving that n3 in nonce->customer tree
    Merkle sum path proving that v3 allocated in txout

For Alice the proof is as above, except for n1,v1 and n2,v2.


Practical Considerations
------------------------

1) Customers request deposit addresses, but the exchange doesn't know in
   advance how much they are going to deposit. Those addresses should
   commit values and nonces for use in the solvency proof, so we need to
   define a merkle-sum-tree that operates on relative amounts rather
   than absolute.

2) We'd rather not have to spend a txout just to "make change" when a
   customer's balance changes internally. Thus rather than, say, a
   simple binary of two value decomposition in a txout, consider making
   available duplicate values. Q) What's optimal here? Real world data
   would help.


Deterministic nonces and backups
--------------------------------

There needs to be care taken in how nonces are generated - losing a
nonce can mean losing the ability to spend the txout. What should be
done is for the merkle-sum-trees per txout be generated deterministicly
using "sufficient" sub values to allocate change... Which leads to a
curious final conclusion: we can in reality skip the actual
merkle-sum-trees, so to speak, and derive the actual nonces committed to
in the nonce->customer tree from some deterministic splitting algorithm
and the globally unique txout, specifically H("nonce" | txid:n).
Essentially the nonce->customer mapping is actually a "part of a
txout"->customer mapping, where every txout value is split into
convenient-sized change. We still get the privacy we want, because the
customer-containing tree is not a merkle-sum tree, and we completely
prevent fraudulent reuse, and we don't risk losing coins in the event of
a backup failure as all txout scriptPubKeys can be regenerated
deterministicly from a seed.


Future work
-----------

Implement this.


References
----------

1) https://iwilcox.me.uk/2014/proving-bitcoin-reserves
2) http://www.reddit.com/r/Bitcoin/comments/1yk4nv/please_ask_your_favorite_exchange_to_prove_that/cflqtn0
3) Homomorphic Payment Addresses and the Pay-to-Contract Protocol,
   Ilja Gerhardt, Timo Hanke, 13 Dec 2012


Copyright
---------

This document is placed in the public domain.

-- 
'peter'[:-1]@petertodd.org
000000000000000039d6ffee2cd4a4162ad9bdb665abeb5f916af96dbd0b83f9
-------------------------------------
Practically I would approach it from a different angle. We need to make
sure that notes we're accepting are still loaded, but assuming it's NFC
enabled this is still quite easy for the user and is an acceptable
usability drawback.
Then what we need to make sure is that when someone is redeeming the notes
- he has control over physical object itself, ideally for a period of time.

​With some active powered electronics in place it would be easy, but how do
we do it without anything active in place? ​


Best regards,
Alex Kotenko


2014-05-18 21:10 GMT+01:00 Natanael <natanael.l@gmail.com>:

-------------------------------------
On Thu, Mar 13, 2014 at 1:18 PM, Mark Friedenbach <mark@monetize.io> wrote:

Yes.  That was in Tamas's recursive link, and also brought up on
github by jcorgan.  +1

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Thanks, Peter and you convinced me. I run away with a thought.

Itd be great to find a spot to deploy payment channels, but I agree this is not it.

Tamas Blummer
http://bitsofproof.com

On 10.04.2014, at 12:40, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
Who said anything about a re-org? The original block remains valid, your block reward is just zero, upon maturity, in light of a valid fraud proof.

ie. the "coinbase confiscation" that I was just arguing against in another thread :P but of course here based on cryptographic proof, not human judgement.

On 27 April 2014 11:22:07 AM AEST, Mark Friedenbach <mark@monetize.io> wrote:

-- 
Sent from my Android device with K-9 Mail. Please excuse my brevity.


-------------------------------------
Hmm, I've mostly setup what's promised, testing DNS seeds now. There is one
problem I see that I can't really solve myself.
This dnsseed daemon cannot serve more than one name at once, which means
that I cannot serve testnet and mainnet seeds off one daemon instance which
means I need to buy two IP addresses for it. That's unfortunate as it needs
much more spendings from me to operate, second IP address will cost nearly
as much as the server itself.

​Can anybody help with this? I cannot into C++ to fix that myself.   ​


Best regards,
Alex Kotenko


2014-05-17 13:39 GMT+01:00 Andreas Schildbach <andreas@schildbach.de>:

-------------------------------------
On Mon, Jun 16, 2014 at 01:37:52PM -0700, Daniel Rice wrote:

You can always use fidelity bonds, or as I called it at the time(1),
"Trusted identities":

    Lets suppose Alice has some bitcoins held at bitcoin address A. She
    wants to establish trust in the "identity" associated with the ECC
    keypair associated with A, for instance for the purpose of having other
    users trust her not to attempt to double spend. Since the trust she
    seeks is financial in nature, she can do this by valuing the identity
    associated with A, by delibrately throwing away resources. A simple way
    to do this would of course be to transfer coins to a null address,
    provably incurring a cost to her.

    A more socially responsible way would be for her to create a series of
    transactions that happen to have large, and equal, transaction fees.
    Bitcoin makes the assumption that no one entity controls more than 50%
    of the network, so if she makes n of these transactions consecutively,
    each spending m BTC to transaction fees, there is a high probability
    that she has given up at least n/2 * m BTC of value. This of course is
    all public knowledge, recorded in the block chain. It also increases the
    transaction fees for miners, which will be very important for the
    network in the future.

    Now Bob can easily examine the block chain, and upon verifying Alice's
    trust purchase, can decide to accept a zero-confirmation transaction at
    face value. If Alice breaks that promise, he simply publishes her signed
    transaction proving that Alice is a fraudster, and future Bob's will
    distrust Alice's trusted identity, thus destroying the value needed to
    create it.

    In effect, we now have a distributed green address system.

Note that the second paragraph is seriously obsolete - better to either
use announce-commit sacrifices, or much preferably, simple destruction
of coins. (sacrifice to fees encourages mining centralization for
obvious reasons)

1) "[Bitcoin-development] Trusted identities", Apr 26th 2012, Peter Todd,
   http://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg01005.html

Incidentally, my first post to this mailing list!

-- 
'peter'[:-1]@petertodd.org
000000000000000058ca7ee3a40438ea5a96e499910638352468c6d69abdb226
-------------------------------------
This one looks entirely useless (it cannot be made secure), and the assertion 
that it is necessary for atomic cross-chain transfers seems unfounded and 
probably wrong...

Luke

On Friday, April 25, 2014 6:49:37 PM Tier Nolan wrote:


-------------------------------------
I am in favor of xbit, my only concern is if average Joes will consider
that name "stupid" (like various attempts at "cool" branding with unusual
letters like Q, X, Z, etc). We should see if we can get support for it in
the community and if there would be any notable opposition against it or
not. If there's no significant opposition and most people are in favor, I'd
say go ahead.

- Sent from my phone
Den 21 apr 2014 11:38 skrev "Tamas Blummer" <tamas@bitsofproof.com>:

-------------------------------------
Very good, I like the proposal.

A question I have: can it be used to do the opposite, i.e. build a script
that can only be spent up until block X?

On Thu, Oct 2, 2014 at 2:09 AM, Peter Todd <pete@petertodd.org> wrote:

-------------------------------------
Hi Mark,

This is very similar to a proposal I made some time ago:


https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04053.html

I think the outlines of a design are clear - my proposal and yours don't I
think differ substantially. Someone needs to make it happen though.
-------------------------------------
You're correct, my impression of the term is based of what I experience in
the US. If it is more widely used in other cultures that should be a
consideration.
On Apr 20, 2014 12:27 PM, "Wladimir" <laanwj@gmail.com> wrote:

-------------------------------------
On 10/22/2014 10:46 AM, Chris D'Costa wrote:

Isn't this the same problem with PGP?

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
On Wed, Jun 25, 2014 at 10:25 AM, Mike Hearn <mike@plan99.net> wrote:

Good standard must be explicit as much as possible. Having million optional
fields with ambiguous meaning is even worse than not having these fields.

HTTP status codes are good example. There are hundreds of them, still
applications understands just few of them, because other have ambiguous
meaning and software don't know how to handle them.

Good example of such over-engineering is also XMPP. XMPP has milions
extensions and features, but look at Jabber clients; call yourself lucky
when you can send messages and files, although there're various extensions
like searching for contacts (something which has be working in ICQ decade
ago), voice support, end to end encryption or alerting users. These
features are defined, but not widely implemented, because its definition is
vague or the feature is abused because of poor design.

Please don't over-engineer payment protocol.

Thank you for your attention.

slush
-------------------------------------
After some off-list discussion about details with wallet developers, it
seems that structure

m/<cointype>'/<account>'/<change>/<n>

fulfill requirements of all wallet developers around, including myTrezor,
Electrum, Multibit, Wallet32 and other software is willing to adapt once
anything will be standardized (i.e. they don't care).

Because I think that everybody told their comments to the topic already and
because it seems that there's quite wide agreement on that, I would like to
close the discussion and finally implement these paths into our software.

Cheers,
Marek


On Fri, Mar 28, 2014 at 3:59 PM, slush <slush@centrum.cz> wrote:

-------------------------------------
There can be multiple independent transport networks for Bitcoin.

There already is: ipv4, ipv6, Tor, and native_i2p (out of tree patch).

As long as multihomed hosts that act as bridges then information will propagate across all of them.
--
Justus Ranvier
-----------------
sent with R2Mail2

----- Original Message -----
From: Matt Whitlock <bip@mattwhitlock.name>
Sent: 2014/06/16 - 13:10
To: Mike Hearn <mike@plan99.net>, Justus Ranvier <justusranvier@gmail.com>
Subject: Re: [Bitcoin-development] Incentivizing the running of full nodes



-------------------------------------
On Thu, Apr 24, 2014 at 1:39 AM, Mike Hearn <mike@plan99.net> wrote:

May I direct your attention to the third post in that thread?

Luke attempting to ret-con the enforcement flag into a vote didn't
make it one, and certantly wouldn't make it a fair, just, or sane
method of one. And so much for the effectiveness— you didn't implement
it for years even after it was deployed.

And yes, you can take any decision system and draw comparisons to
voting and call it a vote but that doesn't mean is serves the same
role or was intended for that purpose.


Yes, you can reorg out the blocks and actually remove them, but I
understood that you were _not_ proposing that quite specifically. But
instead proposed without reorging taking txouts that were previously
assigned to one party and simply assigning them to others.


I don't think thats the root of the the disagreement at all. I think
all sorts of changes are interesting, especially ones that increase
flexibility or fix bugs but less so ones that would impose significant
changes on parties without their consent especially things that look
like taking someone's coins and assigning them to someone else.

I think the root is that you believe that the miners are, should be,
or even could be trustworthy in ways that I do not,  and as a result
you expect to be able to extract the performance of a trusted
centralized system out of them that I do not. Bitcoin is a system
where the incentives are well enough aligned that you appear to only
need a small amount of altruism to make it reliable. ... and even
summoning that altruism is a challenge— as miners hand over control of
their hash-power to centralized pools (some known to have behaved
poorly in the past), etc.

I would like that performance if it came at no cost: But proposals
that miners conspiring to blacklist transactions/blocks produced by
other people is something with a risk of a worse violation of the
system's promises than some disagreement of the ordering of
unconfirmed transactions.  Pretty much immediately after your post
Peter Todd— in his trouble making manner— went and posted on reddit
proposing the mechanism be used to claw back mining income from a
hardware vendor accused of violating its agreements on the amount of
self mining / mining on customers hardware.  While Peter's suggestion
was no doubt intentionally trouble making— I'm not clear on where the
line is here: Harm from reordering pretty much non-existent currently
and is highly speculative, while the harm to miners by hardware
vendors who've promised to not compete with their own customers or use
their equipment is not at all speculative and very salient to miners.

This especially in light of the fact that the system already has an
equitable method to decide what order transactions should be in... but
instead you propose an additional complex heuristic system where based
on some unspecified collusion some majority of miners take a
minorities coins and assign them to themselves.

Unlike reorginization this form of wealth transferal has no collateral
damage meaning that a majority cabal can use it to deprive a minority
outsider of some or all income without risking disrupting the network,
it would also lay the groundwork for additional forms of censorship
which I believe would be at odds with the purpose and architecture of
the system... and, as I noted above, it wouldn't actually prevent
theft, it would just mean that no single block could make its theft
services available to all comers (or even any of the public at all).
The simple mechenism of allowing only only a small number of paid
reordering transactions per block would prevent forming a quorum on
the decision to revoke the coinbase, and you'd even get additional
income from the probe transactions without even helping any real
double spends at all. The incentives seem very hard to analyze.


-------------------------------------
On Thu, Jun 19, 2014 at 09:54:31AM -0400, Gavin Andresen wrote:

Sounds like it could turn EvalScript() into a mess over time, but that's
a long way away. Anyway a BIP will be useful.


Yeah, that's what I implemented in https://github.com/bitcoin/bitcoin/pull/4311

-- 
'peter'[:-1]@petertodd.org
00000000000000004f73d48c972aa30493526191aa009f95e4a71dcfbdca08b2
-------------------------------------
Has there ever been serious discussion on extending the protocol to
support UDP transport? That would allow for NAT traversal and for many
more people to run effective nodes. I'm also curious if it could be
made improve block propagation time.

On Tue, May 20, 2014 at 7:52 AM, Gmail <will.yager@gmail.com> wrote:



-- 
Andy Alness
Software Engineer
Coinbase
San Francisco, CA


-------------------------------------
Seconded - IMO a key future use of the chain will be securing other
chains.  I'm interested in pursuing the merged-mining angle.

Getting chain hashes to a miner, and getting that miner payment from
the chain, is key to this.  Consider a future where there are 10,000
chains secured by one block...


On Wed, Oct 29, 2014 at 10:34 AM, Sergio Lerner
<sergiolerner@certimix.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
SPDY requires SSL and is even more complex than HTTP.

Really, the current protocol we've got (length prefixed protobufs) is just
fine except for the lack of encryption/authentication. For that you need to
do ECDH to establish a shared AES session key, and MAC each packet. Like I
said, it's not entirely trivial which is why it's worth trying SSL too, but
it's also not a massive effort.


On Fri, Mar 21, 2014 at 4:20 PM, Andreas Schildbach
<andreas@schildbach.de>wrote:

-------------------------------------
On Wed, Apr 23, 2014 at 9:55 PM, Luke-Jr <luke@dashjr.org> wrote:


Wallet don't see UTXO until it scans all branches/accounts on HD node
import.
-------------------------------------
It is very young in bitcoin's life.  We don't know what features will
work out best, or need to be radically changed after initial
deployment in the field.

Loose coordination is good.  Good ideas will spread on their own.
Users will demand compatibility with certain features, and fail to
care incompatibilities in other features.

Tight interoperability at this stage is too confining.




On Fri, Apr 25, 2014 at 11:46 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Since you are taking the hash of Unicode data, I would strongly
recommend using a canonical form, e.g. Normalized Form C.

On 01/20/2014 09:42 AM, slush wrote:
CenturyLink Cloud: The Leader in Enterprise Cloud Services.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJS3ZzAAAoJEAdzVfsmodw4L3sP/2VjvICLTYlkZcY6brBIZhoU
P6ei6qECzmBCWpW5iC1r99j76bPwP3M6jH6P7iBljj72J5NgHXq+K8GvA5M6qu0o
6s+WJ7HYJ8KwRZuvGPvcopXBKJAJXadrN7xSPikYD2zMm2KCZTUI5IurR1p/dpUR
3HzL2RdjbDugBOiAjiMMq0dAs1x9/vmF0F2KDZHiCJEtP/+gbtOE/KmXrnrAJSNI
Aswb/lZg1GWGpOs+iCdEaRfST2PIL/jGgnteJ4iKHvh2+dOW0/AhINo5g56LTVvU
Q+pAv8SRLad/30PVaWAStrtLMxu+j0JQ1wgEkRCrsQ0xE3iKtmbppzh2dIQ8Idrt
EkjqoykB2wn4Kw+QcT2TXIcBV7LBqSurE/jDWWIFtHxdV0++8PDYFOesq2Xf9Rif
VStYnUVvUhuzGXD3oOnIGpEvMm2i30Qyi33oJLvqfWUBkzJzFdtZ+YYBYlbpwBOQ
YLEr2DmVHLk/MXWL1POruvnIT4N+6uyh59HKHKRJI0nGMmRR3cBLkM8vEEHerD3P
ucg++TTdqXM6XoSmIk55CQnGdglDJEOGc+gzaGffqeDMJhmz/apEawN5en7ogN0o
XfWDWSdtwMvlza3F6cMejvBkuFZTLUxyaedP13vOTDhUIbmqsliyhwA2YrXE7udQ
1JMYADuvb18LYE/hQJX3
=Ycdc
-----END PGP SIGNATURE-----


-------------------------------------
I'm seeing another uninitialized memory problem in bitcoind using valgrind:

tm@tm-VirtualBox:~/bitcoind/bitcoin/src$ valgrind ./bitcoind
==2337== Memcheck, a memory error detector
==2337== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==2337== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==2337== Command: ./bitcoind
==2337==
==2337== Conditional jump or move depends on uninitialised value(s)
==2337==    at 0x319176: CWallet::LoadKeyMetadata(CPubKey const&,
CKeyMetadata const&) (wallet.cpp:110)
==2337==    by 0x33645A: ReadKeyValue(CWallet*, CDataStream&, CDataStream&,
CWalletScanState&, std::string&, std::string&) (walletdb.cpp:509)
==2337==    by 0x3374F0: CWalletDB::LoadWallet(CWallet*) (walletdb.cpp:623)
==2337==    by 0x3218FD: CWallet::LoadWallet(bool&) (wallet.cpp:1485)
==2337==    by 0x157F16: AppInit2(boost::thread_group&) (init.cpp:958)
==2337==    by 0x140142: AppInit(int, char**) (bitcoind.cpp:143)
==2337==    by 0x13649E: main (bitcoind.cpp:180)
==2337==
-------------------------------------
On Wed, Apr 23, 2014 at 2:18 PM, Luke-Jr <luke@dashjr.org> wrote:

Hopefully it would be clarified as only a MUST NOT do so silently...
"I have funds split across two wallets and it WONT LET ME SPEND THEM"
sounds like a terrible user experience. :)


-------------------------------------
On 3 January 2014 05:45, Troy Benjegerdes <hozer@hozed.org> wrote:



Which is why, as pointed out several times at 30c3 by several renowned
figures, why cryptography has remained squarely outside of mainstream use.
It needs to just work and until you can trust the connection and what the
end point sends you, automatically, it's a big fail and the attack vectors
are many.

<sarcasm>I can just see my mother or grandma manually checking the hash of
a download... </sarcasm>

Drak
-------------------------------------
The idea was not to register profiles or any human identity, or associate it with any other identity directly. Neither was it to have a massive BlockChain, or use proof of work. In this case proof of work is detrimental to security - you want as many people to know about your keys as quickly as possible. I want to add that this implies a shadow p2p network.

Also it's just a point if view, but I thought it better not to have any specific link to a person's identity, or their Bitcoin "identity" by which I mean no connection to their public addresses. The device keys are not meant to be a permanent identity or to store encrypted data either (think what happens if the device changes hands), so the use case is only to establish secure communications, and to verify signatures whilst still in use by the owner. A new owner would need to establish a new device key - again this is in the details and probably more specific to the project.

Regards

Chris D'Costa






-------------------------------------
On 4/2/2014 12:45 PM, Laszlo Hanyecz wrote:
Thank you for giving me the benifit of the doubt.  I did not realize my 
mistake.  I hope we can now get back to talking about bitcoin


-- 
Kevin



-------------------------------------
About the small number of bitcoin nodes:
Hi, I read the message that Mike Hearn sent to this mailing list some days
ago (2014-04-07 11:34:43) related to the number of bitcoin full nodes.

As an owner of two Bitcoin Nodes, one in my home computer and one in a
dedicated server, I believe I can contribute with some of my thoughts and
ideas:

- Allow users to view the bandwith used by Bitcoin Core:
This is available in the Bitcoin Core GUI (btw, when the computer is
restarted the data gets reseted) but I cant find it in the bitcoind
commandline, people that run nodes want to see the amount of GB that they
have "donated" to the network.

- Educate users about the correct setup of a bitcoin node:
Add a page in the bitcoin.org website with a tutorial about running Bitcoin
Core with the ports opened, about runing bitcoind, etc. This guide shoud
not be for regular users but for advanced ones.

- bitcoind and Bitcoin Core should create a bitcoin.conf file on the first
start:
The first time the software should create a default config file with a
random RCP password and username (user can change it later) and the config
file should be commented so the user can know how to change configurations.
This is very useful in setups without GUI, for example in Ubuntu Server.

- bitcoind and Bitcoin Core should be in Linux repos:
People want to type "yum install bitcoind" or "apt-get install bitcoind"
and install bitcoin. No one wants to follow a tutorial made by somewho
saying that you have to add external repos to install bitcoin in your
server.
For example Electrum has been added to Ubuntu software center recently.
Bitcoin Core an bitcoind should be on CentOS, Debian, Ubuntu and Ubuntu
Server repos.

- Create a "grafical interface" for bitcoind on Linux servers:
Create a command, for example "bitcoind show" that shows a nice summary in
your Terminal (Console) with all the data that a node administrator wants
to know.
When I say "grafical interface" I mean like "top" command, an interface
made out of characters in ASCII.

- Split Bitcoin Wallet from Bitcoin Node:
I believe that this is planned, some people want to help the network and
others want to keep a wallet, someones want both.
With bitcoind you can use the option "disablewallet=1" that allows to save
some memory.

- Inform users if 8333 port is closed:
That should be more visible, I dont mean an alert or warning but some icon.

- Keep connections if bitcoind is restarted:
I noticed that if I restart bitcoind (to apply new config) my reset to 0
and take some hours to rise up to ~40. I believe that my peers should
notice that I am down for less than ~15 minutes and try to connect again
faster.
-------------------------------------
Please download and help test 0.9.0rc2; binaries are available from:
   https://bitcoin.org/bin/0.9.0/test/

If no serious bugs are found in this release candidate, it will be the
final 0.9.0 release.

Release notes (please help proofread/improve these, too):
---------------------------------------------------------------------------

Bitcoin Core version 0.9.0rc2 is now available from:

  https://bitcoin.org/bin/0.9.0/test/

This is a release candidate for a new major version. A major version brings
both new features and bug fixes.

Please report bugs using the issue tracker at github:

  https://github.com/bitcoin/bitcoin/issues

How to Upgrade
--------------

If you are running an older version, shut it down. Wait until it has
completely
shut down (which might take a few minutes for older versions), uninstall all
earlier versions of Bitcoin, then run the installer (on Windows) or just
copy
over /Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).

If you are upgrading from version 0.7.2 or earlier, the first time you run
0.9.0 your blockchain files will be re-indexed, which will take anywhere
from
30 minutes to several hours, depending on the speed of your machine.

On Windows, do not forget to uninstall all earlier versions of the Bitcoin
client first, especially if you are switching to the 64-bit version.

Windows 64-bit installer
-------------------------

New in 0.9.0 is the Windows 64-bit version of the client. There have been
frequent reports of users running out of virtual memory on 32-bit systems
during the initial sync. Because of this it is recommended to install the
64-bit version if your system supports it.

NOTE: Release candidate 2 windows binaries are not code-signed; use pgp
and the SHA256SUMS.asc file to make sure your binaries are correct.
The final 0.9.0 release Windows setup.exe binaries will be code-signed.

OSX 10.5 / 32-bit no longer supported
-------------------------------------

0.9.0 drops support for older Macs. The minimum requirements are now
a 64-bit-capable CPU running OSX 10.6 or later.

Rebranding to Bitcoin Core
---------------------------

To reduce confusion between Bitcoin-the-network and Bitcoin-the-software we
have renamed the reference client to Bitcoin Core.

Autotools build system
-----------------------

For 0.9.0 we switched to an autotools-based build system instead of
individual
(q)makefiles.

Using the standard "./autogen.sh; ./configure; make" to build Bitcoin-Qt and
bitcoind makes it easier for experienced open source developers to
contribute
to the project.

Be sure to check doc/build-*.md for your platform before building from
source.

Bitcoin-cli
-------------

Another change in the 0.9 release is moving away from the bitcoind
executable
functioning both as a server and as a RPC client. The RPC client
functionality
("tell the running bitcoin daemon to do THIS") was split into a separate
executable, 'bitcoin-cli'. The RPC client code will eventually be removed
from
bitcoind, but will be kept for backwards compatibility for a release or two.

`walletpassphrase` RPC
-----------------------

The behavior of the `walletpassphrase` RPC when the wallet is already
unlocked
has changed between 0.8 and 0.9.

The 0.8 behavior of `walletpassphrase` is to fail when the wallet is
already unlocked:

    walletunlocktime = now + 1000
    Error: Wallet is already unlocked (old unlock time stays)

The new behavior of `walletpassphrase` is to set a new unlock time
overriding
the old one:

    walletunlocktime = now + 1000
    walletunlocktime = now + 10 (overriding the old unlock time)

Transaction malleability-related fixes
--------------------------------------

This release contains a few fixes for transaction id malleability issues:

- -nospendzeroconfchange command-line option, to avoid spending
  zero-confirmation change
- IsStandard() transaction rules tightened to prevent relaying and mining of
  mutated transactions
- Additional information in listtransactions/gettransaction output to
  report wallet transactions that conflict with each other because
  they spend the same outputs.
- Bug fixes to the getbalance/listaccounts RPC commands, which would report
  incorrect balances for double-spent (or mutated) transactions.
- New option: -zapwallettxes to rebuild the wallet's transaction information

Transaction Fees
----------------

This release drops the default fee required to relay transactions across the
network to 0.01mBTC per kilobyte. Note that getting a transaction relayed
across the network does NOT guarantee that the transaction will be
accepted by a miner and included in a block, and the default fee accepted
by miners remains 0.1mBTC per kilobyte.

As in previous releases, the relay fee may be changed with the
-minrelaytxfee
command-line option, and miners may change the default minimum fee they
accept
with the -mintxfee command-line option.

0.9.0rc2 Release notes
=======================

RPC:

- New notion of 'conflicted' transactions, reported as
  confirmations: -1
- 'listreceivedbyaddress' now provides tx ids
- Add raw transaction hex to 'gettransaction' output
- Updated help and tests for 'getreceivedby(account|address)'
- In 'getblock', accept 2nd 'verbose' parameter, similar to
getrawtransaction,
  but defaulting to 1 for backward compatibility
- Add 'verifychain', to verify chain database at runtime
- Add 'dumpwallet' and 'importwallet' RPCs
- 'keypoolrefill' gains optional size parameter
- Add 'getbestblockhash', to return tip of best chain
- Add 'chainwork' (the total work done by all blocks since the genesis
block)
  to 'getblock' output
- Make RPC password resistant to timing attacks
- Clarify help messages and add examples
- Add 'getrawchangeaddress' call for raw transaction change destinations
- Reject insanely high fees by default in 'sendrawtransaction'
- Add RPC call 'decodescript' to decode a hex-encoded transaction script
- Make 'validateaddress' provide redeemScript
- Add 'getnetworkhashps' to get the calculated network hashrate
- New RPC 'ping' command to request ping, new 'pingtime' and 'pingwait'
fields
  in 'getpeerinfo' output
- Adding new 'addrlocal' field to 'getpeerinfo' output
- Add verbose boolean to 'getrawmempool'
- Add rpc command 'getunconfirmedbalance' to obtain total unconfirmed
balance
- Explicitly ensure that wallet is unlocked in `importprivkey`
- Add check for valid keys in `importprivkey`

Command-line options:

- New option: -nospendzeroconfchange to never spend unconfirmed change
outputs
- New option: -zapwallettxes to rebuild the wallet's transaction information
- Rename option '-tor' to '-onion' to better reflect what it does
- Add '-disablewallet' mode to let bitcoind run entirely without wallet
(when
  built with wallet)
- Update default '-rpcsslciphers' to include TLSv1.2
- make '-logtimestamps' default on and rework help-message
- RPC client option: '-rpcwait', to wait for server start
- Remove '-logtodebugger'
- Allow `-noserver` with bitcoind

Block-chain handling and storage:

- Update leveldb to 1.15
- Check for correct genesis (prevent cases where a datadir from the wrong
  network is accidentally loaded)
- Allow txindex to be removed and add a reindex dialog
- Log aborted block database rebuilds
- Store orphan blocks in serialized form, to save memory
- Limit the number of orphan blocks in memory to 750
- Fix non-standard disconnected transactions causing mempool orphans
- Add a new checkpoint at block 279,000

Wallet:

- Bug fixes and new regression tests to correctly compute
  the balance of wallets containing double-spent (or mutated) transactions
- Store key creation time. Calculate whole-wallet birthday.
- Optimize rescan to skip blocks prior to birthday
- Let user select wallet file with -wallet=foo.dat
- Consider generated coins mature at 101 instead of 120 blocks
- Improve wallet load time
- Don't count txins for priority to encourage sweeping
- Don't create empty transactions when reading a corrupted wallet
- Fix rescan to start from beginning after importprivkey
- Only create signatures with low S values.

Mining:

- Increase default -blockmaxsize/prioritysize to 750K/50K
- 'getblocktemplate' does not require a key to create a block template

Protocol and network:

- Drop the fee required to relay a transaction to 0.01mBTC per kilobyte
- Send tx relay flag with version
- New 'reject' P2P message (BIP 0061, see
https://gist.github.com/gavinandresen/7079034 for draft)
- Dump addresses every 15 minutes instead of 10 seconds
- Relay OP_RETURN data TxOut as standard transaction type
- Remove CENT-output free transaction rule when relaying
- Lower maximum size for free transaction creation
- Send multiple inv messages if mempool.size > MAX_INV_SZ
- Split MIN_PROTO_VERSION into INIT_PROTO_VERSION and MIN_PEER_PROTO_VERSION
- Do not treat fFromMe transaction differently when broadcasting
- Process received messages one at a time without sleeping between messages
- Improve logging of failed connections
- Bump protocol version to 70002
- Add some additional logging to give extra network insight
- Added new DNS seed from bitcoinstats.com

Validation:

- Log reason for non-standard transaction rejection
- Prune provably-unspendable outputs, and adapt consistency check for it.
- Detect any sufficiently long fork and add a warning
- Call the -alertnotify script when we see a long or invalid fork
- Fix multi-block reorg transaction resurrection
- Reject non-canonically-encoded serialization sizes
- Reject dust amounts during validation
- Accept nLockTime transactions that finalize in the next block

Build system:

- Switch to autotools-based build system
- Build without wallet by passing `--disable-wallet` to configure, this
removes
  the BerkeleyDB dependency
- Upgrade gitian dependencies (libpng, libz, libupnpc, boost, openssl) to
more
  recent versions
- Windows 64-bit build support
- Solaris compatibility fixes
- Check integrity of gitian input source tarballs
- Enable full GCC Stack-smashing protection for all OSes

GUI:

- Switch to Qt 5.2.0 for Windows build
- Add payment request (BIP 0070) support
- Improve options dialog
- Show transaction fee in new send confirmation dialog
- Add total balance in overview page
- Allow user to choose data directory on first start, when data directory is
  missing, or when the -choosedatadir option is passed
- Save and restore window positions
- Add vout index to transaction id in transactions details dialog
- Add network traffic graph in debug window
- Add open URI dialog
- Add Coin Control Features
- Improve receive coins workflow: make the 'Receive' tab into a form to
request
  payments, and move historical address list functionality to File menu.
- Rebrand to `Bitcoin Core`
- Move initialization/shutdown to a thread. This prevents "Not responding"
  messages during startup. Also show a window during shutdown.
- Don't regenerate autostart link on every client startup
- Show and store message of normal bitcoin:URI
- Fix richtext detection hang issue on very old Qt versions
- osx: Make use of the 10.8+ user notification center to display growl like
       notifications
- osx: Added NSHighResolutionCapable flag to Info.plist for better font
       rendering on Retina displays.
- osx: Fix bitcoin-qt startup crash when clicking dock icon
- linux: Fix Gnome bitcoin: URI handler

Miscellaneous:

- Add Linux script (contrib/qos/tc.sh) to limit outgoing bandwidth
- Add '-regtest' mode, similar to testnet but private with instant block
  generation with 'setgenerate' RPC.
- Add 'linearize.py' script to contrib, for creating bootstrap.dat
- Add separate bitcoin-cli client

Credits
--------

Thanks to everyone who contributed to this release:

- Andrey
- Ashley Holman
- b6393ce9-d324-4fe1-996b-acf82dbc3d53
- bitsofproof
- Brandon Dahler
- Calvin Tam
- Christian Decker
- Christopher Latham
- Chuck
- coblee
- constantined
- Cory Fields
- Cozz Lovan
- Daniel Larimer
- David Hill
- Dmitry Smirnov
- Drak
- Eric Lombrozo
- fanquake
- fcicq
- Florin
- frewil
- Gavin Andresen
- Gregory Maxwell
- gubatron
- Guillermo Cspedes Tabrez
- Haakon Nilsen
- HaltingState
- Han Lin Yap
- harry
- Ian Kelling
- Jeff Garzik
- Johnathan Corgan
- Jonas Schnelli
- Josh Lehan
- Josh Triplett
- Julian Langschaedel
- Kangmo
- Lake Denman
- Luke Dashjr
- Mark Friedenbach
- Matt Corallo
- Michael Bauer
- Michael Ford
- Michagogo
- Midnight Magic
- Mike Hearn
- Nils Schneider
- Noel Tiernan
- Olivier Langlois
- patrick s
- Patrick Strateman
- Peter Todd
- phantomcircuit
- phelixbtc
- Philip Kaufmann
- Pieter Wuille
- Rav3nPL
- regergregregerrge
- Robert Backhaus
- Roman Mindalev
- Rune K. Svendsen
- Ryan Niebur
- Scott Ellis
- Scott Willeke
- Sergey Kazenyuk
- Shawn Wilkinson
- Sined
- sje
- Subo1978
- super3
- Tamas Blummer
- theuni
- Thomas Holenstein
- Timon Rapp
- Timothy Stranex
- Vaclav Vobornik
- vhf / victor felder
- Vinnie Falco
- Warren Togami
- Wil Bown
- Wladimir J. van der Laan
-------------------------------------
When forgoing bootstrapping due to disk space constraints, you, and the
network, are likely better off -reindex-ing from current blk000??.dat files.

Which brings up an interesting point: The improvements related to the
headers first approach are likely to increase, how ever marginally, the
percentage of block exchange-related traffic, as it is less painful now to
be catching up.

It'd be interesting to see the statistics, not from a single node
perspective, but from the viewpoint of an Internet backbone provider, say
through the cables coming ashore in Cornwall. For the incurred bandwidth
expense would invariably trickle down to transaction fees in an equilibrium
model.

There is an opportunity somewhere in this.


On Sun, Oct 12, 2014 at 7:13 PM, Jameson Lopp <jameson.lopp@gmail.com>
wrote:

-------------------------------------
Hi Chuck,

Both Bitcoin Core and bitcoinj are about to ship with the protocol as-is,
so any changes from this point on have to be backwards compatible.

On Thu, Jan 30, 2014 at 6:47 AM, Chuck <chuck+bitcoindev@borboggle.com>wrote:


That's all you need to prove payment, yes.




That's right (+memo). And to provide an additional hook for future
features, like recurring billing, ECDH key agreements etc.



Refund addresses as specced currently are optional. For instance bitcoinj
currently doesn't use them and won't until HD wallets support is done.

Let's get some practical experience with what we've got so far. We can
evolve PaymentRequest/Payment/PaymentACK in the right direction with
backwards compatible upgrades, I am hoping.
-------------------------------------
The comparison with multisig fails to mention that multi-signature
transactions explicitly define security at the transaction level.
This permits fine-grained specificity of what a key holder may
approve.

Shamir is much more coarse-grained.  You reconstitute a private key,
which may then be used to control anything that key controls.  Thus,
in addition to Shamir itself, you need policies such as "no key
reuse."

My first impression of Shamir many moons ago was "cool!" but that's
since been tempered by thinking through the use cases.  Shamir has a
higher D.I.Y. factor, with a correspondingly larger surface of
things-that-could-go-wrong, IMO.

(None of this implies making an informational BIP lacks value; I'm all
for an informational BIP)




On Sat, Mar 29, 2014 at 7:54 AM, Chris Beams <chris@beams.io> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On 10/01/2014 04:58 PM, Gavin Andresen wrote:

If you're doing some kind of proof-of-burn scheme, wouldn't using P2SH
defeat the purpose of it?


-------------------------------------
Whats a sensible limit on practical/convenient QR code size?

How much of the payment protocol message size comes from use of x509?

(Just exploring what the options are).

Adam

On Thu, Mar 20, 2014 at 11:36:09AM +0100, Mike Hearn wrote:


-------------------------------------
How does this system handle problems with the lower chains after they have
been "locked-in"?

The rule is that if a block in the child chain is pointed to by its parent,
then it effectively has infinite POW?

The point of the system is that a node monitoring the parent chain only has
to watch the header chain for its 2 children.

A parent block header could point to an invalid block in one of the child
chains.  That parent block could end up built on top of before the problem
was discovered.

This would mean that a child chain problem could cause a roll-back of a
parent chain.  This violates the principle that parents are dominant over
child chains.

Alternatively, the child chain could discard the infinite POW blocks, since
they are illegal.

P1 -> C1
P2 -> ---
P3 -> C3
P4 -> C5

It turns out C4 (or C5) was an invalid block

P5 -> C4'
P6 -> ---
P7 -> C8'

This is a valid sequence.  Once P7 points at C8, the alternative chain
displaces C5.

This displacement could require a compact fraud proof to show that C4 was
an illegal block and that C5 was built on it.

This shouldn't happen if the miner was actually watching the log(N) chains,
but can't be guaranteed against.

I wonder if the proof of stake "nothing is at stake" principle applies
here.  Miners aren't putting anything at stake by merge mining the lower
chains.

At minimum, they should get tx-fees for the lower chains that they merge
mine.  The rule could require that the minting reward is divided over the
merge mined chains.
-------------------------------------
Peter Todd <pete@petertodd.org> wrote:

Drak responded:

Ooo, I like this. I *can* use git, but would love to be able to avoid it -- as would most non-technical contributors.

Anyway, this particular solution doesn't appear to be possible in this case, as the file isn't at https://github.com/bitcoin/bitcoin/tree/0.9.0/doc/release-notes , and I don't believe I could copy it to the repository without going the whole git route. Suggestions welcome, here or privately.

Peter writes:

The foolishness of sending a payment to a Mt. Gox-held wallet -- which is required to edit the wiki -- strikes me as a pressing issue. If I understand it correctly, this is a hard blocker that'll stop *all* new contributors. Further, I registered for the wiki and never got my confirmation email. Methinks the whole thing is broken. :(

Again, please to redirect me if this is inappropriate for this list. (I'm new here.) Cheers,

---
          Tom Geller  *  Oberlin, Ohio  *  415-317-1805
           Writer/Presenter * http://www.tomgeller.com
         articles, marketing, videos, user guides, books








-------------------------------------
Yes. I think one of the next things we need is a library that produces nice
and attractive PDFs of "wallet certificates" so it's easy to print out a
paper backup.

But the whole field of secure key escrow needs more research. Banking gives
people the very nice property that you can lose literally everything except
your face and still retain access to your money, so people feel very safe
with that. Matching that experience doesn't seem possible at the moment, so
being your own bank will continue to seem much riskier than just using a
real one.
On 8 Nov 2014 17:21, "Jeff Garzik" <jgarzik@bitpay.com> wrote:

-------------------------------------
And they can't just do

  NetworkParams.TESTNET = NetworkParams.REGTEST

at the start of a program that is connecting to regtest?

It's not like changing the address code is a huge problem or anything, but
it would disrupt a bunch of people and seems kind of annoying. Surely
there's a simpler way to work around this issue on their side? I mean their
code already has to know what network is *expected*, right, otherwise what
stops you accidentally trying to send coins cross chain?



On Tue, May 13, 2014 at 1:02 PM, Warren Togami Jr. <wtogami@gmail.com>wrote:

-------------------------------------
On Mon, Apr 7, 2014 at 12:00 PM, Tamas Blummer <tamas@bitsofproof.com> wrote:

A bitmap also means high overhead and— if it's used to advertise
non-contiguous blocks— poor locality, since blocks are fetched
sequentially.


-------------------------------------
On Tue, Jun 17, 2014 at 4:20 PM, Christophe Biocca
<christophe.biocca@gmail.com> wrote:

This. There is no need to create anything new when GBT already exists.
In my opinion.


Yep. As pools in general are not a part of the bitcoin protocol itself
(nobody cares how the work happened), I am not sure how this can be
forced.


Also, yep. If the miners cared about 51% attack, they wouldn't join
ghash in the first place. All the miners willingly accept the risk in
joining the big pool.

K. B.



-------------------------------------
On 04/28/2014 07:32 AM, Sergio Lerner wrote:

No, that's sortof tangential. What you are solving is some higher level
application on top of SPV proofs, compact or otherwise. SPV proofs have
many broad applications, such as 2-way pegs where proof-of-work is used
to reach consensus over the most-work side-chain header, and a non-51%
attack is detectable from observed difficulty and interblock times. Do
you need an honest peer to learn about the best chain? Yes. Do you need
to *trust* that you have an honest peer? No, because a non-51% attack
against you is probabilistically detectable with existing tools.

Maybe SmartSPV is useful, maybe not. The application domain is not
something I've been concerned with in the past. But what you describe is
a higher-level protocol that uses block headers to determine which chain
to trust. My simple point from the start has been that you can use
back-link commitments and compact SPV proofs to accomplish what you want
fewer messages, less bandwidth, and equal security. The two proposals
are not in conflict with each other.


-------------------------------------
On Thursday, October 02, 2014 12:05:15 AM Peter Todd wrote:

This sounds do-able, although it doesn't address using timestamps.


For many use cases, short maturity periods are just as appropriate IMO.

Luke


-------------------------------------
On Mon, Feb 24, 2014 at 3:06 PM, Andreas Petersson <andreas@petersson.at> wrote:

At least there is no ambiguity that such usage is abusive. Adoption of
the practices matters too. Right now I've seen a lot of people
promoting data storage as a virtuous use, and gearing up to directly
store data when a commitment would work.

If it turns out that encouraging people to use hashes is a lost cause
it can always be further relaxed in the future, going the other way is
much harder.


-------------------------------------
Transactions are already sitting in everyone's (or nearly everyone's)
mempools (because they get broadcast to get to a miner in the first
place). If you don't have it (because you just connected to the
network after stopping for a bit) you can just call getdata against
your peers to get a copy.

Not rebroadcasting the transactions as part of the blocks is already
in the cards because it's such an easy way to cut network traffic
nearly in half.

On Wed, Jan 22, 2014 at 5:10 PM, Jorge Timn <jtimon@monetize.io> wrote:


-------------------------------------
Excuse the ignorance, but there is something I’m not getting in this discussion.


Given it’s a published protocol, with available source code running on an open P2P network, why would any messages between nodes benefit from being encrypted? Surely all the data being processed by the network is known to any persistent client node(s)? 


Seems like that solution is orthogonal to the root problem, where attackers could monitor the network and deduce IP addresses by e.g. mapping senders of transactions.

  



From: Peter Todd
Sent: ‎Wednesday‎, ‎August‎ ‎20‎, ‎2014 ‎9‎:‎28‎ ‎AM
To: William Yager, bitcoin-development@lists.sourceforge.net





-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 19 August 2014 21:19:43 GMT-04:00, William Yager <will.yager@gmail.com> wrote:

Hence my suggestion of separating that surface by using the standalone Tor binary, which runs under a different user to the Bitcoin Core binary.


First of all, without encryption we're leaking significant amounts of information to any passive attacker trying to trace the origin of Bitcoin transactions, a significant privacy risk.

Secondly the upcoming v0.10's fee estimation implementation is quite vulnerable to Sybil attacks. Authentication and encryption are needed to make it secure from ISP-level targeting to ensure that your view of the network is representative. Tor support used in parallel with native connection is ideal here, as neither the Tor network nor your ISP alone can Sybil attack you. It's notable that Bitcoinj has already implemented Tor support for these same reasons.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJT8/mSMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhRZjCAC4PSpQ68qgtFMR77xf
zXZLr/iMKX6yyJwXRj+vGi+0Ng/sv9NlYjYnDeflom37WlpGo/sCOFcVWImhnS2d
kUFoUH92iXwRuEt/SN/LrHghkLWOxtVu9wa49eS/piGZFF3JWllk82MgdBZ6vjNw
B6WuInEIurK+h8rUbAi2HjFkxVN0K0SsrFt/P0tHj10ABcMealBRoJh2Jx7fLNdS
uTKddqeLyThEpLGNti3k+lhwQ2dA5RUBq6q3GUS/hWvTHRnU+viGMJSYv62LXRN5
t87BXRY/R9UBpnudf3TIlPtOuIWcv2LhlXVjvbDDQqwJkvB3Qf4ejE3RZ28S5IUr
OBQH
=Gy7X
-----END PGP SIGNATURE-----


------------------------------------------------------------------------------
Slashdot TV.  
Video for Nerds.  Stuff that matters.
http://tv.slashdot.org/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
On Tue, Jul 15, 2014 at 4:19 AM, Wladimir <laanwj@gmail.com> wrote:

There are major gaps that the payment protocol doesn't cover.

There are several deployed use cases where you are provided/request an
address, an API provides one, and one or more incoming payments arrive
as the user sends them over minutes/hours/days/weeks.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Speaking very generally, the Linux kernel wisdom on this tends to be,

* Compile in as many cheap, compiler-predictable asserts as possible
into the production runtime.
* Debug builds are of limited value.  Users do not recompile software,
just to provide better bug reports/diagnostics.
* Make it as easy as possible for users to send reports that are
useful to programmers.
* Expensive diagnostics are fine. Compile in, but disable by default
at runtime (and make sure these features, when turned off, do not slow
down the system).
* Make sure the assert/dump provides a high level of diagnostics.
Stack trace of each thread + multi-threaded core dump are a good
start.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
The output has to be burned  otherwise there is no cost of expressing
any number of alternate opinions the same time. 

Tamas Blummer
Bits of Proof

On Dec 15, 2014, at 3:55 PM, Isidor Zeuner <cryptocurrencies@quidecco.de> wrote:

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

bleep bloop

Peter Todd:

- -- 
http://abis.io ~
"a protocol concept to enable decentralization
and expansion of a giving economy, and a new social good"
https://keybase.io/odinn
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUkNluAAoJEGxwq/inSG8CKy0IAJmCUmDbaCx33/km0J2mP7ha
kxX3fxiPpicD8hXa4FXBsrYqj7ZFu0OmFOU/ei0AXMOuu94rQdIp6hon3f5GO73J
WVT2Toqd2GTCXhmddyqtOzZ5mYOyZhlJUYlNjbwTmlk+U2hQbZC1aJ4AKdmjQn5v
9DFkZfqBSsNhcoLCKoVqY3l4qzw0XqeL6fOYkz2H9AssWdcUV9JB5C0wm8rI70AX
qcxABgrKDwhThWgHyHGZXHLCvRRpMUFFVbzO67BPZA2R+gXYtOAVDozl7jdx7PLl
x3nyzZK3pX1bqcT2T5fD8wQtu4yJ3RCBVWzHfrA5MF6q4Yh6DEh7DnO8ccOnPlk=
=1os7
-----END PGP SIGNATURE-----


-------------------------------------
Hi Alex,

I think the problem is with my suggestion to use bind forwarding.. 
basically bind is stripping off the authorative answer bit in the 
reply.. this causes the recursor to go into a loop chasing the authority 
server which again returns a non-authoritve answer with itself as the 
authority again. I'm not sure if this can be fixed without hacking the 
bind src, so maybe it wasn't such a great suggestion in the first place. 
Basically I think if bind was returning authorative answers it would 
work, but I can't see any way to make that happen in the bind 
configuration.

Rob


On Fri, 30 May 2014 14:19:05 +0100, Alex Kotenko wrote:



-------------------------------------
On Sat, Jun 07, 2014 at 07:22:56PM +0800, Mike Hearn wrote:

As I explained in the email you're replying to and didn't quote, bloom
filters has O(n) cost per query, so sending different bloom filters to
different peers for privacy reasons costs the network significant disk
IO resources. If I were to actually implement it it'd look like a DoS
attack on the network.

Essentially with bloom filters you have to make a tradeoff between
scalability and privacy; with prefix filters you don't have to make that
ugly tradeoff. Notably that tradeoff gets worse if we ever increase the
Bitcoin blocksize.

-- 
'peter'[:-1]@petertodd.org
00000000000000003afb1fdf0867fc063775e69f9ae79870bb8727f25b49e88f
-------------------------------------
On Tue, Feb 11, 2014 at 01:00:21AM +0530, naman naman wrote:

That's basically what appears to have happened with Mt. Gox.

Preventing the attack is as simple as training your customer service
people to ask the customer if their wallet software shows a payment to a
specific address of a specific amount at some approximate time. Making
exact payment amounts unique - add a few satoshis - is a trivial if
slightly ugly way of making sure payments can be identified uniquely
over the phone. That the procedure at Mt. Gox let front-line customer
service reps manually send funds to customers without a proper
investigation of why the funds didn't arrive was a serious mistake on
their part.

Ultimately this is more of a social engineering attack than a technical
one, and a good example of why well-thought-out payment protocols are
helpful. Though the BIP70 payment protocol doesn't yet handle busines to
individual, or individual to indivudal, payments a future iteration can
and this kind of problem will be less of an issue.

Similarly stealth addresses have an inherent per-tx unique identifier,
the derived pubkey, which a UI might be able to take advantage of.

-- 
'peter'[:-1]@petertodd.org
0000000076654614e7bf72ac80d47c57bca12503989f4d602538d3cd7892ca7d
-------------------------------------
I think you're misunderstanding the point. The way you get IsStandard
changed is that you make an application-oriented BIP detailing the use
of some new standard transaction type (say, generalized hash-locked
transactions for atomic swaps). We then discuss that proposal for its
technical merits and reach consensus about the best way to do, for
example, cross-chain atomic swaps. It is then implemented.

So please, focus on some BIP(s) detailing applications of hash-locked
transactions, and we will engage more constructively -- I promise that I
will as cross-chain atomic swaps scratch my itch as well.

On 04/25/2014 01:48 PM, Tier Nolan wrote:


-------------------------------------
On 4/23/14, Mike Hearn <mike@plan99.net> wrote:

I thought the mechanism they used to prevent double-spends was proof of work.
Therefore dishonest miners where only those who mine on top of a block
which is not the longest valid chain they've seen.
To distinguish this definition from your own "honest miners are those
who decide on double-spends by mining the transaction they saw first"
definition I propose to give another new name to the later, instead of
changing the definition of the former.
So inside the group of honest miners we have some that decide on
transactions based on reception times and others that simply maximize
their revenue while respecting the protocol rules.
I suggest "stupid miners" and "smart miners" respectively as more
clear terms for what we're talking about here.


I completely disagree.
Miner's proof of work makes transactions irreversible. Even if zero
confirmation transactions weren't possible in a replace-by-fee
environment, that's very useful.
Even if you always had to wait for transactions to be confirmed with
some irreversible proof of work (as described in Satoshi's
whitepaper), it doesn't follow that "automatically resolves the
Bitcoin experiment as a failure". I don't understand how can you
conclude that.

But in fact 0 conf txs are possible *precisely* using replace-by-fee,
as described in the "
0 confirmation txs using replace-by-fee and game theory" thread. So
that conclusion is definitely wrong.

On your concrete proposal, it seems to me that you're trying to
prevent double-spending without relying on proof of work, which I
think it impossible in the context of a truly p2p system.
I don't think your current proposal is secure and I fear that at best
you will end up with an "invite only" transaction processing network
like Ripple.com has with their consensus algorithm and Unique Node
Lists: that's not really p2p.

-- 
Jorge Timn

http://freico.in/


-------------------------------------
Gregory Maxwell says : "Try paying a consultant if your ego demands that
you have a technical
expert to entertain your musing with immediate response."

I don't know why your resorting to such an adhominem. But I have already
said that you were the only one who responded. Your response was correct as
is reflected in the conversation on the forums. No doubting that. But it
does not address the full scope of the attack where a small pool would
intentionally (or out of whatever reason) make the hash invalid for the txs
they recieve. So that leaves a whole lot of businesses in the lurch who
have relied on txid (albeit wrongly that) for their tracking purposes.
Thats all I'm trying to say, without blaming anyone.

Hope it makes sense.


On Wed, Feb 12, 2014 at 2:19 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------
Does it make sense to implement a generic Policy interface (abstract
class) which StandardPolicy extends?

Maybe you can then implement a WhitelistPolicy,
ReplacebyFeeStandardPolicy, ReplacebyFeeWhitelistPolicy...

This would make it simpler for miners to implement their own policies
in general.
The following functions (maybe more) could become methods of Policy:

script IsStandard
main IsStandardTx
main AcceptToMemoryPool


-------------------------------------
On Fri, Jul 18, 2014 at 5:39 PM, Mike Hearn <mike@plan99.net> wrote:

Nothing really. If it's controversial in any way, I'm fine with
changing that. It's just one those things that nobody needs, nobody
uses, has never been standard, and shouldn't have been possible in the
first place IMHO. Given that, it's easier to just make it a consensus
rule.


I'm not comfortable with dropping OpenSSL-based signature parsing
until we have well-defined rules about which encodings are valid. At
this point I'm not even convinced we *know* about all possible ways to
modify signature encodings without invalidating them.

But perhaps we should investigate how many non-DER signatures still
make it into blocks first...

-- 
Pieter


-------------------------------------

BTW, I find it curious that any nodes have code to disconnect peers that
send Bloom filters. It shouldn't be necessary. Bitcoinj is the only large
scale user of filtering and it will disconnect itself if a peer advertises
support for a version lower than 70000. If a node advertises support for
this version or higher then it is supposed to implement BIP37.

It sounds like some node authors decided to advertise support for a
protocol version they didn't bother implementing, which would be a bug.
-------------------------------------
Jean-Pierre Rupp from Haskoin here.

I support a hard fork to fix consensus bugs.  The Bitcoin protocol should eventually get to a state where it is documented in a clear and understandable fashion.  Bugs are bugs, and are the enemy.  We should not attempt to live with them.  We should be opening a process of thoroughly documenting and reparing consensus bugs on a separate branch, and eventually schedule a hard fork.

There are two good things that will come out of that:

1. Known bugs will be gone, and
2. We will have a process in place to get rid of future bugs in eventual future hard forks.

We do not need to become paranoid about the ramifications of a hard fork, or how it will open the door for unwanted changes in the protocol.  We are discussing about removing bugs, and bugs that could be used to exploit the network in ways that may not be immediately obvious.

There are 144 blocks generated per day by groups of miners that are mostly identified.  It is not going to be a titanic task to get consensus from the main mining pools on fixing this at the mining level.  We must address how the fixes for some of these bugs affect other types of software such as wallets.  I can think that fixing the bug where OP_CHECKMULTISIG pops an extra value from the stash could be more traumatic, since it requires anything that creates and validates multi-signature transactions to change the way it works.  Hardware wallets could be impacted.  But most of the consensus bugs would not affect the way the vast majority of bitcoin transactions that are currently created.  Therefore it should not be traumatic at all for users, but only really affect mining pools, who would only need to be convinced to upgrade their bitcoind well in advance, which seems to me that it is not an issue at all.

We should not compare doing a Bitcoin hard-fork with doing something like deploying IPv6 world-wide or enforcing TLS and SPF on every SMTP connection.  We should not conflate Bitcoin with other network protocols.  The Bitcoin protocol is actually relatively easy to upgrade at this point.  Let's take advantage of this fact.

On 06/11/14 15:36, Justus Ranvier wrote:

-- 
Be Happy :)

-------------------------------------

Deterministic builds are one part of the equation. Matt Corallo actually
did implement auto-updating using gitian updater:
https://github.com/bitcoin/bitcoin/pull/1453

It ran into lots of bike shedding and was eventually abandoned, but there
is no question whether it is possible with the current build process.

Wladimir
-------------------------------------
On Fri, Nov 28, 2014 at 5:22 PM, Oliver Egginger <bitcoin@olivere.de> wrote:



This might be useful for you https://github.com/MatthewLM/cbitcoin
-------------------------------------

I don't think Twitter is an appropriate medium for discussing the details
of byzantine consensus algorithms.

I'm not going to bother arguing in replies to a blog post. Suffice it to
say, miners are already handsomely compensated via both inflation and fees
for doing their job of preventing double spends. Your suggestion is people
should pay them EVEN MORE for simply not being corrupt. My proposal is
simpler - how about we find the ones that are claiming people's money via
coinbases yet not doing their jobs correctly, and take the money back (or
destroy it). I think I prefer that one. Miners that are maliciously double
spending cannot justify their existence, they offer no useful service and
do not deserve compensation as a result.
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 06/24/2014 09:07 AM, Wladimir wrote:

I think btcd has done this right.

A wallet is a daemon that runs constantly in the background, just like
the full node.

The GUI (which is distinct from the wallet) runs as little as
possible. Presumably there's no need for a 1:1 relationship between
wallets and GUIs.


- -- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBAgAGBQJTqZpVAAoJEMP3uyY4RQ21E48H/0XNYBzR8QZjfku/MeL5IbwL
A56jrlWe2EZTabwfKdGx12L5oeBXe3DOeLsTizqIu0vijcl7qQryU49AjrVe91Rx
OdEi4lmaiXdkM3lWeWUxLoLLHR1B+1f8T18Mrnzo+yasyrywPb+6H79VN5KERdA2
5yHYCZyHXdNoXpzyf38GC2PdYJmAZdrRfAGyC5+OXSwE3XLhpRBrSBh/mrx0ct5M
ghkCKtsmJCJJ6sR2TbFxaj71kPp0J0tp8JVvjVEqC2uB4Ih0NY+79kz8L81TaNmw
ol1o6p7TypIk7QRQ4ES3Fq0ALh2aQ/tX4rc0GC0ed+xLi+dHJ2wGBI37HoyGIyg=
=Nn9X
-----END PGP SIGNATURE-----
-------------------------------------
Please excuse me. I had a more thorough look at the original problem and
found that the only problem with the original test case was that you
cannot specify codepoints from the SMP using \u in Java. I always tried
\u010400 but that doesn't work.

Here is a fix for bitcoinj. The test now passes.

https://github.com/bitcoinj/bitcoinj/pull/143

We can (and probably should) still need to filter control chars, I'll
have a look at that now again.


On 07/16/2014 11:06 PM, Aaron Voisine wrote:




-------------------------------------
On Tue, Jan 14, 2014 at 11:12:40AM -0800, Jeremy Spilman wrote:

Good catch, yeah, use the master shared secret to derive per-pubkey
secrets.


Well like I said, you shouldn't force the txout to be exactly a 2-of-2
multisig - the recipient might be using a multi-factor wallet for
instance. So, if I understand your code, what you want is the following:

byte[] Q = <payee root pubkeys>;
byte[] Q_Scan = <may or may not be provided in Q>
int m = <# of pubkeys required to redeem>;
byte[] S = EC.DH(e, Q_Scan);

byte[] qDerived[];
for (int = 0; i < len(Q); i++){
    qDerived[i] = EC.PointAdd(Q[i], Util.SingleSHA256(S || i));
}

// Best to have a single canonical order re: anonymity set.
qDerived = sorted(qDerived);

if (len(Q) > 1){
    stealthTx.Vout.Add(TxOut.PayToMultiSig(amount, m, len(Q), qDerived));
} else {
    stealthTx.Vout.Add(TxOut.PayToPubKeyHash(amount, qDerived[0]);
}
stealthTx.Vout.Add(TxOut.OpReturn(P));


Finally, it would probably be better if the multisig output was wrapped
in a P2SH output to better match the behavior of other wallets for the
sake of a bigger anonymity set - seems that stuff that is implementing
multifactor wallets and escrow is using P2SH to do it rather than bare
multisig. Also there's quite a bit of support for making bare multisig
not IsStandard() to discourage data-storage applications.

-- 
'peter'[:-1]@petertodd.org
00000000000000010c474cd4e25913535ec1c166b6d43fbdd9a5f2726711ced7
-------------------------------------
Peter I was curious if you could detail what specific concerns Adam Back 
brought up with the current iteration of the tree-chains idea? It's been 
alluded to a few times yet I have not read the specific problem.

Greg





-------------------------------------
On 30/04/14 00:13, Mike Hearn wrote:

I haven't seen anybody arguing that it is.

Bitcoin is the elegant embodiment of /artificially contrived/
mathematical rules, which just so happen to be very useful in their
current configuration :-P

Nobody is saying those rules are immutable. Just that it isn't sensible
to undermine them by introducing imprecise and unpredictable elements
like human politics.



No it isn't. That's the node enforcing the protocol. It isn't a matter
of opinion, and it isn't a vote. The protocol is clearly defined: you
either follow it or you're not running a Bitcoin node. If 51% don't
follow it tomorrow /they're/ not running Bitcoin.

Contrast with your "vote to reinterpret the meaning of arbitrary blocks"
mechaism - you're free to vote either way while remaining within the
protocol. That's a /real/ vote - majority decides what the Bitcoin
protocol /and every node that follows it/ will recognise as valid.
Nothing like that currently exists. Thank $deity.



-------------------------------------
On Thu, Oct 30, 2014 at 11:18 PM, Rusty Russell <rusty@rustcorp.com.au> wrote:

Irregularity is a required property for convergence. Imagine what
would happen in a network where a blocks were produced at an exact
interval: Almost everyone would produce one the exact same time, and
the network would fragment and because the process would continue it
would not converge. It is precisely the variance  being some huge
multiple of the network radius which allows the network to converge at
all.

When lower variance is tolerable for convergence it can be achieved by
reducing the expectation. Maybe some other distribution can be proven
to be convergent to, it's difficult to reason about.

Bitcoin testnet implements a rule that allows lower difficulty blocks
after a delay (20 minutes, in fact), but it's a testing-toy... not
secure or intended to be so. At least one altcoin has copied that
behavior and been exploited on account of it.

If you're simply looking for faster evidence that the network is
working on a particular transaction set, at some lower timescale:,
then thats already possible.  e.g. look into how the p2pool sharechain
builds a consensus around mining work used for pooling. The same
mechanism can be used to give faster transaction selection evidence.

I'll dig up some citations for you later. Cheers.


-------------------------------------

On Mar 12, 2014, at 6:11 AM, Pavol Rusnak <stick@gk2.sk> wrote:


Yes I am. There are some differences between BIP 39 and my proposal though. 

- BIP 39 offers an easy list of words, no gnarly string of case sensitive letters and numbers.
- BIP 39 only offers one fixed length of entropy, always 12 words, no option to increase or decrease the length.
- BIP 39 doesn't have a genesis date field, so no optimization during blockchain rescan.
- BIP 39 doesn't have password typo detection. No easy way to recover a password if you know most of it.
- BIP 39 does not have a user selectable KDF, only 2048 round PBKDF2-HMAC-SHA512. 
- BIP 39 can't outsource the KDF computation to a 3rd party.
- BIP 39 wallet implementors can use their own word lists, breaking cross wallet compatibility.


jp
-------------------------------------
On 1/31/2014 3:16 AM, Jeremy Spilman wrote:
My original message was focused on #1.  Not only #1, but ensuring the 
merchant can't act maliciously too.

As far as #2 is concerned, I don't think it makes any difference - it's 
in both the customer and the merchant's best interest to have the 
transactions confirmed.

...
What I meant was (and maybe this was roundabout?): the customer includes 
the UNsigned transactions as well as the hashes (and only the hashes) of 
the fully signed transactions.  The customer keeps the fully signed 
transactions private until the merchant ACKs the unsigned versions.  If 
the merchant has the hash of the fully signed transaction, he can 
monitor the network for delivery of the signed transaction.

It definitely complicates things, but it's nothing that can't be done.

Cheers,

Chuck


-------------------------------------
[...]

Miners might decide to block all burn transactions, and other nodes
might decide to stop relaying them. This may be considered as
preferable by all participants who do not want to add more potential
for deflation.

Best regards,

Isidor


-------------------------------------
I'm starting a thread on proposed changes on BIP70 based on my
experience in implementing the payment protocol in Bitcoin Wallet:

- certificate chain in pki_data: I think it should be required that is
most contain the first certificate PLUS all intermediate certificates
(if any), but NOT the root certificate. Reason: We want to be able to
verify offline.

- definition of timezone: Its not clear if times (e.g. expires) are in
UTC or local. I suggest to require UTC. If if we can't agree on this,
there should be a sentence about timezones in the spec.

(probably more to be added...)



-------------------------------------
On Mon, Jan 13, 2014 at 11:59 AM, Alan Reiner <etotheipi@gmail.com> wrote:
[...]

The stealth address stuff is the ECDH to create multiple payment
addresses without querying the payee.


Uh while I'm responding again, what I'd discussed with Peter Todd in
IRC used two EC points in the stealth address. One for the payment and
one for the ECDH.  The reason to use two is that it makes delegating
detection possible and so you don't have to have you spending keys
online to even detect these payments.  Why'd that get dropped?

I don't think this is a good idea if you have to constantly keep your
spending key(s) online even to detect payments, even with the limited
use-cases envisioned.


-------------------------------------
On Fri, Aug 8, 2014 at 1:38 PM, Mike Hearn <mike@plan99.net> wrote:

This diverges from the topic but seems like a good idea to me in
general, not so much as replacement for jgarzik's proposal.

Something like `getutxos` or this proposal could be implemented as an
external application or script, instead of having to integrate
everything into bitcoind.

Bitcoind would need a local interprocess message bus for that, and
would need to act as router for messages from/to the P2P network.
ZeroMQ seems like a good choice for that. That's not completely crazy
as there are already plans to add zeromq as an optional dependency for
notifications [1].

[1] https://github.com/bitcoin/bitcoin/pull/4594

Wladimir


-------------------------------------
On 04/07/2014 12:00 PM, Tamas Blummer wrote:

The point is that the node has decided not to prune transactions from
that block, so that it is capable of returning full blocks within that
range.


-------------------------------------
On Mon, Jun 2, 2014 at 10:01 PM, Toshi Morita <toshi@peernova.com> wrote:

Thanks for the report.

Which version/commit id of bitcoind?

Wladimir


-------------------------------------
This could probably be done fairly easily by bundling Stratum (it's
not just for pools!) and allowing SPV wallets to ask Bitcoind to start
it (if you don't use it, there's no need to waste the resources), and
then connect to it. The point of using Stratum is that it already is
being used by Electrum, and that it might be an easier way to support
SPV clients than creating a new API in bitcoind for it since Stratum
itself already relies on bitcoind to provide it's services.

On Wed, Apr 9, 2014 at 5:29 PM, Wladimir <laanwj@gmail.com> wrote:


-------------------------------------
Thanks for starting the discussion on finding a better structure.

For me, the most important thing is either we're 100% interoperable or
0%. There should not be anything inbetween, as users will delete seeds
without knowing there is still money in them on another implementation.
I heard from multiple sources that using this standard some wallets will
only see a subset of the addresses/keys of some other wallets.
Implementation differences can always happen (and should addresses as
bugs), but I think its unacceptable that this source of issues is by design.

I suggest we agree on an even simpler least common denominator and
wallets that want to implement some feature on top of that can do but
are encouraged to pick a totally different "cointype". I guess that
would mean removing reserved and account.

I'm still thinking it might be a good idea to have a separate chain for
"refunds". Refunds will be rarely used and thus need a much slower
moving window than receiving addresses or change.


On 03/26/2014 09:49 PM, Mike Hearn wrote:




-------------------------------------
Dear all,

thank you for your invaluable feedback. As requested, the spec
will from now on be under version control. It can be found under:

https://github.com/minium/Bitcoin-Spec

The old link to the PDF will be, just in case, kept updated as well.


Warm greetings,
Krzysztof Okupski
-------------------------------------
How is this different from the proposal I have made?

You distribute the root public key (but not chaincode!) of a BIP32
branch.  You can put your root key on a business card if you want.  Then
when someone wants to pay you, you simply give them the multiplier and
root key (they already have the root key, but should verify).  The
multiplier does not reveal the chaincode, thus keeping it private, but
it does allow them to confirm that the final address they are paying is
derived from that root key they know belongs to you ("Please pay address
X; oh btw, X=rootKey*mult").

You can /choose/ to reveal that a given payment address is linked to
your root key without any compromise of privacy.  Or you can choose to
ignore it and just give them a bare address the old way and still
maintain privacy.  What advantages does "stealth addresses" have over
this scheme?  You could extend it using some kind of deterministic
sub-branching and/or ECDH to create multiple payment addresses without
querying the payee. 

I had planned to implement this system and push for people to accept it
because I don't see any downsides to it.  It can easily be integrated
into a WoT (with signed root keys), or CA system piggybacking on SSL.

-Alan


On 01/13/2014 02:44 PM, Drak wrote:

-------------------------------------
On Thu, Mar 13, 2014 at 6:36 PM, Alan Reiner <etotheipi@gmail.com> wrote:


As default?

If so, only for new installs? Or will all current users automatically be
switched over?

Wladimir
-------------------------------------
On Tue, Jun 17, 2014 at 9:23 AM, Peter Todd <pete@petertodd.org> wrote:

Anyhow -- back to the original proposal. I'm fine with setting aside
part of the service bit space for experiments.

Wladimir


-------------------------------------
On Mon, Nov 03, 2014 at 06:01:46PM +0200, Alex Mizrahi wrote:

We are aware of the distintion between hardness (expected work) and
likelihood of successful attack -- much of Appendix B talks about this,
in the context of producing compact SPV proofs which are (a) hard to
forge, and (b) very unlikely to be forgeries.

We did spend some time formalizing this but due to space constraints
(and it being somewhat beside the point of the whitepaper beyond "we
believe it is possible to do"), we did not explore this in as great
depth as we'd have liked.
 

Well, even in the absense of a reorganization, the attacker's false proof
will just be invalidated by a proof of longer work on the real chain.
And there is still a real cost to producing the false proof.


-- 
Andrew Poelstra
Mathematics Department, University of Texas at Austin
Email: apoelstra at wpsoftware.net
Web:   http://www.wpsoftware.net/andrew

-------------------------------------
Given that the fee drop puts fees in "real" (i.e. dollar) terms back to
where they were some months ago, it seems odd to claim this is creating
vulnerabilities that didn't exist in the previous version. The cost of an
attack would be the same as before.
-------------------------------------
On Wednesday, October 01, 2014 1:08:26 PM Peter Todd wrote:

Thoughts on some way to have the stack item be incremented by the height at 
which the scriptPubKey was in a block? A limitation of encoding the target 
height/time directly, is that miners may choose not to mine the first 
transaction until they can also take the "burn to fee". So, one may prefer to 
say "cannot be spent until 100 blocks after the first transaction is mined", 
in effect reproducing the generation maturity rule.

I propose any stack item under 0x40000 be incremented by the height at which 
the scriptPubKey was mined for comparison. Maybe there is a use case for doing 
something similar for time too?

Luke


-------------------------------------
current block height onto the operand stack. Then you could implement
arbitrary logic about which blocks the transaction can be valid in. This
would require that the client revalidate all transactions in its mempool
(really, only those making use of this opcode) whenever the chain tip
changes.

I have to say I like this idea, this would allow someone to prove they
can't spend funds before a given date, and vice versa, prove that the funds
can't ever be spent after a given date (and this is provably prunable,
isn't it?). Of course, there are some risks associated with that, but
nobody is forced to use it.


This becomes increasingly expensive as the deadline is further away, so not
very hard to mitigate.


On Sat, Aug 2, 2014 at 1:36 AM, Tom Harding <tomh@thinlink.com> wrote:

-------------------------------------
* Abstract

A Stealth Address is a new type of Bitcoin address and related
scriptPubKey/transaction generation scheme that allowers payees to
publish a single, fixed, address that payors can send funds efficiently,
privately, reliably and non-interactively. Payors do not learn what
other payments have been made to the stealth address, and third-parties
learn nothing at all. (both subject to an adjustable anonymity set)


* Acknowledgments

Credit goes to ByteCoin for the original idea.(1) Gregory Maxwell, Adam
Back, and others on #bitcoin-wizards contributed valuable input on the
implementation. Finally thanks goes to Amir Taaki for input on the
general idea of stealth addresses and use-cases.


* Background

Viewed generally a Bitcoin address is a mechanism by which a payee
instructs a payor to create a transaction such that the payee can spend
one or more of the transaction outputs. Of course, typically the address
is simply the hash of a pubkey, and the mechanism by which the funds are
made available to the payee is to simply create a scriptPubKey of the
following form:

    DUP HASH160 <pubKeyHash> EQUALVERIFY CHECKSIG

The problem however is address reuse: it is convenient for payees to
give one or more payor a single address and use it multiple times for
various purposes. This results in all those payments becoming trivially
linkable to each other by an attacker - a threat not only to the privacy
of the user, but also to all users of Bitcoin.(2)

BIP32 hierarchical deterministic wallets are frequently proposed as a
solution. Now an address is a chain code and the mechanism by which a
scriptPubKey is generated is to derive a one-time-use pubkey from that
chain code and some index i. However, this quickly runs into two main
problems:

1) Lack of privacy: While someone not in possession of the address can't
   link payments together, someone who is can.

2) State: If the index is not to be re-used wallets must either maintain
   per-address state, or somehow query for already used indexes, or
   somehow generate them in a sufficiently small range that the payee
   can recover the indexes. All these solutions are problematic.

A good example of where the BIP32-derivation solutions fails come up at
the Dark Wallet Hackathon where it was suggested by the author that for
the purpose of securing person-to-person payments OpenPGP public keys
and X.509 certificates be extended with a new user-id field containing a
Bitcoin address. Wallet software could then use either certificate
system to ensure funds were being sent to the intended recipients -
essentially a non-interactive way of solving what the BIP70 payment
protocol solves interactively. Of course, without stealth addresses the
scheme would likely have little or no privacy.


* Requirements

1) Generated scriptPubKey must be globally unique

2) Must be only spendable by payee

3) scriptPubKey and associated transaction must be indistinguishable to
   third-parties from other transactions in some anonymity set.

4) Method must be fully deterministic and funds recoverable from a
   wallet seed and blockchain data for both payee and payor.

5) Funds must be efficiently recoverable by payee with reasonable, and
   configurable, computation and bandwidth costs.

6) Must be compatible with CoinJoin/Must not leak information to payee
   about what txins were used to pay them.

7) Must be compatible with multisig-protected wallets.

8) Must not make assumptions about txin scriptSig form.

9) Must be possible to prove to third parties that payment was made in
   accordance to instructions without revealing any other information.


** Payment Reliability

Schemes for making payments by transmitting nonces to the recipient
through some other medium, such as Bitmessage, were discussed at the
Dark Wallet Hackathon. However using any medium but the blockchain
itself for the communication means that the reliability of the payment
getting to the recipient is less than that of a standard transaction.
For instance Bitmessage nodes only keep messages for two weeks. We
decided that anything less than reliable atomic transactions was
unacceptable.


* Applying encryption to payments, simple explanation

Using Elliptic curve Diffie-Hellman (ECDH) we can generate a shared
secret that the payee can use to recover their funds. Let the payee have
keypair Q=dG. The payor generates nonce keypair P=eG and uses ECDH to
arrive at shared secret c=H(eQ)=H(dP). This secret could be used to
derive a ECC secret key, and from that a scriptPubKey, however that
would allow both payor and payee the ability to spend the funds. So
instead we use BIP32-style derivation to create Q'=(Q+c)G and associated
scriptPubKey.

As for the nonce keypair, that is included in the transaction in an
additional zero-valued output:

    RETURN <P>

The payee recovers the funds by scanning the blockchain for candiate P's
in transactions, regenerating the scriptPubKey, and finally checking if
any txouts in the transactions match. Note the close similarity of this
technique to how the Bitmessage network functions - an initial
implementation of the idea will find the Bitmessage code a suitable
starting point.


* Trading off anonymity set size for decreased bandwidth/CPU

By taking advantage of prefix filters(3) we can choose a tradeoff
between anonymity set size and bandwidth/CPU usage if the payee
specifies that payments to them are to match some short prefix k. There
are a few possibilities for how the prefix is to the applied - the most
simple is if per-block indexes of scriptPubKeys are available:

    RETURN <k> <P>

Alternatively if per-block indexes of H(scriptPubKeys) are only
available the wallet software can grind the scriptPubKey with nonce i
until it matches the specified prefix:

    RETURN <i> <P>

Furthermore as symmetric ciphers are quite cheap we might as well hide
the purpose of the OP_RETURN txout and encrypt the pubkey P using H(Q)
as a symmetric key. This gives us a slightly larger anonymity set.


* Advantages of using a separate output

An alternative would be to either re-use a pubkey or signature nonce
value from a transaction input, saving about 45 bytes per txout. An
absolute minimum sized Bitcoin transaction is 166 bytes(4) so at best we
have a 27% savings in tx fees, and more typically around ~15%. (modulo
mass-payments from a single txin)

However using an explicit prunable OP_RETURN output to store the pubkey
rather than re-using one from a txin or txin signature has a number of
advantages:

1) The txin's owned by the payor are not revealed to the payee. In fact,
   they could be held by a third-party who simply makes a transaction
   with the appropriate txouts on behalf of the payee.

2) Less information about the txouts is leaked. The statistical
   distribution of txouts remains unchanged - not possible in re-use
   schemes because they need to grind the payee scriptPubKey's for the
   sake of the prefix filters.

3) If required the nonce secret can be revealed to prove that a payment
   was made to a third-party, e.g. for dispute resolution.


* Bare CHECK(MULTI)SIG output alternative

An alternative with better efficiency could be to use bare
OP_CHECK(MULTI)SIG outputs to hold the nonce pubkey - generally a second
output is needed anyway for change. The most simple would be to use Jeff
Garzik's OP_DROP proposal(5) for the prefix:

  <prefix> DROP n <pubkey>...<pubkey> m CHECKMULTISIG

  or

  <prefix> DROP <pubkey> CHECKSIG

The payor pubkey is in the *change* txout, and the payee's ECDH-derived
pubkey in the other txout. By setting the prefix to be the same on both
txouts and using the same basic scriptPubKey form the relationship of
change and payment is still hidden; CoinJoin-using implementations can
adopt even more sophisticated approaches.

If IsStandard() rules remain the same and using OP_DROP is impractical,
we can also grind the change pubkey to match the prefix in a
deterministic manner so the wallet can still be recovered from a seed.
More costly, but maybe still acceptable for reasonably short prefixes.
Either way the result is transactions that are actually smaller and
cheaper than standard transactions, although without the advantage of
pushing scriptPubKey size payment to the receiver. (a pity we didn't
spend the extra time to adopt OP_EVAL)

A disadvantage is that revealing the nonce secret to prove a payment was
made is more problematic - either the txout needs to be spent first, or
we need a CHECKMULTISIG.


* Address format

To be decided. To support mulisig we probably want the ability to
specify n-of-m master pubkeys, using the nonce to generate derived ones.
For the single pubkey case the addresses will be a little longer than
standard Bitcoin addresses:

  s9KND3vfXjs3YqfZp86Acce3bM7Mhuptwh6mjeDnThsDei9Z2ZZcU

  vs.

  1LZn91ynrA6BCmoUKwnV3Ygk4FQMfPxLbg


1) ByteCoin, Untraceable transactions which can contain a secure message
   are inevitable, https://bitcointalk.org/index.php?topic=5965.0

2) Gregory Maxwell, Dark Wallet Certification discussions, also
   http://snowdenandthefuture.info/PartIII.html

3) Peter Todd, [Bitcoin-development] Privacy and blockchain data,
   http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03612.html

4) Bitcoin Wiki, Maximum transaction rate,
   https://en.bitcoin.it/w/index.php?title=Maximum_transaction_rate&oldid=36983

5) Jeff Garzik, Add small-data OP_DROP transactions as standard
   transactions, https://github.com/bitcoin/bitcoin/pull/1809

-- 
'peter'[:-1]@petertodd.org
0000000000000002861ee0919fc86990573ac360820766dc1b9ba580e5ccf7b6
-------------------------------------
On Thursday, August 07, 2014 11:02:21 PM Pedro Worcel wrote:

This is old news; both BFGMiner and Eloipool were hardened against it a long 
time ago (although no Bitcoin pools have deployed it so far). I'm not aware of 
any actual case of it being used against Bitcoin, though - the target has 
always been scamcoins.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

We have BIP70 already in use (over a hundred paid requests).

Could you elaborate on why this needs changing?



On 28-04-14 14:39, Gavin Andresen wrote:
"Accelerate Dev Cycles with Automated Cross-Browser Testing - For FREE
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQEcBAEBAgAGBQJTX9bcAAoJELhWickZBkAlKqcH/RVFAr6vGgDjJvYah46StMHy
ZhKwpV1oqFCslOts6MyO+bZp9uDRlmYtnAy02CTPmlico3IyK85/+CGCGEdyiGo1
AEI2Ixr5FJs9t8uAVLyUKwOQddUFEJuZuiKXd1Wl9GqfG/z8gwdSxd08Wrq57lSH
JdwUnWOG1xBwyhgm7stqFoXgTrrnFNcE97vwsk6QMIzJG/v0suw7Lp42q7bKYaA/
J9xWSQ1cRKSPdsmu4K45oxXriqUmiqz3EouaTSQqC80OO7y8sfa96DqiHR83Vy3w
KUna5enjGqhhberWCokg3x5lCiH/IfLPrgK23iib4cg6Vm70jSQ2S2Xh/NuoDaM=
=JA5K
-----END PGP SIGNATURE-----


-------------------------------------
* the general cost of any network-wide change, versus P2SH which is
already analyzed by devs, rolled out and working
* the cost of updating everybody to relay this new transaction type,
whereas P2SH Just Works already
fair -- I think that there may be a big benefit realizable with this kind
of system.

* cost of increasing rate of UTXO growth versus P2SH
This operation is similar in cost to multisig? Although I suppose there is
the proposal to make all multisigs p2sh

* the cost of P2SH output is predictable, versus less predictable outputs
 * "default public", versus P2SH's "default private"
-- Can you elaborate on these?

I think part of the problem is that there is low incentive for
development/cataloging  of these useful types of script because there isn't
a horizon on getting them broadcastable by nodes other than testnet? Even
with pay to script hash it is still currently relegated to a subset of
script types iirc (I think I'm wrong on this one maybe (hopefully) -- if
so, let's get writing!)?



Hmm... another idea... what about doing a p2sh with a switch statement, ie:

OP_HASH160 <script set hash> OP_EQUAL

payable by:

{signatures...} <scriptX> <<script1 hash>, <script2 hash>...<scriptN hash>
in sorted order> OP_DUP

And then executed like a normal p2sh transaction except before the
<scriptX> is run, the set of hashes is checked for set membership (can't
find a concise way to express this, but it should be doable within the
current framework of p2sh processing).

Which lets you select one of n scripts each 520 bytes long without bloating
the utxo pool more than a p2sh, the cost being purely on disk.

In theory, this could represent a space savings on disk longterm for
regular p2sh. ie, if I have two 2 of 3 groups I want to be able to spend,
this system would represent an overall space savings.


Adding some kind of "function-hash-pointer jump table / switch statement"
could be pretty cool in terms of space savings as well as allowing for more
complicated scripts to be built.



On Thu, Jul 17, 2014 at 2:21 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:




-- 
Jeremy Rubin
-------------------------------------
The problem is if someone moves system time forward between app launches.
The lockout period doesn't have to be all that precise, it just makes you
wait for the next block, then 5, then 25, and so on. Using a well
known time server over https would also be a good option, but the wallet
app already has the chain height anyway.

On Friday, July 25, 2014, Mike Hearn <mike@plan99.net> wrote:


-- 

Aaron Voisine
breadwallet.com
-------------------------------------
It applies to OP, bitcoin community development and Satoshi.

"value of in person vetting of identity is undeniable"...  no it is
quite deniable. Satoshi is the quintessential example. We value brain
output, code.  The real world identity is irrelevant to whether or not
bitcoin continues to function.

The currency of bitcoin development is code, and electronic messages
describing cryptographic theses.  _That_ is the relevant fingerprint.

Governmental id is second class, can be forged or simply present a
different individual from that who is online.  PGP WoT wanking does
not solve that problem at all.






On Mon, Sep 15, 2014 at 9:32 AM, Brian Hoffman <brianchoffman@gmail.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
A quick update on the state of transaction malleability work in
Bitcoind/Bitcoin-Qt (aka Bitcoin Core). This is not about longer-term
malleability issues, just the very short-term work being done (or already
done) to the reference implementation.

First, the problems:

We've had a longstanding TODO to improve the way the core code deals with
double-spends. From the core code's point of view, malleable transactions
are just one particular form of double-spend.

Improving double-spend handling never made it to the top of the TODO list,
because the cases where it happened involved doing unsupported things (like
copying your wallet.dat to another machine and then spending on both
machines).

And because there is a heavy-handed workaround if a wallet becomes confused
because of a double-spend:  restore all of the keys, rescan for
transactions confirmed in the blockchain, and any outputs tied up in
double-spends get released. Coins (really, unspent transaction outputs)
were never permanently lost, but they could be tied up and unspendable when
associated with a 0-confirmation transaction that would never confirm.

So, work in progress or done:

https://github.com/bitcoin/bitcoin/pull/3659
https://github.com/bitcoin/bitcoin/pull/3674

These implements a kinder, gentler sledgehammer (-zapwallettxes) to fix a
confused wallet. If you have a wallet with 0-confirmation transactions that
are tying up bitcoins these should fix it.


https://github.com/bitcoin/bitcoin/pull/3651
https://github.com/bitcoin/bitcoin/pull/3657
https://github.com/bitcoin/bitcoin/pull/3676

These three merged pull requests implement a new command-line option:
-nospendzeroconfchange .  The best way to get a wallet confused is to spend
zero-confirmation change outputs that you created yourself; if the
transaction creating the change gets mutated, then the subsequent
transaction is invalid and will never confirm.

The core code spends unconfirmed change only as a last resort. If you are a
service using bitcoind that generates a lot of transactions then best
practice would be to run with -nospendzeroconfchange, and use "sendmany" to
batch payments only after previous payments have confirmed.

https://github.com/bitcoin/bitcoin/pull/3025

This tightens up the IsStandard() rule, so the easiest-to-implement method
of mutating transactions is blocked. Many big mining pools are already
running this patch.

https://github.com/bitcoin/bitcoin/pull/3669
https://github.com/bitcoin/bitcoin/pull/3671
https://github.com/bitcoin/bitcoin/pull/3694

These three get at the root of the problem; they rework the core wallet
code to implement "handle double spends better."  See the pull requests for
details.

How can you help:

Testing and code review is, as always, the bottleneck for getting out a
release with these changes.

We have a chronic problem with people running Bitcoin services on top of
the core code waiting until there is an "official" release, and then
assuming that somebody else has done the hard work of reviewing and testing
the changes.

YOU SHOULD NOT BE MAKING THAT ASSUMPTION!  Your particular RPC call usage
might trigger some edge-case bug that was missed, or perhaps the size of
your wallet triggers a performance problem introduced by a fix.

Or, in other words: do not treat the core development team as if we were a
commercial company that sold you a software library. That is not how open
source works; if you are making a profit using the software, you are
expected to help develop, debug, test, and review it.

-- 
--
Gavin Andresen
-------------------------------------
On Mon, Dec 29, 2014 at 7:21 PM, Sergio Lerner
<sergiolerner@certimix.com> wrote:


If the motivation is purely enabling different rules in a soft-fork
than I think nothing needs to be done.

Instead of providing inputs to a coinbase: you provide an unusual
anyone can spend transaction in the block which pays to fees; and
simultaneously add a soft-forking rule that makes that anyone can
spend rule no longer anyone can spend.

To make that more concrete.  E.g. You make your anyone can spend
output   "PUSH<hash of coinbase output script_pubkeys> OP_NOP3".  Now
this anyone can pay transaction is really just a coinbase input.

The construction is reasonably efficient, and also more flexible-- in
that it could control the data under the hash in more flexible ways
than available in the existing sighash flags.


As an aside, I'm not sure that I agree with the claim that making
coinbases have inputs is a simple modification... as we use one of the
inputs already as the special coinbase field and at least that must be
special cased.


-------------------------------------
Sounds great.  I'm glad to see this with a more active maintainer.
Maintaining -three- client libs was a bit much for me.

On Sat, Mar 15, 2014 at 9:43 AM, Peter Todd <pete@petertodd.org> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On Sun, May 04, 2014 at 05:26:06PM +0200, Mike Hearn wrote:

The purpose of the proposal is to change the protocol spec, not to
ignore it.

The argument for the proposal is explained in the Rationale section, and
in abstracted form means precisely to make everybody follow the protocol
spec by reducing incentives to ignore it. Specifically, it is about
protecting the timestamp field. 

I talked about relative costs involved in hashing, and how those will
change, and what incentives that creates. This development cannot be
ignored.


Why does it require 32 bits?


Again, this is a BIP. I am proposing a software upgrade, which is
absolutely required. When I said that version 3 is not required I meant
that the software upgrade (which basically just turns the nonce into a
short) does not have to be accompanied by a new version number for any
technical reason. Is there another reason why it should be incremented?


-- 
Timo Hanke
PGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8


-------------------------------------
Hello,

This is primarily aimed at developers of SPV wallets.

The recently reported decrease in number of full nodes could have several
reasons, one of them that less people are running Bitcoin Core for the
wallet because the other wallets are getting ahead in both features and
useability.

It's great to see innovation in wallets, but it's worrying that the number
of full nodes decreases.

It may be that lots of people would support the network by running a full
node, but don't want to go through the trouble of installing bitcoin core
separately (and get confused because it's a wallet, too).

Hence I'd like to explore the idea of adding an option to popular SPV
wallets, to spin a bitcoind process in the background. This could be pretty
much transparent to the user - it would sync in the background, the wallet
could show statistics about the node, but is not dependent on it.

In exchange the user would get increased (full node level) security, as the
SPV wallet would have a local trusted node.

Does this sound like a good idea?

Is there any way that Bitcoin Core can help to accomedate this 'embedded'
usage? Specific Interfaces, special builds - maybe add a walletless
bitcoind build to gitian - bindings, dlls, etc?

Wladimir
-------------------------------------
On Thu, Nov 06, 2014 at 04:48:54PM -0600, Justus Ranvier wrote:

For the same reason we don't do hard-forking upgrades of basically every
protocol on the planet on a regular basis, even when we don't have
consensus problems to worry about.

Flag days are really rare in engineering, and for good reason.

-- 
'peter'[:-1]@petertodd.org
000000000000000008f2290924a6882928d4566f487f33cc57203a6535795201
-------------------------------------
On 20 December 2014 at 14:48, Peter Todd <pete@petertodd.org> wrote:

Well while you cant prevent it you could render it insecure enabling
miners to take funds.

That could work via a one-show signature; normal ECDSA being address
a=H(Q), public key Q=dG, R=kG, r=R.x, s=(H(m)+rd)/k, signature (r,s),
verify: a=?H(Q) and sR=?H(m)G+rQ one-show being: a=H(Q,R), verify
being: a=?H(Q,R) and sR=?H(m)G+rQ.  Now that is unsafe to double-spend
by design as only that specific R is usable and as we know reusing R
with different messages leaks the private key because: s=(H(m)+rd)/k
and s'=(H(m')+rd)/k implies sk=H(m)+rd and s'k=H(m')+rd so
k=(H(m)-H(m'))/(s'-s), and d=(sk-H(m))/r.

Adam


-------------------------------------
On Thu, Nov 27, 2014 at 2:22 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

In my experience the problem has always been getting bootstrapped.
Most nodes hardly give any hidden service nodes in their getaddr.
(this has been improved in master by including a set of hidden service
seed nodes)
But this assumes -onlynet=tor. Tor with exit nodes should be less
problematic, unless someone managed to DoSban all the exit nodes as
described in the paper (but I've never seen such an attack myself).


Right, there's something to be said for splitting your own transaction
submission from normal P2P networking and transaction relay.
(esp for non-SPV wallets which don't inherently leak any information
about their addresses)

There was a pull request about this for Bitcoin Core one, maybe I
closed it unfairly https://github.com/bitcoin/bitcoin/issues/4564 .

Wladimir


-------------------------------------
On Wed, Apr 16, 2014 at 10:45 AM, Melvin Carvalho
<melvincarvalho@gmail.com>wrote:


Probably - but that's a very rare edge case. People that are security
conscious enough to buy a Trezor will not run XP. Also I don't dare to say
that there is not some way to sociaal-engineer the user with malware on a
compromised OS even with a trezor.

Maybe: for 0.9.2 add a warning message and push people to upgrade (either
to Win8.1 or something else), then in the next major release 0.10.0 drop XP
support completely.

Wladimir
-------------------------------------
I think Mark makes some good arguments.
I realize this would only add to the confusion, but...
What if we did relabel 100 satoshis to be some new kind of unit ("bit" or
whatever else), with a proper 3 letter code, and then from a user
standpoint, where people are using mBTC, they could switch to using Kbits
(ok thats obviously bad, but you get the idea) at the same nominal price.
 But accounting backends and so forth would operate in the "bit" base unit
with 2 decimals of precision.




On Fri, Mar 14, 2014 at 12:01 PM, Mark Friedenbach <mark@monetize.io> wrote:

-------------------------------------
On Tue, Mar 11, 2014 at 7:43 AM, Drak <drak@zikula.org> wrote:

It also assumes a reality different from our current one.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On Fri, Apr 25, 2014 at 1:14 PM, Peter Todd <pete@petertodd.org> wrote:

I think the hash-locked transactions are very useful, and I think
Peter agrees (no?)

But I agree with him that that for the oracle case the EC public
points are superior. (Also: Reality keys works like this.)


-------------------------------------
Sorry, perhaps I misinterpreted that question.  The estimates will be
dominated by the prevailing transaction rates initially, so the estimates
you get for something like "what is the least I can pay and still be 90%
sure I get confirmed in 20 blocks"  won't be insane, but they will still be
way too conservative.  I'm not sure what you meant by reasonable.  You
won't get the "correct" answer of something significantly less than 40k
sat/kB for quite some time.  Given that the half-life of the decay is 2.5
days, then within a couple of days.  And in fact even in the steady state,
the new code will still return a much higher rate than the existing code,
say 10k sat/kB instead of 1k sat/kB, but that's just a result of the
sorting the existing code does and the fact that no one places transactions
with that small fee.   To correctly give such low answers, the new code
will require that those super low feerate transactions are occurring
frequently enough, but the bar for enough datapoints in a feerate bucket is
pretty low, an average of 1 tx per block.  The bar can be made lower at the
expense of a bit of noisiness in the answers, for instance for priorities I
had to make the bar significantly lower because there are so many fewer
transactions confirmed because of priorities.  I'm certainly open to tuning
some of these variables.





On Tue, Oct 28, 2014 at 10:30 AM, Alex Morcos <morcos@gmail.com> wrote:

-------------------------------------
On Fri, Aug 22, 2014 at 09:20:11PM +0200, xor wrote:


This is why I clone git to mercurial, which is generally designed around the
assumption that history is immutable. You can't rewrite blockchain history,
and we should not be re-writing (rebasing) commit history either.

The problem with github is it's too tempting to look at the *web page*, which 
is NOT pgp-signed, and hit the 'approve' button when you might have someone
in the middle approving an unsigned changeset because you're in a hurry to
get the latest new critical OpenSSL 0day security patch build released.

We need multiple redundant 'master' repositories run by different people in
different jurisdictions that get updated on different schedules, and have all
of these people pay attention to operational security, and not just outsource
it all to github because it's convenient.


There's no reason to *stop* using github, cause it *is* easy... but you want
to have multiple review of *the actual code*, not just signatures and see 
if the changes really do make sense.

-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
On Thu, Jul 31, 2014 at 6:06 PM, Peter Todd <pete@petertodd.org> wrote:

I think this would be compatible with most uses of nLockTime -- e.g.,
at the time a refund transaction becomes broadcastable, its
beneficiary would usually have no reason to wait for a long time
before broadcasting it; if they did so (probably because they weren't
online to redeem the refund), they'd need to use the
submit-directly-to-miner option, but they wouldn't lose their refund.


Perpetuating transactions that have been in mempools for a long time
and are not being confirmed has been cited as a reason for nodes not
to exchange mempools (#3721, #1833, #3722); it's been implied that it
would be desirable for wallets to wait until a transaction had had a
chance to be accepted before double-spending with a higher fee
(#3722); and an unconfirmed transaction-age-based policy for
preventing mempool accumulation has been advocated (#3753, #3722) [I
hope my summarization is not misrepresenting anyone's opinions here;
please see the arguments made in the actual comments on the bugs].
These discussions are mostly fairly old, but I don't know of any
changes that have been made that provide alternative answers to these
concerns mentioned by at least three different developers.


That's true, but none of the benefits of these changes require the
policy to be unanimous; most of the effect could be provided by most
of the network following these rules.


Yes, that is a feature. None of the benefits of transaction expiration
rely on expiration being final, and any possible downsides of
expiration are largely mitigated by the option still being available
to get expired transactions mined.


-------------------------------------
I had a long discussion recently with somebody who wants and has resources
to do exactly this - paper currency representing bitcoins. Yet we've been
thinking mostly about a centralized solution, where one party is producing
and maintaining paper currency, with bitcoins tied to each note verifiable
via blockchain.

The points we've ended up is that it needs to be:
- reloadable
- NFC based
So anybody can verify any notes instantly by just touching it with his
phone, and so merchants could redeem the notes at the moment of accepting
it, convert it into fully online bitcoins and avoid costs of maintaining
paper money turnover. Probably merchant would sell back redeemed
empty notes to the issuer for a price of the note issue, and issuer will
recharge it and put back into circulation.

One problem we couldn't figure out here though - how to protect the notes
from unauthorized redeem. Like if someone else tries to reach your wallet
with his own NFC - how can we distinguish between deliberate redeem by
owner and fraudulent redeem by anybody else with custom built long
range NFC antenna? Any ideas?


Best regards,
Alex Kotenko


2014-05-17 17:40 GMT+01:00 Gregory Maxwell <gmaxwell@gmail.com>:

-------------------------------------
I updated again.

The new version only requires non-standard transactions on one of the two
networks.

Next step is a simple TCP / RPC server that will implement the protocol to
trade between testnet and mainnet.  Timeouts of much less than 24 hours
should be possible now.


On Wed, Apr 30, 2014 at 9:48 PM, Tier Nolan <tier.nolan@gmail.com> wrote:

-------------------------------------
I'm very pleased that my old idea is getting some traction and that I have been appropriately credited!
I also think the term "reusable addresses" is preferable to anything to do with "stealth" for the reasons mentioned.

You should note that the privacy guarantees they provide are not that strong but their limitations have been adequately discussed elsewhere.

On an unrelated note - I'd like to solicit some help in restoring access to my Bytecoin account on http://bitcointalk.org/

Cheers!

Bytecoin
-------------------------------------
On Thursday, 31 July 2014, at 7:28 pm, Gregory Maxwell wrote:

I understand what you're saying, but I don't understand why it's a problem. Transactions shouldn't be considered "final" until a reasonable number of confirmations anyway, so the possibility that an "accepted" transaction could become invalid due to a chain reorganization is not a new danger. Ordinary transactions can similarly become invalid due to chain reorganizations, due to inputs already having been spent in the new branch.


-------------------------------------
Message encoding and length (or terminator or checksum or error correction or...) should be part of the transport protocol, in my humble opinion.

--
Gavin Andresen


-------------------------------------
Interesting analysis! I think there are a few important effects that aren't
being considered.

1. When the block reward is halved, inflation is halved as well. Is this
halving already priced in by the market or will it result in an upward
pressure on the price?

2. It was acknowledged that the referenced analysis did not take into
account the result of a double-spend attack on the bitcoin price. However,
the effect of a detectable double-spend attack on the Bitcoin network is
not isolated to Bitcoin markets. The price of altcoins often trend with the
price of Bitcoin, so attacking Bitcoin may reduce the profitability of
'multipool' mining. Any alt-coin market vulnerable to the malicious
hash-power would probably go into panic mode.

-Alex Leishman




On Sat Oct 25 2014 at 1:51:10 PM Alex Mizrahi <alex.mizrahi@gmail.com>
wrote:

-------------------------------------
On Thu, May 15, 2014 at 7:50 AM, Andreas Schildbach
<andreas@schildbach.de> wrote:

While I agree that the problem seeds should be fixed, it also sounds
like a problem with bitcoinj / other layers, if a malfunctioning seed
is a problem for your app.

Seeds are fundamentally a backup for peer exchange.  You are going to
run into problems if you rely 100% on seeds, always.

Further, there are multiple seeds so that we are not impacted if a
couple seeds malfunction or die.  All bitcoin apps must take this into
account.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Ok, wanting structured data is a decent argument, but why this random arbitrary case in particular? There are hundreds of fields like this that people might want to use. 

If we're going to support one random cosmetic field, we might as well support them all with a generic structured data format. 

I'd rather we just didn't have this essentially pointless "feature" at all. Let's try and keep as much cruft as possible out of the payment protocol. The textual memo field is already more than sufficient. 

-------------------------------------
On Wed, Jun 4, 2014 at 8:37 AM, Wladimir <laanwj@gmail.com> wrote:

Almost forgot to mention: new translations from Transifex,

Much thanks to everyone who submitted translations there as well (I
don't have a list handy right now)!

Wladimir


-------------------------------------
On Tue, Aug 19, 2014 at 8:14 PM, Peter Todd <pete@petertodd.org> wrote:


I'm not. I don't think this proposal is even good.


Again, the NSA might get an absolutely trivial amount of data from
monitoring connections on the Bitcoin network. A bit of publicity is *not*
worth drastically increasing the software complexity of the client.




Enabling hidden service support by default would introduce an insanely huge
attack surface.

And you're conflating two different things; using Tor is valuable to
Bitcoin because it would provide some anonymity. The encryption aspect is
pretty much useless for us.
-------------------------------------
On Wed, Apr 23, 2014 at 10:43 PM, Pavol Rusnak <stick@gk2.sk> wrote:

Would you consider software which scans all accounts as specified by
BIP64, but has no user interface option to distinguish them in any
way, view them independently, and has no ability to keep the coins
apart... compatible with BIP64?

According to the argument here mentioned earlier ("all or nothing"),
it is, as it will not break interoperability with other BIP64
software. Still, it doesn't support the accounts feature, and perhaps
that's fine?

-- 
Pieter


-------------------------------------
<cynic hat: on>

Every volatility bump messes up expectations of what a bitcoin is worth,
so why are we bikeshedding uBTC vs mBTC? Just be done with it and do mBTC
now, and plan uBTC for just after the next price spike to $10KUSD or whatever, 
and then plan on rolling back to mBTC when the price crashes from altcoin
money supply inflation competition.


On Thu, Mar 13, 2014 at 09:45:54AM -0400, Jeff Garzik wrote:

-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
I generally agree, but I wonder how popular cloning wallets between devices
will be in future. Right now if someone wants to have a wallet shared
between Hive, blockchain.info and Bitcoin Wallet for Android, we just tell
them they're out of luck and they need to pick one, or split their funds up
manually.

But probably a lot of people would like to use different UI's to access the
same wallets. Sharing key trees is a part of that, though full blown wallet
metadata sync would also be needed.

So I guess we're going to end up with some kind of fairly complex
compatibility matrix. But I agree it may be unavoidable.
-------------------------------------
On 4/24/14, Mike Hearn <mike@plan99.net> wrote:

I'm not saying proof of work is the goal, the goal is still p2p
transaction serialization.
And that's achieved through proof of work, not through "miner's honesty".


Whatever, let's keep calling stupid miners "honest miners", smart
miners "dishonest-by-replace-by fee miners" and miners that do replace
by fee and also hash on top of old blocks "utterly dishonest miners".


Maybe Satoshi hadn't thought in depth about replace-by-fee when he
wrote the code.
Why should we care?
If nSequence was a design mistake Satoshi did, should we maintain it
to somehow honor him?
Maybe the payment protocol shouldn't have been developed because he
had some weird ideas about paying to ips? Maybe we shouldn't write any
tests because he didn't do so?
This persistent argument from authority is annoying.


It is not a protocol rule that validators can use to discriminate the
longest valid chain and therefore is not enforceable. Not even through
a softfork because miners can't know which transactions other miners
saw first.
So if it is a protocol rule, I think it shouldn't be.


Miners that mine on top of the longest valid chain are helping in
making transactions irreversible whether they implement a first-saw or
a replace-by-fee policy.


That's not what I'm saying. Miners that don't mine on top of the
longest chain are dishonest by my own definition as well.
You want to equate replace-by-fee "dishonesty" with
trying-to-rewrite-history dishonesty by saying that the transactions
that "have been seen" in the network are already history and that's
where we disagree. I think only what's in the chain is history and I
also think that's the whole point of proof of work.
And I also disagree that all the people who think this way are
"hopelessly confused". We may be confused, but I think there's always
hope for removing confusions provided that there's will to learn,
which I think it is at least my case.


This is in fact quite polemic and thus obviously not obvious.
Bitcoin works because rewriting the chain gets exponentially more
expensive as time passes.


I see now that I may have not properly expressed myself in the earlier
post since you clearly misunderstood what I meant by "smart miners".
By that I mean miners implementing replace-by-fee and
child-pays-for-parent policies Not miners trying to rewrite history,
which I agree is about as smart as mining on top of orphan blocks.


-------------------------------------
On Monday, 7 April 2014, at 5:38 pm, Gregory Maxwell wrote:

That only *decodes* Base58Check. It has no encode function, which would require biginteger division.


-------------------------------------
Ah, BIP32 allows for a range of entropy sizes and it so happens that they
picked 256 bits instead of 128 bits.

I'd have thought that there is a right answer for this. 2^128 should not be
brute forceable, and longer sizes have a cost in terms of making the seeds
harder to write down on paper. So should this be a degree of freedom?


On Thu, Mar 27, 2014 at 1:28 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
On 28 Jul 2014, at 14:46 , Mike Hearn <mike@plan99.net> wrote:


I referred to your idea in https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04076.html which is indeed not the proposal itself.


Ill rephrase what I intended to say. In your proposal two signatures need to be computed over the payment request data, one with the key related to the X.509 certificate (for backwards compatibility) and one with the ECDSA public key. On my proposal only one signature needs to be computed over the payment request data using the former key, the same way it happens now.

Indeed there is another signature, which is to authenticate the payment delegation. If you take it into account in the signature count, then your proposal has three signatures.

/Mark
-------------------------------------
Bitcoin Core version 0.9.2 is now available from:

  https://bitcoin.org/bin/0.9.2/

(or https://bitcoin.org/en/download)

This is a new minor version release, bringing mostly bug fixes and some minor
improvements. OpenSSL has been updated because of a security issue
(CVE-2014-0224).
Upgrading to this release is recommended.

Please report bugs using the issue tracker at github:

  https://github.com/bitcoin/bitcoin/issues

Upgrading and downgrading
==========================

How to Upgrade
--------------

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the
installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or
bitcoind/bitcoin-qt (on Linux).

If you are upgrading from version 0.7.2 or earlier, the first time you run
0.9.0 your blockchain files will be re-indexed, which will take anywhere from
30 minutes to several hours, depending on the speed of your machine.

Downgrading warnings
--------------------

The 'chainstate' for this release is not always compatible with previous
releases, so if you run 0.9.x and then decide to switch back to a
0.8.x release you might get a blockchain validation error when starting the
old release (due to 'pruned outputs' being omitted from the index of
unspent transaction outputs).

Running the old release with the -reindex option will rebuild the chainstate
data structures and correct the problem.

Also, the first time you run a 0.8.x release on a 0.9 wallet it will rescan
the blockchain for missing spent coins, which will take a long time (tens
of minutes on a typical machine).

Important changes
==================

Gitian OSX build
-----------------

The deterministic build system that was already used for Windows and Linux
builds is now used for OSX as well. Although the resulting executables have
been tested quite a bit, there could be possible regressions. Be sure to report
these on the Github bug tracker mentioned above.

Compatibility of Linux build
-----------------------------

For Linux we now build against Qt 4.6, and filter the symbols for
libstdc++ and glibc.
This brings back compatibility with

- Debian 6+ / Tails
- Ubuntu 10.04
- CentOS 6.5

0.9.2 Release notes
=======================

The OpenSSL dependency in the gitian builds has been upgraded to
1.0.1h because of CVE-2014-0224.

RPC:
- Add `getwalletinfo`, `getblockchaininfo` and `getnetworkinfo` calls
(will replace hodge-podge `getinfo` at some point)
- Add a `relayfee` field to `getnetworkinfo`
- Fix RPC related shutdown hangs and leaks
- Always show syncnode in `getpeerinfo`
- `sendrawtransaction`: report the reject code and reason, and make it
possible to re-send transactions that are already in the mempool
- `getmininginfo` show right genproclimit

Command-line options:
- Fix `-printblocktree` output
- Show error message if ReadConfigFile fails

Block-chain handling and storage:
- Fix for GetBlockValue() after block 13,440,000 (BIP42)
- Upgrade leveldb to 1.17

Protocol and network code:
- Per-peer block download tracking and stalled download detection
- Add new DNS seed from bitnodes.io
- Prevent socket leak in ThreadSocketHandler and correct some proxy
related socket leaks
- Use pnode->nLastRecv as sync score (was the wrong way around)

Wallet:
- Make GetAvailableCredit run GetHash() only once per transaction
(performance improvement)
- Lower paytxfee warning threshold from 0.25 BTC to 0.01 BTC
- Fix importwallet nTimeFirstKey (trigger necessary rescans)
- Log BerkeleyDB version at startup
- CWallet init fix

Build system:
- Add OSX build descriptors to gitian
- Fix explicit --disable-qt-dbus
- Don't require db_cxx.h when compiling with wallet disabled and GUI enabled
- Improve missing boost error reporting
- Upgrade miniupnpc version to 1.9
- gitian-linux: --enable-glibc-back-compat for binary compatibility
with old distributions
- gitian: don't export any symbols from executable
- gitian: build against Qt 4.6
- devtools: add script to check symbols from Linux gitian executables
- Remove build-time no-IPv6 setting

GUI:
- Fix various coin control visual issues
- Show number of in/out connections in debug console
- Show weeks as well as years behind for long timespans behind
- Enable and disable the Show and Remove buttons for requested
payments history based on whether any entry is selected.
- Show also value for options overridden on command line in options dialog
- Fill in label from address book also for URIs
- Fixes feel when resizing the last column on tables (issue #2862)
- Fix ESC in disablewallet mode
- Add expert section to wallet tab in optionsdialog
- Do proper boost::path conversion (fixes unicode in datadir)
- Only override -datadir if different from the default (fixes -datadir
in config file)
- Show rescan progress at start-up
- Show importwallet progress
- Get required locks upfront in polling functions (avoids hanging on locks)
- Catch Windows shutdown events while client is running
- Optionally add third party links to transaction context menu
- Check for !pixmap() before trying to export QR code (avoids crashes
when no QR code could be generated)
- Fix "Start bitcoin on system login"

Miscellaneous:

- Replace non-threadsafe C functions (gmtime, strerror and setlocale)
- Add missing cs_main and wallet locks
- Avoid exception at startup when system locale not recognized
- Changed bitrpc.py's raw_input to getpass for passwords to conceal
characters during command line input
- devtools: add a script to fetch and postprocess translations

Credits
--------

Thanks to everyone who contributed to this release:

- Addy Yeow
- Altoidnerd
- Andrea D'Amore
- Andreas Schildbach
- Bardi Harborow
- Brandon Dahler
- Bryan Bishop
- Chris Beams
- Christian von Roques
- Cory Fields
- Cozz Lovan
- daniel
- Daniel Newton
- David A. Harding
- ditto-b
- duanemoody
- Eric S. Bullington
- Fabian Raetz
- Gavin Andresen
- Gregory Maxwell
- gubatron
- Haakon Nilsen
- harry
- Hector Jusforgues
- Isidoro Ghezzi
- Jeff Garzik
- Johnathan Corgan
- jtimon
- Kamil Domanski
- langerhans
- Luke Dashjr
- Manuel Araoz
- Mark Friedenbach
- Matt Corallo
- Matthew Bogosian
- Meeh
- Michael Ford
- Michagogo
- Mikael Wikman
- Mike Hearn
- olalonde
- paveljanik
- peryaudo
- Philip Kaufmann
- philsong
- Pieter Wuille
- R E Broadley
- richierichrawr
- Rune K. Svendsen
- rxl
- shshshsh
- Simon de la Rouviere
- Stuart Cardall
- super3
- Telepatheic
- Thomas Zander
- Torstein Husebø
- Warren Togami
- Wladimir J. van der Laan
- Yoichi Hirai


-------------------------------------
+1 for the new field, overloading fields with new meaning is definitely not
a good idea.

Something like nExpireAt with a block height sounds reasonable to me, but
we need to document that the usual caveats with blockchain reorgs apply.


On Wed, Aug 6, 2014 at 4:08 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
Andreas Schildbach <andreas <at> schildbach.de> writes:
 



Agreed, supports_instant is redundant and can/should/will go.

trusted_instant_providers on the other hand I think is needed.

Sometimes the providers will charge fees for instant.

While the software can ignore the fields, 
users may not want to pay for instant when the merchant may not accept it or 
care (even if it would not break the protocol it would still be a waste of 
fees)

Does it make sense? 

Not all transactions from GreenAddress provide double spend protection, there 
are additional checks on prevout that are normally not done when spending 
normally, etc



-------------------------------------
I think you Peter & Jeremy figured it out - dont disagree with the
explanation details.

And it seems better explained between the two posts than I did.  I think
Peter is right that you do not need an explicit prefix, the prefix after
decryption can be a chosen number of leading 0s and this gives a tunable
amount of false positives.  You already have privacy becaue the query is
only revealed to the semi-trusted full node, and its query scope is limited
to one or a chosen batch of blocks.  But you can if desired add additional
ambiguity as Peter described by reducing the number of bits of 0 in the
decrypted block.  There is no need for matching a specific prefix as its
already a recipient specific calculation.  (It means the actual encrypted
value where it is chosen would have to mimic false positives: random with
n-bits of trailing 0s and expected probability distribution).

It should be compatible for combining with sharding or public prefixes, as
Peter mentioned but for short public prefixes those still has some (reduced)
blockchain ledger logged possibility to reduce anonymity set when combined
with flow analysis.

Maybe you could vary a public prefix per block.  Eg the public prefix for a
given user is the LSBits of the per block IBE derived pubic key for a given
user.  I am not sure if that helps or hinders.  Maybe it hurts anonymity set
because the analyst (Eve) is given multiple chances over time to exclude an
analysed flow candidate.

It would desirable to find a non-IBE way to do this.  (And more
computationally efficient / precomputable / indexable)

Or you could use different address types depending on the circumstance:
one-use, stealth, or IBE.  Kind of difficult to automate that (to know what
the user is planning to do with it) and avoid user confusion.  Clearly users
are quite confused and the convenient and understandable thing is to have a
(safely) reusable address.

Adam

On Sun, Feb 02, 2014 at 07:26:10AM -0500, Peter Todd wrote:




-------------------------------------
I'm afraid I'm going to be the jerk that requested more details and then
only nitpicks seemingly minor points in your introduction. But its
because I need more time to digest the contents of your proposal. Until
then:


This isn't true. The re-org issue is fairly handled in the 2-way pegging
scheme that Greg Maxwell developed and Adam Back described a week ago on
this list. Depending on the implementation it could even be configurable
by the person performing the peg too - allowing the transfer to specify
the confirmation depth required during the quieting period in order to
protect against re-orgs up to a sufficient depth. I think this is worked
out quite well with sufficient enumeration of edge cases, and I don't
think they are particularly tricky to handle or lead to money-losing
situations under the explicit security assumptions.

More importantly, to your last point there is absolutely no way this
scheme can lead to inflation. The worst that could happen is theft of
coins willingly put into the pegging pool. But in no way is it possible
to inflate the coin supply.

I will look at your proposal in more depth. But I also think you should
give 2-way pegging a fair shake as pegging to side chains and private
accounting servers may eliminate the need.


-------------------------------------
I believe this is self-explainatory:

1) Bitcoin usually runs on port 8333. Why?

2) Bitcoin does not show in up http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml .. why?

3) What needs to happen to have someone from the Bitcoin foundation 
  to fill out the form asking for an assigned port (see 
  http://www.iana.org/form/ports-services )

4) what should the process be for new cryptocoins to get both default
port numbers, as well as P2P network identifier 'magic numbers'


-------------------------------------
A number of people - most recently Gavin Andresen - have speculated that
cloud hashing operations may in fact be ponzi schemes that don't
actually own the hashing power they claim to own. The claim is that the
customers upfront purchase of hashing power is simply kept and used to
pay off existing customer profits rather than actually being used to
purchase mining equipment.

We can use merkle sum trees to detect this fraud cryptographically:

1) Put the MH/s paid for by each account into a merkle sum tree, each
with a customer supplied unique identifier. (like their email address)
This allows the customer to verify that the hashing power they paid for
has been included in the total hashing power claimed.

2) Mark blocks found by the operation publicly so they can be associated
with the specific cloud mining operation; putting the merkle sum tree
root hash into the coinbase or an OP_RETURN output would be ideal. This
allows anyone to verify that the hashing power claimed corresponds to
the # of blocks actually found.

-- 
'peter'[:-1]@petertodd.org
0000000000000000201d505432d708aa2edb656f6fe34d686b37d4747e5ff389
-------------------------------------
On Tuesday, 17 June 2014, at 9:57 am, Wladimir wrote:

Why use textual strings? These fields are not for human consumption. Why not use UUIDs, which are fixed length and will not waste as much bandwidth in the protocol? Or if you'd prefer a hierarchical namespace, you could use OIDs, a la ASN.1.


-------------------------------------

Correct. Still, a high number of nodes has a few other benefits:

1) The more nodes there are, the cheaper it should be to run each one,
given that the bandwidth and CPU for serving the chain will be spread over
more people.

2) It makes Bitcoin *seem* bigger, more robust and more decentralised,
because there are more people uniting to run it. So there's a psychological
benefit.

Also, we don't have a good way to measure capacity vs demand at the moment.
Whether we have enough capacity is rather a shot in the dark right now.



Which is why I'm interested to learn the reason behind the drop. Is it
insufficient interest, or is running a node too painful?

For this purpose I'd like to exclude people running Bitcoin Core on laptops
or non-dedicated desktops. I don't think full nodes will ever make sense
for consumer wallets again, and I see the bleeding off of those people as
natural and expected (as Satoshi did). But if someone feels it's too hard
to run on a cheap server then that'd concern me.




It would be good to explain the difference, but I suspect your definition
of "well reachable" excludes people running Core at home. From the diurnal
cycle we see in Addy's graphs it's clear some nodes are being shut down
when people go to bed. So if we have 6000 nodes on servers and 2000 at
home, then I'd expect Addy's graphs and yours to slowly come into alignment
as people give up using Core as a consumer wallet.
-------------------------------------
I've had these same questions myself. I'm happy to write up some documentation this afternoon. I can draft something based on this thread. What other key terminology should be included?



-------------------------------------
It's also not necessary for wallet software - it's really just for
human consumption.

A wallet can easily detect inputs being respent in another
transaction. You don't need a static hash for that (which wouldn't
need with all hash types, non-malleability double spends, ...).

On Wed, Feb 12, 2014 at 6:13 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:


-------------------------------------
Luke Dashjr <luke@dashjr.org> writes:

I normally just lurk, but I looked at this issue last year, so thought
I'd chime in.  I never finished my paper though...

In the event of an *anticipated* weakening of SHA256, a gradual
transition is possible which avoids massive financial disruption.

My scheme used a similar solve-SHA256-then-solve-SHA3 (requiring an
extra nonce for the SHA3), with the difficulty of SHA256 ramping down
and SHA3 ramping up over the transition (eg for a 1 year transition,
start with 25/26 SHA2 and 1/26 SHA3).

The hard part is to estimate what the SHA3 difficulty should be over
time.  My solution was to adjust only the SHA3 target on every *second*
difficulty change (otherwise assume that SHA2 and SHA3 have equally
changed rate and adjust targets on both).

This works reasonably well even if the initial SHA3 difficulty is way
off, and also if SHA2 breaks completely halfway through the transition.

I can provide more details if anyone is interested.

Cheers,
Rusty.


-------------------------------------
On Wed, Feb 12, 2014 at 08:34:48AM -0800, Dan Carter wrote:

You're assuming the seller cares about fairness - why should they? They
offered a price for an asset and someone bought it; exactly which buyer
willing to buy at that price was able to complete the trade is
irrelevant to them. What they do care about is being sure that at
whatever given price they offered 100% of the buyers willing to buy at
that price actually see the offer in a reasonable amount of time - at
the best price the seller will get there will be only a single buyer
after all so you need that solid proof that said buyer was actually able
to get the offer.

-- 
'peter'[:-1]@petertodd.org
0000000000000000c34e2307bf2d8e1de9db0351acfe7320a08826a5de3c146a
-------------------------------------
On Wednesday, October 15, 2014 8:47:18 AM Wladimir wrote:

ACK


ACK


ACK


ACK


ACK


ACK


Shouldn't we be doing this in a GitHub PR rather than spamming up the ML?

Luke


-------------------------------------
On Thu, Apr 10, 2014 at 1:37 PM, Mike Hearn <mike@plan99.net> wrote:


Well with bitcoin, (average) time, number of blocks and (maximum) size are
all related to each other so it doesn't matter how it is specified, it's
always possible to give estimates of all three.

As for implementation it indeed makes most sense to work with block ranges.



This assumes that nodes will always be storing the latest blocks. For
dynamic nodes that take part in the consensus this makes sense.

Just wondering: Would there be a use for a [static] node that, say, always
serves only the first 100000 blocks? Or, even, a static range like block
100000 - 200000?

Wladimir
-------------------------------------
So I like static address name too.  In the write up for my variant I called
it something less sexy than stealth "unlinkable public address":

https://bitcointalk.org/index.php?topic=317835.msg4103530#msg4103530

(there are 3 variants that are approximately the same thing).

Maybe we could call it an unlinkable static address.  Otherwise static
addresses are maybe too synonymous with reused addresses a bad practice we
have been complaining about users and wallet authors incorrectly doing.

But to explain, in Peter Todds (and Amir Taaki also?) variant stealth refers
to an actual useful security criteria.  Stealth objective actually means
"looks like a normal bitcoin payment to the outside observer".  You
generally want that to be the case for fungibility reasons.  Its like
browser cookie state, the more things that are unusual about your
transaction, the more your transactions identify you in the public
block-chain.  Statistics are cumulative so it matters.


And is an actual element of stealthiness (hence the name) in this variant
that Peter Todd proposed, at least as an objective, though I think the
stealthiness somewhat fails because the P parameter is extra and not present
in a normal transaction.

Unfortunately so far removing P and using an input in its stead breaks
CoinJoin which is also necessary for fungibility.  Maybe there is another
way to make an extended CoinJoin that can mix inputs and unlinkable static
addresses.


I was meaning to comment on the SPV privacy properties.

For full-node use these unlinkable static addresses have quite nice
properties.  It also nicely solves the problem of having to educate users
and wallet authors to not reuse addresses.  But for SPV nodes they have no
direct-way to find the payments.  So then in Peter Todd's variant (maybe it
was suggested by Greg Maxwell?) there is a second address so that the SPV
client can delegate detection to a full node without giving it the private
key allowing it to spend!  (This is something analogous to bloom filtering). 
But I think its moderately expensive for the full node because it has to do
a DH calculation per transaction and its not precomputable so there is IO
per query.  (In the P version in fact only payments which are thereby
reconizable as unlinkable static need to be processed).

Then an artificial prefix is proposed to constrain the query to a subset,
however that leaks to everyone so in some wayts its a worse privacy leak
than bloom filtering.  It can be used to rule out recipients and could be
quite a powerful extra lever for statistical analysis.  (And also there is
proposed a version of the prefix computed via brute-force to make it
somewhat stealthy still).


So I also am quite enthusiastic about the possiblity to fix this address
reuse problem, but there remain a few open problems in my view, for SPV
uses.  Not nay-saying, I spent quite a bit of time trying to solve this for
my variant, its a tricky problem, or basically we wouldnt have one-use
addresses and bloom filtering.


But maybe its intereting enough already for full-node uses.  Many processors
and businesses are full nodes.  Many power users run full-nodes  The data
isnt lost, you just need to scan a full-node.

It could help the related problem of paying the wrong person.  Ie deposit
address given by merchant.  If the deposit address is static, and the used
address user derived from it, then that itself is an assurance to the user
that they are paying an address at least owned by the service.  (As opposed
to someone who hacked the web site or MITM the link).  Of course for users
probably the main likelihood is they have malware on their machine, but that
is what offline wallets are for.  A smartphone is maybe a little less
hackable and could be trained to store the static address and warn if its
not the same as the last time they used the site.  (TOFU for bitcoin
addresses, or at least be able to call someone you know who also uses the
service and compare static addresses).

Maybe in the payment address case the service should choose the derivation
factor and communicate it and the client with the static address, as
suggeste by Alan Reiner because then it can also serve the function of
allowing the service to tie the payment to the users account.

People also mention payment protocol for certifying addresses however I
think it is useful to have address level TOFU / static to principal
verification because it is simpler for harware wallets, maps to account
number concept users understand, and doesnt rely on the CA infrastructure. 
Also the typical payment protcol is talking about a message constructed by a
web app.  Thats millions of lines of web server, script language, db code
etc in play on an online server.  The static address private key would be
airgapped from that mess.  

Mike Hearn proposed if I understand that you could something analogous and
upload in batches signed payment protocol sub-messages from a different CA
certificate key.  But I think the above is simpler, and its useful to have
something that works at the low level.  What we have now is like SSH without
the knownhosts cache.  Lets add it.  It can then play with the payment
protocol at the address level.

Adam

On Wed, Jan 15, 2014 at 03:44:17PM -0500, Jeff Garzik wrote:





-------------------------------------
Hmm, r1, r2 etc is actually interesting. It takes less chars then array
(yes, array brackets have to be escaped) and provides unlimited number of
options, uniformed approach and priority definition. I'd say that is the
way to go. Any objections?
On 1 Jul 2014 16:39, "Andreas Schildbach" <andreas@schildbach.de> wrote:

-------------------------------------
On Mon, May 19, 2014 at 11:26 AM, Bjørn Øivind Bjørnsen
<bo.bjornsen@gmail.com> wrote:

There is already an (old) patch that implements that. It won't be
merged, though, until headers-first and parallel block download is in.
Only when the node can download blocks from multiple peers at once it
is really safe to allow limiting rates.

(sure - there are tricks to limit rates anyway, like the script in
contrib/qos, but to have it generally available the block download
needs to be more robust first)

Wladimir


-------------------------------------
Hi Andreas


I'm implementing support for BIP70 in my POS at the moment, and I've just
realized that with options you're proposing usecase I'm looking for is not
covered.

Right now, before BIP70, I'm sending BIP21 URI via NFC or QR code, and I
need to still be able to use it for backwards compatibility. But at the
same time I want to be able to support BIP70. And also I want to avoid
using external servers, the concept of my POS is that everything is
happening between just payer's phone and payee's POS device. This means
that BIP72 HTTP(S) link inside Bitcoin URI is not suitable for me.

You're also offering an option to include Base43 encoded PR body right
inside the Bitcoin URI, but in a way that is not backwards compatible with
BIP21.

In the end this all means that there is no way for me to at the same time
keep backwards compatibility with all wallets not supporting NFC and BIP70
(all other wallets right now), and keep things inside POS without need for
external servers.

I understand your intention behind base43 encoding and noncompatible URI -
you want to make most possible use of QR codes. But I wonder - did you
compare this base43 to base64 encoded request in a binary QR code format?
How much do we actually win in total bytes capacity at a price of
noncompatibility and increased complexity?

And also maybe we can extend BIP72 to include encoded payment request in
the URL directly in a backwards compatible way?


Best regards,
Alex Kotenko


2014-03-02 11:50 GMT+00:00 Mike Hearn <mike@plan99.net>:

-------------------------------------
I like the proposal.

I suggest that applications and nodes should only broadcast transactions
having OP_CHECKLOCKTIMEVERIFY a few blocks after the timeout value.
If a node broadcasts a TX having OP_CHECKLOCKTIMEVERIFY and nLockTime is
equal to the current height and equal to the timeout value, but that
peer is one block behind in the blockchain, the transaction will be
rejected by the peer and the source will be banned.

Another option will be not to ban peers sending transactions failing to
verify OP_CHECKLOCKTIMEVERIFY , but I don't like this.

Still another option would be that the sender checks periodically the
height of it's peers (using the version command) in order to be sure to
send the transaction having OP_CHECKLOCKTIMEVERIFY only to the peers
that are up to date with the blockchain.

Regards,
 Sergio.





-------------------------------------
On 04/23/2014 10:09 PM, Luke-Jr wrote:

I think one of the following is happening:

a) you have not read the document
b) you don't understand what accounts are, because you have not read
   the document
c) you don't understand how restoring accounts work, because you
   have not read the document
d) you don't understand that accounts funds are not meant to be mixed
   together, because you have not read the document
e) I got your emails wrong because I am not a native speaker,
   but please read the the document ;-)

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
It's not limited to HTTP. I was pointing out that unsolicited
merchant-to-consumer messages don't work on HTTP (and a lot of other
situations), and so you can't add a need for it to the payment
protocol (since it wouldn't be usable in the majority of cases).

On Mon, Feb 3, 2014 at 3:30 PM, Tim Tuxworth Founder Go-taxi.biz
<tim@go-taxi.biz> wrote:


-------------------------------------
A border router that is not able to serve blocks is still protecting consensus rules, that SPVs do not.
If the network would only consist of SPV nodes only then e.g. a majority coalition of miner could increase their reward at will.

Archives need a different solution.

Regards,

Tamas Blummer
http://bitsofproof.com

On 09.04.2014, at 17:47, Mark Friedenbach <mark@monetize.io> wrote:


-------------------------------------
Some users on bitcointalk[0] would like to have their vanity addresses
available for others easily to find and verify the ownership over a kind
of WoT. Right now they sign their own addresses and quote them in the
forums.
As I pointed out there already the centralized storage in the forums is
not secury anyhow and signed messages could be swapped easily with the
next hack of the forums.

Is that use case taken care of in any plans already?

I thought about abusing pgp keyservers but that would suit for single
vanity addresses only.
It seems webfinger could be part of a solution where servers of a
business can tell and proof you if a specific address is owned by them.

[0] https://bitcointalk.org/index.php?topic=502538
[1] https://bitcointalk.org/index.php?topic=505095

-------------------------------------
Dear everyone,

I've developed a C++ wrapper for JSON-RPC communication with
an existing Bitcoin installation. For everyone that is a developer and
interested in building extensions or alike, this might prove useful.

The code can be found on GitHub:
-> https://github.com/minium/bitcoin-api-cpp

Warm greetings,
Krzysztof



-------------------------------------
I rather prefer to start with SPV and upgrade to full node, if desired.

Tamas Blummer
http://bitsofproof.com

On 07.04.2014, at 19:40, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
Related:  We must handle some legitimate miner-privately-mined cases,
such as miner payout TXs (outside coinbase) or side chain conditional
TXs[1].

[1] https://bitcointalk.org/index.php?topic=676703.msg7682680#msg7682680

On Fri, Jul 18, 2014 at 3:51 PM, Kaz Wesley <keziahw@gmail.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On 09/23/2014 11:12 PM, Mem Wallet wrote:

I don't know what criticism it was, but I feel that another BIP than
BIP44 should be created to describe which HD paths should be used for ECIES.


That looks great! I already implemented Electrum's way of ECIES into
TREZOR firmware, but yours version seems much more complete, so I am
inclined to throw it away and use your implementation.

Have you thought about pushing this as a new BIP (different one than I
mention above)? I think it's important to have it reviewed and
standardized ASAP.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
On Mon, Jan 13, 2014 at 02:59:08PM -0500, Alan Reiner wrote:

Basically stealth addresses *are* your scheme, using the blockchain as a
low or even no overhead communication channel for the payor to give the
payee that multiplier without bidirectional communication.

In the business card example I can't easily take your business card and
just send you some money without that transaction being linked to public
information. (your business card)


WoT is a perfect example of the problem: if you put BIP32 branch payment
info into my OpenPGP key I can't pay you securely and reliably without
making the transaction public. The best I can do is pick a nonce and pay
X=rootKey*nonce, communicating to you the nonce later - this isn't
reliable because if I or you lose the nonce the funds are lost.

With stealth addresses the user experience can be as simple as you
telling me on the phone "hey! send me that 0.234 BTC you owe me!", me
clicking on "Send to Alan Reiner (verified by PGP)" (perhaps again on my
off-line second factor device for a multi-sig wallet) and tellling you
"OK, sent".

Even if your phone has been wiretapped, the attacker still didn't learn
exactly what transaction was actually used to make the payment - a big
advantage over per-tx nonce stuff.

-- 
'peter'[:-1]@petertodd.org
00000000000000023d5a8bbe131414328a6c50a2741933ba03775afd3c3db395
-------------------------------------
Something like that would be a great help for SPV clients that can't
detect double spends on their own. (still limited of course to sybil
attack concerns)

Aaron Voisine
breadwallet.com


On Thu, Sep 25, 2014 at 7:07 PM, Matt Whitlock <bip@mattwhitlock.name> wrote:


-------------------------------------
On Mon, Apr 7, 2014 at 2:19 PM, Jameson Lopp <jameson.lopp@gmail.com> wrote:

In my opinion, the number of full nodes doesn't matter (as long as
it's enough to satisfy demand by other nodes).

What matters is how hard it is to run one. If someone is interesting
in verifying that nobody is cheating on the network, can they, and can
they without significant investment? Whether they actually will
depends also no how interesting the currency and its digital transfers
are.


My own network crawler (which feeds my DNS seeder) hasn't seen any
significant drop that I remember, but I don't have actual logs. It's
seeing around 6000 "well reachable nodes" currently, which is the
highest number I've ever seen (though it's been around 6000 for quite
a while now).

-- 
Pieter


-------------------------------------
On Thu, Apr 3, 2014 at 8:41 PM, kjj <bitcoin-devel@jerviss.org> wrote:

In my opinion you can have whatever style you want on the BIPs, so
long as you pledge to slay all who come and complain about the new
style.


-------------------------------------
I've put up some bitcoind nodes after the network is
in need of some, and would like some feedback in that
the nodes are fully operational and doing something
useful. Please check the logs and tell me whether
I'm doing good.

debug.log from a node that has been running for a day:

2014-04-29 08:06:18 ERROR: CheckTransaction() : vin empty
2014-04-29 08:06:18 ERROR: AcceptToMemoryPool: : CheckTransaction failed
2014-04-29 08:06:18 Misbehaving: 122.224.182.248:23159 (0 -> 10)
2014-04-29 08:07:00 receive version message: /getaddr.bitnodes.io:0.1/: version 70001, blocks=298263, us=88.198.51.132:8333, them=0.0.0.0:0, peer=148.251.238.178:63657
2014-04-29 08:07:19 receive version message: /bitcoinseeder:0.01/: version 60000, blocks=230000, us=[2a01:4f8:131:13ed::2]:8333, them=0.0.0.0:0, peer=[2a02:348:5e:5a29::1]:53921
2014-04-29 08:09:37 receive version message: /Snoopy:0.1/: version 60001, blocks=0, us=88.198.51.132:8333, them=192.33.90.253:8333, peer=192.33.90.253:43104
2014-04-29 08:09:37 socket recv error 104
2014-04-29 08:10:26 receive version message: /getaddr.bitnodes.io:0.1/: version 70001, blocks=298263, us=[2a01:4f8:131:13ed::2]:8333, them=0.0.0.0:0, peer=[2a01:4f8:202:81b1::2]:50624
2014-04-29 08:10:32 receive version message: /bitcoinseeder:0.01/: version 60000, blocks=230000, us=88.198.51.132:8333, them=0.0.0.0:0, peer=217.78.0.153:37275
2014-04-29 08:10:50 receive version message: /getaddr.bitnodes.io:0.1/: version 70001, blocks=298263, us=88.198.51.132:8333, them=0.0.0.0:0, peer=148.251.238.178:50788

debug.log from a node that I just restarted:

2014-04-29 08:06:16 Opening LevelDB in /home/bitcoind/.bitcoin/blocks/index
2014-04-29 08:06:17 Opened LevelDB successfully
2014-04-29 08:06:17 Opening LevelDB in /home/bitcoind/.bitcoin/chainstate
2014-04-29 08:06:19 Opened LevelDB successfully
2014-04-29 08:06:22 LoadBlockIndexDB(): last block file = 135
2014-04-29 08:06:22 LoadBlockIndexDB(): last block file info: CBlockFileInfo(blocks=631, size=128154379, heights=297633...298263, time=2014-04-25...2014-04-29)
2014-04-29 08:06:22 LoadBlockIndexDB(): transaction index disabled
2014-04-29 08:06:22 LoadBlockIndexDB(): hashBestChain=0000000000000000162f5f571eef4742b70204d983bda3c4b18fc1496ac27f86 height=298263 date=2014-04-29 08:00:23 progress=0.999981
2014-04-29 08:06:22 init message: Verifying blocks...
2014-04-29 08:06:22 Verifying last 288 blocks at level 3
2014-04-29 08:07:42 No coin database inconsistencies in last 289 blocks (111189 transactions)
2014-04-29 08:07:42  block index           86284ms
2014-04-29 08:07:42 init message: Loading wallet...
2014-04-29 08:07:42 nFileVersion = 90100
2014-04-29 08:07:42 Keys: 101 plaintext, 0 encrypted, 101 w/ metadata, 101 total
2014-04-29 08:07:43  wallet                  108ms
2014-04-29 08:07:43 init message: Rescanning...
2014-04-29 08:07:43 Rescanning last 39 blocks (from block 298224)...
2014-04-29 08:07:43  rescan                  204ms
2014-04-29 08:07:43 init message: Loading addresses...
2014-04-29 08:07:43 Loaded 14015 addresses from peers.dat  84ms
2014-04-29 08:07:43 mapBlockIndex.size() = 298264
2014-04-29 08:07:43 nBestHeight = 298263
2014-04-29 08:07:43 setKeyPool.size() = 100
2014-04-29 08:07:43 mapWallet.size() = 0
2014-04-29 08:07:43 mapAddressBook.size() = 1
2014-04-29 08:07:43 AddLocal(213.239.218.20:8333,1)
2014-04-29 08:07:43 IPv4 eth0: 213.239.218.20
2014-04-29 08:07:43 AddLocal([2a01:4f8:a0:74c8::2]:8333,1)
2014-04-29 08:07:43 IPv6 eth0: 2a01:4f8:a0:74c8::2
2014-04-29 08:07:43 ext-ip thread start
2014-04-29 08:07:43 dnsseed thread start
2014-04-29 08:07:43 Loading addresses from DNS seeds (could take a while)
2014-04-29 08:07:43 net thread start
2014-04-29 08:07:43 upnp thread start
2014-04-29 08:07:43 opencon thread start
2014-04-29 08:07:43 addcon thread start
2014-04-29 08:07:43 dumpaddr thread start
2014-04-29 08:07:43 msghand thread start
2014-04-29 08:07:43 init message: Done loading
2014-04-29 08:07:43 GetMyExternalIP() received [213.239.218.20] 213.239.218.20:0
2014-04-29 08:07:43 GetMyExternalIP() returned 213.239.218.20
2014-04-29 08:07:43 AddLocal(213.239.218.20:8333,4)
2014-04-29 08:07:43 ext-ip thread exit
2014-04-29 08:07:44 receive version message: /Satoshi:0.8.6/: version 70001, blocks=298263, us=213.239.218.20:44169, them=166.78.243.104:8333, peer=166.78.243.104:8333
2014-04-29 08:07:44 Added time data, samples 2, offset +8 (+0 minutes)
2014-04-29 08:07:51 No valid UPnP IGDs found
2014-04-29 08:07:51 upnp thread exit
2014-04-29 08:07:53 connect() to 71.23.29.162:8333 failed after select(): No route to host
2014-04-29 08:07:53 receive version message: /Satoshi:0.9.1/: version 70002, blocks=298263, us=213.239.218.20:46921, them=91.238.134.58:8333, peer=91.238.134.58:8333
2014-04-29 08:07:53 Added time data, samples 3, offset +0 (+0 minutes)
2014-04-29 08:07:54 106 addresses found from DNS seeds
2014-04-29 08:07:54 dnsseed thread exit
2014-04-29 08:08:16 receive version message: /Satoshi:0.8.6/: version 70001, blocks=298263, us=213.239.218.20:50533, them=98.218.92.212:8333, peer=98.218.92.212:8333
2014-04-29 08:08:16 Added time data, samples 4, offset +2 (+0 minutes)
2014-04-29 08:08:22 receive version message: /Satoshi:0.8.5/: version 70001, blocks=298263, us=213.239.218.20:35016, them=108.3.172.22:8333, peer=108.3.172.22:8333
2014-04-29 08:08:22 Added time data, samples 5, offset +3 (+0 minutes)
2014-04-29 08:08:22 nTimeOffset = +2  (+0 minutes)
2014-04-29 08:08:27 receive version message: /bitcoinseeder:0.01/: version 60000, blocks=230000, us=213.239.218.20:8333, them=0.0.0.0:0, peer=178.18.90.41:52783
2014-04-29 08:08:27 Added time data, samples 6, offset +0 (+0 minutes)
2014-04-29 08:08:31 connect() to 24.136.254.2:8333 failed after select(): No route to host
2014-04-29 08:08:37 connect() to 187.15.64.129:8333 failed after select(): Connection refused
2014-04-29 08:08:38 receive version message: /Satoshi:0.8.5/: version 70001, blocks=298263, us=213.239.218.20:37793, them=209.99.52.77:8333, peer=209.99.52.77:8333
2014-04-29 08:08:38 Added time data, samples 7, offset -1 (+0 minutes)
2014-04-29 08:08:38 nTimeOffset = +0  (+0 minutes)
2014-04-29 08:08:50 receive version message: /Satoshi:0.9.0/: version 70002, blocks=298263, us=213.239.218.20:54044, them=69.23.94.246:8333, peer=69.23.94.246:8333
2014-04-29 08:08:50 Added time data, samples 8, offset -15 (+0 minutes)
2014-04-29 08:08:50 receive version message: /Satoshi:0.8.6/: version 70001, blocks=298263, us=213.239.218.20:45277, them=84.126.227.120:8333, peer=84.126.227.120:8333
2014-04-29 08:08:50 Added time data, samples 9, offset -1 (+0 minutes)
2014-04-29 08:08:50 nTimeOffset = +0  (+0 minutes)
2014-04-29 08:08:51 receive version message: /Satoshi:0.8.6/: version 70001, blocks=298263, us=213.239.218.20:55627, them=91.66.153.44:8333, peer=91.66.153.44:8333
2014-04-29 08:08:51 Added time data, samples 10, offset -2 (+0 minutes)
2014-04-29 08:09:05 receive version message: /bitcoinseeder:0.01/: version 60000, blocks=230000, us=[2a01:4f8:a0:74c8::2]:8333, them=0.0.0.0:0, peer=[2a02:348:5e:5a29::1]:39788
2014-04-29 08:09:05 Added time data, samples 11, offset +0 (+0 minutes)
2014-04-29 08:09:05 nTimeOffset = +0  (+0 minutes)
2014-04-29 08:09:35 receive version message: Dain 0.0.1: version 70001, blocks=298263, us=213.239.218.20:8333, them=162.242.155.221:8333, peer=162.242.155.221:53878
2014-04-29 08:09:35 Added time data, samples 12, offset +0 (+0 minutes)
2014-04-29 08:09:38 receive version message: /Snoopy:0.1/: version 60001, blocks=0, us=213.239.218.20:8333, them=192.33.90.253:8333, peer=192.33.90.253:34143
2014-04-29 08:09:38 Added time data, samples 13, offset +5 (+0 minutes)
2014-04-29 08:09:38 nTimeOffset = +0  (+0 minutes)
2014-04-29 08:10:16 receive version message: /bitcoinseeder:0.01/: version 60000, blocks=230000, us=213.239.218.20:8333, them=0.0.0.0:0, peer=192.3.11.20:49902
2014-04-29 08:10:16 Added time data, samples 14, offset +36 (+0 minutes)
2014-04-29 08:10:36 receive version message: /getaddr.bitnodes.io:0.1/: version 70001, blocks=298263, us=213.239.218.20:8333, them=0.0.0.0:0, peer=148.251.238.178:13436
2014-04-29 08:10:36 Added time data, samples 15, offset +0 (+0 minutes)
2014-04-29 08:10:36 nTimeOffset = +0  (+0 minutes)
2014-04-29 08:11:11 receive version message: /bitcoinseeder:0.01/: version 60000, blocks=230000, us=213.239.218.20:8333, them=0.0.0.0:0, peer=108.18.18.4:46999
2014-04-29 08:11:11 Added time data, samples 16, offset +36 (+0 minutes)
2014-04-29 08:11:23 receive version message: /getaddr.bitnodes.io:0.1/: version 70001, blocks=298263, us=[2a01:4f8:a0:74c8::2]:8333, them=0.0.0.0:0, peer=[2a01:4f8:202:81b1::2]:54634
2014-04-29 08:11:23 Added time data, samples 17, offset +0 (+0 minutes)
2014-04-29 08:11:23 nTimeOffset = +0  (+0 minutes)



-------------------------------------
On Fri, May 09, 2014 at 05:15:52PM +0200, Mike Hearn wrote:

Ah, you're still misunderstanding my point: You can get atomicity in the
worst-case where the communications medium fails *and* stealth payments
that use up no extra space in the blockchain. This gives you the best of
both worlds.

I haven't yet specified that mode of operation in the current draft
stealth address standard, however I do plan on adding it. Notably the
standard is designed to allow exactly that feature to be added in a
backwards compatible way - senders who don't implement that feature, or
choose not to use it, simply fall back to op-return.

-- 
'peter'[:-1]@petertodd.org
00000000000000004d25218420094fda0891fe1d734e1a8df581bd6de7f2d0cd
-------------------------------------
Those clarifications are what I needed to hear. For some reason I started
thinking about this last night and wanted to bring it up just in case it
would help, but def. not necessary. Will get back to more low hanging fruit
in the UI/UX as I get to know the project more.

Gregory: "But there doesn't have to be and shouldn't just be one
network transport
for Bitcoin."
is there a formal abstraction for a Transport layer? I suppose if there
isn't it'll be there when needed.

Thanks!

http://twitter.com/gubatron


On Tue, Apr 8, 2014 at 12:48 PM, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------
On Wed, Apr 23, 2014 at 10:39 PM, Gregory Maxwell <gmaxwell@gmail.com>wrote:



Interesting.  You set the share-block size to 16kB and set the share POW to
1/64 of the main target.

Each share-block would be allowed to append up to 16kB on the previous
share-block.

This would keep the bandwidth the same, but on average blocks would be only
512kB.

e.g. to get you fast confirmation.", or

This effect could be reduced by having "colours" for blocks and
transactions.

The block colour would be a loop based on block height.

You could have 16 transaction "colours" based on the lowest 4 bits in the
txId.

A transaction is only valid if all inputs into the transaction are the
correct colour for that block.

This allows blocks to be created in advance.  If you are processing colour
7 at the moment, you can have a colour 8 block ready.

16 colours is probably to many.   It would only be necessary for things
like 1 second block rates.

The disadvantage is that wallets would have to make sure that they have
coins for each of the 16 colours.

If you spend the wrong colour, you add 16 block times of latency.



In a shop setting, you could set it up so that the person scans a QR-code
to setup a channel with the shop.

They can then scan all their stuff and by the time they have done that, the
channel would be ready.

If there was a queue, it could be done when the person enters the queue.

In fact, there could be QR-codes at multiple locations.
-------------------------------------
On Mon, Jan 20, 2014 at 9:02 PM, Luke-Jr <luke@dashjr.org> wrote:

Wordlist is necessary for the step [seed]->[mnemonic]. Step
[mnemonic]->[bip32 root] doesn't need any wordlist, there's just hashing
involved.
For this reason client can generate whatever mnemonic and unless all
clients use the same process [mnemonic]->[bip32 root], the result is the
same.


Trezor generates the seed and transforms it to mnemonic (which is then
shown on internal display). Generating the mnemonic outside the client-side
(computer) is one of main functionality of Trezor.

slush
-------------------------------------
On Mon, 19 May 2014 19:49:52 -0400, Jeff Garzik wrote:

Setting it up as a zone forwarder causes each request to go through to 
the dnsseed backend for each request.

Rob


-------------------------------------
On Tue, Aug 19, 2014 at 4:39 PM, Justus Ranvier
<justusranvier@riseup.net> wrote:

I think it's desirable (and you can go look in #bitcoin-dev logs for
me talking about it in the past)— but all of engineering is
tradeoffs... and the ones involved here don't make it a high priority
in my book, esp when people should be using Bitcoin over tor in any
case, which provides better privacy and also covers encrypt + auth.

In general I think authentication is more important than encryption,
since authentication is table stakes required for a number of
anti-partitioning-attack measures.  My past thinking on opportunistic
encryption is that once you're authenticating also encrypting would be
fairly little work, but it should be auth that drives that kind of
effort.


-------------------------------------
On Tue, 14 Jan 2014 06:19:08 -0800, Peter Todd <pete@petertodd.org> wrote:


Right now I have this:

   byte[] e = EC.NewPrivateKey();
   byte[] P = EC.GetPublicKey(e, compressed: true);
   byte[] S1 = EC.DH(e, Q1);
   byte[] S2 = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S1));
   byte[] q2New = EC.PointAdd(Q2, Util.SingleSHA256(S2));
   stealthTx.Vout.Add(TxOut.PayToMultiSig(Util.Amount(".995"), 2, 2, q1New,  
q2New));
   stealthTx.Vout.Add(TxOut.OpReturn(P));

In this case, you can scan with d2, calculate S2, and matching payments  
will have the right 'q2New'. But you need to check again offline with d1  
since it's a separate shared secret.

Maybe you are saying:

   byte[] S = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S));
   byte[] q2New = EC.PointAdd(Q2, Util.SingleSHA256(S));

But the payment would have (q2New - q1New) == (Q2 - Q1), so I think not  
entirely stealth? OK, let's fix that by adding a counter to the hash  
function...

   byte[] S = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S || 1));
   byte[] q2New = EC.PointAdd(Q2, Util.SingleSHA256(S || 2));
   stealthTx.Vout.Add(TxOut.PayToMultiSig(Util.Amount(".995"), 2, 2, q1New,  
q2New));
   stealthTx.Vout.Add(TxOut.OpReturn(P));

This is assuming we want to put q2New somewhere into the transaction,  
which, is it even required?

   byte[] S = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S));
   stealthTx.Vout.Add(TxOut.PayToPubKeyHash(Util.Amount(".995"), q1New);
   stealthTx.Vout.Add(TxOut.OpReturn(P));

I'll wait for ACK and then update my sample code.



-------------------------------------
I took the number out, it is now just "the getutxo bip" until a number is
assigned.


On Thu, Jul 10, 2014 at 4:29 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
On 01/16/2014 01:28 PM, Peter Todd wrote:


I agree wholeheartedly against using "reusable address".  I personally
am fine with "stealth address", but can see where there might be a
negative connotation.

Might I suggest "master address", which is neutral in connotation, but
indicates both that it is fixed and that payment addresses are generated
as needed from it.

But please, no "reusable address."

-- 
Johnathan Corgan, Corgan Labs
SDR Training and Development Services
http://corganlabs.com
-------------------------------------

I'm sure it would be *possible*, but testnet and mainnet are entirely
separate networks. Not only that, but the entire point of the testnet is
separation. There is no logic to multiplexing them.

If conservation is an issue, I'd forgo the testnet port. We don't have a
'test ssh' or 'test mail server' port either, most people will just
allocate a temporary number for those themselves.

In case the port is already in use, bitcoin can run on and announce any
another port. There is no strict need for it to be 8333 (or 18333) at all.

There isn't even an argument for convenience. Most of the time, users don't
specify nodes. And in the rare cases that they do they can specify a port
as well.

If a whole slew of alt coins also tried to reserve ports, I suspect that

That's somebody else's problem. Bitcoin is by far the most well-known of
the 'coins' so it may be considered realistic to allocate one or two ports
for it. Or not, in which case the altcoins can forget it too.

Regards,
Wladimir
-------------------------------------
On Tue, May 13, 2014 at 12:40 AM, Chris Pacia <ctpacia@gmail.com> wrote:


I think you are right. Awkward.

Wallets could auto-respend transactions to a plain (private) HD derived key
to make them findable again. But that gets us back to using block space
inefficiently.

Over time I think wallet backups will get more valuable anyway, as they
will start containing more and more essential data that isn't in the block
chain: receipts, messages, exchange rate records for tax purposes etc. But
being able to get access to your money with just the 12 words (+a date for
SPV wallets) is a pretty desirable safety feature.
-------------------------------------
Im pleased to announce version 0.12 of bitcoinj, one of the worlds most popular Bitcoin libraries. It is used by at least four Android wallets, three desktop wallets, blockchain.info, Circle, biteasy, CryptoCorp, Lighthouse, BlueMatts relay network, bitpos, countless alt coin wallets, for academic research projects and much more.

This release represents 8 months of work. The biggest new feature is HD wallets. Other notable enhancements include a bundled Tor client that can be activated with one line of code, support for multisig wallets, much faster and deterministic ECDSA, many API improvements and big upgrades to the included GUI wallet which can be seen in a new screencasted tutorial.

The commit hash of bitcoinj 0.12 is 83a9a71f3fff3f223d0737ad758b519a39dbbd62. 

New in this release

Privacy enhancements:
Wallets are now hierarchical and deterministic (HD) by default, using the BIP32 specification. Support for mnemonic codes (BIP 39) is also included. Change and receive addresses are no longer being reused. Old wallets are upgraded in place using the private key of the oldest non-rotating key as the seed bytes, so old backups remain valid.
Thanks to devrandom, we have an integrated Tor mode using the Orchid library. The user does not have to install the Tor client as its all pure Java. WalletAppKit users can enable usage of Tor with a single line of code. This support should be considered experimental for now.
Thanks to Kosta Korenkov, we have an experimental multisig wallets implementation. Multisig (also married) wallets are HD wallets that are connected to a third party risk analysis service or device. When married, the wallet tracks multiple BIP32 key trees, keeps them in sync and starts vending P2SH addresses.
As part of this work, transaction signing is now pluggable. TransactionSigner implementations can be added to the wallet and will be serialized into and out of the users saved wallet file. Signers are given a transaction to sign in sequence. This is intended for risk analysis providers to provide a class that talks to their server to get a signature of the right form, so that all bitcoinj based wallets can be easily upgraded to support the new provider.
Reject messages are now deserialized and logged, though not yet exposed in the API.
Upgraded to Guava 16 and Bouncy Castle 1.51. Thanks to Peter Dettman and the rest of the Bouncy Castle team, bitcoinj now uses deterministic ECDSA for signing and were now using an accelerated secp256k1 implementation that exploits the special properties of this curve, for dramatically faster calculations.
Payment protocol code improvements: Some X.509 utility code was refactored out of PaymentSession for general usage. StartCom was added to the default trust store which was promoted to override the system trust store on non-Android platforms. A command line tool to dump requests to stdout was added.
Thanks to Andreas Schildbach:
We are now BIP62 (canonical push encodings) compliant.
A new Coin class replaces usage of BigInteger for marking values that are quantities of bitcoin. Formatting has moved into the new MonetaryFormat class.
The wallet now saves the fee paid on transactions we calculated ourselves. This is useful for putting it into a wallet user interface.
Transactions can have user memos and exchange rates attached, that will be saved by the wallet.
Support for decrypting BIP 38 protected private keys has been added.
Checkpoints can now be stored textually as well as in the old binary format.
There is also a new BtcFormat API that provides an alternative to MonetaryFormat that plugs in to the java.text framework.
Added new DNS seed from Addy Yeow.
Wallets can now have string->byte[] mappings attached to them, for lighter weight extensions.
Thanks to Richard Green, there is now a Python version of the ForwardingService program from the getting started tutorial. This shows how to use bitcoinj from Python using the Jython interpreter.
bitcoinj now probes localhost for a Bitcoin node and automatically uses that instead of the P2P network, when present. This means any bitcoinj based app can be easily upgraded from SPV to full security just by running Core at the same time: no setup needed.
Thanks to Michael Bumann, there are now more example apps showing how to use parts of the API.
WalletTemplate/WalletAppKit improvements. WalletTemplate is a demo app that shows how to create a cross-platform GUI wallet with a modern style and 60fps animations. WalletAppKit is a very high level API for creating apps that have a Bitcoin wallet:
Now supports mnemonic code and restore from seed words. A date picker is provided to cut down on the amount of chain that needs to be rescanned.
Support for encrypting wallets. Password is requested when needed. The difficulty of the scrypt function is selected to always take a fixed number of seconds even if hardware gets more powerful.
Some new animation and utility code backported from Lighthouse.
Tor support
Thanks to Martin Zachrison, the micropayment channels implementation has received various improvements.
Thanks to Eric Tierney (Circle), the Postgres store can now take a custom schema.
The Bloom filtering API has been extended so FilteredBlock objects can now be produced from Block objects given a BloomFilter. Previously there was support for client-side Bloom usage but no implementation of the generation part.
Many other bugfixes, cleanups, minor tweaks and small new APIs.
Documentation and tutorials

A JavaScript tutorial has been added, showing how to use bitcoinj from this language. More tutorials in other languages will come in future.
The Working with the wallet document has been significantly extended to cover encryption, watching wallets, HD wallets and multisig/married wallets.
A new document and accompanying screencast shows how to extend the WalletTemplate app to have a transactions list, and then make a native/bundled packages that dont need the user to install Java. By following this tutorial you will learn how to make a basic cross platform desktop wallet of your own.
All other docs were refreshed to the latest APIs.
API changes

The package name has changed to org.bitcoinj and the core Maven artifact name is now bitcoinj-core. You can auto-port most of your code by running find . -name '*.java' \| xargs sed -i .bak 's/com.google.bitcoin./import org.bitcoinj./g
Wallet.completeTx now throws more precise unchecked exceptions in edge cases, instead of IllegalArgumentException.
The use of BigInteger to represent quantities of Bitcoin has been replaced with the more efficient, type safe and useful class Coin. Coin is mostly source compatible with BigInteger so you can probably just do a search and replace to update your codebase. Utils.bitcoinValueToFriendlyString and friends moved to CoinFormat.
NetworkParameters.getProofOfWorkLimit was renamed to getMaxTarget for consistency with other Bitcoin codebases.
The library no longer uses the misleading term nanocoins to mean satoshis (the old term predated the use of the word satoshi to describe the smallest possible amount of bitcoin).
TransactionConfidence no longer tracks total work done.
Because outputs are now shuffled any code during that assumes the ordering is preserved will break. You can set the shuffleOutputs field of SendRequest to false to disable this behaviour if you need to.
The ECKey and HD APIs have changed quite a bit: several constructors were replaced with clearer static factory methods that make it more obvious how their parameters are interpreted. The new methods dont change their behaviour depending on the pattern of nulls passed into them.
Some unit testing utilities have been moved to the new testing subpackage and cleaned up/rearranged. It should be easier to write unit tests for your app that need a simulated network now. DeterministicKey now derives from ECKey.
We now use Utils.HEX.encode() and Utils.HEX.decode() to do translation to and from base 16.
Transaction.hashTransactionForSignature was renamed to just hashForSignature.
The subVer string sent by bitcoinj now has a lower cased first component.

-------------------------------------
This was originally submitted to the bitcoin github issue manager. I'm
re-posting here.

I propose the transaction fee should be calculated from a percentage of the
input amount divided by the confirmations of the input multiplied by the
number of inputs.

By using a percentage of the input amount the transaction fee will always
make sense no matter what the "price" of bitcoins may be in fiat; by
dividing the fee by the number of confirmations we discourage hasty spends
and reward savings (ie. old inputs); by multiplying the fee by the number
of inputs we discourage "payment fragmenting."

Let me further explain payment fragmenting by way of an example: Let's say
I get paid $2,500 in bitcoins per month from my job. If I then take that
$2,500 and pay for a coffee (right away, 1 confirmation) I'll be charged a
fee of $2.50 because I'm charged according to the *input amount*, not the
actual transaction size. Because of this it would behove my employer to pay
me the $2,500 as one transaction with, perhaps, 100 output addresses at $25
apiece so that when I pay for my coffee I use one of the $25 unspent
outputs. By multiplying the transaction fee be the number of inputs this
provides a disincentive for payment fragmenting as multiple inputs will be
required to pay for larger purchases.

Furthermore this provides an incentive for wallet software to use the
oldest input(s) which most closely match the transaction amount. For the
example above: In real life a user's wallet would have a number of inputs
to choose from and wouldn't use the newest "paycheck" input for the coffee
purchase. Furthermore, even if the $2,500 input was the only input
available, by waiting for 100 confirmations (less than a day) the
transaction fee would be 2.5 cents.

Transaction fees would then be calculated by the following formula:

((INPUT_AMOUNT * BASE_PERCENT) / CONFIRMATIONS) * NUMBER_OF_INPUTS

The INPUT_AMOUNT, CONFIRMATIONS and NUMBER_OF_INPUTS would be determined by
the creator of the transaction and should be optimized for the transaction
amount -- the BASE_PERCENT would be hard-coded in the bitcoind software.
The special case of zero CONFIRMATIONS will be treated as 1 confirmation in
order to avoid a divide by zero error.

For example: if I choose a BASE_PERCENT of 0.1% and one input it will cost:

   - $1 to send $1,000,000 that has 100 confirmations;
   - $0.10 (10 cents) to send $1,000,000 that has 1,000 confirmations
   (approx. 1 week);
   - $0.10 (10 cents) to send $100 which has 1 confirmation;
   - $0.01 (1 cent) to send $100 which has 10 confirmations;
   - $0.001 (1/10 cent) to send $100 which has 100 confirmations (less than
   a day);

I've put together a spreadsheet which shows the various fees by amount and
confirmations -- the spreadsheet assumes one input for a transaction:

https://docs.google.com/spreadsheets/d/1ovAQfxksQmOq3zYf79qFEDPCrSx58SmyK3Uwpu8iTUs/edit?usp=sharing
-------------------------------------
On Wed, Dec 10, 2014 at 6:47 AM, Wladimir <laanwj@gmail.com> wrote:

And there is also NACK, that's an aspecific 'I wouldn't like this
merged'. I always explain why in the text.

A document on this would be welcome, as it may look like Martian to
outsiders. That's been brought up many times before, but no one ever
created it.

Wladimir


-------------------------------------
On Dec 20, 2014 8:49 AM, "Peter Todd" <pete@petertodd.org> wrote:
implement proof-of-publication. Knowing that no conflicting message exists
says nothing about who be in posession of that message, or indeed, any
message at all. Thus anti-replay is not sufficient to implement other uses
of proof-of-publication such as decentralized exchange³.

How does proof of publication prove who is in possession of that message?
Or of any message at all?  The data written in an anti-replay system and
the data written in a proof of publication system differs in that you can't
repeat data in an anti-replay system according to some understanding of the
rules of the meaning of the data (if I am following your description
correctly).

Obviously you can publish the same data as many times as you like in a
proof-of-publication system; the interpretation of what that data means
would be the responsibility of the observers, not the "publishing
vehicle".  Repeated entries thus can be written, and the user of PoP can
validate and prove they did so.

If the data itself defines possession, the "ownership of the message" (it
isn't even clear to me what you mean by that phrase) isn't defined by
either proof, but by the message itself.  And the message itself isn't
constrained by either to prohibit proving ownership (what ever you mean by
that).

Of course, I do assume I can test a message (or a set of messages sharing
some feature like a particular input on a transaction) as being publishable
in an anti-replay system without actually publishing it.  That does allow
one to prove non-publishing.  You can determine if a message exists that
would preclude the publishing of a message; the very purpose of an
anti-replay proof.

And I would assert that such a search (i.e. the idea that such a search has
meaning in a anti-replay system) is already incorporating the assumption
that such a search is possible and must be possible for an anti-replay
system.
-------------------------------------
On Fri, Jan 03, 2014 at 09:23:20PM +0100, Adam Back wrote:

Lol, fourth if you include me, although my case is rather embarassing as
I had re-read Bytecoin's original post recently and completely missed
the main point of it!


Actually I think it has the potential to be *more* SPV compatible than
the alternative, as in conjunction with prefix filters it lets you
receive unlimited unrelated payments that you can find in the blockchain
with a single prefix query with a fixed bandwidth/anonymity set size
tradeoff. (obviously in conjunction with one of the many ways of tagging
transactions for more efficient search)

The BIP38 approach with UI's that make it easy to create a new address
for every payment on the other hand force you to either accept higher
bandwidth consumption, or decrease your anonymity set size, or lose
payments. (inclusive)

I've got a post talking about this in more detail as well as an overview
of bloom filters vs. prefix filters that I'll publish tomorrow. (tl;dr:
bloom filters have very poor O(n^2) scalability and should be
depreciated)


-- 
'peter'[:-1]@petertodd.org
0000000000000001a96469654430aa06e4ae7c7328a7eb848c6fc63443f24e4a
-------------------------------------
On Thu, Feb 20, 2014 at 10:07 PM, Mike Hearn <mike@plan99.net> wrote:

We're in agreement.  I had mistakenly believed you were supporting the
discussion about trying to force these constraints on current version
transactions, in which case "wallets will pick up at different times"
is an absolute deal breaker.  :)


-------------------------------------
On Sat, May 24, 2014 at 5:04 PM, Alan Reiner <etotheipi@gmail.com> wrote:

This directly opens an attack where as soon as you find a block you
announce the header to the world and then you delay announcing the
block content.  You can continue to mine on the block but no one else
can (or alternatively they break their rule and risk extending an
invalid block— bad news for SPV wallets)— then when you find a
successor block or someone else finds a competing block you
immediately announce the content.

It basically means that you can always delay announcing a block and be
sure that doing so doesn't deprive you of your winning position.


With an alternative transport protocol, assuming the content has
already been relayed a block could be sent in a couple back to back
UDP packets.  (e.g. a few bytes per transaction to disambiguate the
transaction order out of the already sent transactions).  So I think
very similar latency could be achieved without doing any thing which
might increase the motivations for miners to misbehave.


-------------------------------------
Jumping in on this conversation because I've been doing research in this
area. Using a list of trusted providers in the payment details will be very
limiting and not scalable. I understand the reason for wanting the
supports_instant field, but I think that's a bad idea because the list
could literally be a million providers. Secondly, some merchants already
support instant transactions without any trust signature, so they should
also be able to advertise that as well.

I also don't believe that trusted or not trusted is a valid on and off
switch. For example, I might trust an instant provider for a 1 btc
transaction, but not 1,000,000 btc. Trust is all about the risk involved.
We can definitely learn from the current financial system in this realm.

I 100% agree with the In Payment Message portion of the BIP extension.
Here's how I think this will practically shake out in an automated way:
Anyone can become an instant provider, but nobody will trust them at first.
As that particular instant provider processes more and more transactions
without any double spends, they essentially build up trust. Based on the
past history of a particular instant provider a risk factor could be
calculated for a given transaction. This would also factor in the size of
the transaction. It would be very similar to a credit file showing the past
history of that particular instant provider based on all the transactions
they signed.

Andreas Schildbach <andreas <at> schildbach.de> writes:




Agreed, supports_instant is redundant and can/should/will go.

trusted_instant_providers on the other hand I think is needed.

Sometimes the providers will charge fees for instant.

While the software can ignore the fields,
users may not want to pay for instant when the merchant may not accept it or
care (even if it would not break the protocol it would still be a waste of
fees)

Does it make sense?

Not all transactions from GreenAddress provide double spend protection, there
are additional checks on prevout that are normally not done when spending
normally, etc
-------------------------------------
We've done forking changes before much faster than a year and that was with
less experience. If we want, we can get this done within months.
On 20 Feb 2014 16:30, "Michael Gronager" <gronager@mac.com> wrote:

-------------------------------------
On Tuesday, 22 April 2014, at 10:39 am, Jan Møller wrote:

I agree that M > 16 is probably not a viable use case for human beings, but machines would probably be able to make use of it. I, for one, welcome our new robot overlords.

Also, the byte that encodes M−1 is optional, so if you're concerned about space, you can omit it (and the checksum).


-------------------------------------
On Tue, Nov 4, 2014 at 8:29 AM, Pieter Wuille <pieter.wuille@gmail.com>
wrote:


I agree; soft-forking is a useful way of rolling out upgrades, we shouldn't
prohibit it.

-- 
--
Gavin Andresen
-------------------------------------

Psychological benefit vs. effective benefit involves the danger of
destroying trust in the Bitcoin network when there are hard facts for
non-robustness while the node number looks big. Therefore, it may make
sense to establish better metrics.


In my opinion, the characteristic of being able to make use of
non-dedicated nodes should be regarded as an advantage of the Bitcoin
protocol, and not something to get rid of. Nodes being able to
contribute this way may lead to even more robustness than
decentralization alone, as they can do so without exposing a fixed
address which could be attacked.

Best regards,

Isidor


-------------------------------------
Consensus is the spec should be clarified to match current behavior, so it won't change.

--
Gavin Andresen




-------------------------------------
https://bitcointalk.org/index.php?topic=145066.0

The idea proposed in the above article seemed like an excellent idea. What
is holding this up from being implemented? Does someone need to code it, or
write a BIP first?
-------------------------------------
On Tue, May 13, 2014 at 3:21 AM, Peter Grigor <peter@grigor.ws> wrote:

For reference: https://github.com/bitcoin/bitcoin/issues/4171

I think the responses in the issue tracker already adequately address
why this doesn't belong in *Bit*coin. Your cure is worse than the
disease, IMHO.


-------------------------------------
On Wednesday 23 April 2014 15:31:38 Mike Hearn wrote:

Again true enough; but then we're back to evenly distributed dishonesty, and 
so you still don't get the potential 5% scam being used at 100% capacity.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com



-------------------------------------
Hello Krzysztof,

[...]

I think it's great work and provides a good reference for those
who want to get some insight into Bitcoin's design.

Have you considered putting the document source under version control,
which may facilitate tracking future protocol improvements in the
document easily?

Best regards,

Isidor


-------------------------------------
On Mon, Sep 8, 2014 at 1:31 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

Changes: https://github.com/bitcoin/bips/pull/102/files

Gregory, Jeff: does this address your concerns?
Others: comments?

-- 
Pieter


-------------------------------------
On Fri, Apr 4, 2014 at 6:51 AM, Nikita Schmidt
<nikita@megiontechnologies.com> wrote:

Operation mod the group order is how secret keys must be combined in
type-2 private derivation for BIP-32. It's also absolutely essential
if you want to build a secret sharing scheme in which the shares are
usable for threshold ECDSA.

I still repeat my concern that any private key secret sharing scheme
really ought to be compatible with threshold ECDSA, otherwise we're
just going to have another redundant specification.


-------------------------------------
Hello.  How would I submit a patch?  Could it be sent through the list 
as an attachment?

-- 
Kevin



-------------------------------------
On Mon, Feb 10, 2014 at 08:45:03AM -0800, Gregory Maxwell wrote:

Thank you.

I also appreciate your commentary[1], and willingness to list your investment
position. What I'm concerned about are people who have signed non-disclosure 
agreements or who's salary/equity/whatever depend on people who are experts
at manipulating markets to take naive investors money.

Independent is also a state of mind as much as it is about financial connections.

What pisses me off here is that a huge amount of wealth just changed hands based
on MtGox's press release, and it stinks of insider trading. I still maintain the
best outcome would be for MtGox to AGPLv3 release their code, and then those of 
us that understand it would be able to have a public technical discussion about
how to fix it, and MtGox would still maintain their intellectual property
ownership position.

This, however, cuts off a significant revenue stream for people who take money
making market bets 5 minutes before the information goes public, so I expect
the likelyhood of such an outbreak of sanity is quite low.

[1] http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/


DISCLAIMER: I have a significant emotional investment in copyleft/viral copyright
development models, and I expect to take a lot of money charging people to write
code I give away for free. I also occasionally make money from cryptocurrency
mining, but only when I can sell it in functional and transparent markets.


-------------------------------------
On Sat, Mar 29, 2014 at 10:10 AM, Matt Whitlock <bip@mattwhitlock.name> wrote:

This is not the case: one can use MPC techniques to compute a
signature from shares without reconstructing the private key. There is
a paper on this for bitcoin, but I don't know where it is.




-- 
"Those who would give up Essential Liberty to purchase a little
Temporary Safety deserve neither  Liberty nor Safety."
-- Benjamin Franklin


-------------------------------------
I somehow think that it is too early for this heavy kind of extension,
given that the first version of BIP70 isn't even deployed widely let
alone *used*.

By reading your proposal I get the idea that the current spec doesn't
allow two (or three) different PKIs at once -- we would want this for
migration purposes as you wrote and also because different people prefer
different kinds of PKIs. And that's perhaps something we want to fix in
the current (version 1) spec to prevent us running into a wall and be
doomed to patch around the spec. Note I assume a potential PGP or
Bitcoin-based infrastructure would also be called 'PKI'.

I would prefer if your fix would stay local to X.509 (and thus only
change X.509 specific structs rather than the top-level PaymentRequest).
And for a future PKI we would implement identity delegation in a
straight forward, non-kludgy way.


On 02/28/2014 12:46 PM, Mike Hearn wrote:





-------------------------------------
Thankfully those two duplicated transactions were never spent when they first appeared. Because of that, I chose to not not add them to the UTXO at all when they first appear. When the duplicates appear they get added to the UTXO successfully because the earlier, conflicting versions are not present. That way you can carry on assuming that all transaction hashes are unique, and enforce that rule over the entire blockchain.

Date: Mon, 14 Jul 2014 13:18:22 +0200
From: mike@plan99.net
To: me@ricmoo.com
CC: bitcoin-development@lists.sourceforge.net
Subject: Re: [Bitcoin-development] Self-dependency transaction question...

Conceptually all transactions in the block chain lie on a single timeline. The fact that we quantise that timeline into blocks is in many ways neither here nor there - it's still a strict line. 

What can happen and you must be aware of is duplicated transactions. Satoshi sort of assumed this could never happen because everything is hash based, but forgot that duplicating coinbases is possible and at one point this did happen. It was banned by a rule change afterwards but you still must be able to process the older parts of the chain that have this. There is a BIP that covers the new rule.



------------------------------------------------------------------------------
Want fast and easy access to all the code in your enterprise? Index and
search up to 200,000 lines of code with a free copy of Black Duck
Code Sight - the same software that powers the world's largest code
search on Ohloh, the Black Duck Open Hub! Try it now.
http://p.sf.net/sfu/bds
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development 		 	   		  
-------------------------------------
Unlikely. I doubt any significant portion of miners in china will continue to mine on a china-specific chain, since it will certainly be outmined by non-Chinese miners, and will be orphaned eventually. 

More likely is that mining interests in china will make special arrangements to circumvent the GFwOC.

Users who can't access the worldwide blockchain will notice horrendously slow confirmation times and other side effects. 

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 27 November 2014 18:46:23 GMT-05:00, Gregory Maxwell <gmaxwell@gmail.com> wrote:

<snip 100% accurate commentary from gmaxwell>


It does; it is still a draft. That said I think writing up some actual working examples, in code, of CHECKLOCKTIMEVERIFY using protocols is a bigger priority. Micropayment channels comes to mind, as well as a greenaddress-style wallet.

When I get a chance I'm going to rebase the initial implementation and add to it a command-line-flag to verify CHECKLOCKTIMEVERIFY as an IsStandard() rule for testing purposes.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJUd+luMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhWmcB/0UK030Q6TSpi95x0Gh
hGYaSAInUWpbZzZtP+1AFrGDGRdGo0glFFf8xggI+U5kuc0woPYrn/VEGcprPhvs
KQFZrirXVr7Q09TVlHiPDen5v3Y7xwL5kQDUrBPP71Pe3R2o6IbfdwxsZ8+yYso8
hY6WQmImQpKJd4gEd76w1QrF8Btl1Jz/PGh4EE3GSPGlflvBwA6igSiRoD/czb1x
63y4AsPEil2hrmIjTZHqwnl40BqnmZ8qpNLWeIEjE++pbkxLTjvUcPy03/wtTWZA
5dCGeY5WavgZsPazhSdaTtM5/7wPSQQ0PDXNHdHgmewkvbyBpy78orV/3bEG+xFz
2SWi
=4OmI
-----END PGP SIGNATURE-----



-------------------------------------
Thanks for the explanation.

On 01/13/2014 06:56 PM, Pieter Wuille wrote:


Looks good so far. Just wanted to keep you aware (-:




-------------------------------------
On Sun, Apr 6, 2014 at 12:35 AM, Maciej Trebacz <maciej@bitalo.com> wrote:

For just having a dummy output for an all fee transaction you do not
need to have a PUSH at all.


-------------------------------------
2014-03-07 11:23 GMT+01:00 Andreas Schildbach <andreas@schildbach.de>:



Yes, that's also something adopted from the existing Smartcard world.
Existing smartcards can contain different payment applications (for example
in Germany the "Maestro" and the "Geldkarte" application on the same card).
So the terminal can actively request one specific application within the
Smartcard.

But as Mike correctly said, we have no pre-existing infrastructure to
support. So decisions should only be based on what makes sense for the
future.


Bad news: It seems - at least CATEGORY_PAYMENT - very credit card centric.

I'm not sure about this. I've built several HCE test apps and tested them
with readers (and other phones used as reader) but I did not notice any
difference to using CATEGORY_OTHER (besides that the apps using
CATEGORY_PAYMENT appear in KitKat's new shiny "Tap & Pay" menu).


HCE seems to cover only the payer side. I wonder if there is also an API

You are free to implement whatever protocol you want. On the reader side
you simply do a IseDep "connect()" and send your commands with
"transceive()" (
https://developer.android.com/reference/android/nfc/tech/IsoDep.html#transceive(byte[])).
After sending the initial ISO 7816-4 "SELECT APPLICATION" command (see here
for some ISO 7816-4 doc:
http://www.cardwerk.com/smartcards/smartcard_standard_ISO7816-4_6_basic_interindustry_commands.aspx#chap6_11)
which triggers Android HCE routing mechanism to route all following PDUs to
your HCE app, you are free to send whatever you want.

Anything you send with "transceve()" on the sender side, will be received
within your HCE application in the "processCommandApdu" method:
https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#processCommandApdu(byte[],
android.os.Bundle)

The only limitation is that you have a strict request/response model. The
reader terminal (or the reading phone) sends a request, the HCE phone sends
a response.
-------------------------------------
Resurrecting this topic.  Bitcoin Wallet moved to mBTC several weeks
ago, which was disappointing -- it sounded like the consensus was
uBTC, and moving to uBTC later --which will happen-- may result in
additional user confusion, thanks to yet another decimal place
transition.



On Sun, Nov 17, 2013 at 9:28 PM, Wendell <w@grabhive.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Hi all,

        I've been toying with an algorithm to place a ceiling on
confirmation latency by allowing weaker blocks after a certain time.
Hope this isn't noise, but thought someone must have considered this
before, or know of flaws in the scheme?

Gory details:
http://rustyrussell.github.io/pettycoin/2014/10/30/More-Regular-Block-Times.html

Thanks,
Rusty.


-------------------------------------
can be

Quoting from RFC 3986, Section 3.4. Query:  "The characters slash ("/")
and question mark ("?") may represent data within the query component."


Thanks for testing this. It would be interesting to know what device and
software you used for scanning. But anyway, it falls into the same
ballpark as my tests.


So BIP72 with a BT URI in the 'r' parameter?



-------------------------------------
We had a halving, and it was a non-event.

Is there some reason to believe next time will be different?

-- 
--
Gavin Andresen
-------------------------------------
On Wed, Mar 5, 2014 at 2:18 PM, Jean-Paul Kogelman
<jeanpaulkogelman@me.com> wrote:

I've done some preliminary work on making it leak less, but it's by no
means guaranteed to be constant time either (so better assume it is
not).

-- 
Pieter


-------------------------------------
On Thu, Jul 17, 2014 at 6:14 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:


To my knowledge, Satoshi left the project before mining pools got a
traction.

slush
-------------------------------------
Hello,

so far, nothing yet?

See: https://launchpad.net/~bitcoin/

I'm developing currently a LiveCD for hot/cold wallet management on
Ubuntu LTS basis. For critical vulnerabilities I have to provide timely
updates. I have now decided to maintain my own repository for this
project. If there are better alternatives, let me know.

regards
Oliver


-------------------------------------
Ok, agreed. I will submit a pull request to BIP72 then.
Not sure about escaping though. It is indeed not critical for bitcoin URIs,
but still it is a part of RFC, don't think we should go against it.

Andreas, we will implement this on our side, with bluetooth on r= and web
address on r1=.


2014-07-01 18:59 GMT+01:00 Mike Hearn <mike@plan99.net>:

-------------------------------------
Jeff, there are *plenty* of places that lack local Internet access for
one or both participants.

Obviously making the case where both participants lack access to the
bitcoin network is difficult to secure, but not impossible (e.g. use a
telephany-based system to connect to a centralized double-spend
database, as VISA does).

I expect the case where one participant has Internet access (the
merchant) and the other does not to be very, very common. The majority
of transactions I do on a daily basis are like this, and I live in
Silicon Valley!

On 03/22/2014 09:35 AM, Jeff Garzik wrote:


-------------------------------------
I think a reputation network is more complicated than is needed for
this. This can be solved by the market.

What is needed is a simple method for each individual user to mark
certain merchant as trusted. For example, if your device gets an
untrusted payment request, it'll make a small sound, light up the screen
and ask the user to authorize the payment. The user then has the choice
of adding the merchant to trust list, authorizing just a single
transaction or not paying (and perhaps adding to the user's publicly
shared untrusted list?).

This way, even lacking a trust architecture, only the first payment to a
merchant needs to take several seconds. If trust is granted, the next
payments will be swift.

The lack of chargebacks presents a clear risk to the customer, though,
so a need for a third party that can keep the merchants honest exists.
This opens up markets for transaction insurance companies. Even though
bitcoin transactions are final, if a transaction insurance company
offers to cover your losses in the event of fraudulent charge, the risk
is practically eliminated.

Such an insurance company would have a strong incentive to make sure the
merchants they insure for behave. Otherwise they'll suffer the losses. I
think this would result in an equally trustworthy but more decentralized
system than with credit cards.

- Joel

On 06.03.2014 16:20, Brooks Boyd wrote:

-------------------------------------
If this policy of mining empty blocks upon new block headers before
downloading and verifying the blocks became the standard, then wouldn't the
marginal orphan probability per transaction vanish?  It seems like this
could be a way to seriously reduce transaction fees.


On Sun, Apr 20, 2014 at 10:44 PM, Daniel Lidstrom <lidstrom83@gmail.com>wrote:

-------------------------------------
On Tue, Mar 25, 2014 at 08:40:40PM +0000, Ricardo Filipe wrote:

I think is actually a major fundamental disagreement, and opinions
tend to correlate strongly with salary considerations.

"It is difficult to get a man to understand something, when his salary
depends upon his not understanding it!" -- Upton Sinclair

Let us either agree to disagree, or get on with moderating this list 
so that only sensible salaried discussions can take place.


-------------------------------------


This seems to come up a lot. Your definition of rational is a short term
rationality only. I can pass up a short term profit in return for more
stable longer term profits and be completely rational, by a reasonable
definition of the word.

I think it's clear by now that if most or even some miners decide to
prioritise short term profit over the long term health of the system (i.e.
longer term profit), Bitcoin basically doesn't work right. This attack is
only one of several such things that can happen. This certainly can be a
problem when difficulty is skyrocketing because a mining investment is I
guess quite short term anyway, but presumably at some point the mining arms
race will end and miners will become more settled in.
-------------------------------------
I'm asking for how to DEVELOP THE CODE so I can trade between two block 
chains, and then I'm going to start trading cats and dogs and bits.

Somewhere in trying to figure out the design spec we got caught up in existential
concern about 'globally knowable and accurate price history', and I'm telling you
it doesn't matter.

I'm the customer and the developer, someone give me a clear design document to
trade between two chains and I can write it, and then we can debate improvements.
 

On Sat, Mar 01, 2014 at 01:33:25PM -0500, Jeff Garzik wrote:

-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
At the start of February we had 10,000 bitcoin nodes. Now we have 8,500 and
still falling:

   http://getaddr.bitnodes.io/dashboard/chart/?days=60

I know all the reasons why people *might* stop running a node (uses too
much disk space, bandwidth, lost interest etc). But does anyone have any
idea how we might get more insight into what's really going on? It'd be
convenient if the subVer contained the operating system, as then we could
tell if the bleed was mostly from desktops/laptops (Windows/Mac), which
would be expected, or from virtual servers (Linux), which would be more
concerning.

When you set up a Tor node, you can add your email address to the config
file and the Tor project sends you emails from time to time about things
you should know about. If we did the same, we could have a little exit
survey: if your node disappears for long enough, we could email the
operator and ask why they stopped.
-------------------------------------
BIP: https://github.com/petertodd/bips/blob/bip-node-bloom/bip-node-bloom.mediawiki

Pull-req: https://github.com/bitcoin/bitcoin/pull/2900

Pretty simple really: service bit NODE_BLOOM is defined to allow nodes
to advertise to their peers that they support bloom filters. The network
protocol version number is also bumped. Recommended behavior for nodes
that do not support bloom is to simply disconnect peers who send a
filter* message anyway to let them quickly find another peer.

Rational: Bloom filters are not always supported or appropriate. For
instance no node implementation other than Bitcoin Core supports them,
e.g btcd and obelisk. (which ironically implement this BIP already,
modulo the version number bump) In the long term bloom filters will be
obsoleted eventually as they have poor scaling properties - problematic
with blocksize increases - and are incompatible with UTXO/TXO
commitments, which will use prefix-based filtering instead. (already
being implemented in electrum and obelisk)

In the short term bloom filters have high IO loads, which have lead to
DoS attacks, and are not an optimal use of resources for nodes which are
IO constrained rather than bandwidth constrained. (common in VPS setups
which could better help the network by serving full blocks)

Adding NODE_BLOOM as a service bit now will save us some hassle later
down the road, reflects what actual implementations do anyway, has been
already deployed on Litecoin, Dogecoin, and a zillion other alts with no
issues, (including SPV client support) and is a trivial patch.


Gregory Maxwell: Please assign a BIP #

-- 
'peter'[:-1]@petertodd.org
000000000000000049066dab2483c9e069656239f5782da204bd4995bd92c19f
-------------------------------------

See https://github.com/bitcoin/bitcoin/pull/5387

Wladimir


-------------------------------------
A few thoughts on this:

(1) Base64 of SHA256 seems overkill. 256 bits of hash is a lot. The risk
here is that a MITM intercepts the payment request, which will be typically
requested just seconds after the QR code is vended. 80 bits of entropy
would still be a lot and take a long time to brute force, whilst keeping QR
codes more compact, which impacts scannability.

(2) This should *not* be necessary in the common HTTPS context. The QR code
itself is going to be fetched from some service, over HTTPS. I see no
reasonable attacker that can MITM the request for the BIP70 message but not
the request to get the QR code. Adding a hash makes QR codes more bloated
and harder to scan, all on the assumption that HTTPS is broken in some odd
way that we haven't actually ever seen in practice.

(3) This can be useful in the Bluetooth context, but then again, we could
also do things a different way by signing with the key in the first part of
the URI, thus avoiding the need for a hash.

I know I've been around the loop on this one with Andreas many times. But
this BIP doesn't fix any actually existing problem in the previous spec. It
exists because Andreas thinks SSL is useless. If SSL is useless we all have
much bigger problems.
-------------------------------------


Le 24/04/2014 09:10, Pieter Wuille a crit :

yes, I saw that.

In particular, bip64 stipulates that the wallet "never mixes coins
across different accounts". This is not what Electrum does currently.
The UI allows you to chose between two modes: activate a single account
(and the wallet will only use UTXOs from that acccount), or activate all
accounts (and spend from all of them simultaneously).

Concerning multisig addresses, I have changed my mind: Electrum will use
parallel BIP32 trees. A wallet will not mix standard and multisig
accounts. I think that is better in terms of UX.

I agree with Mike Hearn's view that wallets with multiple accounts are
probably too difficult to deal with for most users. If a user feels the
need to have different "accounting identities", they will probably
create different wallet files, instead of creating bip32 subwallets.

However, since multiple subwallets have been asked by many users,
Electrum will propose them. But this should not be the default. More
important, multiple accounts should never be required (in my previous
implementation, they were required for multisig, because the wallet was
creating multisig addresses in dedicated multisig accounts)

Thomas


-------------------------------------

ZeroMQ is just a lightweight message routing system. It could just as
well make P2P messages available to other applications (if they
subscribe to them). The other way around, routing messages from ZeroMQ
to certain P2P clients, is easy.

Wladimir


-------------------------------------
RE: taking discussion elsewhere:

Yes, please, the purpose of this mailing list is technical discussions to
encourage interoperability of Bitcoin implementations, improve ease-of-use
and security, etc.

-- 
--
Gavin Andresen
-------------------------------------
On Sun, Aug 10, 2014 at 4:07 PM, Bob McElrath <bob_bitcoin@mcelrath.org> wrote:

This is actually an independent problem (though something to be aware
of). Flaky hardware can make synchronization fail completely - as it
relies on being able to exactly assess the validity of everything in
the blockchain.

Stilll...


Orphan blocks during synchronization are unfortunately very common,
and the result of a mostly broken download logic in the client. They
are blocks that are further ahead in the chain than the point where
you're currently synchronized to, and thus can't be validated yet.
Note that 'orphan' here means 'we do not know the parent'; it doesn't
just mean 'not in the main chain'. They are blocks that are received
out of order.

As Jeff mentions, headers-first synchronization fixes this problem
(and many other download-logic related things), by first verifying the
headers in the chain (thus already having partially validated
everything), and then downloading the blocks (in not necessarily the
right order) anymore, from multiple peers in parallel. There is
currently a pull request for it, but it's not production ready
(#4468).


Yes and no. While you're still synchronization, and don't actually
know the best chain, a peer could send you stale branches (with valid
proof of work), which you would accept, store and process. But it has
to be done very early, as once you learn of a good-enough chain, a
branch with more proof of work would be requires due to some
heuristics designed to exactly prevent such an attack.

-- 
Pieter


-------------------------------------
On Fri, Jun 06, 2014 at 02:03:29AM -0700, Gregory Maxwell wrote:

Yup. Obelisk's indexing is sufficiently fast that they hadn't even
bothered making Dark Wallet store transaction information between
sessions until recently. Prefix brute-forcing isn't yet implemented,
although prefix filters is being implemented for lookups in general. (at
the very least it gives the server operators some valuable plausible
deniability)

-- 
'peter'[:-1]@petertodd.org
00000000000000003a68ee16d702ca5dd5547fb4aead910a004747cb06241dd6
-------------------------------------
The upcoming release of breadwallet uses the height of the blockchain to
enforce timed pin code lockouts for preventing an attacker from
quickly making multiple pin guesses. This prevents them changing the
devices system time to get around the lockout period.

Aaron

On Thursday, July 24, 2014, Ron OHara <ron.ohara54@gmail.com> wrote:



-- 

Aaron Voisine
breadwallet.com
-------------------------------------
Hello Angel,

Good initiative. This looks good. If I understand, the dropdown menu is for
the whole application, so it make sense to have it in a common part of the
layout.

A slight optimisation would be to write the unit in the transaction table
header too (since we read from top to bottom). This would give something
like "Amount (mBTC)". That way, the user doesn't have to think twice about
the unit of his values.


Hope it helps,





On Fri, May 30, 2014 at 6:39 PM, Angel Leon <gubatron@gmail.com> wrote:



-- 
sebastien requiem
-------------------------------------
On Mon, Mar 3, 2014 at 12:02 AM, Tom Geller <tom@tomgeller.com> wrote:


It's not entirely trivial as you have to make sure you're editing on the
0.9 branch not the master branch, but can be done like this:

- Go to https://github.com/bitcoin/bitcoin/blob/0.9.0/doc/release-notes.md
- Click "edit"
- Make your changes and add a commit message describing the change, usually
something like 'doc: Add missing foowidget to release notes'.

Wladimir
-------------------------------------
On 05/15/2014 07:48 PM, Gregory Maxwell wrote:

I just used "nslookup", after seeing the issues in bitcoinj.

I agree that clients should be robust regarding DNS lookups (and
bitcoinj isn't), but still I think the first step needs to be
maintaining a quality infrastructure.




-------------------------------------
On 4 April 2014 01:42, Matt Whitlock <bip@mattwhitlock.name> wrote:

Right, of course.  Sorry, I didn't notice there was an update.  Two
bytes are plenty.

I'm worried however about the dependency on SHA-512, which may be
stretching it for a tiny embedded application.  The other uses of
HashL can be avoided.  We are balancing here between consistency with
the rest of this proposal, where everything is done via HashL, and
consistency with the general practice of generating fingerprints with
SHA-256, like in Base58Check.

Similarly, re-assembly software suddenly finds itself having to
implement Hash16 just to check this particular fingerprint.  So I'd
vote for a more traditional approach here, also considering that HashL
is designed specifically to generate numbers in a finite field.


It's been a tradition to support it in general, however I guess it's
not really needed here.  I'm happy without a dedicated testnet
encoding.


Yes, "5" for uncompressed private key and "K" or "L" for compressed
private key.  One A/VB and three prefixes in base58.  Am I the only
one to see this as a counter-example?

However, thinking about this, I can find logic in wanting to stabilise
text prefixes at a cost of six A/V bytes (as per the latest spec).
There are only 58 first characters versus 256 AVBs, so we should
rather be saving the former.


Fair enough.  Although I would have chosen the field order (p) simply
because that's how all arithmetic already works in bitcoin.  One field
for everybody.  It's also very close to 2^256, although still smaller
than your maximum prime.  Now of course with different bit lengths we
have to pick one consistency over others.


Wow, big deal.  It's hard to imagine anyone needing exactly 256
shares, but who knows.  And with j = x (starting from 1) we'd get
user-friendly share numbering and simpler formulas in the spec and
possibly in the implementation, with no off-by-one stuff.  And M
instead of M-2...


Exactly.  Thank you.  Without these fields, a secret share still fits
into a 29x29 QR code.  Add one more byte and it'll need a 33x33.
Imagine engraving that onto metal plates!  Or the hassle of going
above 32 bits per line in a tiny embedded system.


-------------------------------------
clarification, I am not a doge dev.  It was intended just as a joke, to
make you laugh.

regarding pull requests improving these issues I am under the impression
that the developers will take care of what needs to be taken care of in
that regard.  Am presently in collaboration on a bitcoin project that may
implement aspects of the ABIS concept as presented, but it is in very very
early stage(es).

I hope you had a good laugh, that was my intent. good morning / afternoon
/ evening





-------------------------------------

That's fair. From the server perspective, I'd argue that payment requests /
payments already need to be publicly accessible endpoints. Current
practical use requires support for cross-app/cross-device requests for
them. It seems like a reasonable logical extension to explicitly allow for
them to be accessed cross-site as well.

For this to be useful, someone would have to actually want to fully

I think there is still value in fetching the payment request cross-site
even if the request payload is validated by a 3rd party using a more
conventional TLS/crypto suite. Exposing x.509/RSA/ASN.1/chain verification
functionality strikes me as a useful thing browsers could easily offer but
that's another discussion entirely but sure it could be done all in JS. In
certain environments downloading a "real app" isn't possible/practical.



It certainly won't be if there is no ability :)

-Andy
-------------------------------------
I think it should be made more clear what's the reference price for the
discount. In Germany, we generally don't use credit cards but rather
"EC-Cards", which is already much cheaper. Or maybe for some merchants
the only alternative is cash, and they would still offer a Bitcoin discount.

Also, currently PR are created by the payment processors afaik. How can
they know what other payment option the merchant provides and what's the
conditions? Maybe we should first solve the signature delegation problem
so that the merchant can create the request.

Although I'm sure this feature will get abused, I (as a wallet author)
would be willing to give it a try. I agree with Jeff that the name of
the field should start with something like "marketing".


On 06/24/2014 03:27 PM, Mike Hearn wrote:




-------------------------------------
Then of course I tried to do this with BIP 10 
<https://github.com/bitcoin/bips/blob/master/bip-0010.mediawiki> when
Armory implemented offline-transactions two years ago.  I got some
positive feedback, but no one wanted to help improve it, etc.  I guess
nobody else was doing it and/or cared at the time.  So I continue to use
BIP 10 even though it's pretty crappy.  I wanted it to be useful for
multisig, too, but it has some deficiencies there (it was done when
Armory was extremely young and OP_EVAL was still on the table).

However, with all this activity, we should start thinking about that and
discussing it.  Otherwise, I'll just do my own thing again and probably
end up with something that fits my own needs, but not anyone else's. 
Really though, multisig shouldn't require all the same app to work.

-Alan


On 03/10/2014 01:49 PM, Gavin Andresen wrote:

-------------------------------------
On Thursday, March 13, 2014 4:37:02 PM slush wrote:

Please don't bring locale into this. Bitcoin has always been intentionally 
locale-independent (hence BTC using xxx,xxx,xxx.xx format even in locales 
which swap the commas and periods). Localising display makes different locales 
more or less incompatible at a human level, even if they use the same 
blockchain.

Luke


-------------------------------------
On Tuesday, 15 April 2014, at 6:39 pm, Chris Beams wrote:

The intent is to open-source it. We will do so when I'm confident that we have all the kinks worked out.

Here's what it can do presently:

$ ./btctool
usage: ./btctool <function> [<args>]
  encode16
    Encode stdin to hex.
  decode16 [<hex>]
    Decode hex from stdin or string.
  encode64 [<hex>]
    Encode stdin or octets to Base64.
  decode64 [<base64>]
    Decode Base64 from stdin or string.
  encode58 <version> [<hex>]
    Encode stdin or octets to Base58Check.
  decode58 [<base58>]
    Decode Base58Check from stdin or string.
  disassemble [<script>]
    Disassemble hex script.
  sha256 [<hex>]
    Hash stdin or octets using SHA-256.
  rmd160 [<hex>]
    Hash stdin or octets using RIPEMD-160.
  privkey [<hex>]
    Derive private key from stdin or octets.
  pubkey [<privkey>]
    Derive public key from private key.
  address [<pubkey>]
    Derive address from public key.
  address <m> [<pubkey>...]
    Derive m-of-n P2SH address from public keys.
  encrypt [<privkey>]
    Encrypt private key per BIP38.
  decrypt [<privkey>]
    Decrypt private key per BIP38.
  shares <m> <n> [<privkey>]
    Distribute private key into m-of-n shares.
  join [<share>...]
    Join shares to reconstitute private key.
  privkeys <k> [<privseed>]
    Derive k private keys from private seed.
  pubkeys <k> [<pubseed>]
    Derive k public keys from public seed.
  addresses <k> [<pubseed>]
    Derive k addresses from public seed.
  addresses <k> <m> [<pubseed>...]
    Derive k m-of-n P2SH addresses from public seeds.

$ ./chaintool
usage: ./chaintool <function> [<args>]
  init
    Initialize a new cache file.
  add <label> <pubkey>
    Add a public key.
  add <label> :<pubseed>
    Add a public seed.
  add <label> <m> {<pubkey>|:<pubseed>}...
    Add public keys/seeds for m-of-n P2SH.
  rm <label>
    Remove a public key or seed.
  ls
    List public keys and seeds.
  sync <blocksdir>
    Synchronize with block chain.
  tip
    Print hash of block at tip of main chain.
  getbalance [<label>...]
    Get available balance.
  listunspent [<label>...]
    List unspent outputs in JSON.
  createtx [<fee>] [<label>...]
    Create transaction from address+amount pairs on stdin.
  signtx <tx> [{<privkey>|<privseed>}...]
    Sign transaction with private key(s)/seed(s).



-------------------------------------
Culturally neutral? "bit" in French phonetically collides with slang
for phallus ("bitte", with a silent "e"). Apparently it means "louse"
in Turkish as well.

Not that this really would be avoidable with any short word (all the
short possible words are usually taken), but it's not neutral.

On Sun, Apr 20, 2014 at 2:43 PM, Oliver Egginger <bitcoin@olivere.de> wrote:


-------------------------------------
So I looked into gitian, the first thing I noticed was the hashes that  
people were signing, for example:

    https://github.com/bitcoin/gitian.sigs/blob/master/0.8.6-win32/gavinandresen/bitcoin-build.assert

don't match the hash of the file 'bitcoin-0.8.6-win32-setup.exe' actually  
hosted by sourceforce. That was a bit alarming at first, but I talked to  
BlueMatt and maaku on IRC and the difference is due to Gavin Authenticode  
signing the executable for windows.

BlueMatt asked if someone could implement in gitian-downloader a way to  
strip off the signature so that we could get back to the raw binary with a  
hash that matches what everyone is producing from gitian.  I found:

   http://blog.didierstevens.com/programs/disitool/

which is a Python script which can strip the signature nicely, but the  
hashes still don't match.

I couldn't find a gitian build of 0.8.6 so I built my own, and after  
verifying the hash for v0.8.6 was '49547ff9...' as expected I looked at  
the hex diff between that and the sig-stripped .exe from sourceforge, and  
the only two differences are:

   - At offset D8 the stripped file has '5D E2 B2' versus 'F9 F4 00' in the  
gitian build
   - The sig-stripped file has an extra byte '00' at the end

I started to look at the file spec for windows PE files and quickly  
thought better of it. Maybe someone better informed can chime in on what  
those three bytes at offset D8 specify.

I'm not sure if we want to patch the signature onto the gitian build, or  
strip the signature off of the Gavin-signed build, but something of the  
sort is necessary if you want get gitian-downloader to match the official  
distro (for Windows at least).

In any case, I think wallet users want to know when an upgrade is  
available, and ability to click an 'update' button get a binary they can  
trust. It's not a problem unique to bitcoind, deterministic builds are  
awesome, but I don't think fully solve it.

Thanks,
Jeremy

On Tue, 31 Dec 2013 13:33:54 -0800, Matt Corallo  
<bitcoin-list@bluematt.me> wrote:




-------------------------------------
On Sat, Aug 23, 2014 at 07:02:55PM +0000, Luke Dashjr wrote:

Mike is correct here: It *might* be public information, and probably
won't be. We already can give weak assurance that it probably won't be
against many weaker attackers, simply because getting lots of IP
addresses is moderately expensive, and in the future additional methods
will be developed and deployed.

-- 
'peter'[:-1]@petertodd.org
0000000000000000239344fc532bbad8a679e3fc30e8900772523a10c4720a0c
-------------------------------------

Yes, it's certainly better to do that during the development phase. However
if it does turn out to be good and valuable then it'd eventually need to be
integrated or rewritten into Core anyway, lest we accidentally increase the
setup cost of running a node and end up with a two-tier network. And if the
code will eventually want to be merged into Core anyway, it might as well
be implemented into it directly, perhaps behind a switch that can disable
those codepaths if something goes wrong.

So I think the tradeoffs here are rather complicated and subtle.
-------------------------------------
On 06/17/2014 06:46 PM, Gregory Maxwell wrote:
Can anyone summarize the current status of the bounty? I see nothing 
definite about the bounty in that thread from the beginning of January 
2014, other than that the multisig address continues to accumulate 
bitcoins. Meanwhile, on other mailing lists, I've seen some talk about 
paying a portion or the whole of the bounty to the Dark Wallet team.

-Kristov


-------------------------------------
Is anyone working on a serialisation format to convey P2SH HD chains? For 
example, to give someone who wants to make recurring payments a single token 
that can be used to generate many P2SH addresses paying to a multisig script.

I'm thinking of something along the lines of a simple series of tokens, each 
indicating either a HD chain or literal script content. For all HD chains in 
the data, a child key would be generated based on the payment number, and all 
tokens concatenated to form the P2SH serialised script. Eg, for a simple 2-
of-2, you would do something like this:
    literal(OP_2) HDChain HDChain literal(OP_2 OP_CHECKMULTISIG)
Does this sufficiently cover all reasonable use cases?

Luke


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

That is mistaken: you can't mine on top of just a block header, leaving small miners disadvantaged as they are earning no profit while they wait for the information to validate the block and update their UTXO sets. This results in the same problem as before, as the large pools who mine most blocks can validate either instantly - the self-mine case - or more quickly than the smaller miners.

Of course, in reality smaller miners can just mine on top of block headers and include no transactions and do no validation, but that is extremely harmful to the security of Bitcoin.


On 20 April 2014 23:58:58 GMT-04:00, Mark Friedenbach <mark@monetize.io> wrote:
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJTVJlDMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhTbNB/4lHTsUN/iee7H0UyBn
+TDRgf1BSoUx9HP+vtwXzS0JkVQoxoB5x4Pls+ex7qIXGNxdG9EPYi1RqQ5A8RUo
X2ntOL2pj6qTmW4aYxqqyihiQayLs5ixHPmJxqHv343g5ekqsKmBeDuWR4hXjUyZ
0Pfcp40Xd3eJ38dSbq98letl5eD+ryBPKYtb91Trumqa9S0WB8kw9IqNaXjlpfG1
lYuaVEllpaLpZW+4cx1mlPneS1GmLvloWhXf4Qh4X39VXECAjOAmNKh1atJCyT7H
ugkOcx1F2Rxo5P3jNzBRJKyAD96sbOhKm4sX7rzSjhT3WJgyHtJm3wkeluDCOVbR
QZqK
=R7Tv
-----END PGP SIGNATURE-----



-------------------------------------
On 04/23/2014 11:22 PM, Gregory Maxwell wrote:

That is a subjective matter. To me it makes PERFECT SENSE that funds
across accounts NEVER MIX. One can still send funds from one account to
another and then perform another spend.

That's what I consider a consistent and thus GOOD user experience.
What's the purpose of Accounts if wallet mixes coins among them anyway?

I know it's not good to use classic bank accounts as analogy, but that's
exactly how they work. Or have you every done ONE transaction from two
bank accounts simultaneously?

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
A cup of coffee in Tokyo costs about 55 yen. You see similar magnitude
numbers in both Chinas, Thailand, and other economically important East
Asian countries. Expect to pay hundreds of rupees in India, or thousands
of rupees in Indonesia.

This concept that money should have low, single digits for everyday
prices is not just Western-centric, it's English-centric. An expresso in
Rome would have cost you a few (tens of?) thousand lira in recent
memory. It was pegging of the Euro to the U.S. dollar that brought
European states in line with the English-speaking world (who themselves
trace lineage to the pound sterling).

No, there is no culturally-neutral common standards for currency and
pricing. But there are ill-advised, ill-informed "standards" in
accounting software that we nevertheless must live with. These software
packages do not handle more than two decimal places gracefully. That
gives technical justifications for moving to either uBTC or accounting
in Satoshis directly. An argument for uBTC is that it retains alignment
with the existing kBTC/BTC/mBTC/uBTC conventions.

However another limitation of these accounting software practices is
that they do not always handle SI notation very well, particularly
sub-unit prefixes. By relabeling uBTC to be a new three-digit symbol
(XBT, XBC, IBT, NBC, or whatever--I really don't care), we are now fully
compliant with any software accounting package out there.

We are still very, very early in the adoption period. These are changes
that could be made now simply by a few big players and/or the bitcoin
foundation changing their practice and their users following suit.

On 03/14/2014 07:49 AM, Andreas Schildbach wrote:


-------------------------------------
Just chiming in...

I'm not opposed to a more generic default key tree, but we need to
standardize this soon I believe. There are already existing code bases
that implement BIP32 wallets (and more are popping up...); just using
a separate one will result in lots of incompibilities.

That said, I'm not convinced about the extra layers. The "cointype" in
my opinion isn't necessary inside the derivation. There is already
support (4 bytes!) for magic bytes in the serialized form. Inside
applications/p2p it should always be known to which chain it applies,
and outside of that you shouldn't transfer raw keys. Maybe seeds need
some marker, but that's a separate case anyway. Mainnet and testnet
have specified magics here already - alts can define what they want
imho.

A 'reserved' field for future extensions may be useful, but as already
suggested by Mike, I don't believe we can encode how key chains are to
be used inside the derivation structure anyway. The most basic case
(not losing money in a wallet without special structure) can perhaps
be supported with just "the blockchain is your wallet", but I don't
believe this principle can scale to more advanced uses anyway, and you
need metadata in the wallet to deal with it.

In my view, your wallet just has a bunch of chains, and each chain
gets used for a particular purpose, fixing how the derivation beneath
it works. Either that is as a wallet, as part of a pair of multisig
keys, as a recurring payment receiver, ... or more complex things.
Some of these will require extra layers beneath, but that is
application specific. You would import a chain into your (advanced)
wallet with a particular extpub/extpriv code, and some metadata on how
to use it. Serialization formats for such designated extra uses sounds
better to me than trying to fit it into the derivation structure.

-- 
Pieter


On Thu, Mar 27, 2014 at 4:57 PM, Allen Piscitello
<allen.piscitello@gmail.com> wrote:


-------------------------------------

I only know of one site that worked the way you propose: TicketMaster, a
long time ago. They used it as a less harsh form of blocking for IPs that
they strongly suspected were bots, which is what you suggest indeed. But
99% of the hard work of that system was in scoring the connections. The
actual PoW part didn't work that great because bots have much more patience
than humans do.

Other sites also use proofs of work, but they're CAPTCHAs i.e. human PoWs.
And unfortunately those don't work very well these days either :(




Yes, I understand, but then you're back to scoring clients - the hard part
- and the only question is do you slow down that client by sticking them at
the bottom of a work queue or by requiring them to solve a difficult PoW.
The best approach is the first one because that scales naturally .... you
don't have to define some notion of misbehaviour, you just prioritise
amongst clients.

The current notion of "misbehaviour" is only somewhat useful. It's easy to
classify reasonable behaviour as harmful and shoot yourself in the foot. We
managed this at least once back in 2010 when we actually released a version
of Bitcoin that interpreted a normal request to serve the block chain as a
DoS attack! It couldn't serve the chain at all! Additionally many things
that can be interpreted as an attack like sending a message with a bad
signature can also be caused just by mistakes, or version skew during
software upgrades. So it's very tricky to get this right.

That's important because one quite common way big sites suffer DoS attacks
is by accidentally having real users create a DoS "attack" by e.g. pushing
a bad software update, or by having sudden and unexpected press-driven
growth, etc. You really don't want to force users to sit around waiting and
wasting battery. It's better to serve as many requests as you can up to
your absolute limit and try to ensure as many of them as possible are good.



I doubt it matters. Any DoS attack that's powerful enough to use up most of
the networks resources is probably being driven by a botnet of some kind,
and *all* legitimate users will lose in an even fight against a botnet.

Cookies can be somewhat anonymized. For example a cookie that is merely a
signature over a timestamp of some kind (doesn't have to be an secp256k1
signature) can be normalised to the day or week. So you can prove you've
been using Bitcoin for say 3 years but it doesn't pin you down precisely.

This isn't perfect:  attackers can and do "age" accounts before preparing
for abuse. Proof of UTXO is another way to rank users. If you're richer
you're presumably more important for the network to process than poor
people. However you end up back at a CPU imbalance. PoW can possibly play a
role here to even it out: the cost of submitting a UTXO proof should be at
least equal to the cost of verifying the signature, but that is a PoW small
enough that users would not notice.
-------------------------------------
Advertising NODE BLOOM as a service sounds good.

But the critique of bloom filters, I am not so sure prefix filters are
better.  Prefix filters offer questionable privacy tradeoffs in my opinion. 
Same problem as with stealth address proposed use of prefixes.

All for scalability, efficiency and decentralization but not ideally at the
expense of nuking privacy.  The effects on privacy are cumulative, and
affect everyone not just the user.  Same pattern of local decision, global
effect as with reused addresses.

Adam

On Fri, Jun 06, 2014 at 04:19:33AM -0400, Peter Todd wrote:


-------------------------------------
Whenever you do a reissuing of a transaction that didn't go through
earlier, you should make sure to reuse one of the inputs for it. That
guarantees that both cannot confirm simultaneously.

On Sat, Jun 7, 2014 at 12:21 AM, Ral Martnez <rme@i-rme.es> wrote:


-------------------------------------
On Thu, Mar 20, 2014 at 07:31:27PM +0100, Mike Hearn wrote:


I'm not sure if this what you're getting at, but in a common
face-to-face scenario, it really doesn't overlap so much (in that the
PKI in BIP70 isn't really helpful).

It's not unusual, in a face-to-face transaction at a bricks-and-mortar
establishment, that you know neither the legal name of the entity
running the establishment, nor any electronic identifier (domain name,
email address) that might be presented to you in an X.509 certificate,
even if such a certificate is presented in the PaymentRequest.

In many cases I want/need to simply be assured that I am paying "the
person/organisation which operates that machine behind the counter,
right there".

In many ways I'll miss the simplicity of BIP21 QR codes for
face-to-face transactions - because in this use case the payment
protocol complicates (and in many cases weakens) the assurance that
you really are paying the entity that prepared the QR code.

roy


-------------------------------------
The alert system filters based on the clients version number.

The ubuntu bitcoin ppa is dynamically linked to openssl unlike the 
binaries available from bitcoin.org

There is no way currently to notify users of 0.9.0 w/ static linking 
without also notify 0.9.0 w/ dynamic linking.

On 04/19/2014 04:34 PM, Oliver Egginger wrote:



-------------------------------------
Hi there,

I'd like to start a discussion on periodic rotation of outbound connections.
E.g. every 2-10 minutes an outbound connections is dropped and replaced
by a new one.

Motivation:
Each bitcoin non-UPnP client behind NAT has 8 outbound connections
which change only rarely (due to occasional remote side disconnections).
A subset of these 8 entry nodes uniquely identifies a user.
An attacker can listen for transactions in Bitcoin network and for each
transaction record the first 8 peers which forwarded the transaction.
If two distinct transactions (with unrelated bitcoin addresses)
come from the same set of 8 peers, the attacker can conclude that they
originated from the same user. This gives another method (in addition
to transaction graph analysis) for an attacker to link different BC
addresses of the same user.
Also note that by default bitcoin clients advertise their public IP
addresses. The attacker can link the advertised IP's to corresponding
8 entry nodes and use it to deanonymise Bitcoin clients.

If a bitcoin client periodically rotates his set of outbound
connections, his 8-peers fingerprint is blurred over time.

Corresponding pull request is #4723.

Some details are here: https://www.cryptolux.org/index.php/Bitcoin

-- 
Ivan


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 05/19/2014 09:11 AM, Jeff Garzik wrote:

If we're talking about making bitcoind behave like a proper daemon,
then syslog support should be on the list.

Also, the option to store things in FHS-compliant directories (not
somewhere/.bitcoin)
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQEcBAEBAgAGBQJTebHTAAoJEMP3uyY4RQ2170IIAMDcx5rj/ZlCTJTOJ2sFttFM
miK9t7oewJ73UpgvFniCUngfjk9Tt5knmskQYEMQ5C9Do/P3Deh1gF6MBBuuai5G
kDNDv51zMEqhwGcqGrPYFMV3NEnBEjullTMgJFvKJf1kZRo7uplwp+eUhILjgSY5
mZjLIUK8iKDNn+Pi8/2UetAvyaRibHAsAnkJnEeOoKAhxUbtzjgZsj08loCCmJrs
RleOTLgArdc33e1bwTTwsS9DDvF18RNTACglsc75Oz0ohHyc5U1A1hBfaRuyu6Fv
8BK+0KPg/zdBCnM1m3aueVukg9p3kIfB2VUVFBHBTo4CPMi91k6oldbfRHy8dXw=
=SjxO
-----END PGP SIGNATURE-----


-------------------------------------
A bunch of different people either have implemented or are implementing
BIP70 at the moment. Here's a bunch of things I've been telling people in
response to questions. At some point I'll submit a pull req with this stuff
in but for now it's just an email.

*Error handling during signature checking*

I've had queries around the right behaviour here. BIP 70 is underspecified
and we should fix it IMO. If PKI checking fails you should just treat the
request as if it's unsigned. The reason is that there is no incentive for
an attacker to break the signature instead of just removing it entirely, so
an attacker would never trigger any error flows you put in. However,
someone who is signing their request with an unknown CA or using an
upgraded version of the protocol that isn't entirely backwards compatible
*could* trigger signature checking failure.

Therefore, in order to make introducing new (possibly community run) CA's
or new variations on signing possible, please treat any errors as if there
was no signature at all. This is not what browsers do,  but browsers have
an advantage - they were already given an identity and told to expect a
secure protocol when the user typed in the web address with an
https://prefix (or clicked a link). Unfortunately a Bitcoin wallet has
no context
like this.

One person asked me whether this makes the whole scheme pointless because a
MITM can just delete the signature. The answer is no - downgrade attacks
are always possible on systems that start out insecure. The solution is to
train users to expect the upgrade and refuse to go ahead if it's not there.
Training users to expect signed payment requests will be a big task similar
to the way the browser industry trained users to look for the padlock when
typing in credit card details, but it must be done.

Because wallets lack context there's no equivalent to HSTS for us either.
So in your GUI's try to train the user - when showing a signed payment
request, tell them to expect the recipient name to appear in future and
that they should not proceed if it doesn't. This gives us a kind of mental
HSTS.

*Extended validation certs*

When a business is accepting payment, showing the name of the business is
usually better than showing just the domain name, for a few reasons:

   1. Unless your domain name *is* your business name like blockchain.info,
   it looks better and gives more info.

   2. Domain names are more phishable than EV names, e.g. is the right name
   bitpay.com or bit-pay.com or bitpay.co.uk?

   3. More important: Someone who hacks your web server or DNS provider can
   silently get themselves a domain name SSL cert issued, probably without you
   noticing. Certificate transparency will eventually fix that but it's years
   away from full deployment. It's much harder for a hacker to get a bogus EV
   cert issued to them because there's a lot more checking involved.

EV certs still have the domain name in the CN field, but they also have the
business name in the OU field.

In theory we are supposed to have extra code to check that a certificate
really was subject to extended validation before showing the contents of
this field. In practice either bitcoinj nor Bitcoin Core actually do, they
just always trust it. It'd be nice to fix that in future.

You should show the organisation data instead of the domain name if you
find it, for EV certs.

*pki=none*

Signing is optional in BIP 70 for good reasons. One implementor told me
they were considering rejecting unsigned payment requests. Do not do this!
A MITM can easily rewrite the bitcoin URI to look as if BIP70 isn't in use
at all.

Even though today most (all?) payment requests you'll encounter are signed,
it's important that signing is optional because in future we need
individual people to start generating payment requests too, and many of
them won't have any kind of memorisable digital identity. Plus other people
just won't want to do it. BIP70 is about lots of features, signing is only
one.

*S/MIME certs*

Email address certs look a bit different to SSL certs. You can get one for
free from here

    https://comodo.com/home/email-security/free-email-certificate.php

In these certs the display name can be found in the Subject Alternative
Name field with a type code of 1. Example code:


https://github.com/bitcoinj/bitcoinj/commit/feecc8f48641cd02cafc42150abba4e4841ea33d

You won't encounter many of these today except on Gavin's test site, but in
future people may wish to start creating and signing their own payment
requests for individual purposes using these certs (especially as they are
free). So please try to handle them correctly.

*Broadcast vs upload*

Please upload transactions and commit them to your wallet when the server
responds with 200 OK, but expect the merchant to broadcast them. Don't give
the user an option to pick - it's pointless as there's no obvious right
answer.

*Testing*

You can find a test site here:

http://bitcoincore.org/~gavin/createpaymentrequest.php

It's testnet only. For testing regular payment requests on the main
network, I use BitPay as they were the first seller-side implementation:

http://bitgivefoundation.org/donate-now/

*Memo contents*

Please put something useful here, ideally what is actually being sold but
failing that, the name of the merchant if you're a payment processor. Don't
be like BitPay and put large random numbers in the memo field but nothing
about what's actually purchased.

This is not particularly important today except for cosmetic reasons,
because wallets don't store the payment requests they saw to disk. But in
future they will and then a properly signed memo field + the transactions
used for payment give us a digital receipt. Receipts are useful for things
like filing expense reports, proving a purchase when returning an item to a
merchant, etc.

*Expiry times*

Don't be too aggressive with these. Although today it doesn't matter much,
some users may be trying to pay from multi-party accounts that require
multiple humans to coordinate to make a payment.
-------------------------------------
I doubt that this is possible (with the Android API). But I'll try.


On 03/06/2014 06:00 PM, Mike Hearn wrote:




-------------------------------------
On 1/30/2014 7:02 PM, Pieter Wuille wrote:
If you sent the Payment message and the server goes silent after 
receiving it, you retry to delivery.  However, the merchant can 
broadcast the transactions and force them into your wallet anyway. You 
could, quite likely, pay and never get an ACK.


-------------------------------------
On Wed, Apr 23, 2014 at 4:52 PM, Justus Ranvier <justusranvier@gmail.com>wrote:


As was already pointed out, yes. However this requires them to immediate
establish a majority consensus and be absolutely sure it really is the
majority. You suggest an out of band mechanism for that, but why is this
better than using the actual consensus mechanism you're trying to measure?




Bitcoin imposes far more rules than just execution of the scripting
language, many of which are entirely arbitrary and the result of
(controversial) human judgement, like the inflation schedule. You can't
claim Bitcoin implements only some kind of natural law.
-------------------------------------
Hello all,

It has been way to long since last major release. Many improvements and new
features have been added to master since, so we'd like to do a 0.9rc1
release soon.

The current aim is next month, February 2014.

Of course there are still some open issues that need to be resolved before
release
https://github.com/bitcoin/bitcoin/issues?milestone=12&state=open

If there is something else that you're working on and needs to end up in
0.9, or know of some nasty bug in master that should absolutely be solved
first, please tell.

Wladimir
-------------------------------------
AFAIK the only protection is SSL + certificate validation on client side.
However certificate revocation and updates in miners are pain in the ass,
that's why majority of pools (mine including) don't want to play with
that...

slush


On Fri, Aug 8, 2014 at 1:45 AM, Luke Dashjr <luke@dashjr.org> wrote:

-------------------------------------
* Summary

CoinJoin, CoinSwap and similar technologies improve your privacy by
making sure information about what coins you own doesn't make it into
the blockchain, but syncing your wallet is a privacy risk in itself and
can easily leak that same info. Here's an overview of that risk, how to
quantify it, and how to reduce it efficiently.


* Background

In the most general sense a Bitcoin wallet is a collection of one or
more scriptPubKeys, often known as addresses.(*) The basic purpose of
the wallet is maintain the set of all transaction outputs (txouts)
matching the scriptPubKeys in the wallet.  Secondary to that purpose is
to maintain the set of all transactions associated with scriptPubKeys in
the wallet; almost all (all?) wallet software maintains transaction
information rather than only txout data. Usually, but not always, the
wallet will have some mechanism to spend transaction outputs, creating
new transactions. (if the wallet doesn't it is referred to as a
watch-only wallet)

Given a full set of blockchain data the task of keeping the set of all
relevant transactions and txouts up-to-date is simple: scan the
blockchain for the relevant data. The challenge is to devise systems
where wallets can be kept up to date without this requirement in a way
that is secure, efficient, scalable, and meets the user's privacy
requirements.

*) Alternatively addresses can be thought of as instructions to the
   payor as to how to generate a scriptPubKey that the payee can spend,
   a subtlety different concept.


* Threat Model and Goals

Currently the Bitcoin network consists of a large (low thousands) number
of allegedly independent nodes. There is no mechanism to prevent an
attacker from sybil attacking the network other than the availability of
IP addresses. This protection is made even weaker by the difficulty of
being sure you have a non-sybilled list of nodes to connect too; IP
addresses are passed gossip-style with no authentication.

From a privacy perspective we are conservative and assume an active,
internal, and global attacker - using the terminology of Diaz et al.(1)
- that controls up to 100% of the nodes you are connected too. With
regard to retrieval of blockchain data we can use the Sweeney's notion
of k-anonymity(2) where the privacy-sensitive data for an individual is
obscured by it's inclusion in a data of a large set of individuals, the
anonymity set.


* Basic Functionality

With regard to blockchain data we have the following basic functions:

** Spending funds

The user creates a transaction and gets it to miners by some method,
usually the P2P network although also possibly by direct submission.
Either way privacy can be achieved through a mix network such as Tor
and/or relaying other users' transactions so as to embed yours within a
larger anonymity set. In some cases payment protocols can shift the
problem to the recipient of the funds. Using CoinJoin also helps
increase the anonymity set.

Usually the sender will want to determine when the transaction confirms;
once the transaction has confirmed modulo a reorganization the
confirmation count can only increase. Transaction mutability and
double-spends by malicious CoinJoin participants complicate the task of
detecting confirmation: ideally we could simply query for the presence
of a given txid in each new block, however the transaction could be
mutated, changing the txid. The most simple way to detect confirmation
is then to query for spends of the txouts spend by the transaction.


** Receiving new funds

While in the future payment protocols may give recipients transaction
information directly it is most likely that wallets will continue to
have to query peers for new transactions paying scriptPubKey's under the
user's control for the forseeable future.


** Detection of unauthorized spends

Users' want early detection of private key compromise, accomplished by
querying blockchain data for spends from txouts in their wallets. This
has implications for how change must be handled, discussed below.


* Scalability/Efficiency

The total work done by the system as a whole for all queries given some
number of transactions n is the scalability of the scheme. In addition
scalability, and privacy in some cases, is improved if work can be
easily spread out across multiple nodes both at a per-block and
within-block level.


* Reliability/Robustness

Deterministic wallets using BIP32 or similar, where all private keys are
derived from a fixed seed, have proven to be extremely popular with
users for their simple backup model. While losing transaction metadata
after a data-loss event is unfortunate, losing access to all funds is a
disaster. Any address generation scheme must take this into account and
make it possible for all funds to be recovered quickly and efficiently
from blockchain data. Preserving privacy during this recovery is a
consideration, but 100% recovery of funds should not be sacrificed for
that goal.


* Query schemes

** Bloom filters

BIP37 bloom filters are currently implemented by the Bitcoin reference
implementation and used by bitcoinj-based SPV clients. Bloom filters
achieve a privacy-bandwidth tradeoff by having probabalistic
false-positives; the false-positives comprise the anonymity set.

Boom filters have a number of problems, both in the specific BIP37
implementation, as well as fundemental to the idea. Scalability is a
serious problem: the client sends asks a peer with a copy of all
blockchain data to filter data sent to the client, limiting the client's
bandwidth to only the data they are interested in. In the typical case
of a SPV wallet syncronizing against m new blocks this requires the peer
to read those m blocks from disk in their entirety, apply the filter,
and send the client the subset of matching transactions. Obviously this
results in poor O(n^2) scaling for n clients each making some fixed
number of transactions.

Of course bloom filters are attractive in that they have very good
performance per match, but this performance is only really relevant for
the most recent blockchain information where the data is in RAM. For
older information they make possible the Bloom IO attack where an
attacker uses an inordinant amount of disk IO bandwidth at little cost
to themselves.(3)

The actual BIP37 standard, and existing implementations of it, have a
number of other flaws that reduce privacy. For instance the standard
lets the seed value of the hash function be tweaked with a 32-bit
integer, nTweak. However on the one hand if randomly chosen and rarely
changed, as suggested by BIP37, the 32-bit integer can be used by an
attacker to correlate multiple connections from the same wallet. On the
other hand if nTweak is changed an attacker that can link multiple bloom
filters can AND those filters together to greatly decrease the
false-positive rate and determine exactly what funds are in the user's
wallet.


** Prefix filters

With a randomly distributed keyspace - common in cryptographic
applications - clients can query using variable length prefixes that
partially match the desired keys. A very simple format for a query of n
prefixes will look like the following:

    <1 byte length in bits> <1 to 256/8 bytes of prefix>
    ...
    ...
    0x00

The anonymity set is then the blockchain data whose key is the same
prefix, usually H(scriptPubKey) or scriptPubKey directly. An important
advantage of prefix filters is compatibility with the proposed (U)TXO
commitment schemes: the prefix maps directly to the committed
scriptPubKey lookup trees, and nodes simply return all entries matching
the prefix, as well the the rest of the merkle path to the blockchain
headers proving the data is valid.

While bloom filters have O(n) cost per lookup, or O(n^2) scalability
system-wide, prefix filters have significantly better O(log n) cost per
lookup, or O(n log n) system-wide. It's also worth noting that a naive
implementation can achieve very similar performance to bloom filters
without bothering to build key-value indexes by just scanning blockchain
data; once the data is hashed testing the hash against a prefix has a
minimal cost.


** Cryptographically blinded schemes

There are many blinded database query schemes in existence. While we do
not reject such schemes completely, technologies that rely on simple and
easy-to-understand cryptography have a significant advantage in their
simplicity. In addition such complex schemes are unlikely to ever be
made into miner commitments and thus are less trustworthy in the long
run.


* Correlation attacks

It is often advantageous if blockchain queries can be efficiently spread
across multiple servers to avoid allowing the attacker to correllate the
information into a whole. If you have n addresses that need to be
watched for new transactions, splitting the queries across m nodes
reduces the information any one node may learn. With bloom filters doing
this is extremely costly as the full blockchain data needs to be read
from disk to apply the filter; with prefix filters if the nodes have
appropriate indexes there is little overhead to splitting the queries
and no performance loss.


* DoS attacks

A possible DoS attack on bandwidth is to insert a large amount of
blockchain data matching the target's filter; the BIP37 nTweak parameter
was an attempt to avoid this problem, although with privacy tradeoffs.
Blockchain data is an extremely expensive communications channel so we
do not consider this a serious issue. Implementations may wish to give
clients the ability to specify a filter for information they do not want
to avoid unintentional collisions, although hopefully in the future the
address reuse making this a potential problem will become less common.


* Address use, management, and generation

If privacy was not a consideration the most efficient mode of operation
would be to use a single address, as is done by many existing wallets,
notably the bitcoinj-derived Multibit and Android Wallet, both of which
use bloom filters. In addition to strongly encouraging address re-use,
neither provide the user any control over the privacy/bandwidth tradeoff
given by bloom filters; the default settings have an extremely low
false-positive rate that is a significant privacy risk.

Taking privacy into account better clients such as Electrum, Armory, and
Bitcoin Core discourage the re-use of addresses in their UIs, and send
change to new addresses. However this leads to problem with user
expectations: users expect it to be possible to be notified quickly of
new transactions paying any address ever generated by their wallet, as
well as unauthorized spends from any txout, yet for privacy each query
for transactions related to the address/txout must match false-positives
that consume bandwidth; for a fixed bandwidth budget the specificity and
size of the filter must increase over time.

We have two main avenues to solve this problem:

1) Txin-reuse: Continue to reinforce the idea that transaction inputs
   have no particular relationship to outputs. Using them for refunds or
   other purposes implying "ownership" must be strongly discouraged.
   CoinJoin will help here. If addresses associated with change txouts
   are truly one-time-use, we can reduce or eliminate queries associated
   with them. In particular, while the set of all change addresses ever
   used will grow linearly with time, the set of all change addresses
   with funds in them will remain roughly stable - it's this set that
   needs to be queried to detect unauthorized spends.

2) Common prefixes: Generate addresses such that for a given wallet they
   all share a fixed prefix. The length of that prefix determines the
   anonymity set and associated privacy/bandwidth tradeoff, which
   remainds a fixed ratio of all transactions for the life of the
   wallet.

With this approach change addresses continue to be generated randomly, a
requirement for CoinJoin privacy. There is some statistical information
leaked if many non-change txouts are spent in a single transaction in a
CoinJoin, but even that leak can be avoided with the authors
OP_RETURN-based stealth addresses proposal. (to be published)

The actual prefix-forcing scheme in many cases will have to be
brute-force search; fortunately the search space involved is reasonably
small, ~2 to ~16 bits, and can be done as a background task.


1) Towards Measuring Anonymity, Claudia Diaz and Stefaan Seys and Joris
   Claessens and Bart Preneel (April 2002)

2) k-Anonymity: A Model for Protecting Privacy, Latanya Sweeney, May
   2002

3) Private discussions with developers.

-- 
'peter'[:-1]@petertodd.org
000000000000000f9102d27cfd61ea9e8bb324593593ca3ce6ba53153ff251b3
-------------------------------------
On Tue, Dec 30, 2014 at 4:25 PM, Sergio Lerner
<sergiolerner@certimix.com> wrote:

Sergio there is no "abuse" there,  OP_NOP3 in that case would be
redefined to OP_COINBASE_FOO_CONSISTENCY.

(I say FOO because it's not clear what rule you actually hope to apply there.)

What you suggested has no purpose by itself: it would need an
additional change which overlays functionality in order to actually do
something. Such a change would likely be "ugly"-- it's easy to be
elegant when you do nothing.


-------------------------------------

And as I said before, that's a huge leap. A majority of miners deciding
double spending needs tougher enforcement doesn't imply they also think all
miners should identify themselves. Those are unrelated things.

This kind of totally unsupported "obvious next step" argument can be
applied to any proposal in any walk of life. We developed SPV clients? The
obvious next step is that miners have to stop being anonymous. We developed
floating fees? The obvious next step is that miners have to stop being
anonymous. The prior arguments sound absurd exactly because they're not
obvious or even logical - same as this.
-------------------------------------
You can always just extend the payment protocol with the new fields as
well, vs making very long addresses. If this technique can be made to work
well, it would have applicability in both fixed textual address context,
and for a fixed/upload-once payment protocol file. That has the advantage
of backwards compatibility as well - the new addresses would not be
clickable or acceptable by old wallets, but with the payment protocol you
can always craft a bitcoin URI that contains a regular current style
address, and a link to a fixed payment protocol file (uploaded to a
pastebin type site), and modern wallets would ignore the address and use
the ECDH based system instead.



On Sun, Jan 12, 2014 at 11:33 AM, Jeremy Spilman <jeremy@taplink.co> wrote:

-------------------------------------
Hi Ron,

FYI your mail is being spamfoldered due to Yahoo's DMARC policy and the
brokenness of the SF.net mailing list software. I would not expect to get
replies reliably whilst this is the case. I think we should move away from
SF.net for hosting mailing lists personally, because it's this list that's
at fault not Yahoo, but until then you may wish to send to the list with a
different email address.

As to your question,

assert() should have *no* side effects, that is the problem.

Back in 2010 most code was still being written by Satoshi so perhaps you
should ask him. Regardless, it's very common for professional codebases to
require assertions be enabled. For example the entire Google C++ codebase
uses always-on assertions that have side effects liberally: it's convenient
and safe, when you have the guarantee the code will always run, and the
performance benefits of compiling out assertions are usually non-existent.

So for this reason I think Bitcoin Core currently will fail to build if
assertions are disabled, and that seems OK to me.
-------------------------------------
On Wed, Feb 19, 2014 at 12:28 PM, Michael Gronager <gronager@mac.com> wrote:

You did. See the other sighash flags.


In exchange you make the behavior basically impossible do deploy
without first blocking all ongoing transactions. This seems foolish.
All signers need to be updated to change their behavior to be
anti-malleability compatible, they can change their version at the
same time... and leave things actually working for the things which
can't be easily updated.


-------------------------------------
We are considering pulling in https://github.com/bitcoin/bitcoin/pull/2340
"Discourage fee sniping with nLockTime"

Comments from other wallet implementors in particular are welcomed.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------

I don't understand this point. It's the *sender* that is parsing the
PaymentRequest and following the instructions. By definition the sender
must be online. A computer that is switched off cannot sign a transaction
at all.




Yes, and an extension to BIP 70 to allow for this (or stealth addresses or
whatever) has been discussed several times.

This thread started by proposing (I think) an expiry time for addresses.
BIP70 satisfies this use case, I think we all agree on that. Now for cases
where someone can't use BIP70 for whatever reason, or it's suboptimal,
absolutely we should design extensions to fix that.
-------------------------------------
As suggested before submitting a BIP, I am sending this to the mailing list.


Bitcoin is often described as “the currency of the Internet”, “the TCP/IP
of money”, or simply “the Internet of Money”. What is needed is an optional
identity layer — a Bitcoin Assigned Custodial Identities Authority, much
like the Internet Assigned Numbers Authority, to oversee global Custodial
Identity allocation. Such an authority delegates Custodial Identity Spaces
to Regional Bitcoin Custodial Identity Registries, much like the RIRs
(Regional Internet Registries) managing the allocation of Internet number
resources.

A Bitcoin Custodial Identity (BCI) account address would consist of a
Custodial Identifier allocated by the BACIA/RBCIRs (much like a bank’s
routing number), and an account address (much like an account number).
Bitcoin Custodial Identities allow dispute resolution in the legal system
for transactions in the BCI address space. Free market would drive and
determine the demand for custodial accounts. P2PKH users not affected.


Feedback is appreciated.
-------------------------------------
Well, not sure I wanted to subscribe the mbtc vs ubtc list... its a
default, not a big deal.
-------------------------------------
On 02/24/2014 05:45 PM, Gavin Andresen wrote:

So are 75 bytes. (I'm not trying to push anything. Just saying ...)

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
I agree that it may look silly to have just one-of-one share from a
technical point of view, but from an end-user point of view there could be
reasons for just having one piece of paper to manage. If M can be 1 then
the software/hardware doesn't have to support multiple formats,
import/export paths + UI  (one for SIPA keys in one share, one for HD seeds
in one share, one for SIPA keys + HD seeds in multiple shares).

Less complexity & more freedom of choice.
-------------------------------------
No, I was thinking of the height in coinbase change. At any rate, p2sh was
supported by the consensus code in bitcoinj for a long time already, since
it was first written.

Support for sending to such addresses in the wallet appeared once an app
that wanted that support also appeared, which seems OK - the market for
wallets is very competitive so there will always be some skew in what
features are worked on in what order. V3 transactions are a consensus
change that wallets will pick up at different times like any other feature.
On 20 Feb 2014 19:45, "Gregory Maxwell" <gmaxwell@gmail.com> wrote:

-------------------------------------


Not only useful but essential! Otherwise mobile clients can run out of RAM
and have to cycle around and reuse addresses.

Which is indeed why BIP70 has this feature. It was thought about quite some
time ago. Addresses are an evolutionary dead end, they will never do
everything we need them to do. If there's somewhere that's using addresses,
that's somewhere we will eventually need to upgrade to use BIP70 instead.
-------------------------------------
This ship may have already sailed, but...

Using milli- and micro- notation for currency units is also not very
well supported. Last time this thread was active, I believe there was a
suggestion to use 1 XBT == 1 uBTC. This would bring us completely within
the realm of supported behavior in accounting applications.

On 03/13/2014 09:29 AM, Jeff Garzik wrote:


-------------------------------------
On Fri, Aug 8, 2014 at 7:59 AM, Wladimir <laanwj@gmail.com> wrote:

Seconded.  Command plug-ins and such seem like an idea worth exploring.

We don't need to shove everything into bitcoind.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On Tue, Aug 19, 2014 at 9:07 AM, Justus Ranvier
<justusranvier@riseup.net> wrote:

TLS is a huge complex attack surface, any use of it requires an
additional dependency with a large amount of difficult to audit code.
TLS is trivially DOS attacked and every major/widely used TLS
implementation has had multiple memory disclosure or remote execution
vulnerabilities even in just the last several years.

We've dodged several emergency scale vulnerabilities by not having TLS.


-------------------------------------


I'm skeptical such a situation can ever be stable. People have no incentive
to create a transaction that will remain stuck in the backlog forever,
regardless of the effect it may have on the rest of the system.

If someone invents a business model in which lots of payments are made,
with fees, but that only clear probabilistically, perhaps such a situation
could occur. But otherwise I think we have to assume that people won't make
transactions that will lose the competition game, and instant demand would
only ever be roughly equal to supply.
-------------------------------------
On Saturday 25. October 2014 21.06.32 Alex Mizrahi wrote:


For the sake of argument, lets assume that somehow (quite unlikely) half the 
mining equipment gets shut off.
The amount of hashes/second is such that it is currently, lets just say, quite 
secure against any takeover.

Your document makes a long series of assumptions about how this can turn out 
bad with each individually is implausible, together are just fiction.

Your research didn't convince me about this being bad somehow. It also 
completely disregards the equilibriums reached by doing so.


-------------------------------------
On 25 October 2014 21:53, Alex Mizrahi <alex.mizrahi@gmail.com> wrote:


This is a good point, imho.  Miner sophistication has increased drastically
in 2 years.  Sites like ( http://www.coinwarz.com/ ) can heavily influence
mining, 1-2 orders of magnitude on significant levels of hashing.

I think this is more prevalent with scrypt than sha256, litecoin is set to
half reward in 9 months, and it will be interesting to observe what happens
there.


-------------------------------------
On 4/9/2014 11:29 AM, Wladimir wrote:
I personally like the ida.  Are you talking about a flag that could 
toggle this "in the background" mode or recoding for in the background use?


-- 
Kevin

-------------------------------------
Have a look at my post "Payment Protocol for Face-to-face payments". In
short: I implemented BIP70 using combinations of either QR-code or NFC
plus Bluetooth. You can download a working preview app from:

https://github.com/schildbach/bitcoin-wallet/releases/tag/v3.30-bitcoinj0.11


On 02/03/2014 09:30 PM, Tim Tuxworth Founder Go-taxi.biz wrote:




-------------------------------------
On Fri, Mar 14, 2014 at 03:05:25PM +0100, Andreas Schildbach wrote:

At the moment, I imagine the vast majority of Bitcoin users are
familliar with SI units and know what milli- and micro- mean.

I doubt that is true of the general population, though.

roy


-------------------------------------
On Friday, January 17, 2014 8:53:47 PM Jeff Garzik wrote:

Heck, even I disagree with implementation details, but it's still better than 
nothing. We can always merge major reorganisations/reimplementations later 
when they're written: merging this one doesn't mean we're stuck with it 
forever...

Luke


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

This feature makes possible Bitcoin Core to read a balance of any
public address via RPC call or, after importing the balance, it became
available only via QT interface?

On 18-10-2014 07:13, Wladimir wrote:
Comprehensive Server Monitoring with Site24x7.

- -- 
Felipe Micaroni Lalli

Walltime: https://walltime.info
Bitcoin Paranoid Android developer
PGP ID: 0x4c0afccfed5cde14
BTC: 1LipeR1AjHL6gwE7WQECW4a2H4tuqm768N

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQIcBAEBAgAGBQJUQrS8AAoJEEwK/M/tXN4UcsgQAMKyKFO2EcJ1+Ib08c5dJAft
VGNzf9c7TQtv/wfTWwqfD0QlkZ0jYqgoEJIflYJi7DhqFARQg2nTJIDoKAyDypaH
0x7ckt0G4Fp4Dq9GQAqyJq+5NFTO+S4LpnhzMGDLE6PZNOeoDRYf8GbuzNjCAU6s
huB9OhvXa4XZ2azsFnAhx3CcM98jTcbm0SLctqlTcHr//FMjEJioDFZATutlu8be
/PIhQ6OkfjBSeZv7A4lwgd0vbGJ8ioEkLMmjzYgfeaZG5KxOJXXzX9nDysAw7O3U
jXE/zpm9pFqZ9uhgdG1gzTBoROn49xZmycA82NbTn8/+mLrK7WYFei3Th5V0G1DG
hUI0vEb8g6id+y3w0HWnYqquFZBFOLNfs7ONsKdqvMj+ci2+IavAU7SY51BQcEwm
GW6d24Fd9/zhliEmFzq61xvOj5Rgcj7piGH/qMtGKYececS0tFMxQ4IDH+bkxKhr
lZ00Zk0K4bTCq3cASjP9L9AgV3zmTOUfe9RMtIHTJq79TIDPbBCsz2PrbtAcgWGZ
vb/08asgPC2FZHKOWf1TGiDr34JlBPhNKVKfiDuxbGqLGjlhYrdqkl1CrVqJP7dW
dxvEkwittodLc5MnVdS7QIHfjXJ/UEbyINIe7zrX/7w3pf0aLAX0KaxpDpfBessD
Nf2y99ZocpddQu0/EDJl
=Ctf/
-----END PGP SIGNATURE-----


-------------------------------------
On Thu, Jul 24, 2014 at 10:39 PM, Gregory Maxwell <gmaxwell@gmail.com>
wrote:

It's an iOS application. I would imagine it is substantially more difficult
to attach to a process (which, at the very least, requires root, and
perhaps other things on iOS) than to convince the device to change its
system time.

That said, the security benefits might not be too substantial.
-------------------------------------
On Wed, Apr 9, 2014 at 6:09 PM, Thomas Voegtlin <thomasv1@gmx.de> wrote:


Thanks for the explanation.

Adding a RPC call for a "address -> utxo" query wouldn't be a big deal. It
has been requested before for other purposes as well, all the better if it
helps for interaction with Electrum.

Spent history would be involve a much larger index, and it's not likely
that will end up in bitcoin

Wladimir
-------------------------------------
On Wed, Apr 16, 2014 at 05:20:41PM +0200, Pieter Wuille wrote:

Do we need a similar warning for OS X 10.6?  The EOL of that one is
*far* less well known than XP (because of Apple's failure to
communicate product lifecycles).

roy




-------------------------------------
On 04/23/2014 11:18 PM, Luke-Jr wrote:

Our users do and we are creating this BIP for them, because we love them. ;)

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
I'm not sure it does really - typical C/C++ exploits let you run arbitrary
code, at which point you can quite easily ptrace the other process and do
whatever you want with it, or read /proc/pid/mem etc. But process
separation is certainly a prerequisite for sandboxing so I'm not arguing
against such a change, just pointing out that it requires some work to
really get the benefits. Also an SPV Bitcoin Core would obviously be of
tremendous utility all by itself ...


On Fri, Feb 21, 2014 at 12:20 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------

bitcoind already supports SPV mode, that's how bitcoinj clients work.
However the current wallet code doesn't use it, it integrates directly with
the full mode main loop and doesn't talk P2P internally. Which is the fine
and obvious way to implement the wallet feature. I'm not totally convinced
it should become an SPV wallet given the complexity of doing that. But if
you did want to separate the wallet code from the full node then that'd be
the way to do it.

The question is; what does this buy us, and is it worth the potentially
huge amount of time it could take? My gut feeling is we have bigger fish to
fry. There's plenty of work to do just on the core consensus code, making
Bitcoin Core into a competitive wallet as well would be an additional
burden.

However I may be quite biased, as I am the maintainer of what is primarily
a wallet library :)



People use Electrum as shorthand to mean "something a bit like the P2P
network, but with trusted remote servers which build additional databases
and thus support additional commands".
-------------------------------------
Hello,

I'm pleased to announce the release of bitcoinj 0.11, a library for writing Bitcoin applications that run on the JVM. BitcoinJ is widely used across the Bitcoin community; some users include Bitcoin Wallet for Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me, Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced contracts research and more.

The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin key as with previous releases (check their release announcements to establish continuity). Additionally, this email is signed using DKIM and for the first time, a key that was ID verified by the Swiss government.

Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
Signature for last paragraph: H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=

Notable changes and new features

Thanks to Ken Sedgwick, an implementation of BIP39 ("Mnemonic code for generating deterministic keys") has been added. This is compatible with the latest Trezor implementation.
Thanks to Mike Belshe, the wallet can now send to P2SH addresses.
Thanks to Matt Corallo, the network layer was rewritten from scratch. It no longer depends on Netty, and it now supports both blocking and non-blocking sockets. In practice that means Java's built in support for transparent SSL and SOCKS becomes available again, which in turn means connecting via Tor is now possible. The new framework is lightweight, easy to understand and has been running a DNS seed crawler for some months now.
Thanks to Kevin Greene, we've added some support for the BIP70 payment protocol. Wallet authors can now consume payment requests, check their signatures and submit payments with the new easy to use PaymentSession class. The wallet-tool command line UI has support and an article explains how to use it.
Thanks to Miron Cuperman, the wallet can now watch arbitrary addresses and scripts. The wallet could previously watch an address as long as the public key was known. Now it's possible to watch for addresses even when the public key is not known.
Also thanks to Miron, Bloom filtering was also improved. The system now tracks false positive rates and cleans the filter when FP rates get too high. Unfortunately, some privacy bugs in Bloom filtering remain, which could (amongst other things) allow a malicious remote peer to test whether you own a particular key.
Thanks to Alex Taylor (bitpos.me), a new PostgreSQL based pruning block store was added. This block store is fast, and indexes the UTXO set, allowing for fast lookup of the balance of any given address.
A Java 8 based wallet template app is now included. The template is designed for people writing contract based applications. It provides a simple app that can be copy/pasted, which connects to the P2P network, manages a wallet, and provides a GUI that shows progress, balance, address+qrcode for receiving money and has a button that is used to empty the wallet out. It's designed to have an attractive and modern look, with tasteful animations and artwork.
Micropayment channels got many big improvements to the API and implementation. The release in 0.10 can be seen as a beta, in this release the micropayments code has been taken for a test drive for a couple of real apps and many rough edges polished as a result.
The default USER_THREAD executor can now be replaced, allowing a 1-line switch of all callbacks onto a thread of your choice instead of needing to override each callback, each time. This should simplify and clean up the GUI code of wallet apps significantly.
The WalletTool command line app has a more convenient user interface now.
A new DNS seed has been added. The seed is run by Christian Decker, from ETH Zurich.
bitcoinj 0.11 will shortly be available via Maven Central. Please use the dependency verifier plugin and/or check the PGP signatures on the uploads, if you use this!
Smaller improvements

We finished adding nullity annotations to the API. You should now be able to assume that any method not annotated with @Nullable won't ever return null values.
The WalletAppKit got a bunch of new features and convenience APIs.
The wallet will now create inputs with dummy signatures if the private key for an output is missing, rather than throwing an exception. You can then edit the input later to substitute in a real signature. This is useful when the signing is being done elsewhere, outside of the library.
In full verification mode, execution of scripts (i.e. checking signatures) can now be switched off. This is useful if you trust the source of the chain and just want to calculate the UTXO set.
The wallet risk analysis code is now pluggable, better documented and checks for finality in a more sensible way.
Various memory usage and flow control optimisations were made to allow much larger wallets to sync on Android.
The transaction broadcast algorithm was changed to be more robust.
Double spend handling in the wallet was improved.
Generated signatures now use canonical S values. This will aid a future hard-forking rule change which bans malleable signatures.
Some fixes were made for enable usage with the Orchid Tor library. Further support for Tor is planned for future releases.
Notable bug fixes

Some hard-forking full verification bugs were fixed.
Thanks to Miron, PeerGroup now performs exponential backoff for peer connections, for instance if we cannot connect to them or if they disconnect us. This resolves an annoying bug in which if the library was configured with a single peer that was down, it would spin in a tight loop consuming battery.
API changes

Some functionality of the Wallet class was moved into separate classes under the wallet package.
The micropayments API and protocol changed. New clients/servers are not compatible with apps running against previous releases.
The Wallet sendCoins/completeTx methods no longer return booleans or null to indicate failure, they now throw InsufficientMoneyException or a subclass if the transaction cannot be completed. The exception object typically contains information on how much money is missing.
Some mis-named methods in the HD key derivation API were renamed.
The WalletEventListener interface has an extra method for watching scripts now.
Peer discovery classes moved under the net.discovery package
Any APIs that relied on Netty are now different.
New documentation

An article on the networking API
Info on testing your apps, and how to use regtest mode to make a private Bitcoin network that allows you to mine blocks instantly.
A reference table showing which API's implement which Bitcoin Improvement Proposals (BIPs).
Please note that as I am no longer employed by Google, after 0.11 signing the Google contributor license agreement will no longer be necessary. I look forward to welcoming contributions from Andreas Schildbach now this requirement has gone away. Also, in future I plan to re-namespace the library from com.google.bitcoin to org.bitcoinj - auto-migration scripts will be provided when this is done.
-------------------------------------
On 03/12/2014 08:55 PM, William Yager wrote:

Ok, I see. So the spec allows one real and one fake password. That is
something I don't consider plausible deniability. I am not saying that
this solution is wrong, I find it quite interesting, but it's not
plausible deniability. ;-)


Ah, I misunderstood. I thought that outsourcing the KDF means allowing
the 3rd party to use any KDF instead of the specified ones. What would
be the reason to outsource if this is not possible, anyway?

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
2014-04-07 21:08 GMT+01:00 Troy Benjegerdes <hozer@hozed.org>:

I am of the same opinion, although i understand Gavin's point. Would
the multisig seed work for this purpose?
I have been toying with this idea and I think that for this BIP to
make sense it would require a "root" key as your login. Then if you
need to make transfers the system would request you to create and
associate a new key to your account for each purchase (signing the new
key with the root one for example).


-------------------------------------
Binaries for 0.9.0rc3 are available at:

    https://bitcoin.org/bin/0.9.0/test/

Please help sanity test.

We will also need more 'gitian builders' for the final 0.9.0 release
(Wladimir and I are the only builders so far for the rc3 binaries), so if
you are running Linux or OSX and are willing to help please start up those
virtual machines and start building dependencies.

-------------------------------------
Youre right.  Thats a huge oversight.  I think any software product youve ever considered installing has a section that says

Hey, we want this much ram on your system, this much disk space, this processor, etc.

Otherwise, youre just setting yourself up for a bad user experience from people with marginal machines.


On Apr 16, 2014, at 9:44 AM, Mark Friedenbach <mark@monetize.io> wrote:


-------------------------------------
Happy New Year to all the good people out there working hard to make
Bitcoin better than ever before.

Thank you!


On 1 January 2014 19:25, Melvin Carvalho <melvincarvalho@gmail.com> wrote:

-------------------------------------
Correct, though that was somewhat unintentional.  The pushed-data size
is limited to <= 40 bytes, and as non-pushdata opcodes carry zero
pushed data, they are accepted.

On Sun, May 4, 2014 at 8:07 AM, Sergio Lerner <sergiolerner@certimix.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
How about just calling them 'type S addresses'?

Not sure any other name will in reality convey much more meaning than
that.

On Wed, Jan 15, 2014 at 06:07:28PM -0500, Jeff Garzik wrote:


-------------------------------------
On 10/27/2014 7:36 PM, Gregory Maxwell wrote:

If I understand correctly, the simplest example of this attack is three 
transactions spending the same coin, distributed to two miners like this:

             Miner A    Miner B
Mempool       tx1a       tx1b
Relayed       tx2        tx2

Since relay has to be limited, Miner B doesn't know about tx1a until it 
is included in Miner A's block, so he delays that block (unless it 
appears very quickly).

To create this situation, attacker has to transmit all three 
transactions very quickly, or mempools will be too synchronized. 
Attacker tries to make it so that everyone else has a tx1a conflict that 
Miner A does not have.  Ditto for each individual victim, with different 
transactions (this seems very difficult).

Proposal shows that there is always a tiny risk to including tx1 when a 
double-spend is known, and I agree that this attack can add something to 
that risk.  Miner A can neutralize his risk by excluding any tx1 known 
to be double-spent, but as Thomas Zander wrote, that is an undesirable 
outcome.

However, Miner A has additional information - he knows how soon he 
received tx2 after receiving tx1a.

The attack has little chance of working if any of the malicious 
transactions are sent even, say, 10 seconds apart from each other. 
Dropping the labels for transmit-order numbering, if the 1->2 transmit 
gap is large, mempools will agree on 1.  If 1->2 gap is small, but the 
gap to 3 is large, mempools will agree on the 1-2 pair, but possibly 
have the order reversed.  Either way, mempools won't disagree on the 
existence of 1 unless the 1->3 gap is small.

So, I think it will be possible to quantify and target the risk of 
including tx1a to an arbitrarily low level, based on the local 
measurement of the time gap to tx2, and an effective threshold won't be 
very high.  It does highlight yet again, the shorter the time frame, the 
greater the risk.



-------------------------------------
On Thu, Apr 10, 2014 at 8:19 PM, Paul Rabahy <prabahy@gmail.com> wrote:

A 51% attack can make you believe you were paid, while you weren't.

Full node security right now validates everything - there is no way
you can ever be made to believe something invalid. The only attacks
against it are about which version of valid history eventually gets
chosen.

If you trust hashrate for determining which UTXO set is valid, a 51%
attack becomes worse in that you can be made to believe a version of
history which is in fact invalid.

-- 
Pieter


-------------------------------------
This is the discussion post corresponding to this PR:
https://github.com/bitcoin/bips/pull/106

"Amend BIP72 by an "h" parameter, which contains a hash of the
PaymentRequest message that is fetched via the "r" parameter.

The hash is meant to link the trust anchor (e.g. the QR code) to the
payment request message in a secure way. This will solve the problem
several apps are comparing address+amount fields as a workaround
instead, preventing some advanced BIP70 usecases. When these apps read a
matching hash, they need not compare any of the other fields.

Thanks to Julian Haight for helping with the standard."



-------------------------------------
Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE
that allows colored coins and similar embedded consensus system assets
to be securely transferred to another party in exchange for Bitcoins
atomically. In summary his p2p 2-step-trade mechanism operates as
follows:

Alice controls a colored txout and wishes to sell it for 1BTC. Bob
wishes to buy that txout.

Alice signs a scriptSig using SIGHASH_SINGLE|ANYONECANPAY for a
transaction with a that time. (albeit a offer floor) single input, the
colored txout, and a single output with a scriptPubKey she controls and
nValue=1 This transaction is not valid as the value out is greater than
the value in.

She gives this partial transaction to Bob. He can now complete the
transaction by providing one or more inputs with a sum value >=1BTC, one
output for the colored coins to be directed to, and optionally any other
outputs required. (for instance for change)

Bob signs his inputs with SIGHASH_ALL and broadcasts the transaction,
completing the trade.

What Alice has signed, the first txin scriptSig, guarantees that if the
colored txout is spent she will receive 1BTC. Meanwhile what Bob has
signed, all other txin scriptSigs, sign the colored input and output,
guaranteeing that he will receive his coin in exchange for his money.
Thus the trade is trust free and atomic.


Decentralized markets and honest pricing
========================================

We can extend Mizrahi's 2-step-trade mechanism to create a decentralized
marketplace. First of all, remember that traders wishing to sell their
assets want to be sure that their assets offers reach the 100% of the
audience who may wish to buy said assets; an attacker may try to
manipulate the market to depress the price of an asset by hiding offers
from potential buyers. Similarly buyers want assurance that the offers
they are responding to represent all offers available.

Proof-of-publication(2) offers a solution. Alice can embed her
incomplete transaction as data in a second, valid, transaction. She
broadcasts this secondary transaction to some agreed upon blockchain,
either the one the colored coin is in, or potentially a secondary system
with suitable proof-of-publication security. Bidders such as Bob can now
scan the blockchain for offers with an acceptable price. (the offers can
make use of techniques like prefix filters to allow Bob to only scan
part of the blockchain, although Bob needs to know the status of all
assets of the type he is interested in anyway)

There is still some potential for manipulation with very recent offers,
particularly those embedded in unconfirmed transactions. However
typically markets have a large number of long-standing offers, which in
this case would be committed to the blockchain with one or more
confirmations.

Interestingly such a system can also provide honest historical pricing
information: any offer that goes unfilled for one or more blocks has (in
theory) been honestly published to 100% of those watching the blockchain
at that time. Thus we can assume the unfufilled offers at any
given block height are honest information about the market at that time
historically.

The overhead involved involved in Alice publishing the offer is roughly
a doubling of the overall transaction fees consumed. (remember that the
offer transaction is incomplete, and about half the size of the
acceptance transaction)


Application to other embedded consensus systems
===============================================

Any embedded consensus system can make use of the 2-step-trade mechanism
so long as it is possible to create transactions where spending a single
transaction output moves an asset appropriately.

Unfortunately extending this to circumstances where more than one input
needs to be spent, or more than out output needs to be created, is
difficult. SIGHASH_SINGLE by itself results in a signature where the
index of the output is signed, but the contents - scriptPubKey and
nValue - of all other outputs is not signed. Meanwhile all transaction
inputs are signed and changes to that set, other than modifying the
nSequence value in each CTxIn, is not possible.

If there was a SIGHASH mode that merely truncated vin and vout based on
the index of the scriptSig we could commit to data in either, but
unfortunately we can't do that.

An alternative could be to create a mechanism where some embedded data
signified the creation of a temporary transfer txout, where spending
that txout made the underlying change desired in the consensus state
atomically.


1) Alex Mizrahi, color kernel design considerations, Jan 7th 2014,
   Colored coins (BitcoinX) mailing list,
   https://groups.google.com/d/msg/bitcoinx/pON4XCIBeV4/IvzwkU8Vch0J

2) Peter Todd, [Bitcoin-development] Disentangling Crypto-Coin Mining:
   Timestamping, Proof-of-Publication, and Validation, Nov 19 2013,
   https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03307.html

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------------------------------

No, it'd be sensible.

Here's a list I drew up a long time ago of features I imagined adding to
the payment protocol:

https://bitcointalk.org/index.php?topic=270055.msg2890147#msg2890147

The protocol is there to contain features! There is zero benefit to
slavishly following some religious notion of purity or minimalism here. The
shared resource in question is just varint encoded integers. So, we should
be guided by what will help our users and what will help adoption.

Anyway, Gavin asked me to start handling more BIP 70 stuff a few weeks ago.
I want to use something simple to set up the extensions process more
formally. IMO we need a "living document" version of the payment protocol
with all the different extensions out there folded into it, to simplify
programming tasks and ensure field numbers don't collide.
-------------------------------------
I think there is nothing wrong with having a numeric memo field, which
is effectively what this is.  Structured rather than unstructured
data.

On Tue, Jun 24, 2014 at 11:15 AM, Gmail <will.yager@gmail.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
It seems to me that people maybe arriving at the idea that they should
put transaction data in the blockchain for three related reasons: a)
its there and its convenient; and b) they are thinking about permanent
storage and being able to recover from backup using a master seed to a
bip32 address-set and want that logic to extend to the extra features;
c) they are thinking out of band, but they think they are forced to
send the data there in order to achieve atomicity.

I think the data that is sent on the blockchain is design-compressed
minimal necessary to achieve transaction integrity, and its important
for scalability that we keep it that way.  About the rationales for
using that scarce scalability impacting channel:

a) convenience: is not a great reason to my mind. there are lots of
channels: email, web forms, point2point various transports NFC, TCP,
HTTP for payment protocol or extensions or new protocols.  I think
there could be a need for a reliable privacy preserving store and
forward decentralised infrastructure to act as a channel for such
purposes.  Until then email could be pretty convenient, if you dont
get the message due to spam filter etc ask them to resend.  Or a web
storage locker related to the app.

b) backup: the blockchain is not an efficient reliable generic backup
mechanism because its broadcast.  there are cheaper and relatively
simple ways to get end2end secure backup, the main challenge of which
is having secure keys and not forgetting them.  bitcoin already has
that covered as its a central requirement of blockchain security.  If
you want to archive your payment protocol receipts store them on some
cloud storage service or disk encrypted with related keys.  for
example tahoe-lafs is optimised for the decentralised long-term
storage kind of use.

c) atomicity. as an example application requiring atomicity that may
use op_return stealth addresses where if the stealth auxiliary message
was sent out of band, then if message is lost, and the sender didnt
keep it or cant be relied on to care, then the money could be
permanently lost to both parties.

It occurred to me recently the kind of use requiring atomicity as
stealth address in c) can be achieved by sending both the extra
message (the stealth packet) AND the signed bitcoin transaction over
the reliable store & forward (eg email for now).  Then the recipient
can do the calculations involving the auxiliary message and payment
message, and relay the message to the blockchain IFF they receive the
message (and chose to accept it).  If they dont receive the message
they can ask for it to be resent.  And if the payment is unclaimed the
sender still owns it and can double-spend to avoid risk of later
spending in their replacement message, or double-spend to self if the
recipient declines the payment.  This has privacy, efficiency and SPV
advantages over sending to the blockchain.

I think we could make a case that as a design principle auxiliary data
could do with a bitcoin-related but separate reliable store and
forward channel, as email has been sufficiently spammed to end up with
loss of reliability.  So I think a payment message transport would be
good here: invoices & receipts, and other things necessary for
applications, transaction disputes, records for normal p2p trades and
business functions reliable store and forward substrate with
decentralisation & privacy. For email the existing mechanism with
closest semantics, add-on privacy features exist: mixmaster,
nymservers, webmail + encryption, webmail over Tor etc for privacy
related uses.  Slow transports can offer better security than
interactive transports.

Adam

On 17 November 2014 10:35, Pieter Wuille <pieter.wuille@gmail.com> wrote:


-------------------------------------
On Mon, Dec 15, 2014 at 1:42 PM, Cory Fields <lists@coryfields.com> wrote:


"That's exactly what was done except it wasn't"

Yes, in micro, at the pull request level, this happened
* Code movement
* Refactor

At a macro level, that cycle was repeated many times, leading to the
opposite end result:  a lot of tiny movement/refactor/movement/refactor
producing the review and patch annoyances described.

It produces a blizzard of new files and new data structures, breaking a
bunch of out-of-tree patches, complicating review quite a bit.  If the vast
majority of code movement is up front, followed by algebraic
simplifications, followed by data structure work, further patches are easy
to review/apply with less impact on unrelated code.

The flow of patches into the tree over time should be examined.  Simply
tagging patches as movement-only does not address the described problem at
all.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------------------------------
Good to see so much activity! But please do remember, there's more to 
"multisig" than just keys - you need the whole user experience to be 
planned out and specced for fully interoperable implementations.

For the "group account for an organisation" feature, you don't really 
want to expose end users to the notion of a key. Historically this has 
just led to confusion (and an ugly visual explosion of padlocks and 
small metal objects :) It'd be much better for the UI to be designed in 
terms of people, perhaps with a bit of social network integration to 
avoid having to set up profiles, and then a "group spend" feature would 
behind the scenes rendezvous with the others and swap signatures around, 
etc.  So for interop, you'd need to define all the rendezvous protocols 
as well.
I don't know how you are implementing this/what framework you're using, 
but I suggest using placeholders that are the length of an actual 
expected signature, at least when forming the transaction. This is what 
bitcoinj will do because otherwise you could end up miscalculating the 
fee, which is based on the final size. See TransactionSignature.dummy() 
<http://plan99.net/%7Emike/bitcoinj/0.11/com/google/bitcoin/crypto/TransactionSignature.html#dummy%28%29> 
in the API.
-------------------------------------
Define acceptable.  The 40% thing is marketing and a temporary
solution.  And people come down on both sides of whether or not
marketing "40%" is a good idea.

I think it is a baby step that is moving in the right direction.  You
want the numbers and sentiment moving in that direction (down, versus
"own the market! </IPO>").

The more critical piece is fleshing out the various proposals and
technical solutions for decentralized transaction selection and other
aspects of SPOF-proofing mining.

Historical note:  On one hand, Satoshi seemed to dislike the early
emergence of GPU mining pools quite a bit.  On the other hand, Satoshi
noted that the network would probably devolve down to a few big
players if we ever reached VISA/MC transaction levels.  Satoshi
clearly never figured this part out :)

Today, there is consensus on the need for a "keep bitcoin free and
open" technical solution, but it remains to be seen how much we
engineers can really do to make life fair.  Making transaction
selection a bit more independent from hashpower seems one step.  There
are several other proposals floating about.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 19 August 2014 21:19:43 GMT-04:00, William Yager <will.yager@gmail.com> wrote:

Hence my suggestion of separating that surface by using the standalone Tor binary, which runs under a different user to the Bitcoin Core binary.


First of all, without encryption we're leaking significant amounts of information to any passive attacker trying to trace the origin of Bitcoin transactions, a significant privacy risk.

Secondly the upcoming v0.10's fee estimation implementation is quite vulnerable to Sybil attacks. Authentication and encryption are needed to make it secure from ISP-level targeting to ensure that your view of the network is representative. Tor support used in parallel with native connection is ideal here, as neither the Tor network nor your ISP alone can Sybil attack you. It's notable that Bitcoinj has already implemented Tor support for these same reasons.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJT8/mSMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhRZjCAC4PSpQ68qgtFMR77xf
zXZLr/iMKX6yyJwXRj+vGi+0Ng/sv9NlYjYnDeflom37WlpGo/sCOFcVWImhnS2d
kUFoUH92iXwRuEt/SN/LrHghkLWOxtVu9wa49eS/piGZFF3JWllk82MgdBZ6vjNw
B6WuInEIurK+h8rUbAi2HjFkxVN0K0SsrFt/P0tHj10ABcMealBRoJh2Jx7fLNdS
uTKddqeLyThEpLGNti3k+lhwQ2dA5RUBq6q3GUS/hWvTHRnU+viGMJSYv62LXRN5
t87BXRY/R9UBpnudf3TIlPtOuIWcv2LhlXVjvbDDQqwJkvB3Qf4ejE3RZ28S5IUr
OBQH
=Gy7X
-----END PGP SIGNATURE-----



-------------------------------------
Ok, addressed these (and a few other things) in
https://github.com/bitcoin/bips/pull/117:
* Better names for the rules.
* Clarify interaction of BIP62 with P2SH.
* Clarify that known hashtypes are required, despite not being part of DER.
* Use v2 transactions instead of v3 transactions.
* Apply the optional rules only to strict v2, and not higher or lower.


On Tue, Nov 4, 2014 at 12:07 PM, Peter Todd <pete@petertodd.org> wrote:


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 1 October 2014 11:23:55 GMT-07:00, Luke Dashjr <luke@dashjr.org> wrote:

Better to create a GET-TXIN-BLOCK-(TIME/HEIGHT)-EQUALVERIFY operator. scriptPubKey would be:

    GET-TXIN-BLOCKHEIGHT-EQUALVERIFY

(fails unless top stack item is equal to the txin block height)

    <delta height> ADD

(top stack item is now txin height + delta height)

    CHECKLOCKTIMEVERIFY


You'd want these sacrifices to unlock years into the future to thoroughly exceed any reasonable business cycle; that's so far into the future that miners are almost certain to just mine them and collect the fees.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJULJa7MxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhYlFB/4r2Hv82RK85BDe+hAT
ZQJtzXv1JRCa+o7Y344unMJ8y7rSDJRFSH+X+4VeCln833XKb8FNgj2loniQAq5H
FIH04gPf7yuXvDrKI6HwCj9Q3KLPv4UZM1+LjijczOM/y4e/C82squpTpgFaton+
6VXU/WyaCDYDS4he975E14YhBBVhoadZZMOW3Moxgpnde2RwAYZdkcdhqvh/3dJC
/9VOEUBu0ENyraL5HHGdZyjSJT2MsY4CBTCCd54RxBBMoMZqFRvIi4Xrt2vE1T+Y
R2DtKs7upjydnfg9KPm484upvO2U3lcnPBW9rqOVQyV2q81TcloRtUIU4QQ9GCAk
ayj2
=p0BG
-----END PGP SIGNATURE-----



-------------------------------------


On 06/10/2014 08:43 p.m., Tom Harding wrote:

Yes, that's how simulation works. The problem is that the existence of
high-fee delays the decision to switch to M10. Since the network is
moving slower (because of fragmentation) the effect of the high-fee is
twofold: it delays the convergence because it promotes selfishness and
it delays convergence because it promotes fragmentation.

During that time window where the network is frozen, any other high-fee
transaction only makes things worse.  This is a very rare example where
a well distributed network (100 miners having 1% each) is much much
worse than 3 miners having 33% each.

Using the my previous terminology, automatic fee-sharing ("ORBS") is a
solution to the freeze problem ("FRONT") but opens the windows to
"CHAKIDO" double-spending. and CHAKIDO double-spending is a much worse
problem than FRONT.
But as Tamas pointed out, sooner or later someone will implement
something like ORBS, get over the critical mass of miner adoption, and
then the CHAKIDO problem will be inevitable.

The only clean solution to this problem is the DECOR+ protocol, which
shares block-rewards by including "uncles" (as GHOST does) and splitting
the reward between all miners at the same height until coinbase maturity
is over. This way the best choice is always cooperative.

PS: Using so many acronyms makes arguments much more concise, but
suggest we should have all the attack terminology described in a single
"Bitcoin Security Wiki"...















-------------------------------------

Why does error handling have to be standardized?

I generally think that wallet software should be free to do whatever gives
the user the best experience, so I'm in favor of restricting BIPs to things
that must be standardized so that different implementations inter-operate.



Referencing whatever RFCs defines how to fetch URLs would be the best way
to do this. Submit a pull request.




PaymentRequests are limited to 50,000 bytes. I can't think of a reason why
Payment messages would need to be any bigger than that. Submit a pull
request to the existing BIP.



Implementation detail that doesn't belong in the spec, in my humble opinion.



I think this should be left to implementations to work out.




.... not a good idea. The user should get feedback right away. Poking a
"pay now" button and then waiting more than a second or three to get "your
payment has been received and is being processed" is terrible UI.


-- 
--
Gavin Andresen
-------------------------------------
On Wed, Dec 17, 2014 at 10:55:28PM +1100, Gareth Williams wrote:

Yup.


1-way-pegs don't require the Bitcoin protocol to change; 2-way-pegs do.


No, they're in favor of systems that are client-side validatable vs.
systems that either allow anyone with sufficient hashing power to steal
coins *or* require "moon-math" that isn't yet available to production
systems.


But again, all these discussions about scarcity are fundementally
*moral* arguments that have no bearing on what's actually the most
appropriate solution for an *individual* problem.

In a decentralized system filled with anonymous actors telling people
"stop doing that! it's bad!" on reddit has pretty severe limitations in
trying to convince people to act against their own best interests.


I think you think consensus in Bitcoin is more "magical" than it really
is; Bitcoin is just code running on computers; consensus isn't really
incentivised at the protocol level beyond "screw it up and you'll lose
money"

Embedded consensus systems are no different: screw up consensus and
you'll lose money in a variety of ways.


No it can't - the transactions are in the blockchain so the sybil attack
has to attack the host system as well.

In any case, keep in mind all of this is in the context of tradeoffs:
for a different and sometimes more fragile consensus mechanism embedded
consensus gets immunity to attack by miners. You're trading off one type
of fragility for another - I'd much rather take the "one-time" fragility
inherent in having to write really solid software than the ongoing
fragility of always being vulnerable to miners.

Notably this is the exact same tradeoff taken elsewhere by the majority
of the crypto world.

-- 
'peter'[:-1]@petertodd.org
000000000000000017d70ee98f4cee509d95c4f31d5b998bae6deb09df1088fc
-------------------------------------

There's really no concept of a "runner up" because hashing is progress
free. It's unintuitive and often trips people up. There's no concept that
everyone is 95% of the way to finding a solution and then someone pips you
to the post. It's more like playing the lottery over and over again.
Doesn't matter how many times you did it before, the next time your chances
are the same.

A better concept is of rewarding "near miss" solutions which is what we
already do of course, via pools, which pay you for shares which don't quite
meet the difficulty target but almost do. So the question is how can we
implement pools which have this reward structure (which obviously works
well) without miners simultaneously giving up their right to block creation
either due to technical problems or sheer lazyness.
-------------------------------------
I wrote a little Javascript program
<https://github.com/bitcoinj/bitcoinj/blob/master/examples/src/main/javascript/payprotocol.js>
to print some minimal protobufs to base64.

Result for a multisig output:

Ik0SSRJHUiECpm1rIsOcaCf/CqL/YeqNXgcnQzb/+hfaawdi9u46xhEhAgoJfDU3M5mr++dfBG2gO5DiBiBVkVmLzjSLf26HEINeUq4YAA

Result for a regular pay to address output:

Ih8SGxIZdqkU4nFAzWDBp6LEi4uXgddL65H11nGIrBgA

That is without any expiry time, which you'd want in practice. For an
HD-iterating payment request you'd also need a few flags and fields, but a
well designed protocol should only add a handful of bytes. The above
strings are, I think, short enough to set as a username in a mining program
so the general UX of Eligius can be maintained.

How to generate them? That's not too hard. Building specialised one-off SPV
wallets is quite easy these days with bitcoinj, there's a template app and
a video tutorial on how to customise it available here:

https://bitcoinj.github.io/simple-gui-wallet

You can just copy/paste the code into a new directory and start modifying
it. The final result is like Lighthouse - you run a program and get an EXE
installer or MSI for Windows, a DMG for MacOS and a .deb for Linux (though
a tarball would work just as well).

So producing a little GUI that lets you build a base64 encoded payment
protocol request that supports HD iteration for one or more keys, along
with a little BIP70 extension that says "although this output is a multisig
output, please actually create a p2sh output", would make a nice starter
project for someone. It could also then act as a watching wallet and plot a
graph of mining payouts over time, for example.

If anyone wants to take this on let me know. I can help out with the final
code signing steps to make Gatekeeper/Internet Explorer happy so don't
worry about distribution.

On Thu, Dec 4, 2014 at 6:25 PM, William Swanson <swansontec@gmail.com>
wrote:

-------------------------------------
On Thu, Jan 30, 2014 at 12:15 PM, Chuck <chuck+bitcoindev@borboggle.com>wrote:


The arbitrator would presumably have some rules about what is or isn't an
acceptable form of payment.

HTTP has response codes for submission of the Payment message. We could add
signing to PaymentACK and other things in future, if that turns out to be
insufficient in practice.
-------------------------------------
On Fri, Apr 4, 2014 at 4:51 PM, Mike Hearn <mike@plan99.net> wrote:
With all respect to your experience, I think you're wrong, for one reason.

2fa auth doesn't *remove* the need of password. It actually *adds* yet
another layer, which complicates stuff for average user. Common user, which
is not paranoid enough (like me) simply don't think he has anything to
hide, so they simply don't see why they should *complicate* their live with
2fa, backing up their phone etc.

In the oposite, authentication based on bitcoin wallet could make the
process much easier and remove the need of passwords at all, because people
*already* care about safe storage of their coins.

Marek
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


On 03.05.2014 02:54, Ben Davenport wrote:

As you said, that's in the US, and I strongly suspect the sole reason
is that in the US the currency symbol is written in front of the
amount. I often pronounce $10k as ten kilodollar, using it exactly
like a SI-prefix.

The much better argument against SI prefixes is that the prefixes for
values less than 1 tend to be much less well known: Most people know
that kilo means 1000, many know that mega means 1,000,000, but few
know that micro means 0.0000001, and those that do tend to confuse
micro and nano.

Jannis
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIbBAEBAgAGBQJTZTmNAAoJEBrvn3PsoRcmrzYP9R0cch42wV+I21MNVbWEEhfw
GjuCqE2Vz7QtI4nhRZ0Eas+MOY6iZD1c2A7cr4BjWx+MdQQwJSMKg/UKruE3j9xs
4QAFQtjvQ69Yd5ztq3ISWM/DpGfPXRvRdIf02ldz0Sf4HMxvqHCcYov3/laOrFnF
3ECpd+JLrU/Wq/HWwuFFXbfyQnpn+9LHx5gcfhV/pW7PwAjwzeaKhY1neQRHhQWq
pD8iv2dikqs30nO6bhnrCv/u0N+2iwV4e+J0E+kpBwrCZLeG8MirRRdnLruJ5mnT
nGyRNdfPKl5n0Gm4AFkBC3a4VIYwOxAzxdfA55Hn27yxll0GFEQNqR9OCNblGUbQ
RWa3Nywa22aYHOTi7evmuP6dVFjF4T8dl8LzDBmeawBsbOeHAUYJgLoHezdwEoto
Dt01ML4CmCINnPIFiuab17gpUYg7OXKomOQPrdyaVnP2abgvQCV5bYhMnKKVa25U
mW5PK02stxKcTEyHBsz0BG8zmdx5+7A5ySaUHrXs+l3YNBp3idlDUeYIsEBKFAtR
vNEGLbV2ZvteOb+tflxuPSjgIaMHD9w6vX2l7+VgkRTms743s/wbQuLb2fXq7osM
zws5D/L74zG1ZwsNM04Ygs2GJoJhkb1QXxY9EuoIeiuK3nVeJEWeRGHBEmqCXOPx
FB/2U/d69fUTbvUzOXA=
=Qo8z
-----END PGP SIGNATURE-----


-------------------------------------
It can be useful to review open source development processes from time to
time.  This reddit thread[1] serves use both as a case study, and also a
moment of OSS process introduction for newbies.
[1]
http://www.reddit.com/r/Bitcoin/comments/2pd0zy/peter_todd_is_saying_shoddy_development_on_v010/




*Dirty Laundry*
When building businesses or commercial software projects, outsiders
typically hear little about the internals of project development.  The
public only hears what the companies release, which is prepped and
polished. Internal disagreements, schedule slips, engineer fistfights are
all unseen.

Open source development is the opposite.  The goal is radical
transparency.  Inevitably there is private chatter (0day bugs etc.), but
the default is openness.  This means that is it normal practice to "air
dirty laundry in public."  Engineers will disagree, sometimes quietly,
sometimes loudly, sometimes rudely and with ad hominem attacks.  On the
Internet, there is a pile-on effect, where informed and uninformed
supporters add their 0.02 BTC.

Competing interests cloud the issues further.  Engineers are typically
employed by an organization, as a technology matures.  Those organizations
have different strategies and motivations.  These organizations will
sponsor work they find beneficial.  Sometimes those orgs are non-profit
foundations, sometimes for-profit corporations.  Sometimes that work is
maintenance ("keep it running"), sometimes that work is developing new,
competitive features that company feels will give it a better market
position.  In a transparent development environment, all parties are
hyperaware of these competing interests.  Internet natterers painstakingly
document and repeat every conspiracy theory about Bitcoin Foundation,
Blockstream, BitPay, various altcoin developers, and more as a result of
these competing interests.

Bitcoin and altcoin development adds an interesting new dimension.
Sometimes engineers have a more direct conflict of interest, in that the
technology they are developing is also potentially their road to instant
$millions.  Investors, amateur and professional, have direct stakes in a
certain coin or coin technology.  Engineers also have an emotional stake in
technology they design and nurture.  This results in incentives where
supporters of a non-bitcoin technology work very hard to thump bitcoin.
And vice versa.  Even inside bitcoin, you see "tree chains vs. side chains"
threads of a similar stripe.  This can lead to a very skewed debate.

That should not distract from the engineering discussion.  Starting from
first principles, Assume Good Faith[2].  Most engineers in open source tend
to mean what they say.  Typically they speak for themselves first, and
their employers value that engineer's freedom of opinion.  Pay attention to
the engineers actually working on the technology, and less attention to the
noise bubbling around the Internet like the kindergarten game of grapevine.
[2] http://en.wikipedia.org/wiki/Wikipedia:Assume_good_faith

Being open and transparent means engineering disagreements happen in
public.  This is normal.  Open source engineers live an aquarium life[3].
[3] https://www.youtube.com/watch?v=QKe-aO44R7k




*What the fork?*
In this case, a tweet suggests consensus bug risks, which reddit account
"treeorsidechains" hyperbolizes into a dramatic headline[1].  However, the
headline would seem to be the opposite of the truth.  Several changes were
merged during 0.10 development which move snippets of source code into new
files and new sub-directories.  The general direction of this work is
creating a "libconsensus" library that carefully encapsulates consensus
code in a manner usable by external projects.  This is a good thing.

The development was performed quite responsible:  Multiple developers would
verify each cosmetic change, ensuring no behavior changes had been
accidentally (or maliciously!) introduced.  Each pull request receives a
full multi-platform build + automated testing, over and above individual
dev testing.  Comparisons at the assembly language level were sometimes
made in critical areas, to ensure zero before-and-after change.  Each
transformation gets the Bitcoin Core codebase to a more sustainable, more
reusable state.

Certainly zero-change is the most conservative approach. Strictly speaking,
that has the lowest consensus risk.  But that is a short term mentality.
Both Bitcoin Core and the larger ecosystem will benefit when the "hairball"
pile of source code is cleaned up.  Progress has been made on that front in
the past 2 years, and continues.   *Long term*, combined with the
"libconsensus" work, that leads to less community-wide risk.

The key is balance.  Continue software engineering practices -- like those
just mentioned above -- that enable change with least consensus risk.  Part
of those practices is review at each step of the development process:
social media thought bubble, mailing list post, pull request, git merge,
pre-release & release.  It probably seems chaotic at times.  In effect,
git[hub] and the Internet enable a dynamic system of review and feedback,
where each stage provides a check-and-balance for bad ideas and bad
software changes.  It's a human process, designed to acknowledge and handle
that human engineers are fallible and might make mistakes (or be
coerced/under duress!).  History and field experience will be the ultimate
judge, but I think Bitcoin Core is doing good on this score, all things
considered.

At the end of the day, while no change is without risk, version 0.10 work
was done with attention to consensus risk at multiple levels (not just
short term).




*Technical and social debt*
Working on the Linux kernel was an interesting experience that combined
git-driven parallel development and a similar source code hairball.  One of
the things that quickly became apparent is that cosmetic patches,
especially code movement, was hugely disruptive.  Some even termed it
anti-social.  To understand why, it is important to consider how modern
software changes are developed:

Developers work in parallel on their personal computers to develop XYZ
change, then submit their change "upstream" as a github pull request.  Then
time passes.  If code movement and refactoring changes are accepted
upstream before XYZ, then the developer is forced update XYZ -- typically
trivial fixes, re-review XYZ, and re-test XYZ to ensure it remains in a
known-working state.

Seemingly cosmetic changes such as code movement have a ripple effect on
participating developers, and wider developer community.  Every developer
who is *not* immediately merged upstream must bear the costs of updating
their unmerged work.

Normally, this is expected.  Encouraging developers to build on top of
"upstream" produces virtuous cycles.

However, a constant stream of code movement and cosmetic changes may
produce a constant stream of disruption to developers working on
non-trivial features that take a bit longer to develop before going
upstream.  Trivial changes are encouraged, and non-trivial changes face a
binary choice of (a) be merged immediately or (b) bear added re-base,
re-view, re-test costs.

Taken over a timescale of months, I argue that a steady stream of cosmetic
code movement changes serves as a disincentive to developers working with
upstream.  Each upstream breakage has a ripple effect to all developers
downstream, and imposes some added chance of newly introduced bugs on
downstream developers.  I'll call this "social debt", a sort of technical
debt[4] for developers.
[4] http://en.wikipedia.org/wiki/Technical_debt

As mentioned above, the libconsensus and code movement work is a net gain.
The codebase needs cleaning up.  Each change however incurs a little bit of
social debt.  Life is a little bit harder on people trying to get work into
the tree.  Developers are a little bit more discouraged at the busy-work
they must perform.  Non-trivial pull requests take a little bit longer to
approve, because they take a little bit more work to rebase (again).

A steady flow of code movement and cosmetic breakage into the tree may be a
net gain, but it also incurs a *lot* of social debt.  In such situations,
developers find that tested, working out-of-tree code repeatedly stops
working *during the process of trying to get that work in-tree*.  Taken
over time, it discourages working on the tree.  It is rational to sit back,
*not* work on the tree, let the breakage stop, and then pick up the pieces.




*Paradox Unwound*
Bitcoin Core, then, is pulled in opposite directions by a familiar
problem.  It is generally agreed that the codebase needs further
refactoring.  That's not just isolated engineer nit-picking.  However, for
non-trivial projects, refactoring is always anti-social in the short term.
It impacts projects other than your own, projects you don't even know
about. One change causes work for N developers.  Given these twin opposing
goals, the key, as ever, is finding the right balance.

Much like "feature freeze" in other software projects, developing a policy
that opens and closes windows for code movement and major disruptive
changes seems prudent.  One week of code movement & cosmetics followed by 3
weeks without, for example.  Part of open source parallel development
is *social
signalling*:  Signal to developers when certain changes are favored or not,
then trust they can handle the rest from there.

While recent code movement commits themselves are individually ACK-worthy,
professionally executed and moving towards a positive goal, I think the
project could strike a better balance when it comes to disruptive cosmetic
changes, a balance that better encourages developers to work on more
involved Bitcoin Core projects.


-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------------------------------
SHA-1 support is there for PHP developers. Apparently it can't do SHA-2.
On 2 Mar 2014 08:53, "Jeremy Spilman" <jeremy@taplink.co> wrote:

-------------------------------------
In the context of Bitcoin I will concede that perhaps it holds true for now.

I also never said the actual credential you receive from a government
agency is trustable. I completely agree that they are forgeable and not
necessarily reliable. That was not my point. I was referring to the vetting
process before issuance.

Just as you have behavioral characteristics online that contribute to
trusting an "identity" you also exhibit in person attributes, such as
physically being in a specific location at a certain time or blue eyes or
biometrics, that are valuable. You simply cannot capture those in an
online-only world. I don't see how you can deny the value there.

You are most certainly and undeniably the expert in the Bitcoin context
here so I will not even attempt to argue with you on that, but I just think
it's not realistic to ignore the value of an in-person network in other
contexts. You called it "geek wanking" with no qualifier "in the Bitcoin
context" so excuse me if I misunderstood your intent.


On Mon, Sep 15, 2014 at 10:33 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------

I've looked at the latest draft and am worried about the increased AVB
namespace usage.  Would it make sense to differentiate main/testnet in
the prefix byte instead of the AVB?  Perhaps aiming for ST rather than
TS.


I'm willing to fork it.
The maximum number of shares possible over GF(2^8) is 255.  That would
make M and x biases unnecessary.


-------------------------------------
That could also work. Still, didn't we want to ditch the word address?
Could be a privacy key...
On 17 Jan 2014 09:15, "Mike Hearn" <mike@plan99.net> wrote:

-------------------------------------
It's meant to be in favor of merge mining.

Dogecoin uses scrypt, which is a very popular algorithm. If any large
currency were to be attacked through merge mining, it would probably be
litecoin miners attacking dogecoin. But if you control enough of the
litecoin network to do attack mining against dogecoin, you almost certainly
have a huge vested interest in cryptocurrencies doing well. By attacking
dogecoin successfully, you'll cast doubt on the entire cryptocurrency
ecosystem and hurt yourself in the process.


On Sat, Jan 4, 2014 at 5:05 AM, Jorge Timn <jtimon@monetize.io> wrote:

-------------------------------------
On Sat, Mar 22, 2014 at 12:43:34PM -0700, Mark Friedenbach wrote:

Sure:

Introduction
============

Bitcoin doesn't scale. There's a lot of issues at hand here, but the
most fundemental of them is that to create a block you need to update
the state of the UTXO set, and the way Bitcoin is designed means that
updating that state requires bandwidth equal to all the transaction
volume to keep up with the changes to what set. Long story short, we get
O(n^2) scaling, which is just plain infeasible.

So let's split up the transaction volume so every individual miner only
needs to keep up with some portion. In a rough sense that's what
alt-coins do - all the tipping microtransactions on Doge never have to
hit the Bitcoin blockchain for instance, reducing pressure on the
latter. But moving value between chains is inconvenient; right now
moving value requires trusted third parties. Two-way atomic chain
transfers does help here, but as recent discussions on the topic showed
there's all sorts of edge cases with reorganizations that are tricky to
handle; at worst they could lead to inflation.

So what's the underlying issue there? The chains are too independent.
Even with merge-mining there's no real link between one chain and
another with regard to the order of transactions. Secondly merge-mining
suffers from 51% attacks if the chain being merge-mined doesn't have a
majority of total hashing power... which kinda defeats the point if
we're worried about miner scalability.


Blocks and the TXO set as a binary radix tree
=============================================

So how can we do better? Start with the "big picture" idea and take the
linear blockchain and turn it into a tree:

           ┌───────┴───────┐
       ┌───┴───┐       ┌───┴───┐
     ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
    ┌┴┐ ┌┴┐ ┌┴┐ ┌┴┐ ┌┴┐ ┌┴┐ ┌┴┐ ┌┴┐

Obviously if we could somehow split up the UTXO set such that individual
miners/full nodes only had to deal with subsets of this tree we could
significantly reduce the bandwidth that any one miner would need to
process. Every transaction output would get a unique identifier, say
txoutid=H(txout) and we put those outputs in blocks appropriately.

We can't just wave a magic wand and say that every block has the above
structure and all miners co-ordinate to generate all blocks in one go.
Instead we'll do something akin to merge mining. Start with a linear
blockchain with ten blocks. Arrows indicate hashing:

    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽ a4 ⇽ a5 ⇽ a6 ⇽ a7 ⇽ a8 ⇽ a9

The following data structure could be the block header in this scheme.
We'll simplify things a bit and make up our own; obviously with some
more effort the standard Satoshi structures can be used too:

    struct BlockHeader:
        uint256 prevBlockHash
        uint256 blockContentsHash
        uint256 target
        uint256 nonce
        uint time

For now we'll say this is a pure-proof-of-publication chain, so our
block contents are very simple:

    struct BlockContents:
        uint256 merkleRoot

As usual the PoW is valid if H(blockHeader) < blockHeader.target. Every
block creates new txouts, and the union of all such txouts is the txout
set. As shown previously(1) this basic proof-of-publication
functionality is sufficient to build a crypto-currency even without
actually validating the contents of the so-called transaction outputs.

The scalability of this sucks, so let's add two more chains below the
root to start forming a tree. For fairness we'll only allow miners to
either mine a, a+b, or a+c; attempting to mine a block with both the b
and c chains simultaneously is not allowed.

    struct BlockContents:
        uint256 childBlockHash # may be null
        bool childSide # left or right
        uint256 merkleRoot

Furthermore we shard the TXO space by defining txoid = H(txout) and
allowing any txout in chain a, and only txouts with LSB=0 in b, LSB=1 in
c; the beginning of a binary radix tree. With some variance thrown in we
get the following:

       b0 ⇽⇽ b1 ⇽⇽⇽⇽⇽ b2 ⇽ b3 ⇽ b4 ⇽ b5 ⇽ b6 ⇽ b7 ⇽ b8
                     ↙                        ↙
    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽⇽⇽⇽⇽⇽ a4 ⇽ a5 ⇽ a6 ⇽ a7 ⇽ a8
           ↖    ↖              ↖         ↖         ↖
       c0 ⇽ c1 ⇽ c2 ⇽ c3 ⇽⇽⇽⇽⇽⇽ c4 ⇽ c5 ⇽ c6 ⇽⇽⇽⇽⇽⇽ c7


We now have three different versions of the TXO set: ∑a, ∑a + ∑b, and
∑a+∑c. Each of these versions is consistent in that for a given txoutid
prefix we can achieve consensus over the contents of the TXO set. Of
course, this definition is recursive:

    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽⇽⇽⇽⇽⇽ a4 ⇽ a5 ⇽ a6 ⇽ a7 ⇽ a8
           ↖    ↖              ↖         ↖         ↖
       c0 ⇽ c1 ⇽ c2 ⇽ c3 ⇽⇽⇽⇽⇽⇽ c4 ⇽ c5 ⇽ c6 ⇽⇽⇽⇽⇽⇽ c7
               ↖         ↖         ↖    ↖              ↖
           d0 ⇽ d1 ⇽⇽⇽⇽⇽⇽ d2 ⇽⇽⇽⇽⇽⇽ d3 ⇽ d4 ⇽⇽⇽ d5 ⇽⇽⇽⇽ d6

Unicode unfortunately lacks 3D box drawing at present, so I've only
shown left-sided child chains.


Herding the child-chains
========================

If all we were doing was publishing data, this would suffice. But what
if we want to syncronize our actions? For instance, we may want a new
txout to only be published in one chain if the corresponding txout in
another is marked spent. What we want is a reasonable rule for
child-chains to be invalidated when their parents are invalidated so as
to co-ordinate actions across distant child chains by relying on the
existance of their parents.

We start by removing the per-chain difficulties, leaving only a single
master proof-of-work target. Solutions less than target itself are
considered valid in the root chain, less than the target << 1 in the
root's children, << 2 in the children's children etc. In children that
means the header no longer contains a time, nonce, or target; the values
in the root block header are used instead:

    struct ChildBlockHeader:
        uint256 prevChildBlockHash
        uint256 blockContentsHash

For a given chain we always choose the one with the most total work. But
to get our ordering primitive we'll add a second, somewhat brutal, rule:
Parent always wins.

We achieve this moving the child block header into the parent block
itself:

    struct BlockContents:
       ChildBlockHeader childHeader # may be null (zeroed out)
       bool childSide # left or right
       bytes txout

Let's look at how this works. We start with a parent and a child chain:

    a0 ⇽ a1 ⇽ a2 ⇽ a3
           ↖         ↖
       b0 ⇽ b1 ⇽ b2 ⇽ b3 ⇽ b4 ⇽ b5

First there is the obvious scenario where the parent chain is
reorganized. Here our node learns of a2 ⇽ a3' ⇽ a4':

                 ⇽ a3' ⇽ a4'
    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽ X
           ↖         ↖
       b0 ⇽ b1 ⇽ b2 ⇽ b3 ⇽ X

Block a3 is killed, resulting in the orphaning of b3, b4, and b5:

    a0 ⇽ a1 ⇽ a2 ⇽ a3' ⇽ a4'
           ↖
       b0 ⇽ b1 ⇽ b2

The second case is when a parent has a conflicting idea about what the
child chian is. Here our node receives block a5, which has a conflicting
idea of what child b2 is:

    a0 ⇽ a1 ⇽ a2 ⇽ a3' ⇽ a4' ⇽ a5
           ↖                     ↖
       b0 ⇽ b1 ⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽ b2'
               ⇽ b2 ⇽ X

As the parent always wins, even multiple blocks can get killed off this
way:


    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽ a4
           ↖
       b0 ⇽ b1 ⇽ b2 ⇽ b3 ⇽ b4 ⇽ b5 ⇽ b6 ⇽ b7

to:

    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽ a4 ⇽ a5
           ↖                   ↖
       b0 ⇽ b1 ⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽ b2'
               ⇽ b2 ⇽ b3 ⇽ b4 ⇽ b5 ⇽ X

This behavior is easier to understand if you say instead that the node
learned about block b2', which had more total work than b2 as the sum
total of work done in the parent chain in blocks specifying the that
particular child chain is considered before comparing the total work
done in only the child chain.

It's important to remember that the parent blockchain has and validates
both childrens' block headers; it is not possible to mine a block with
an invalid secret of child headers. For instance with the following:

    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽ a4
           ↖         ↖    ↖
       b0 ⇽ b1 ⇽ b2 ⇽ b3 ⇽ b4 ⇽ b5 ⇽ b6 ⇽ b7

I can't mine block a5 that says following b2 is b2' in an attempt to
kill off b2 through b7.


Token transfer with tree-chains
===============================

How can we make use of this? Lets start with a simple discrete token
transfer system. Transactions are simply:

    struct Transaction:
        uint256 prevTxHash
        script prevPubKey
        script scriptSig
        uint256 scriptPubKeyHash

We'll say transactions go in the tree-chain according to their
prevTxHash, with the depth in the tree equal to the depth of the
previous output. This means that you can prove an output was created by
the existance of that transaction in the block with prefix matching
H(tx.prevTxHash), and you can prove the transaction output is unspent by
the non-existance of a transaction in the block with prefix matching
H(tx).

With our above re-organization rule everything is consistent too: if
block b_i contains tx1, then the corresponding block c_j can contain a
valid tx2 spending tx1 provided that c_j depends on a_p and there is a
path from a_p to b_(i+k). Here's an example, starting with tx1 in c2:

       b0 ⇽⇽⇽⇽⇽⇽ b1
                ↙
    a0 ⇽ a1 ⇽ a2
           ↖
       c0 ⇽ c1 ⇽ c2

Block b2 below can't yet contain tx2 because there is no path:

       b0 ⇽⇽⇽⇽⇽⇽ b1 ⇽ b2
                ↙
    a0 ⇽ a1 ⇽ a2
           ↖
       c0 ⇽ c1 ⇽ c2

However now c3 is found, whose PoW solution was also valid for a3:

       b0 ⇽⇽⇽⇽⇽⇽ b1 ⇽ b2
                ↙
    a0 ⇽ a1 ⇽ a2 ⇽ a3
           ↖         ↖
       c0 ⇽ c1 ⇽ c2 ⇽ c3

Now b3 can contain tx2, as b3 will also attempt to create a4, which
depends on a3:

       b0 ⇽⇽⇽⇽⇽⇽ b1 ⇽ b2 ⇽ b3
                ↙
    a0 ⇽ a1 ⇽ a2 ⇽ a3
           ↖         ↖
       c0 ⇽ c1 ⇽ c2 ⇽ c3

Now that a3 exists, block c2 can only be killed if a3 is, which would
also kill b3 and thus destroy tx2.


Proving transaction output validity in a token transfer system
==============================================================

How cheap is it to prove the entire history of a token is valid from
genesis?  Perhaps surprisingly, without any cryptographic moon-math the
cost is only linear!

Remember that a transaction in a given chain has committed to the chain
that it can be spent in. If Alice is to prove to Bob that the output she
gave him is valid, she simply needs to prove that for every transaction
in the histroy of the token the token was created, remained unspent,
then finally was spent. Proving a token remained unspent between blocks
b_n and b_m is trivially possible in linear size. Once the token is
spent nothing about blocks beyond b_m is required. Even if miners do not
validate transactions at all the proof size remains linear provided
blocks themselves have a maximum size - at worst the proof contains some
invalid transactions that can be shown to be false spends.

While certainly inconvenient, it is interesting how such a simple system
appears to in theory scale to unlimited numbers of transactions and with
an appropriate exchange rate move unlimited amounts of value. A possible
model would be for the the tokens themselves to have power of two
values, and be split and combined as required.


The lost data problem
=====================

There is however a catch: What happens when blocks get lost? Parent
blocks only contain their childrens' headers, not the block contents.
At some point the difficulty of producing a block will drop sufficiently
for malicious or accidental data loss to be possible. With the "parent
chain wins" rule it must be possible to recover from that event for
mining on the child to continue.

Concretely, suppose you have tx1 in block c2, which can be spent on
chain b. The contents of chain a is known to you, but the full contents
of chain b are unavailable:

        b0 ⇽ b1      (b)  (b)
           ↙         ↙    ↙
    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽ a4 ⇽ a5
                ↖              ↖
       c0 ⇽ c1 ⇽ c2 ⇽ c3 ⇽ c4 ⇽ c5

Blocks a3 and a4 are known to have children on b, but the contents of
those children are unavailable. We can define some ratio of unknown to
known blocks that must be proven for the proof to be valid. Here we
show a 1:1 ratio:

                ⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽⇽
        b0 ⇽ b1      (b)  (b)   b2 ⇽ b3 ⇽ b4 ⇽ b5 ⇽ b6 ⇽ b7
           ↙         ↙    ↙         ↙         ↙    ↙
    a0 ⇽ a1 ⇽ a2 ⇽ a3 ⇽ a4 ⇽ a5 ⇽ a6 ⇽ a7 ⇽ a8 ⇽ a9
                ↖              ↖         ↖
       c0 ⇽ c1 ⇽ c2 ⇽ c3 ⇽ c4 ⇽ c5 ⇽ c6 ⇽ c7 ⇽ c8 ⇽ c9


The proof of now shows that while a3 and a4 has b-side blocks, by the
time you reach b6 those two lost blocks were in the minority. Of course
a real system needs to be careful that mining blocks and then discarding
them isn't a profitably way to create coins out of thin air - ratios
well in excess of 1:1 are likely to be required.


Challenge-response resolution
=============================

Another idea is to say if the parent blockchain's contents are known we
can insert a challenge into it specifying that a particular child block
be published verbatim in the parent. Once the challenge is published
further parent blocks may not reference that children on that side until
either the desired block is re-republished or some timeout is reached.
If the timeout is reached, mining backtracks to some previously known
child specified in the challenge. In the typical case the block is known
to a majority of miners, and is published, essentially allowing new
miners to force the existing ones to "cough up" blocks they aren't
publishing and allow the new ones to continue mining. (obviously some
care needs to be taken with regard to incentives here)

While an attractive idea, this is our first foray into moon math.
Suppose such a challenge was issued in block a2, asking for the contents
of b1 to be published. Meanwhile tx1 is created in block c3, and can
only be spent on a b-side chain:

        b0 ⇽ b1
           ↙
    a0 ⇽ a1 ⇽ (a2) ⇽ a3
                       ↖
         c0 ⇽ c1 ⇽ c2 ⇽ c3

The miners of the b-chain can violate the protocol by mining a4/b1',
where b1' appears to contain valid transaction tx2:


        b0 ⇽ b1              b1'
           ↙                ↙
    a0 ⇽ a1 ⇽ (a2) ⇽ a3 ⇽ a4
                       ↖
         c0 ⇽ c1 ⇽ c2 ⇽ c3

A proof of tx2 as valid payment would entirely miss fact that the
challenge was published and thus not know that b1' was invalid. While
I'm sure the reader can come up with all kinds of complex and fragile
way of proving fraud to cause chain a to be somehow re-organized, what
we really want is some sub-linear proof of honest computation.  Without
getting into details, this is probably possible via some flavor of
sub-linear moon-math proof-of-execution. But this paper is too long
already to start getting snarky.


Beyond token transfer systems
=============================

We can extend our simple one txin, one txout token transfer transactions
with merkle (sum) trees. Here's a rough sketch of the concept:

    input #1─┐   ┌─output #1
             ├┐ ┌┤
    input #2─┘│ │└─output #2
              ├─┤
    input #3─┐│ │┌─output #3
             ├┘ └┤
    input #4─┘   └─output #4

Where previously a transaction committed to a specific transaction
output, we can make our transactions commit to a merkle-sum-tree of
transaction outputs. To then redeem a transaction output you prove that
enough prior outputs were spend to add up to the new output's value. The
entire process can happen incrementally without any specific
co-operation between miners on different parts of the chain, and inputs
and outputs can come from any depth in the tree provided that care is
taken to ensure that reorganization is not profitable.

Like the token transfer system proving a given output is valid has cost
linear with history. However we can improve on that using
non-interactive proof techniques. For instance in the linear token
transfer example the history only needs to be proven to a point where
the transaction fees are higher than the value of the output. (easiest
where the work required to spend a txout of a given value is well
defined) A similar approach can be easily taken with the
directed-acyclic-graph of mutliple-input-output transactions. Secondly
non-interactive proof techniques can also be used, again out of the
scope of this already long preliminary paper.


1) "Disentangling Crypto-Coin Mining: Timestamping,
   Proof-of-Publication, and Validation",
   http://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg03307.html

-- 
'peter'[:-1]@petertodd.org
00000000000000002fd949770524eea54446adb70603a90a4c493d345f890e04
-------------------------------------
El 26/04/2014 10:43 p.m., Mark Friedenbach escribi:
Ok. I was thinking with another definition SPV proof.

For me a SPV proof is a sequence of bits which can be transmitted as
part of a non-interactive protocol that convincingly establishes for a
client without access to the block chain that a block B is part of the
best-chain.

I understand that SPV nodes require SPV proofs as defined in my
definition, but I can't realize how to prove that SPV nodes require SPV
proofs under your definition. So your definition sounds to me like one
possible solution, but not the need.
 
Is your definition something well-established in the community?





-------------------------------------
Very, very limited. The more data you stuff in them, the less reliable and
slower scanning becomes. A URL is about the limit of what's practically
achievable. Even with that, BitPay have been complaining about the
increased character length from adding the https url to download the
payment request (though not escaping reduces character count by a lot and
is valid).

X.509 is extremely bloated, partly due to the number of features it
supports, partly due to its history but mostly due to the widespread use of
RSA which generates giant keys and signatures. Of course you can get ECC
certs as well, but in practice most merchants don't seem to use them yet.
There's no way you can fit a cert chain into a QR code.

However, this is no big deal, because for the serverless PoS device case
Alex cares about you need a backchannel to submit the transaction and
refund address anyway, so Bluetooth is already useful/required. Downloading
the payment request via it as well as uploading the response is not a big
change and - as mentioned - already implemented by Andreas and myself some
time ago.



On Thu, Mar 20, 2014 at 1:12 PM, Adam Back <adam@cypherspace.org> wrote:

-------------------------------------
On Fri, Nov 28, 2014 at 12:45 AM, Mistr Bigs <misterbg6@gmail.com> wrote:

Because if the user does not use tor or an analogous infrastructure
(e.g. something else reimplementing tor's functionality) the user can
be deanonymized in many different ways.

At the end of the day, if I'm listening widely to the network, and
your host is regularly the first to hand me your transactions then I
can draw reasonably reliable conclusions... and this is true even if
there is a complete absence of identifiable characteristics otherwise.

And, on the flip side if the host is persistently behind tor, even
with some watermarkable behaviour, their privacy is protected.  So
making sure that hosts can continually use tor (or similar systems)
should be the higher priority.  (And, of course, not reimplementing
tor  leverages the millions of dollars of investment and dozens of
subject matter experts working on that system).


-------------------------------------
G'day great devs,

How can I gain status of maintainer, admin or / and reviewer in https://www.transifex.com/organization/bitcoin/dashboard ?

I'd like to set the description, project logo and whatever is missing on Bitcoin project inside Transifex. I believe if it is better configured it can attract more contributors. Of course my English is not perfect how you can see, but surely I'll copy the description from wiki, source code docs and other fonts written in native English. The logo I'll set the official one.

Also, I want to be able to make review in Portuguese BR. Unapologetically my Portuguese is perfect, I studied the grammar several years and I am native speaker. I've been contributing in Portuguese BR and yesterday I completed the 35% missing translations.

Thank you so much in advance,


Felipe Micaroni Lalli

Walltime - https://walltime.info
Bitcoin Paranoid Android developer
PGP ID: 0x4c0afccfed5cde14 - ED5CDE14
BTC: 1LipeR1AjHL6gwE7WQECW4a2H4tuqm768N

-------------------------------------
+1
On 4 May 2014 02:06, "Chris Pacia" <ctpacia@gmail.com> wrote:

-------------------------------------
On Sun, Mar 16, 2014 at 3:58 PM, Adam Back <adam@cypherspace.org> wrote:

One point to note here is that the if the whole move and quieting
period stuff sounds
cumbersome— thats because it is. Even with the best efficiency optimizations the
security requirements result in somewhat large and slow transactions—
and thats totally fine!

A key point here is that normally someone who needs to use coins on one chain or
the other can use fast atomic cross-chain transactions[1][2] and not
bother with the
slow direct movement across. The cross chain swapping, however, requires an
(untrusted) counterparty on the other chain, while the 2-way peg migrations can
be performed alone in order to provide liquidity and balance demand.


[1] https://en.bitcoin.it/wiki/Contracts#Example_5:_Trading_across_chains
(Hm the citation there is weird, that predates TierNolan's post)
[2] https://bitcointalk.org/index.php?topic=321228.0
CoinSwap: Transaction graph disjoint trustless trading
(private version)


-------------------------------------
On Sun, Apr 27, 2014 at 02:38:06AM -0700, Mark Friedenbach wrote:

Neat idea. It might somewhat reduce the flexibility in which the version
field can be used in the future, though. 

For the sake of simplicity I lean towards a fixed length version field,
but would be ok with either. Keep in mind that version numbers can be
recycled after a couple of years. So there is effectively zero benefit
in allowing varints to extend beyond 2 bytes. For that reason personally
I think 1 byte of version number would be enough.


-- 
Timo Hanke
PGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8


-------------------------------------

A bit more competitive intelligence - turns out that the experience isn't
quite so good after all. After trying a few more times to use contactless
payments, I found it has a ~75% failure rate based on my usage.

By far the biggest problem is also the most predictable - it's very common
here for merchants to require minimum payment sizes before they'll accept
credit cards, often quite high, like 20 CHF or more. But the PIN-less mode
only works for payments below a certain threshold, I haven't quite figured
out what it is yet, but in the UK it's 20 GBP so maybe it's about 30 CHF.
So there turns out to be an incredibly thin price range in which the simple
touch-to-pay system actually works. Most of the time, either they:

a) Reject cards entirely because the payment is too small
b) Don't have the right hardware, or the hardware just mysteriously fails
to work.
c) Require a PIN because the payment is too large

I'm sure Bitcoin can do better than this.
-------------------------------------
Excellent points Christophe!

Although moving to 1e-6 units is fine for me and I see advantages of doing
this, I don't get that people on this mailing list are fine with calling
such unit "bit". It's geeky as hell, ambiguous and confusing.

slush


On Sat, May 3, 2014 at 5:48 PM, Christophe Biocca <
christophe.biocca@gmail.com> wrote:

-------------------------------------
On Mon, Jul 28, 2014 at 11:01 AM, Mark van Cuijk <mark@coinqy.com> wrote:


I'm not sure postponed is the right word. It wasn't in v1, but many useful
things weren't. It's more like, a bunch of people have to do work to
upgrade this and at the moment they're all busy with other things.



I don't think I proposed this exactly? It's the other way around - a
merchant issues an extension cert to allow the PP to act on their behalf.



I'm not sure I understand. Your proposal also has two signatures. Indeed it
must because delegation of authority requires a signature, but old clients
won't understand it.
-------------------------------------
On Fri, Dec 12, 2014 at 07:50:48PM +0200, Alex Mizrahi wrote:

You're quite mistaken actually. One of the first things to come out of
my research as Mastercoin's Chief Scientist - indeed after a week on the
job - was how to safely upgrade embedded consensus systems in a
decentralized fashion:

http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03890.html

To recap, where valuable scarce tokens are concerned we want to ensure
that an attacker can't use a fork caused by an upgrade to double-spend
tokens. We solve this problem by ensuring that when a token visible to
version V_i is spent in a V_{i+1} client, the token appears spent to
version V_i clients as well. This is easy to accomplish by a "split
transaction" scheme that separates all operations into separate
"increment" and "decrement" operations.

The simplest example of this principle in action is colored coins, which
are certainly an example of an embedded consensus system. Colored coin
implementations naturally ensure that all versions of the system see a
token getting spent the same way - the corresponding txout is spent! So
long as changes to the coloring rules are handled such that only one set
of rules - one version - can apply to a given txout spend we get
anti-doublespend protection.

The second aspect of the problem is the social/political implications of
upgrades - because embedded consensus systems don't outsource trust they
very clearly require the co-operation of the economic majority in an
upgrade. For instance if the community has two competing proposals for
how to upgrade version V1 of Counterparty, V2a and V2b, choosing to move
your tokens to either version becomes a vote with serious economic
consequences. In fact, it's quite possible that a community would choose
to simply fork into two different systems each offering a different set
of features. Equally in the event of such a fork someone can create a
third version, V3, that recombines the two incompatible forks. Again,
anyone who agrees with version V3 can choose to move their tokens to it,
healing the fork.

Arguably this process of handling forks by direct economic voting is
significantly *more* decentralized than Bitcoin's soft-fork mechanism as
adoption of a new version is something all participants in the system
play a part in equally. (as measured by economic stake) Of course, it
will lead to sometimes ugly political battles, but that's simply part of
the cost of having democratic systems.



+1

-- 
'peter'[:-1]@petertodd.org
00000000000000000681f4e5c84bc0bf7e6c5db8673eef225da652fbb785a0de
-------------------------------------
One participant, yes.  Two participants lacking net would require a
serious revisit of BIP 70's security assumptions and some design, at a
minimum.

On Sat, Mar 22, 2014 at 12:55 PM, Mark Friedenbach <mark@monetize.io> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On 04/23/2014 10:01 PM, Luke-Jr wrote:

So you suggest to scan for accounts, show balances but don't allow user
to spend them? Does not seem right to me.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
https://bitcointalk.org/index.php?topic=571414.0
Thanks to the efforts of Cory Fields, Bitcoin Core now has deterministic
builds for MacOS X.  The nightly builder now has Windows, Linux and MacOS X
test builds available for download.

Warren


On Wed, Apr 16, 2014 at 3:43 PM, Warren Togami Jr. <wtogami@gmail.com>wrote:

-------------------------------------
On Friday 04 July 2014 07:22:19 Alan Reiner wrote:


I did.  Sorry.


Excellent.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com



-------------------------------------
n Fri, Aug 8, 2014 at 6:01 AM, Mike Hearn <mike@plan99.net> wrote:

It would be wrong to add NODE_INSIGHT, NODE_ELECTRUM_SERVER, etc. bits
even though you do have useful bitcoin-related APIs that exist on the
same system as bitcoind.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On Sat, Mar 29, 2014 at 2:10 PM, Matt Whitlock <bip@mattwhitlock.name> wrote:

Discussion of whether you should or should not use SSS is separate
from whether you should or should not write a BIP.

If people are using SSS in the field, it is better to write a BIP than
not.  Informational BIPs describing existing practice can be useful.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 19 May 2014 20:43:15 CEST, Gregory Maxwell <gmaxwell@gmail.com> wrote:


Interesting. Is that to say a viable strategy would be to apply for patents and let the application lapse?
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJTelGCMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhQPlCACjJgJEyMYMtF+/dJJh
TgWfVuE7E7QmwgWoQMBo7/5LgO1W5PQt9d3jfQ7gkrdCqTWs4HtA3lcgjdeEQ6ZW
QvMFG5/xITVi85v2zlE9CteQZXLBTSI+J7VlkjqnJeftQkklvGjiDtNfaDDsTacV
ZNem06V4fmBxNgzqmit2Roilp+NMQb2iM9Ofkr5FbI0cT/kzD/IJd2+Crqsu/uDU
8r2YQY0bbEf2wqxVdq5TSf1rFqqnWKHB3lD1GGRJ8n5BciBmysZL43jct8YABSgi
BHFpJP2ii7gz076mRiBb+KwCo+1xKUYNpsJk1m7HND7PjqkXps+JHiNaWdr9vAxx
raFO
=L1oX
-----END PGP SIGNATURE-----



-------------------------------------
An attack on the mining difficulty algorithm does not imply violation of
the typical security properties of a cryptographic hash function*.

Assume someone discovers a method which makes it far easier to discover new
blocks, this method: may or may not be implementable by the current SHA256
ASIC hardware.

1. If it is usable by the mining hardware, then there will be brief period
of overproduction and then difficulty will adjust. If the attack is so bad
that difficulty can't scale and we run out of a leading zero's, then the
SHA256 collision resistance is broken and we have bigger problems. Under
this scenario, everyone would see the need to immediately switch to new
hardware as people could create cycles and irreconcilable forks in the
block chain

2. If the attack is not usable by the mining hardware, then the miners will
need to switch to new ASICs anyways and the hash function can be changed
without resistance.

But lets ignore all that and say, for some unspecified reason, the bitcoin
community wants to switch hash functions and has some lead time to do so.
One could require that miners find two blocks, one computed using SHA256
and one computed using the new hash function. We could then slowly shift
the difficulty from SHA256 to the new hash function. This would allow
miners a semi-predicable roadmap to switch their infrastructure away from
SHA256.

* It would be a distinguisher which would be bad, but collision resistance
could be merely weakened.


On Tue, Jun 3, 2014 at 12:52 AM, Luke Dashjr <luke@dashjr.org> wrote:

-------------------------------------
Yes, that is the one change I am still pondering:  adding categories
(classes), rather than one single bit.

Thus the modified proposal would become:
- eliminate NODE_EXT_SERVICES
- for a class of services, such as insight w/ added blockchain indexes
& queries, add NODE_EXT_INDEXED_CHAIN
- for another class of services, add NODE_EXT_xxxx
- Re-use the same P2P message and structure (CExtService,
"extservices" P2P message) for all NODE_EXT_xxx classes.

This preserves vendor/API neutrality, while saving effort on the part
of clients seeking these services.  The point about service discovery
necessitating some node walking is valid, which makes categories
somewhat attractive.

"Having the service run on some arbitrary other port isn't
particularly useful, IMO" --  A statement disproved by reality.
Multi-port is the method most commonly found in the field today.
Logically so, because it is the easiest to deploy:

* The most likely setup TODAY is multi-daemon: bitcoind + your own software
* The most likely configuration for multi-daemon is self-evidently
multi-port (versus two services appearing on the same port)

It is quite useful, and indeed, the most likely setup to be found in operation.







On Fri, Aug 8, 2014 at 7:38 AM, Mike Hearn <mike@plan99.net> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On Mon, Dec 29, 2014 at 10:34 PM, Justus Ranvier
<justus.ranvier@monetas.net> wrote:

What services?
I must be missing something obvious about the motivation.
I understand the difference between "paying to myself only when I mine
the next block" and "offering fees to whoever mines this tx".
But how does allowing miners to pay to themselves in this way help
with security and future lower subsidies at all?


-------------------------------------
On Wed, Apr 16, 2014 at 11:39 PM, Mark Friedenbach <mark@monetize.io> wrote:

Or, even accidentally, cause a hard forking bug to be rolled out (or
worsen one).

-- 
Pieter


-------------------------------------
The correct approach here is header hash-tree commitments which enable
compact (logarithmic) SPV proofs that elide nearly all intervening
headers since the last checkpoint. You could then query the hash tree
for references to any of the headers you actually need.

See this message for details:

http://sourceforge.net/p/bitcoin/mailman/message/32111357/

On 06/04/2014 12:30 PM, Richard Moore wrote:


-------------------------------------
As someone who has put a lot of thought into how to best help typical everyday people understand bitcoin, I strongly favor 1 bit = 1e-6 BTC as being very straightforward to explain to non technical types, and also XBT as one "bit".  "There are a million bits in a bit coin" is highly intelligible to average people. 

I consider overload/conflict with existing meanings of "bit" as a non-issue for typical population at large. 

Mike

Sent from my iPhone



-------------------------------------
Bear in mind a separate process doesn't buy you anything without a sandbox,
and those are expensive (in terms of complexity).
On 21 Feb 2014 11:40, "Jeff Garzik" <jgarzik@bitpay.com> wrote:

-------------------------------------
I do not suggest to encode the chain, in contrary.

I consider the encoding of main and testnet in WIF and BIP32 as legacy, that I ignore, and suggest that new BIPs should no longer carry this forward.

Regards,

Tamas Blummer
http://bitsofproof.com

-------------------------------------
On Mon, Jun 9, 2014 at 11:13 AM, Richard Moore <me@ricmoo.com> wrote:

See the not yet finished proposal at
https://bitcointalk.org/index.php?topic=258678.0

It's generally a lot more sound and well thought out than BIP38.
Though right now I believe it's being revised to support secret
sharing.


-------------------------------------
On Tue, Aug 19, 2014 at 7:02 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:

Smaller first step would be to mirror the git repository on
bitcoin.org, which is necessary anyway before switching primaries.

- Bryan
http://heybryan.org/
1 512 203 0507


-------------------------------------

On 11/17/2014 06:20 AM, Adam Back wrote:
This is my main concern in the context of stealth addresses. I intend to
start a larger discussion on stealth addresses, but I wont hijack the
tread.

Of course it's easy to send the necessary data out of band as opposed to
OP_RETURN. The problem is if you do that the transaction cannot not be
recovered from seed. We've been fairly successful in transitioning to HD
wallets and avoiding the need to make regular wallet backups.

If users wishes to use stealth addresses with out of band communication,
the benefits of HD would largely be lost and they would be back to
making regular backups ― this time after /every/ transaction rather than
every 100.

There are only a couple options in such cases:

1) The user could send the payment to an addresses that is derived from
seed, but now you're using even /more/ storage space than you would by
just using OP_RETURN.

2) The user can backup after every transaction, which nobody wants to do.

3) The user could use some form of a cloud backup service and place
trust in them that their servers wont go down and lose their coins.

None of those options are really that appealing. OP_RETURN seems like
the best alternative to me, at least for that use case.
-------------------------------------
On Wed, Feb 12, 2014 at 4:39 PM, Alex Morcos <morcos@gmail.com> wrote:

It has been, but there are probably many people like you who have not
bothered researching who may also be curious.


Because doing so would be both unnecessary and ineffective.

Unnecessary because we can very likely eliminate malleability without
changing what is signed. It will take time, but we have been
incrementally moving towards that, e.g. v0.8 made many kinds of
non-canonical encoding non-standard.

Ineffective— at least as you describe it— because the signatures
_themselves_ are malleable.


-------------------------------------
Mike Hearn <mike <at> plan99.net> writes:

his node or relayed by mine (there are only two nodes in this little 
detection network currently), and it does show double spends that occur 
seconds, minutes or even days apart.

I only meant that double spends minutes apart are possible and that by then 
the sole use of a monitor is too late even if it will tell you.

thread. Let's all hope it does and discuss the details in some other thread, 
or on the pull request.

Fair enough.

millisecond counts and you probably don't want to rely on watching 
transactions propagate across the block chain. For inter-exchange traffic 
this BIP would probably be useful. I've been talking about the consumer 
case.

That's quite different, granted.

unnecessary, e.g. when I buy a drink at Starbucks or a burger at McDonalds 
the chances of me wanting to charge it back is basically zero. Same for 
sending between people who know each other, large corporate transactions 
where the threat of a lawsuit is more useful than mediation, etc.

I wouldn't assume that if bitcoin alone (i.e. without third parties) can't 
be used for medium-high value purchases then it's useless. 

yes, I'd expect there to be a handful of well known trusted names for the 
majority of such transactions, and then a long tail of specialists who only 
mediate e.g. purchases of rare Aztec artifacts or other things where a 
generic company might be easily fooled.

Agreed.



-------------------------------------
On Tue, Oct 28, 2014 at 8:17 PM, Ferdinando M. Ametrano
<ferdinando.ametrano@gmail.com> wrote:

Or very old, indeed, if you are using unsigned arithmetic. [...]


Hardly,

http://bitcoincharts.com/charts/mtgoxUSD#rg60zczsg2012-10-01zeg2012-12-01ztgSzm1g10zm2g25zv


It isn't, but many people have performed planning around the current
behaviour. The current behaviour has also not shown itself to be
problematic (and we've actually experienced its largest effect already
without incident), and there are arguable benefits like encouraging
investment in mining infrastructure.

This thread is, in my opinion, a waste of time.  It's yet again
another perennial bikeshedding proposal brought up many times since at
least 2011, suggesting random changes for
non-existing(/not-yet-existing) issues.

There is a lot more complexity to the system than the subsidy schedule.


-------------------------------------
<delurk>

What about "ubit", pronounced "YOU-bit", representing 1e-6 bitcoin? Easy to
say, tied in a visual way to the metric micro, leaves the required 2
decimal places for the marginally numerate.. What more could one want?

</delurk>

Also, hi. My first post; plan to get involved over the southern hemisphere
winter if I can learn enough.
On Apr 20, 2014 4:32 PM, "Mike Caldwell" <mcaldwell@swipeclock.com> wrote:

-------------------------------------
May I ask how the current payment protocol is supposed to handle salaries? I hope you do not assume the employee creates a payment request, since he does not
even calculate the amount. There you go where a channel I described is definitelly needed.

Tamas Blummer
http://bitsofproof.com

On 28.03.2014, at 12:30, Tamas Blummer <tamas@bitsofproof.com> wrote:


-------------------------------------


If it's only during the few seconds that it takes to to verify the block,
then would this really be that big of a deal?  E.g. even if all miners did
this, a 10 second delay would only yield an average of a couple blind/empty
blocks per day.


On Sun, Apr 20, 2014 at 10:06 PM, Peter Todd <pete@petertodd.org> wrote:

-------------------------------------
On Thu, Jul 31, 2014 at 2:41 PM, Kaz Wesley <keziahw@gmail.com> wrote:

"(e.g. from a reconciliation step first)" the list can be communicated
in the space roughly equal to the size of the difference in sets plus
coding the permutation from the permissible orderings.   If you did
have some "simple approach" that guaranteed that some transactions
would be present, then you could code those with indexes... the FEC
still lets you fill in the missing transactions without knowing in
advance all that will be missing.   (Also, the suggestion on the
network block coding page of using part of a cryptographic permutation
as the key means that for unknown transactions the transmission of the
new unknown keys is always goodput— doesn't add overhead)

It's "only a bound" but you can pick whatever bound you want,
including— if you send data equal to the missing amount, then it'll be
always successful, but no bandwidth savings.   Though if the transport
is unordered (e.g. UDP or non-blocking SCTP) even sending 100% of the
missing amount can save time by eliminating a round trip that might
otherwise be needed for a retransmission.


-------------------------------------
RE " It's not like other software where people can choose to skip an
upgrade and things still work just like before."

If you're a minority, sure you can.  Still a few nutters out there on
a 0.3.x codebase, including one or two inattentive,
now-inconsequential miners.

There is some headroom built in for just that... less disruptive
upgrades that don't require 100%.



On Fri, Oct 3, 2014 at 4:58 PM, Mike Hearn <mike@plan99.net> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On Wednesday, April 23, 2014 8:04:03 PM Pavol Rusnak wrote:

Scan all branches for UTXOs, then you have the balance for the wallet. Account 
balances are metadata, so cannot be known from the seed alone. If you want to 
have a way to restore accounts, you must define some more detailed wallet file 
format (which could be built on top of this).

On Wednesday, April 23, 2014 8:04:35 PM you wrote:

Sure, it *knows* what address was used to receive it. But at the point it's a 
UTXO, that address is no longer relevant.

Luke


-------------------------------------
On Mon, Jan 13, 2014 at 12:41 PM, Alan Reiner <etotheipi@gmail.com> wrote:

If you have enough of a communications channel to do that you can just
give the person the finished address (authentication aside).

The idea here is to cover the cases where the communication is one way
or nearly so.  Consider a donation address on a fully static webpage,
in a forum signature or email address, or on a billboard. ... or where
users-being-users mean that the user isn't going to start up their
wallet software to compute a new multiplier every time they give out
an address no matter how much we whine at them.


-------------------------------------
2014-03-20 8:08 GMT+00:00 Andreas Schildbach <andreas@schildbach.de>:


​I guess this would be best option​. I'm also worried about potential QR
code capacity, since as I imagine we can encounter device that has your
Wallet installed and bluetooth enabled, but no NFC available, so we will
have to operate via onscreen QR codes + bluetooth.
Hmm, if we're inventing an URI for bluetooth, I'd rather follow existing
URI's patterns. BT is strictly point-to-point connection, so BT MAC should
be considered as server address, and payment request ID can be considered
as request path. Probably "bt:<bt-mac>/​<random_id_of_payment_request>"
would be more usual and easily understandable.
Really I don't think my PoS will now support multiple simultaneous
payments, but it's good to have this thing in place for the time I will
need it.
I wonder how complex it would be to implement HTTP-over-Bluetooth. Not like
I'm willing to do that now, but HTTP is well known and proven to be quite
good for tasks like this, so in theory it would be handy to have such
capacities in here.



My PoS needs to be compatible with BIP21, as when I'm presenting QR code or
sending NFC message - I have no way to tell what wallet/phone is ​​on the
accepting side, so I have to be compatible to existing widely supported
technologies.





​Well, yes, it would be less efficient than base43. But did you calculate
how much less? ​It's a compatible and already widely used way and loosing
compatibility needs to have serious reasons, so would be great to know
exact figures here.

I can find out base64 size, but I don't have a working base43
implementation (since the only existing is in Java, and I don't speak it).
Can you give me a sample uncompressed PR file of moderate size and a base43
encoded version of it? And I'll convert it into base64 and compare.



------------------------------------------------------------------------------
-------------------------------------
Hi Mike,

thanks for your assessment.

Please find my replies in-line:

Since when? This has been a recognized approach since people called it
"hashcash" ([1] - before cryptocurrencies were even invented).

I hear your concerns, but even then, I would see the PoW-based
approach as an improvement to today's situations.

To be clear, I do not propose to have _all_ clients do complicated
work. Just those using an address which has been misbehaving. Right
now, they cannot connect at all, no matter how much resources they
dedicate towards doing so.


The way I had it in mind, well-behaved clients on an address used by
attackers would have more effort to connect because of the PoW, but
after that, they can stay connected. The attacker also has to put more
effort into connecting, and after sending malformed messages, gets
disconnected. So, the attacker would have to perform much more PoW
computations in order to keep up his attack.


Exactly. Not every user may like to have a cookie by which an observer
might get the chance to even link his connection to his previous
connections, thereby allowing the discussed deanonymization technique
to get even more effective.

Maybe having both options would be even better: In case of an attack,
those able to solve the anti-DoS PoW can still connect (just maybe
slower). Those who wish to run a weak client can choose to sacrifice
privacy for connectivity and keep a cookie for connecting.

Best regards,

Isidor

[1] http://www.hashcash.org/papers/hashcash.pdf


-------------------------------------
Kristov,

On Wed, Apr 23, 2014 at 10:05 PM, Kristov Atlas <kristovatlas@gmail.com> wrote:

I've modified the gitian build so that it builds against Qt 4.6
instead of Qt 4.8 in this pull request:
https://github.com/bitcoin/bitcoin/pull/4094

A test build of master with that pulls gitian descriptor is available:

https://download.visucore.com/bitcoin/linux-4765b8c-gitian-2d48b96.tar.gz
https://download.visucore.com/bitcoin/linux-4765b8c-gitian-2d48b96.tar.gz.sig

These bitcoin-qt executables *should* work on Debian Squeeze / Tails
Linux. Let me know if it is the case.

Wladimir


-------------------------------------
On 18/05/14 19:43, Ral Martnez wrote:

As an interested party not intimately familiar with the bitcoin codebase
who also spent some time setting up a node a while ago, I would like to
add one thing to the above list - network rate limiting.
When I first set up my node, I did not consider this until it started
eating all of my upstream bandwith (on an ADSL line that isn't so fun),
and I must admit I was a bit disappointed when I found that I would have
to set this up separately. An option to limit the upstream and
downstream network usage (like what tor or most torrent clients does)
would be useful.

On the note of the distro packages, I've so far been pretty happy with
the packages provided by Arch Linux - I have no idea if they build it
correctly (with the correct static libs and all), but it seems to work
fine for the edge router case.

Bjrn ivind


-------------------------------------
On Mon, May 19, 2014 at 4:36 PM, Robert McKay <robert@mckay.com> wrote:

Quite the opposite.  dnsseed data rotates through a lot of addresses
if available.  Using the bind/zone-xfer system would result in fewer
total addresses going through to the clients, thanks to the addition
of caching levels that the bind/zone-xfer system brings.

That said, if the choice is between no-service and bind, bind it is ;p

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Modern devices like smartphones and tablets do not have swap files. This
design is chosen to ensure responsive, fluid UI that can avoid blocking on
disk regardless of how much multi-tasking is done, but it creates ripples
that impact everything else.

One implication of this is that on these devices, we cannot store all keys
or transactions in memory forever. BIP 70 has an expiry field for
PaymentRequests that we can use to allow us to eventually stop loading
those keys into RAM - at that point payments to those keys would no longer
be recognised. But there's no equivalent for refund addresses.

More generally, though we re-used the output structure to define the
refund, we didn't (for some reason that I forgot) reuse PaymentDetails,
even though the payment details for a refund are indeed PaymentDetails.

Though I am loathe to go back and redesign this part of BIP 70 so soon
after we shipped v1, it seems to me like the refund feature may be hard to
implement on phones if there's no time limit for when you can receive a
refund. Otherwise a wallet has to be looking out for refunds for payments
you may have made years ago. So perhaps we should add a new refund field
that embeds a PaymentDetails structure instead of being just a list of
outputs.

We could try and solve this problem some other way purely internally, by
doing a kind of wallet-specific swapping process in which things like Bloom
filters are calculated without all keys in them being held in memory at
once (perhaps caching filters for old parts of the key chain on disk), so
you can have "infinite" wallets, but eventually the huge Bloom filters that
would result would hurt efficiency in other ways. So key expiry seems
pretty fundamental to scalability.
-------------------------------------
Wladimir,

On Jun 13, 2014, at 12:18 PM, Wladimir wrote:


this import can actually break things. I'd avoid it.
-- 
Pavel Jank





-------------------------------------
I think i see a bug:

line 273 of key.cpp

        if (rec<0 || rec>=3)
            return false;

Afaict, 3 is a perfectly valid value, meaning 25% of sig-> key recoveries
would fail erroneously...
-------------------------------------
Burn mining side chains might be one of the foundation ideas for that ecosystem, enabling permission-less merge mining for
anyone with interest in a side chain.

I am puzzled by the lack of feedback on the idea.

Tamas Blummer
Bits of Proof
-------------------------------------
There is no infrastructure for writing block chain unit tests
unfortunately. Last time I tried to fix this I ended up going down a rabbit
hole - Bitcoin wasn't written to be a testable codebase and as a result
reinitialising it from scratch is rather difficult (there are lots of
global variables that have to be reset to particular states and no real
list of where they are).

Instead what I ended up doing is extending the pull tester. This is a
bitcoinj based app (BitcoindComparisonTool in the codebase) which builds a
regtest chain and submits it to a local regtest node. It tests things like
reorgs and various rules. It speaks to the node only via P2P so how easy it
is to verify your BIP works will depend on that. Also the code needs
cleaning up, there's a lot of copy/paste coding going on in there.




On Mon, Jul 21, 2014 at 7:30 PM, Sergio Lerner <sergiolerner@certimix.com>
wrote:

-------------------------------------
On Wed, 15 Jan 2014 23:51:21 +0100, Mike Hearn wrote:

I think it might be ok to use proof-of-stake on as an anti-sybil scheme 
on tor.. people would obviously not want to associate their wallet with 
their IP address, but is there any harm in associating it with a 
(temporary) tor service id (especially one that isn't used for anything 
other than relaying bitcoin transactions)? If each node you connect too 
can sign some challenge with a key that controls some BTC (and your 
client node verifies that the funds are different) then that might be 
useful.. even if it were only a small 0.01BTC stake that would be 
similar to the cost of obtaining another IP through a cheap VPS or VPN 
and significantly higher than the cost to an attacker who is able to 
MITM everything and operate on any IP anyway.

Rob


-------------------------------------
On Wed, Mar 5, 2014 at 2:17 PM, Kevin <kevinsisco61784@gmail.com> wrote:

To the reference software?  Normally you'd open a github account and
submit there.

Though if for some reason you can't— though its strongly preferred—
sending a git-format-patch via email might be an acceptable fallback.


-------------------------------------
On Saturday, 29 March 2014, at 5:28 pm, Roy Badami wrote:

Respectfully, it's also possible to take a base58-encoded private key and run it through GPG, which is included in most Linux distros. But yet we have BIP38.


-------------------------------------
At the moment there's no way to distinguish between a failed / rejected
submission and a successful one beyond the freeform memo field, right? It'd
be good if we had an error code field as well, perhaps for a future version.
-------------------------------------
On Mon, Nov 17, 2014 at 4:19 AM, Alan Reiner <etotheipi@gmail.com> wrote:

You can still send the signature out of band (for example using the
payment protocol), and just have the transaction commit to a hash of
that signature (or message in general), either using an OP_RETURN
output to store the hash, or using the pay-to-contract scheme that
Jorge mentioned above. That has exactly the same timestamping
properties.

My main concern with OP_RETURN is that it seems to encourage people to
use the blockchain as a convenient transport channel, rather than just
for data that the world needs to see to validate it. I'd rather
encourage solutions that don't require additional data there, which in
many cases (but not all) is perfectly possible.

-- 
Pieter


-------------------------------------

This is surprising and the first time I've heard about this. Surely your
constraint is CPU or disk seeks? Addresses are small, I find it hard to
believe that clients uploading them is a big drain, and mostly addresses
that are in the lookahead region won't have any hits and so won't result in
any downloads?

This constraint is not so important for bloom-filter clients.


Bloom filters are a neat way to encode addresses and keys but they don't
magically let clients save bandwidth. A smaller filter results in less
upload bandwidth but more download (from the wallets perspective). So I'm
worried if you think this will be an issue for your clients: I haven't
investigated bandwidth usage deeply yet, perhaps I should.

FWIW the current bitcoinj HDW alpha preview pre-gens 100 addresses on both
receive and change branches. But I'm not sure what the right setting is.

We also have to consider latency. The simplest implementation from a
wallets POV is to step through each transaction in the block chain one at a
time, and each time you see an address that is yours, calculate the next
ones in the chain. But that would be fantastically slow, so we must instead
pre-generate a larger lookahead region and request more data in one batch.
Then you have to recover if that batch ends up using all the pre-genned
addresses. It's just painful.



Maybe. I dislike any distinction between users and merchants though. I
don't think it's really safe to assume merchants are more sophisticated
than end users.



I think such synchronization won't be possible as we keep adding features,
because the block chain cannot sync all the relevant data. For instance
Electrum already has a label sync feature. Other wallets need to compete
with that, somehow, so we need to build a way to do cross-device wallet
sync with non-chain data.
-------------------------------------
On Fri, Jun 6, 2014 at 10:29 AM, Wladimir <laanwj@gmail.com> wrote:

There are a few examples of things that would classify as
expensive/redundant checks:
* addrman consistency checks (only enabled with -DDEBUG_ADDRMAN).
* mempool consistency checks (only enabled with -checkmempool).
* deadlock detection (only enabled with -DDEBUG_LOCKORDER).

I'm not sure all of these make sense to put under a single runtime
flag. For example, addrman consistency is unlikely to be affected
unless you're working on addrman code, and is pretty expensive.

Still, I do like the idea of optional consistency checks, that help
guarantee the software always has a consistency state.

-- 
Pieter


-------------------------------------
Right. So part of this is my fault, I'm afraid, because I do not intend to
implement any kind of subwallet/account support in bitcoinj. My reasons are:

   1. The bitcoinj API already lets you create and use multiple wallets.
   What's more, because of the desire to do key rotation (think rotating a
   previously unencrypted wallet to an encrypted one that is stored on SSD's
   that cannot reliably erase data), a bitcoinj wallet can actually contain
   multiple BIP32 seeds and hierarchies at once, although only the last one
   will be used for vending addresses. So adding subwallet support onto this
   makes it even more complicated.

   2. If there was a much better user experience to be enabled by this, it
   may be worth it, but I believe many people will find subwallets rather
   confusing. They don't match the analogy of bank accounts in several ways.
   For instance, transferring money across them leaks private data and costs
   miners fees, neither of which are true with banks.

   Also it differs in a more important way. People have different bank
   accounts because those accounts implement different policies. Current
   accounts may pay a lower interest rate than savings accounts, but have
   different features, and accounts can be used as security boundaries i.e. no
   card withdrawals from savings. But "subwallets" are not like this. The only
   justification for their existence is to avoid outputs being merged together
   to make payments - a subtle technical detail of the protocol that users are
   ill equipped to understand. If someone asked me "why should I create a
   second account" I would be unable to give them a satisfying answer without
   first teaching them about how the Bitcoin protocol works and the privacy
   implications of that, which is practically a lecture sized topic.

   3. MultiBit did support multiple wallets for a long time (just by
   creating multiple wallet files and using the support in bitcoinj for
   running them in parallel), but they decided to remove this feature in
   MultiBit HD because it caused support headaches. People would stash money
   in one wallet or the other, close the wallet and then forget and think they
   had lost it, etc. It may be that TREZOR type subwallets don't suffer this
   confusion because they can't be moved around or "closed" in the same way a
   file can be, but still, this is a data point against multiple simultaneous
   wallets. At least for products targeting entry level consumers.

Whilst I can well believe there are TREZOR users who are asking for this
feature today, currently the costs feel a bit higher than the benefits.

It would be rather nice to be able to type in a mnemonic code that myTREZOR
was initialised with and duplicate that wallet into a bitcoinj based wallet
app. But if I have to implement subwallets and expose this in the API, and
if all wallet authors that want to be able to share a wallet with myTREZOR
have to expose subwallets in their GUIs too, even though the concept may
prove confusing and hard to explain, then it might be more tempting to just
tell users that want to switch wallet apps to send the money via the block
chain instead.




On Thu, Apr 24, 2014 at 9:10 AM, Pieter Wuille <pieter.wuille@gmail.com>wrote:

-------------------------------------
On Thu, Jul 31, 2014 at 6:38 PM, Matt Whitlock <bip@mattwhitlock.name> wrote:

Transactions that become invalid later are have pretty severe
consequences because they might mean that completely in an absence of
fraud transactions are forever precluded due to a otherwise harmless
reorg.

While there may be uses for that, the resulting outputs should be
considered differently fungible— like coinbases which are immature—
and should probably be only used with great caution... not as a
mechanism for ordinary transactions.


-------------------------------------
On Sat, Sep 20, 2014 at 08:38:15AM -0700, Peter Grigor wrote:

It's because of how the merkle tree algorithm works:

    uint256 CBlock::BuildMerkleTree() const
    {
        vMerkleTree.clear();

So here all the txids are pushed onto the vMerkleTree vector:

        BOOST_FOREACH(const CTransaction& tx, vtx)
            vMerkleTree.push_back(tx.GetHash());

For most of the early blocks there's just the coinbase transaction and
no other transactions.

        int j = 0;
        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)

That means this for loop never executes! nSize = vtx.size() == 1, and
the loop terminates when nSize <= 1

        {
            for (int i = 0; i < nSize; i += 2)
            {
                int i2 = std::min(i+1, nSize-1);
                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),
                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));
            }
            j += nSize;
        }
        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());
    }

Thus the vMerkleTree still has only the coinbase txid in it, and and
vMerkleTree.back() returns that txid as the merkle root. There's no
problem with the merkle root algorithm working that way - to make a long
story short all this means is that the merkle tree algorithm
consistently uses the txid as the merkle root whenever there is only one
transaction. The contents of the block is still being securely committed
to by the merkleroot, which is the important thing, and there's no way
to lie about those contents.

There is however a serious flaw in the algorithm, unrelated to the case
of a single transaction, where the merkle tree is indistinguishable from
a merkle tree with duplicate txids if there are a non-power-of-two
number of items in the tree. For bitcoin we fixed this flaw with BIP30
and BIP34; for any other application you should *never* use the Satoshi
merkle root calculation code. Get it right on day one and do things
correctly.

-- 
'peter'[:-1]@petertodd.org
00000000000000000fbf83c9e14d8711e4b2264ceda0d1d06d169c811387eadd
-------------------------------------
On Monday, December 29, 2014 7:21:02 PM Sergio Lerner wrote:

This is something I've wanted since 2011, but hasn't been a priority.


I'm not sure this increases the priority of it.

If someone feels it's worth the time, I'd suggest coding up a branch that 
hardforks it in at some far-off block height. Even if it doesn't get merged 
right away, at least the code will be available for testing and ready to go 
when/if that time comes.

Luke


-------------------------------------
On Tuesday, 22 April 2014, at 8:45 pm, Tom Harding wrote:

Respectfully, this is not the goal of miners. The goal of miners is to maximize profits. Always will be. If they can do that by enabling replace-by-fee (and they can), then they will. Altruism does not factor into business.


-------------------------------------
On Mar 6, 2014 3:47 AM, "Mike Hearn" <mike@plan99.net> wrote:
very well and was quite delightful - definitely want to be doing more of
these in future. I think people will come to expect this kind of
no-friction payment experience and Bitcoin will need to match it, so here
are some notes on what's involved.
thinking about this, but it rapidly became very complicated and feels like
an entirely separate project that should stand alone from Bitcoin itself.
Perhaps rather than try to make a global system, social data could be
exchanged (using some fancy privacy preserving protocols?) so if your
friends have decided to trust seller X, your phone automatically trusts
them too.

A reputation network might be an interesting idea, or several different
networks with different curators (to prevent complete centralization), like
how the US credit score system has three main companies who track your
score. Something like a GPG ring of trust, with addresses signing other
addresses would work well, if some sort of Stealth address or HD wallet
root was the identity gaining the reputation, then address re-use wouldn't
have to be mandatory.
-------------------------------------
On Thu, Apr 10, 2014 at 8:38 AM, Mike Hearn <mike@plan99.net> wrote:

I agree that there is a fundamental incompatibility in usage between
wallets and nodes. Wallets need to be online as little as possible, nodes
need to online as much as possible.

However, a full node background process could also be running if the wallet
is not open itself. Ffor example - by running as a system service.

Bitcoin Core's own wallet is also moving to SPV, so this means a general
solution is needed to get people to run a node when the wallet is not
running.

Maybe the node shouldn't be controlled from the wallet at all, it could be
a 'node control' user interface on its own (this is what -disablewallet
does currently). In this case, there is no need for packaging it with a
wallet The only drawback would be that initially, people wouldn't know why
or when to install this, hence my suggestion to pack it with wallets...

Wladimir
-------------------------------------
On Tue, Mar 25, 2014 at 9:49 AM, Peter Todd <pete@petertodd.org> wrote:

Peter, take this unprofessional, personal crap off-list.

Mike's anecdote of hostility is not an isolated one.  Just today, a
bitcore developer commented on "Peter Todd's ..apocalyptic vision
and... negative view on bitcoin" which turned off some other
developers from participating more interactively.

As I commented on IRC, open source projects are no strangers to people
who simultaneously (a) make useful contributions and (b) turn
potential contributors away with an abrasive or hostile attitude
toward others.  It's an unsolved problem in OSS, that I saw for 15+
years in the Linux kernel community.

For this list, as Mike suggested on IRC, introducing an openly stated
moderation policy may be the one route.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
On 3/22/14, Peter Todd <pete@petertodd.org> wrote:


I'm not against about miners accepting transactions that have longer
data  in non-utxo polluting OP_RETURN than whatever is specified as
standard by the reference implementation, maybe it should be risen in
standard but I think it was assumed that the most common case would be
to include the root hash of some "merklized" structure.
My only argument against non-validated proof of publication is that in
the long run it will be very expensive since they will have to compete
with transactions that actually use the utxo, a feature that is more
valuable. But that's mostly speculation and doesn't imply the need for
any action against it. I would strongly opposed to against a
limitation on OP_RETURN at the protocol level (other than the block
size limit itself, that is) and wouldn't mind if they're removed from
isStandard. I didn't payed much attention to that and honestly I don't
care enough.
Maybe this encourages miners to adopt their own policies, which could
be good for things like replace-by-fee, the rational policy for
miners, which I strongly support (combined with game theory can
provide "instant" transactions as you pointed out in another thread).

Maybe the right approach to keep improving modularity and implement
different and configurable mining policies.


I thought the consensus was that op_return was the right way to put
non-validated data in the chain, but limiting it in standard policies
doesn't seem consistent with that.


The "proof of publication vs separate chain" discussion is orthogonal
to the "merged mining vs independent chain" one.
If I remember correctly, last time you admitted after my example that
merged mining was comparatively better than a separate chain, that it
was economically harder to attack. I guess ecological arguments won't
help here, but you're confusing people developing independent chains
and thus pushing them to a less secure (apart from more wasteful
setup) system design.
Coiledcoin just proofs that merged mining may not be the best way to
bootstrap a currency, but you can also start separated and then switch
to merged mining once you have sufficient independent support.
As far as I can tell twister doesn't have a realistic reward mechanism
for miners so the incentives are broken before considering merged
mining.
Proof of work is irreversible and it's a good thing to share it.
Thanks Satoshi for proposing this great idea of merged mining and
thanks vinced for a first implementation with a data structure that
can be improved.

Peter Todd, I don't think you're being responsible or wise saying
nonsense like "merged mined chains can be attacked for free" and I
suggest that you prove your claims by attacking namecoin "for free",
please, enlighten us, how that's done?
It should be easier with the scamcoin ixcoin, with a much lower
subsidy to miners so I don't feel bad about the suggestion if your
"free attack" somehow works (certainly using some magic I don't know
about).

-- 
Jorge Timn

http://freico.in/


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On 09/23/2014 04:48 PM, Alan Reiner wrote:

http://sourceforge.net/p/bitcoin/mailman/message/32736455/

http://opentransactions.org/wiki/index.php/Deposit_Address_(voting_pools)

Currently being implemented here:

https://github.com/monetas/btcwallet/commits/vp

- --

Really what's so annoying is how the BIP numbering process is handled in
such a way that proposals can be silently pigeonholed.

Especially so in the case of an *informational* BIP which requires no
action on anyone's part (except for not using the same BIP43 purpose
code).

We resolved this by changing the naming scheme for our proposals, and
their associated purpose codes, to not rely on centrally-allocated
numbers.

https://github.com/Open-Transactions/rfc/tree/master/bips

- -- 
Justus Ranvier                   | Monetas <http://monetas.net/>
<mailto:justus@monetas.net>      | Public key ID : C3F7BB2638450DB5
                                 | BM-2cTepVtZ6AyJAs2Y8LpcvZB8KbdaWLwKqc
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCAAGBQJUIajuAAoJEMP3uyY4RQ215dQH/1GNOmZd19/e2Ys7MNFx0gqz
rDmTFBylU3lhJrMY4CDd4Duq5+2U7HgaovqgX8UqxquHWLQUwEzZLqdEPCifLg0c
d/u90cRlClFAaOxPh4HV2/3aZoS2R27N+ZjOfziW7RZySBP/2fMt4/ra+SPbkcAQ
oeplYgqMRDqW52C/o2zm4y4yb0TJPS+lzSNM+JfxHSPRyY55l0KzLJfUNz1RSOze
A8UAwdsLiJROKPKiSrQcqFOejPV7uqSPh10ukm/AI0k8TbvX8ffGQ083394M9IuE
DB/1eyeLQVP5+lQMWNrTHk3BQ75XBEDJoSukaRENcqxtHV2m1JzTWoS2CQBXi2M=
=TwI3
-----END PGP SIGNATURE-----
-------------------------------------
Re-reading this, even with the most recent message, is still isn't
clear _precisely_ how your technology works, or why it is better than
namecoin.  User profiles (and distributed ledgers) need to reflect the
latest updates, and a stream of updates of over time is precisely what
bitcoin technology secures.

Keys expire or are compromised, and the public ledger needs to reflect
that.  There is a lot of computer science involved in making sure the
public ledger you see is not an outdated view.  A log-like stream of
changes is not the only way to do things, but other methods need less
hand-wavy details (show the code) before they are well recognized as
useful.



On Mon, Mar 31, 2014 at 7:14 AM, Chris D'Costa <chris.dcosta@meek.io> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 1 October 2014 14:34:33 GMT-07:00, Gavin Andresen <gavinandresen@gmail.com> wrote:

No, the redeemScript has to be provably published to miners for the sacrifice to be valid; if not you can exploit the scheme by hiding the redeemScript and having a big miner mine it at lower-than-face-value cost when it unlocks.


Yes, you could do that in a followup tx containing the redeemScript in an OP_RETURN output to prove publication. That said as I said to Luke-Jr, the sacrifices need to unlock pretty far into the future, so I don't see miners bothering to do this.





-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJULJiDMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhTwKCACD+GWzID7Qhn2no1p9
KYNiYlQVNt+DPZY0QB7MujL8riAmyJBliF9zptfjEdvglShoIzonJien/DOCjp9S
Lw2wMvPhtZGgSttJEvlr3wclty6TfWygd4Y+v/MR8TnYC99su7HhiQ1pkqohkklv
RxeF9jXhcJMERzN6wPUyeowfziBAfbWw+M5CwiXRlzLLBWO37eoDTXzUD0Np5Nia
nFxQ7sAsSbLijVpvigh9uIi3/1347VqwMc+0ZsZoZ2AnMICA8Q+XKNHv7DKpChxw
Xa+P532Di34uu8dlG/Z/UwYdENvb15P1yUZ7CEDfqNqrZp0RM7x+XKMA7QPwhuz3
YSBp
=mvKP
-----END PGP SIGNATURE-----



-------------------------------------
It seems to me that there's a huge need for a paper currency that is counterfeit-resistant, inexpensive to print, internationally recognized (border-less), fits in a wallet, and machine readable.

I pitched this idea at the Cincinnati Bitcoin meetup last week, and I didn't get thrown out, so I took the time to document a proposed standard to accomplish this.  I've put my ideas into BIP format, so that you can see what I have in mind, although I picked some 
BIP numbers myself that seem to be available.  Call them "proposed proposals", or "provisional BIPs".  I've numbered them provisionally BIP-80 to BIP-84.

If you guys think that this idea has some merit, let's discuss.

https://github.com/jerfelix/provisional_bips/blob/master/README.mediawiki

Submitted with humility and some fear of getting laughed out of here...
- Jerry


 		 	   		  
-------------------------------------
I've written a reference implementation and BIP draft for a new opcode,
CHECKLOCKTIMEVERIFY. The BIP, reproduced below, can be found at:

    https://github.com/petertodd/bips/blob/checklocktimeverify/bip-checklocktimeverify.mediawiki

The reference implementation, including a full-set of unittests for the
opcode semantics can be found at:

    https://github.com/petertodd/bitcoin/compare/checklocktimeverify

<pre>
  BIP:
  Title: OP_CHECKLOCKTIMEVERIFY
  Author: Peter Todd <pete@petertodd.org>
  Status: Draft
  Type: Standards Track
  Created: 2014-10-01
</pre>

==Abstract==

This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin
scripting system that allows a transaction output to be made unspendable until
some point in the future.


==Summary==

CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it
compares the top item on the stack to the nLockTime field of the transaction
containing the scriptSig. If that top stack item is greater than the transation
nLockTime the script fails immediately, otherwise script evaluation continues
as though a NOP was executed.

The nLockTime field in a transaction prevents the transaction from being mined
until either a certain block height, or block time, has been reached. By
comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we
indirectly verify that the desired block height or block time has been reached;
until that block height or block time has been reached the transaction output
remains unspendable.


==Motivation==

The nLockTime field in transactions makes it possible to prove that a
transaction output can be spent in the future: a valid signature for a
transaction with the desired nLockTime can be constructed, proving that it is
possible to spend the output with that signature when the nLockTime is reached.
An example where this technique is used is in micro-payment channels, where the
nLockTime field proves that should the receiver vanish the sender is guaranteed
to get all their escrowed funds back when the nLockTime is reached.

However the nLockTime field is insufficient if you wish to prove that
transaction output ''can-not'' be spent until some time in the future, as there
is no way to prove that the secret keys corresponding to the pubkeys controling
the funds have not been used to create a valid signature.


===Escrow===

If Alice and Bob jointly operate a business they may want to
ensure that all funds are kept in 2-of-2 multisig transaction outputs that
require the co-operation of both parties to spend. However, they recognise that
in exceptional circumstances such as either party getting "hit by a bus" they
need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,
to act as a third-party.

With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with
either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer
not to have immediate access to the funds to discourage bad actors from
attempting to get the secret keys from him by force.

However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of
the form:

    IF
        <now + 3 months> CHECKLOCKTIMEVERIFY DROP
        <Lenny's pubkey> CHECKSIGVERIFY
        1
    ELSE
        2
    ENDIF
    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG

At any time the funds can be spent with the following scriptSig:

    <Alice's signature> <Bob's signature> 0

After 3 months have passed Lenny and one of either Alice or Bob can spend the
funds with the following scriptSig:

    <Alice/Bob's signature> <Lenny's signature> 1


===Non-interactive time-locked refunds===

There exist a number of protocols where a transaction output is created that
the co-operation of both parties to spend the output. To ensure the failure of
one party does not result in the funds becoming lost refund transactions are
setup in advance using nLockTime. These refund transactions need to be created
interactively, and additionaly, are currently vulnerable to transaction
mutability. CHECKLOCKTIMEVERIFY can be used in these protocols, replacing the
interactive setup with a non-interactive setup, and additionally, making
transaction mutability a non-issue.


====Two-factor wallets====

Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's
such that one keypair is controlled by the user, and the other keypair is
controlled by the service. To spend funds the user uses locally installed
wallet software that generates one of the required signatures, and then uses a
2nd-factor authentication method to authorize the service to create the second
SIGHASH_NONE signature that is locked until some time in the future and sends
the user that signature for storage. If the user needs to spend their funds and
the service is not available, they wait until the nLockTime expires.

The problem is there exist numerous occasions the user will not have a valid
signature for some or all of their transaction outputs. With
CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand
scriptPubKeys of the following form are used instead:

    IF
        <service pubkey> CHECKSIGVERIFY
    ELSE
        <expiry time> CHECKLOCKTIMEVERIFY DROP
    ENDIF
    <user pubkey> CHECKSIG

Now the user is always able to spend their funds without the co-operation of
the service by waiting for the expiry time to be reached.


====Micropayment Channels====

Jeremy Spilman style micropayment channels first setup a deposit controlled by
2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends
the output of tx1 to payor and payee. Prior to publishing tx1 a refund
transaction is created, tx3, to ensure that should the payee vanish the payor
can get their deposit back. The process by which the refund transaction is
created is currently vulnerable to transaction mutability attacks, and
additionally, requires the payor to store the refund. Using the same
scriptPubKey from as in the Two-factor wallets example solves both these issues.


===Trustless Payments for Publishing Data===

The PayPub protocol makes it possible to pay for information in a trustless way
by first proving that an encrypted file contains the desired data, and secondly
crafting scriptPubKeys used for payment such that spending them reveals the
encryption keys to the data. However the existing implementation has a
significant flaw: the publisher can delay the release of the keys indefinitely.

This problem can be solved interactively with the refund transaction technique;
with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using
scriptPubKeys of the following form:

    IF
        HASH160 <Hash160(encryption key)> EQUALVERIFY
        <publisher pubkey> CHECKSIG
    ELSE
        <expiry time> CHECKLOCKTIMEVERIFY DROP
        <buyer pubkey> CHECKSIG
    ENDIF

The buyer of the data is now making a secure offer with an expiry time. If the
publisher fails to accept the offer before the expiry time is reached the buyer
can cancel the offer by spending the output.


===Proving sacrifice to miners' fees===

Proving the sacrifice of some limited resource is a common technique in a
variety of cryptographic protocols. Proving sacrifices of coins to mining fees
has been proposed as a ''universal public good'' to which the sacrifice could
be directed, rather than simply destroying the coins. However doing so is
non-trivial, and even the best existing technqiue - announce-commit sacrifices
- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to
create outputs that are provably spendable by anyone (thus to mining fees
assuming miners behave optimally and rationally) but only at a time
sufficiently far into the future that large miners profitably can't sell the
sacrifices at a discount.


===Replacing the nLockTime field entirely===

As an aside, note how if the SignatureHash() algorithm could optionally cover
part of the scriptSig the signature could require that the scriptSig contain
CHECKLOCKTIMEVERIFY opcodes, and additionally, require that they be executed.
(the CODESEPARATOR opcode came very close to making this possible in v0.1 of
Bitcoin) This per-signature capability could replace the per-transaction
nLockTime field entirely as a valid signature would now be the proof that a
transaction output ''can'' be spent.


==Detailed Specification==

Refer to the reference implementation, reproduced below, for the precise
semantics and detailed rationale for those semantics.

    case OP_NOP2:
    {
        // CHECKLOCKTIMEVERIFY
        //
        // (nLockTime -- nLockTime )
    
        if (!(flags & SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY))
            break; // not enabled; treat as a NOP
    
        if (stack.size() < 1)
            return false;
    
        // Note that elsewhere numeric opcodes are limited to
        // operands in the range -2**31+1 to 2**31-1, however it is
        // legal for opcodes to produce results exceeding that
        // range. This limitation is implemented by CScriptNum's
        // default 4-byte limit.
        //
        // If we kept to that limit we'd have a year 2038 problem,
        // even though the nLockTime field in transactions
        // themselves is uint32 which only becomes meaningless
        // after the year 2106.
        //
        // Thus as a special case we tell CScriptNum to accept up
        // to 5-byte bignums, which are good until 2**32-1, the
        // same limit as the nLockTime field itself.
        const CScriptNum nLockTime(stacktop(-1), 5);
    
        // In the rare event that the argument may be < 0 due to
        // some arithmetic being done first, you can always use
        // 0 MAX CHECKLOCKTIMEVERIFY.
        if (nLockTime < 0)
            return false;
    
        // There are two times of nLockTime: lock-by-blockheight
        // and lock-by-blocktime, distinguished by whether
        // nLockTime < LOCKTIME_THRESHOLD.
        //
        // We want to compare apples to apples, so fail the script
        // unless the type of nLockTime being tested is the same as
        // the nLockTime in the transaction.
        if (!(
              (txTo.nLockTime <  LOCKTIME_THRESHOLD && nLockTime <  LOCKTIME_THRESHOLD) ||
              (txTo.nLockTime >= LOCKTIME_THRESHOLD && nLockTime >= LOCKTIME_THRESHOLD)
             ))
            return false;
    
        // Now that we know we're comparing apples-to-apples, the
        // comparison is a simple numeric one.
        if (nLockTime > (int64_t)txTo.nLockTime)
            return false;
    
        // Finally the nLockTime feature can be disabled and thus
        // CHECKLOCKTIMEVERIFY bypassed if every txin has been
        // finalized by setting nSequence to maxint. The
        // transaction would be allowed into the blockchain, making
        // the opcode ineffective.
        //
        // Testing if this vin is not final is sufficient to
        // prevent this condition. Alternatively we could test all
        // inputs, but testing just this input minimizes the data
        // required to prove correct CHECKLOCKTIMEVERIFY execution.
        if (txTo.vin[nIn].IsFinal())
            return false;
    
        break;
    
    }

https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4


==Upgrade and Testing Plan==

TBD


==Credits==

Thanks goes to Gregory Maxwell for suggesting that the argument be compared
against the per-transaction nLockTime, rather than the current block height and
time.


==References==

PayPub - https://github.com/unsystem/paypub

Jeremy Spilman Micropayment Channels - http://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg02028.html


==Copyright==

This document is placed in the public domain.

-- 
'peter'[:-1]@petertodd.org
000000000000000009012f16fe9db21abbba5025453a9b7b589a807b21cec318
-------------------------------------
On 28 February 2014 14:42, Warren Togami Jr. <wtogami@gmail.com> wrote:


Is there any particular reason that patch would not make it into bitcoin if
submitted?

Drak
-------------------------------------
On 04/23/2014 09:00 PM, Tier Nolan wrote:

There is such system and it is called BIP32.

On the other hand, in BIP64 we try to put a set of restrictions and
rules on top of BIP32. There will always be some special usecases where
BIP64 is not a good fit and there's no reason why you cannot use BIP32
in a different manner using a different "purpose" field.

Examples: Electrum does not want to use accounts and they start to use
scheme m/65'/change/address (where change = 0 or 1). Or Andreas
Schildbach wants to have refunds chain so he uses m/66'/chain/address
(where chain = 0, 1 or 2).

We wanted to find one good solution that fits all, but unfortunately it
turned out everyone wants something a little bit different.

The point of the whole effort is that you can have ONE SINGLE BACKUP
(master node) for all these independent purposes and suddenly claims
such as "my wallet is BIP64 and BIP66 compatible" actually mean
something as opposed to "BIP32 compatible" which actually means nothing
except that the wallet author is capable of using HMAC in context of
generating the tree.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
On Wed, Jun 4, 2014 at 12:42 PM, Jannis Froese <
s9jafroe@stud.uni-saarland.de> wrote:

I think most concerns about the current use of asserts would be resolved if

Also, most assertion errors that happen to people running Bitcoin Core are
not caused by software bugs but database corruption errors (usually due to
unclean shutdown).

For example in case we detect missing/truncated block files or UTXO db
consistency we should, instead of raising an assertion error, propose a
-reindex - see also https://github.com/bitcoin/bitcoin/issues/2202 .

So instead of using assertions we need a fatal error function for those
problems which are probably recoverable in a certain specific way. In
principle starting a reindex wouldn't even need to take down the entire
process (though that's easier for implementation due to cleanup and
assumptions made).

Wladimir
-------------------------------------
I think many of us feel it'd be better if this kind of thing were not
needed at all, however, the best way to ensure it doesn't end up being used
is to write code, not to try and block alternative approaches. If Bitcoin
is robust the market should sort it out. If it's robust for some
transactions and not others, that makes for a fun project for a future
generation of hackers to sort out.

OK, enough philosophy - let's try and keep this thread just for discussion
of the BIP itself from now on. If you'd like to continue debating the
Future of Bitcoin please change the subject line and break it out into a
new thread.
-------------------------------------
On Monday, 12 May 2014, at 9:53 am, Gregory Maxwell wrote:

Why is there such a high bar to getting a number assigned to a BIP anyway? BIP 1 seems to suggest that getting a BIP number assigned is no big deal, but the reality seems to betray that casual notion. Even proposals with hours of work put into them are not getting BIP numbers. It's not exactly as though there's a shortage of integers. Are numbers assigned only to proposals that are well liked? Isn't the point of assigning numbers so that we can have organized discussions about all proposals, even ones we don't like?


-------------------------------------
On Sat, Apr 26, 2014 at 08:07:58PM +0200, Mike Hearn wrote:

The seller won't hand over the goods of course until they have a valid
transaction signed by the buyer sending them the escrowed funds. (and
the nLockTime deadline is sufficiently far away that the probability of
not being able to get the transaction mined in time is low)

Note how the mechanism I'm proposing is basically just a Jeremy
Spilman-style micropayment channel(1) used for a single payment; I
should have made that clear in my original post.

1) http://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg02028.html

-- 
'peter'[:-1]@petertodd.org
000000000000000069ea3b64f8b627bc81c8981ce80e95edf81cd356ad04e1a0
-------------------------------------
On 26 October 2014 00:10, Ross Nicoll <jrn@jrn.me.uk> wrote:


Yes that is an interesting data point, but it's really hard to find
comparables to doge, and most of its hashing is now merge mined with
litecoin.  Comparing doge to btc may be a case of apples and oranges.

-------------------------------------
On Sun, Dec 21, 2014 at 11:57:51AM +0800, Mark Friedenbach wrote:

Do you realise that all those Freimarket's uses are either based on
proof-of-publication, or insecure due to sybil attacks?

-- 
'peter'[:-1]@petertodd.org
000000000000000017d70ee98f4cee509d95c4f31d5b998bae6deb09df1088fc
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 04/07/2014 11:34 AM, Mike Hearn wrote:

It doesn't do much good to only focus on the immediate symptoms at the
exclusion of big picture trends. There are three things happening now
that have nothing to do with operating systems.

1. The resource requirements of a full node are moving beyond the
capabilities of casual users. This isn't inherently a problem - after
all most people don't grow their own food, tailor their own clothes, or
keep blacksmith tools handy in to forge their own horseshoes either.

2. The growth of small and medium-sized native Bitcoin businesses is
lagging #1. Native here means their revenue and expenses are both
denominated in BTC. Most business adoption we've seen so far doesn't
actually handle bitcoins themselves. They use Bitcoin as a payment
method whose processing they outsource.

Contributing to this is the fact that Bitcoin Core, although it has made
great progress in the 0.9 release, can't be accurately described as
"enterprise ready".

3. The P2P protocol used by the network is broken from an incentive
perspective. Resource usage wouldn't be a problem as long as the users
which consume resources pay for them and the users who provide resources
are compensated, and they communicate via an efficient price discovery
mechanism. Right now there is no obvious way to incorporate price
discovery for bandwidth usage or storage space without a completely new
P2P protocol, and the effectiveness with which progress has been blocked
towards price discovery of transaction fees (the area where it is most
obviously necessary) means that I'm not optimistic that this subject
will ever be effectively addressed by Bitcoin Core.

- -- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQEcBAEBAgAGBQJTQsgzAAoJECoisBQbQ4v0ZA8H/1YIJAg7AEUUe5RnuuAz7lVV
uiHtpmbmGaZ+Bd0qi1DEfPdeBP9bDKpO3O5napmtz+mqIE5H3VgAVg7z9U0sMf16
sZAJIWuVCg2drY/NaE+n3TKEEd4Z1Zj51rWde/KD6xjgR2usV9nLugkEJdLNahZu
0EbdAv40oCSZ8PScNElYqQyM8qcbta7LuDRCnnWvCyunZJzL4LSkQwDcsAWQ+oSv
FyqKY/e1Kd6mLyrN/NppMzdqiLv95zmE56Qkh6rlKeF+JgXxlfiEfDv8osl8IWJR
TOpmW0Dr+E4qe9E3nA7X5gV46nf8gxGZ4b0cUP+wivN9RRaE27+JlKhKaAV3ulc=
=vdPa
-----END PGP SIGNATURE-----
-------------------------------------
On Tue, Feb 04, 2014 at 04:17:47PM +0100, Natanael wrote:

You're close, but not quite.

So, imagine you have a merkle tree, and you're trying to timestamp some
data at the bottom of the tree. Now you can successfully timestamp the
top digest in the Bitcoin blockchain right, and be sure that digest
existed before some time. But what about the digests at the bottom of
the tree? What can an attacker do exactly to make a fake timestamp if
the tree is using XOR rather than a proper hash function?

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------------------------------
There are reasons to have assertions enabled by default in software like
Bitcoin Core, where incorrect behaviour can be costly. But this comes at
a prize: our assertions have to satisfy certain performance
requirements. It's no longer possible to do expensive, redundant checks
in performance critical code, which is one of the main advantages of
asserts. Imho, asserts are not intended for small range checks etc, but
are meant for checks that a hash hasn't changed, that a tree structure
is still a tree, that data is still sorted, or that data structures are
in sync.

I think most concerns about the current use of asserts would be resolved
if the currently used asserts would be changed to a nicer definition
which is independent of NDEBUG, and a second class of debugging asserts
would be introduced, which is exclusively for expensive, redundant
checks and is disabled by NDEBUG.



Am 2014-06-04 12:15, schrieb Gregory Maxwell:

-------------------------------------
On 6/24/14, Tamas Blummer <tamas@bitsofproof.com> wrote:

I think this is my main question, what's the advantage of having the
processes talking via the p2p protocol instead of something more
direct when you control both processes?

Wladimir, of course headers-first is generally good, and of course
nobody will be force to separate the code in a way he doesn't like, I
was just testing the waters to see what people had in mind, since I
realized the ideas could be more different than I had assumed.
I don't have any issues with electrum, I'm just not convinced by the
arguments that say that the indexes must be necessarily out of the
core, specially when some of them could be committed in the future.
So I'm all in favor of modularity and competing codebases, I'm just
not convinced that the "core full-node" must be necessarily restricted
to validation only (for example, I think it should maintain a minimal
and non-optimized mining functionality,even if it's only used for
testing purposes).

So far it is great that everybody seems to agree that the wallet code
needs to be separated.

Thanks everyone for sharing your views on the subject.


-------------------------------------
On 04/23/2014 10:32 PM, Luke-Jr wrote:

Ah, okay. The last time I saw Bitcoin-qt it was still using independent
addresses.


Which brings us back to my original complaint that the user can be
confused because he doesn't see all his funds.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
Isn't the length of the seed arbitrary anyway? Once decoded using whatever
mnemonic implementation (electrums, or BIP0039) the bytestream is
immediately passed to HMAC-SHA256 to generate the master key. No matter
what your initial entropy is, it would be hashed anyway.


On Thu, Mar 27, 2014 at 12:49 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
On Fri, Feb 14, 2014 at 12:21:59AM -0500, Peter Todd wrote:

Is there a simple way to do cross-chain trades that doesn't need a third 
chain to somehow facilitate things?


-------------------------------------
Here is an earlier reference to bits:

https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04248.html

I forgot that Alan Reiner was also supporting a unit equals to bits :

https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04264.html

and here the earlier going back to March 2013 and a poll at that time pushing for XBT being 1 bit

https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04256.html

Regards,

Tamas Blummer
http://bitsofproof.com

On 20.04.2014, at 16:53, Pieter Wuille <pieter.wuille@gmail.com> wrote:


-------------------------------------
On Thu, Apr 24, 2014 at 12:48:54PM +0200, Jorge Timn wrote:

FWIW I'm running an experiment right now to detect how easy it is to
doublespend 0-conf transactions I need to collect more data, but initial
results indicate that transaction propagation is sufficiently unreliable
that double-spending frequently works without miners using
replace-by-fee even when both transactions pay high fees, there is a 60
second delay between first and second, and there's only about four
replace-by-fee nodes on the network.

With replace-by-fee scorched-earth the success rate of such
double-spends would be significantly reduced as the attacker would need
to get lucky with bad propagation not just once, but twice in a row.


Just to be clear, while that post is mine, original credit for the idea
actually goes to John Dillon as far as I know; I first heard about it
from him in private discussion.


A few things:

1) Replace-by-fee doesn't protect against sybil attacks; only
confirmations are solid evidence that a transaction has actually reached
the mining power and your communication channel to that mining power
isn't being blocked. Keep in mind that Bitcoin depends on the existence
of a jam-free network, and very importantly, lets you detect when that
network has failed and you are being jammed. No unconfirmed transaction
scheme can solve this problem in a decentralized network.

2) Replace-by-fee scorched earth does require you to keep private keys
online to sign the replacements. Not a big deal, but it's yet another
reason why you wouldn't want to use it for high-value stuff.

3) It doesn't directly solve finney attacks(1) where the miner mines the
transaction in private. However finney attacks are only relevant if
there is high centralization of hashing power, and all other proposed
mechanisms, e.g. coinbase reallocation, themselves do a lot of harm to
decentralization. (just look at how coinbase reallocation lets large
pools bully smaller miners out of business by blacklisting their blocks)

One interesting thing with regard to finney attacks and replace-by-fee
though is that enforcing hasher visibility of the blocks they are mining
- what getblocktemplate was meant to do voluntarily - lets any hasher
detect a finney attack double-spend and broadcast it. They have a weak
incentive to do so - the scorched earth reply is a high-fee transaction
of course and pre-broadcasting transactions makes blocks propagate
faster - at which point you're back to a public double-spend.  Enforcing
visibility of block contents to hashers is definitely a good thing for
decentralization.

1) https://bitcointalk.org/index.php?topic=3441.msg48384#msg48384

-- 
'peter'[:-1]@petertodd.org
000000000000000093d8af23978adc9e201a1f2e2dc52844f9013a1da3621572
-------------------------------------

But it does change miner behaviour in pretty significant ways.

Unlike difficulty forecasting, which seems near impossible to do
accurately, miners can plan to purchase less hardware as they approach
the revenue drop. You can do some basic cost/benefit calculation and
see that *if* margins are already low as the halving approaches, then
rational miners would cease purchasing any new hardware that wouldn't
be profitable past that point, unless they expect it to pay for itself
by then.

The lower the margins are, the longer in advance they would alter
their buying behaviour. You'd see an increased focus on cost-effective
hashpower (and older units would not be replaced as they break).
Either a significant supply of cost effective hardware shows up
(because it's the only thing that would sell in the last months), or
difficulty would stall long before the halving happens. Either way,
the predictability of the halving can reduce the hashpower on the day.

On Tue, Oct 28, 2014 at 5:34 PM, Neil <kyuupichan@gmail.com> wrote:


-------------------------------------
On Fri, May 30, 2014 at 6:39 PM, Angel Leon <gubatron@gmail.com> wrote:

Looks good to me.

Though we already allow specifying a unit in all places where the user
can specify a BTC amount.

We also already show the unit in all places where amounts are shown,
except the tables, would be good to add a [unit] in the header there
as well, see https://github.com/bitcoin/bitcoin/issues/3970 .

If that is done, I'm not sure how much a global setting in the status
bar would add. It may make it more apparent to the user that multiple
units can be selected.

Wladimir


-------------------------------------
To be more accurate, the embedded messages already have length prefixes :-)


On Sun, Jan 26, 2014 at 11:14 PM, Andreas Schildbach
<andreas@schildbach.de>wrote:

-------------------------------------

On 23/04/2014 05:51 p.m., Mike Hearn wrote:
5 seconds block interval is possible. I've simulate it with great
success and I encourage anyone to repeat or check my simulations.

There are a very few protocol modifications that are required to allow 5
seconds block, and most of them have already been discussed in the forums.
For more information you can check my post:
http://bitslog.wordpress.com/2014/02/17/5-sec-block-interval/
Also NimbleCoin is a new alt-coin that uses 5-sec block intervals,
allows 100 tps and .... it's based on BitcoinJ (NimbleCoinJ now). So not
only it is possible, but it was coded by Mike itself.
Important note: the 5-sec block interval method probably requires a
block reward forever. It doesn't work well if there is no block reward
at all.

Another solution to achieve <5 secs block intervals is this:
http://bitslog.wordpress.com/2014/03/20/mincen-a-new-protocol-to-achieve-instant-payments/

So the problem with 0-confirmations is solely of Bitcoin and other
alt-coins, new alt-coins may achieve instant transactions and no not
have to rely on 0-confirmations.

Best regards,
 Sergio.

-------------------------------------
On Wednesday, April 23, 2014 9:06:26 PM Pavol Rusnak wrote:

How do you get the more expected/usual behaviour of mixing funds between 
accounts? Only a very niche user base needs funds isolated...

Luke


-------------------------------------
On 03/27/2014 05:14 PM, Pieter Wuille wrote:

Cointype in path is for separation purposes, not for identification.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
On Wednesday 15. October 2014 20.13.11 Mike Hearn wrote:

Other than it being open source, an open platform with no lock-in 'features' 
and it works with everyone that uses the standards properly.
Naturally, if an old version fails to function with Yahoo, I'm all for finding 
a different provider. Thats what open platforms, like Mailman, are about.

-- 
Thomas Zander


-------------------------------------
On Tue, 14 Jan 2014 13:51:06 -0800, Adam Back <adam@cypherspace.org> wrote:

Thanks for reviewing this. The relevant line:

    byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S1));

SingleSHA256 is a single application of SHA256 -- named so since 'SHA256'  
functions in many Bitcoin libraries too often actually run DoubleSHA256.  
32 bytes are returned.

The multiplication by 'G' that you mention is part of my EC.PointAdd...

I should probably just publish all my code as MIT and be done with it ;-)

Thanks,
Jeremy


public static byte[] PointAdd(byte[] point, byte[] scalar, bool compressed  
= true)
{
     var point1 = new OpenSSL.Crypto.EC.Point(EcGroup, point);

     var num = OpenSSL.Core.BigNumber.FromArray(scalar);
     var point2 = OpenSSL.Crypto.EC.Point.Multiply(EcGroup, num,  
EcBnContext);

     var result = point1.Add(point2, EcBnContext);

     if (compressed)
         return result.GetBytes(ConversionForm.Compressed);
     else
         return result.GetBytes(ConversionForm.Uncompressed);
}







-------------------------------------
Hello,

Today I noticed that even my bank is warning people to not do internet
banking with Windows XP.

If it is no longer secure enough for online banking it's CERTAINLY not
secure enough to run a wallet (for a node only it would be ok-ish as they
have no keys to protect).
Any opinions on what to do here? Just warn and allow the user to continue?
Redirect them to a 'Windows XP is dangerous' message on bitcoin.org?
(Microsoft uses http://windows.microsoft.com/en-us/windows/end-support-help)

The drawback of dropping XP support completely would be that a lot of
computers (especially in China and Russia etc) are still running XP, so
this could cause the network to lose nodes.

If you're maintainer of other wallet software: how are you handling this?
Are you going to drop XP support completely? If so, starting from when?

Regards,
Wladimir
-------------------------------------
Hi all,

I was a bit surprised to see MtGox's announcement. The malleability of
transactions was known for years already (see for example the wiki
article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,
or mails on this list from 2012 and 2013). I don't consider it a very
big problem, but it does make it harder for infrastructure to interact
with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to
avoid it altogether to make life easier for everyone.

But we can't just change all infrastructure that exists today. We're
slowly working towards making malleability harder (and hopefully
impossible someday), but this will take a long time. For example, 0.8
not supporting non-DER encoded signatures was a step in that direction
(and ironically, the trigger that caused MtGox's initial problems
here). In any case, this will take years, and nobody should wait for
this.

There seem to be two more direct problems here.
* Wallets which deal badly with modified txids.
* Services that use the transaction id to detect unconfirming transactions.

The first is something that needs to be done correctly in software -
it just needs to be aware of malleability.

The second is something I was unaware of and would have advised
against. If you plan on reissuing a transaction because on old version
doesn't confirm, make sure to make it a double spend of the first one
- so that not both can confirm.

I certainly don't like press making this sound like a problem in the
Bitcoin protocol or clients. I think this is an issue that needs to be
solved at the layer above - the infrastructure building on the Bitcoin
system. Despite that, I do think that we (as a community, not just
developers) can benefit from defining a standard way to identify
transactions unambiguously. This is something Mark Karpeles suggested
a few days ago, and my proposal is this:

We define the normalized transaction id as SHA256^2(normalized_tx +
0x01000000), where normalized_tx is the transaction with all input
scripts replaced by empty scripts. This is exactly what would be
signed inside transaction signatures using SIGHASH_ALL (except not
substituting the previous scriptPubKey to be signed, and not dealing
with the input being signed specially). An implementation is here:
https://github.com/sipa/bitcoin/commits/normtxid.

Note that this is not a solution for all problems related to
malleability, but maybe it can make people more aware of it, in
tangible way.

-- 
Pieter


-------------------------------------
On Tue, Mar 11, 2014 at 8:38 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:


Multisig wallets are a different reality from our current one, so when we
move to that new reality we should do it correctly from the beginning.

-- 
--
Gavin Andrese
-------------------------------------
On Mon, May 19, 2014 at 1:01 PM, Justus Ranvier <justusranvier@gmail.com> wrote:

I promise that if bad people show up with a sufficient pointy gun that
I'll do whatever they tell me to do. I'll make bad proposals, submit
backdoors, and argue with querulous folks on mailing lists, diverting
them from real development and review work, all as commanded. Maybe
I'll try to sneak out a warning of some kind, maybe... but with my
life or my families or friends lives on the line— probably not.

... and I think that anyone who tells you otherwise probably just
hasn't really thought it through.  So what is the point of commitments
like that?  People change, people go crazy, people are coerced. Crap
happens, justifications are made, life goes on— or so we hope.

What matters is building infrastructure— both social and technical—
that is robust against those sorts of failures. If you're depending on
individual developers (including anonymous parties and volunteers) to
be somehow made more trustworthy by some promises on a mailing list
you've already lost.

If you care about this you could instead tell us about how much time
you promise to spend reviewing technical work to make sure such
attacks cannot be successful, regardless of their origins. Where are
your gitian signatures? I think thats a lot more meaningful, and it
also improves security for everyone involved since knowing that such
attacks can not succeeded removes the motivation for ever trying.

A lot of what Bitcoin is about, for me at least, is building systems
which are as trustless as possible— ruled by unbreakable rules
embodied in the software people chose to use out of their own free
will and understanding. Or at least thats the ideal we should try to
approximate. If we're successful the adhomenim you've thrown on this
list will be completely pointless— not because people are trusted to
not do evil but because Bitcoin users won't accept technology that
makes it possible.

So please go ahead and assume I'm constantly being evil and trying to
sneak something in... the technology and security can only be better
for it, but please leave the overt attacks at the door. Think
gentleman spies, not a street fighting death match. The rude attacks
and characterizations just turn people off and don't uncover actual
attacks.  Maybe the informal guideline should be one flame-out
personal attack per cryptosystem you break, serious bug you uncover,
or impossible problem you solve. :)


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

We rebroadcast incoming transactions without fees at several nodes,
including bc.info, to keep them in mempools.

On 01/17/2014 10:04 PM, Mark Friedenbach wrote:
CenturyLink Cloud: The Leader in Enterprise Cloud Services.
_______________________________________________

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.12 (GNU/Linux)
Comment: Using GnuPG with undefined - http://www.enigmail.net/

iQEcBAEBAgAGBQJS2mbQAAoJEIilnEpWGBYhH+8H/2nIZjrrZIPi/4ZeTi71cZOe
78oD4mzWM9zvRbjbGfIWrgTnkRQi4OQ/GorbRiyoAeKzAQ+SdeY8dkRsS14zpqpC
w4efoJOTxgi69giBWGPWlPvAtTwD65EcfJmUs5XeGi7J/3E0qTyry6sDu8t2ip84
hLUnqMOcNhc0J/k0KvBbEyl1YXcRWMjz5X2pMtY9yeMk+qFQPR1+RjZ+91OCRyui
Z47jhHlbhc5daXAWrq4fb54uNSJWUnYky7yN2pDTovAVq5PNNVNJTdxbjXSyYmcP
FwFNkARrgXRlSvf07FN991aa2u4CTkjRgA9uRrvcTtLXr8g2F0yymfPr0AQrgZg=
=J9Z4
-----END PGP SIGNATURE-----


-------------------------------------
Thinking out loud here : would it make sense to separate the consensus code
into some kind of "Bitcoin Kernel" (similar to the Linux Kernel) project
that could be used by anyone ?

Bitcoin Core (and any other application wishing to do so) could be based on
it.

The kernel would just contain the absolute minimum code for reaching
consensus, leaving every other aspects of the implementation to the
applications built with it.

It would be stateless : it would provide an interface to submit a
block/transaction to be validated, including the context needed to validate
it (the previously validated blocks referenced by this block/transaction).

What do you think ?

Clément

Le Fri Nov 07 2014 at 9:49:05 AM, Peter Todd <pete@petertodd.org> a écrit :

On Fri, Nov 07, 2014 at 09:07:47AM +0100, Tamas Blummer wrote:
-------------------------------------
Absolutely not. Time and time again we've seen "anonymized" data sets
that dont work out so well. I'm sure its possible to do but there are
too many factors and we dont want to succumb to this.

Also, these generally look good (and essentially the same as what had
been a gentleman's agreement for those who read IRC actively, the
purpose of codifying this is essentially that we ended up adding a lot
of DNS Seeds run by people who dont follow development closely and/or
are not aware of the issues involved).

Thanks for writing this up,
Matt

On 07/21/14 13:53, Christian Decker wrote:


-------------------------------------
Because the mnemonic is an encoding of a 128-bit random number using its
hash as a private key (or derived part of one) is not a problem, its just an
alternate alphabet encoding of the random private key.

Not being able to generically understand the checksum.  Seems tricky to
solve other than say brute force eg H(mnemonic||1) mod 2^k == 0 where k is
the amount of check digit redundancy.  But that might be expensive for a
trezor if k is very big at all.  And then key = H(mnemonic).

Adam

On Mon, Jan 20, 2014 at 05:35:02PM -0500, Peter Todd wrote:







-------------------------------------
Sergio, why is preventing mining pools a good thing? The issue is not
mining pools, which provide a needed service in greatly reducing
variance beyond what any proposal like this can do.

The issue is centralized transaction selection policies, which is
entirely orthogonal. And the solution already exists: getblocktemplate.
We just need more or better infrastructure which makes use of this
technology to perform local transaction selection.

If you have a proposal for eliminating hosted mining while keeping
variance-reducing pools, that would be an interesting read.

On 06/19/2014 09:58 AM, Sergio Lerner wrote:


-------------------------------------
Oh yes the other thing we need to decide is how to extend BIP70.

Protocol buffers have an extend keyword. But I'm not sure it's what we
really want. IMHO a simpler solution is to have a single "living" version
of the protobuf (where? in a new git repo?) which has all the fields
defined by all the accepted BIPs in a single place. Otherwise the build
process and so on for wallet implementors would get unnecessarily
complicated for no real reason. Also if you wanted to pick a new number for
fields, you'd end up having to read *all* BIPs to figure out what is
available. Simpler seems better.

If we do that then I suggest just using field number 8 or 9 or whatever
rather than 1000. IMHO fields 1000+ should be for private extensions that
are unlikely to collide with other users.
-------------------------------------
xbit is close to XBT because it would be the same unit, both would mean 100 satoshi or 1e-6 Bitcoin.

xbit would be for everyday use, XBT for ISO.

I know, the XBT was used by some sites to be a synonym for BTC that is however in my opinion not yet graved in stone until it is used by e.g. Bloomberg.

Regards,

Tamas Blummer
http://bitsofproof.com

On 21.04.2014, at 14:14, Un Ix <slashdevnull@hotmail.com> wrote:


-------------------------------------
Hmm, this is firmcoin thing looks like what I mean. They don't have a
solution yet, and prices they quote smartcards are unacceptable, but if
they will manage to get down in selfcost - that may work. Ok, I'll follow
them and see what it will come to.


Best regards,
Alex Kotenko


2014-05-19 13:55 GMT+01:00 Sergio Lerner <sergiolerner@certimix.com>:

-------------------------------------
It already is https://bitcointalk.org/index.php?topic=766190.0;all.
Well, ok, a variation on the idea is.

Matt

On 10/02/14 04:39, Rebroad (sourceforge) wrote:


-------------------------------------
The inv trickling mechanism currently serves two purposes:
- protect casual users' privacy by slightly obscuring a tx's originating node
- reduce invs unnecessarily sent both directions for a connection
It has some drawbacks:
- it slows transaction propagation
- it delays knowledge between two nodes of what txes are mutually known
These drawbacks will be especially costly once optimizations based on
mutually-known transactions are available (in progress, see "sparse
blocks" thread).

Both of the benefits of trickling can be achieved more efficiently and
without the costs to transaction propagation and mutual transaction
knowledge.

Privacy: trickling helps hide the origin of 3/4 of the transactions a
node is pushing by preventing most of the node's neighbors from seeing
the transactions from that node right away; by the time a peer becomes
the trickle node, it may have received the same inv from another of
its peers.
This staggering of introduction of new invs to the network could be
made more effective by scheduling staggered pushes of wallet
transactions to each peer in a structure similar to mapAskFor.
This does have the drawback that someone who has established multiple
connections to a node can observe that some invs are pushed at
different times, suggesting they are in the stagger set. I don't see
any straightforward way to remedy this, but trickling is also
vulnerable to sybil attacks, and floods 1/4 of its transactions
immediately anyway -- so I think staggered push would be an overall
privacy improvement.
Likelihood of a partial sybil obtaining inv origin information could
be reduced by a policy of ending staggering and pushing to all peers
once another peer has received the tx from elsewhere and inved the
transaction back to the original node; if the staggering is
sufficiently slow, only one or two nodes would receive the initial
push to the network and after that the inv would be treated
indistinguishably from if it originated externally.

Redundant invs: without trickling, when two nodes receive transactions
at around the same time they may each send each other an inv before
receiving the other's. Trickling reduces this by giving all
non-trickleSend nodes a chance to send first. Thus just eliminating
trickling would at most double inv traffic. Although invs are small
they are numerous, being the only common message potentially sent from
every node to all its neighbors.
A more efficient solution to the who-sends-first problem would be for
connections to have directional parity:
- a node initiating a connection would announce its parity (even or odd)
- an inv is sent right away to peers with matching parity, but only
sent against parity if a certain timeout has elapsed without the inv
being received
In order to allow for nodes with few peers (i.e. -connect) or nodes on
local connections that might as well flood everything to each other,
parity could be specified as a mask (fEven << 1 & fOdd). Peers from
pre-directional-parity versions can be treated as having the mask
fully set.

Both push staggering and directional parity admit simple
implementations. The specific staggering delay distribution would need
some thought; it could be set slower than the typical trickle cycle
period for better than current privacy, since general transaction
propagation would not impeded by heavy staggering. What do you think
of this approach? Any gotchas/improvements/alternatives?


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

The charts are generated on-demand by Graphite, which is a Django app.

I will note that one reason I chose StatsD is because it sends the stats via UDP rather than TCP, which is a non-blocking operation. I didn't want the sending of stats to affect the node's performance.

- - Jameson

On 05/07/2014 04:18 PM, Wladimir wrote:
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQEcBAEBAgAGBQJTapj5AAoJEIch3FSFNiDcofAIALHi7XgQi8pf75btujaeBsX3
nniRD0yZIkoAvPlvFLiKQGE8TH+VR8Sb9fQACzmajYx1yjD0gN4xvkJXbI+pkeP5
L8ZryhqxL5qCh/OI4+fkWlsp5Nwx89QvUepdXXdc/AQGQJIEMceiZOLDcjbk29Yb
vCsyJL5yhzM9BM0cImuvrOBPtF3/L6DbgHP8OLD2LHRl4paJ1UDtfYCx3HVO9wp8
ZWq1oCaFyoYmUyx8GTUzbLjh9sOgaq43GKYec/kQSLmFxhhMF0dGNDMiwD/xz1i7
LIswjlEKHZYOWWL3SMQg3pLlOTzGH4mHg++BAyrtzZ5CHlc1rjsPSk2d2Df/8Zc=
=GFu9
-----END PGP SIGNATURE-----


-------------------------------------
On Tue, Oct 28, 2014 at 9:19 PM, Jérémie Dubois-Lacoste
<jeremie.dl@gmail.com> wrote:

I am not saying that it is "not relevant", I'm saying the discussion
is pointless:

No new information has arrived since the very first times that this
has been discussed except
that the first halving passed without incident.
If people were not sufficiently convinced that this was a serious
concern before there was concrete evidence (however small) that it was
okay, then discussion is not likely going to turn out differently the
50th or 100th time it is repeated...
except, perhaps, by wearing out all the most experienced and
knowledgeable among us as we become tired of rehashing the same
discussions over and over again.

On Tue, Oct 28, 2014 at 9:23 PM, Ferdinando M. Ametrano
<ferdinando.ametrano@gmail.com> wrote:
[snip]

This is wildly at odds with reality. I don't mean to insult, but
please understand that every post you make here consumes the time of
dozens (or, hopefully, hundreds) of people. Every minute you spend
refining your post has a potential return of many minutes for the rest
of the users of the list.

At current difficulty, with a SP30 (one of the
leading-in-power-efficiency) marginal break-even is ~1144.8852 * $/kwh
== $/btc.

At $0.10/kwh each block has an expected cost right now, discounting
all one time hardware costs, close to $3000.


-------------------------------------
On 02/12/2014 08:44 AM, Alan Reiner wrote:

Not to mention that it would be potentially very insecure to have
consensus depend on data (scriptSigs) which are not hashed in the Merkle
structure of a block.

Not that anyone on this list has suggested such a change, but I've seen
it raised multiple times on the forum....

Mark


-------------------------------------
Hey Tom,

Thanks for getting involved! It's great to see someone who would like to
focus on docs.

One project I've been thinking about recently is a "Bitcoin Developer
Network" subsection of our website. Right now bitcoin.org is entirely
consumer focused. And as you noted, the wiki is undergoing some kind of
heart attack - it's not an ideal medium for professional docs anyway.

So it's too hard to learn how to work with Bitcoin as a developer, and we
could really benefit from professionally curated web content. We have a
great web dev in the form of Saivann, who recently got some sponsorship
from the Foundation to spend time on the website, so I'm hoping that if we
find people to produce the content then he can with the visual design and
we could create something really special.

If you're interested in this let me know.


On Mon, Mar 3, 2014 at 8:40 PM, Tom Geller <tom@tomgeller.com> wrote:

-------------------------------------
Note that the problem might arise also by a bug / accident and not as an attack.

Since value spent is not part of the signature it is easy to create an arbitrary fee by a defective wallet software.
Collecting that huge fee might provide a higher incentive to miner than the block subsidy on the trunk.

Assuming miner are fully rational, they might even form a temporary coalition to claim the fee:
The miner who mines forking block might offer part of the fee gained in a similar transaction to
other miners, so they help to extend his fork. A sufficiently high stake could trigger a long
fork battle of ad-hoc coalitions.

Addressing the known bug of the signature hash, that it does not include the value spent,
would have other positive effects, e.g. for resource limited hardware wallets.

Interpretation of an OP_NOP for a value hashing signature check were suggested by Alan Reiner
discussed earlier on bitcointalk.

Tamas Blummer

-------------------------------------
RE: soft-forks bumping version numbers:

Yes, we have consensus that is the way we will do it.  I should probably
turn https://gist.github.com/gavinandresen/2355445 into an informational
BIP.

RE: malleability:

Orthogonal (but related) issue to IsStandard.

Detecting Scripts that leave extra items on the stack will be done in a
different part of the code than the code addressed by this pull reques. No
need to execute the Script twice to figure out if it leaves extra stuff,
and the idea behind IsStandard is to get to a quick yes/no before running a
potentially expensive Script execution.



-- 
--
Gavin Andresen
Chief Scientist, Bitcoin Foundation
https://www.bitcoinfoundation.org/
-------------------------------------
On Wed, Feb 12, 2014 at 7:12 AM, Rune Kjær Svendsen <runesvend@gmail.com> wrote:

This is fine and good. But it only scratches the surface of the
problems created by malleability, especially for fancier transaction
protocols.

Mutation allows you to invalidate a chain of unconfirmed transaction
by mutating the parent. This breaks any protocol which depends on
creating a precomputed nlocked time refund transaction.

So a canonical ID can be used to prevent some buggy behavior it
doesn't actually fix the problem. Fortunately the non-fixed parts
aren't too critical today.

On Wed, Feb 12, 2014 at 8:22 AM, Alan Reiner <etotheipi@gmail.com> wrote:

This is incorrect.  MtGox was automatically issuing replacement
transactions resulting in double payments.

When you attempt to replace/reissue/cancel a transaction you __MUST__
double-spend the original transaction. If the original transaction has
not been conflicted then it is possible someone will pull the original
transaction out of a hat and both your replacement and the original
will be confirmed.  It is not safe at any time to look to see if the
original has been confirmed yet, and if not reissue— not because
mutation may mean you're looking in the wrong place— but because the
state of the world could change nano-seconds after you looked.

If you do double-spend the original then there is no chance that both
will go through, you'll have atomic exclusion and only one transaction
or the other will be confirmed.


-------------------------------------
Just as an aside to this lengthy convo, the Cryptonote-based BCN recently
had some interesting updates which made it easier for ordinary computers
(nothing special) to handle it.

I realize that's not Bitcoin, but I thought I'd throw it out there.





-------------------------------------
As promised I'd like to present my work done on leveraging the payment
protocol for face-to-face payments. The general assumption is that
individuals don't own X.509 certificates. Their devices may be only
badly connected to the internet or in some cases not at all. I've
implemented a prototype on a branch of Bitcoin Wallet. It is using
bitcoinj 0.11 (not released).

https://github.com/schildbach/bitcoin-wallet/commits/payment-protocol


TAP TO PAY

First I looked at the NFC tap-to-pay usecase. The way it works as
currently rolled out: A BIP21 URL is published using an NDEF URI
message. The URL is supplemented by a Bluetooth MAC address that can be
connected in order to finish the payment. Once connected, a very simple
custom protocol transmits the signed transaction(s) in
bitcoin-serialized form to the payee, who replies with an ack or nack.

The way I prototyped it to work in future: Instead of the BIP21 URL a
BIP70 payment request is published using an NDEF MIME message (mime-type
as per BIP71). The paymentUrl field can (and in the face-to-face case
should) contain a Bluetooth URL which contains the MAC address of the
payee. Because I could not find any standard for Bluetooth URLs, I made
up my own: "bt:112233445566" means MAC address 11:22:33:44:55:66. Once
connected, Payment message and PaymentACK reply are used to finish the
payment. Since Bluetooth sockets are streams, I had to use the delimited
variant of the protobufs for Payment and PaymentACK messages. This
prepends them with a VARINT containing the message length.

All of the above should be easy to migrate. NFC implementations are
rare, and the current Bluetooth protocol is implemented only by Bitcoin
Wallet afaik. Fallbacks are provided where necessary.

In future, I'd like to add encryption to the Bluetooth connection, maybe
using SSL and some DH key exchange.


SCAN TO PAY

For scan-to-pay, the current landscape looks different. I assume at
least 50% of Bitcoin transactions are initiated by a BIP21 URL encoded
into a QR-code. Nevertheless, I tried to encode a payment request into
the bitcoin URL. I used my existing work on encoding transactions into
QR-codes. Steps to encode:

1. The payment request is protobuf-serialized. For a simple payment
request, this results in only ~50 bytes thanks to the efficiency of
protobuf.
2. The bytes are encoded using "Base43", which is the same as
Base64/Base58, but its alphabet consists of the characters allowed in
so-called "alphanumeric" QR-codes, minus the characters not allowed in URLs.
3. The resulting string is prefixed by "BITCOIN:"
4. All of that goes into a QR-code, and because it only contains
"alphanumeric" characters, it will produce a very efficient code. For
simple payment requests, I could not notice any difference in scanning
difficulty.

There are some limitations however:

- Obviously such QR-encoded payment requests cannot grow in size as much
as using other media. In particular, I expect PKI signed requests are
out of question. However, in face to face payments the value of a sig
based on PKI is highly questionable, and the fact the sig cannot be
verified without TCP connectivity doesn't help. There should be some
headroom for multiple-output requests and moderately more complex
scripts though.

- I chose to re-use the "bitcoin:" URL scheme, because it's already
whitelisted in web browsers, QR-code scanners and so on. In order to
differentiate "payment requests URLs" from BIP21 URLs, I test for
uri.startsWith("BITCOIN:") because you'll get letters in all-caps from
alphanumeric QR-codes. I will investigate into a better solution.

- Due to wide deployment of BIP21 QR-codes, migration needs to happen in
distinct phases. Ability to parse "payment protocol URLs" comes first,
default to presenting them to users has to come (much) later.


CLICK TO PAY

Finally this is the usecase the payment protocol was invented for and
it's not face-to-face. I don't have much to add, just one thing. As a
byproduct of the above, "payment protocol URLs" can be used for links
published on web pages as well. This might provide a nice replacement
for the imho rather ugly BIP72 specification once the payment protocol
is widely deployed.


Open for discussion.



-------------------------------------
On Fri, Jul 18, 2014 at 5:14 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

Looks good to me.


This is certainly a good thing. Not even OpenSSL is guaranteed to be
bug-for-bug compatible with its own prior versions forever, so better
to strictly define what is allowed.

Wladimir


-------------------------------------
On Sun, Jan 19, 2014 at 3:53 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:




The only thing controversial are the code changes themselves, not the
feature.

Consensus running through the comments in the pull is that it needs
(auto)tests.

Are you going to do this Luke? Or is anyone else working on this?

Wladimir
-------------------------------------

I agree that overloading isn't an issue when necessary, but my point was
that the necessity is lacking. If we're free to pick anything, why pick
something that is overloaded?

Moreover, "bit" is an abbreviation of bitcoin and might be confused with
it. Most currencies use a work that is phonetically very different and
short, so why not do the same?

Pluk, or cred, or finney (as proposed the thread I posted), or
whichever. We could call it "unsp" for unspent ;)

Arne


On 20/04/14 20:11, Mike Caldwell wrote:
Learn Graph Databases - Download FREE O'Reilly Book


-------------------------------------
A while ago I created a patch to make it possible to bind the RPC port to a
specific address or even multiple address/port pairs.

https://github.com/bitcoin/bitcoin/pull/3695

I'm fairly confident that it works, but it cannot hurt if some people that
need this functionality tested it before merge. Test results from normal
setups as well as weird corner cases (IPv4+IPv6, VPNs, ...) are welcome.

Regards,
Wladimir
-------------------------------------
On Thursday, January 16, 2014 9:09:52 AM Wladimir wrote:

https://github.com/bitcoin/bitcoin/pulls/luke-jr

These are pretty much all well-tested and stable for months now.


-------------------------------------
On Mon, Nov 3, 2014 at 5:01 PM, Alex Mizrahi <alex.mizrahi@gmail.com> wrote:

But if the majority of the sidechain miners keep working on the honest
chain, anyone can submit a reorg proof during the contest period that
invalidates this "unlockment" on the parent chain.
Honest sidechain miners will get rewarded in the sidechain, and those
rewards will only be valuable if they form a shared valid history.


This is correct. There's many variables at play.


As explained many times, sidechains and merged mining are orthogonal:
pegged sidechains don't need to use merged mining just as merged
mining altchains don't need to be sidechains.
Anyway, I think you're somehow assuming that deciding to mine against
the sidechain instead of mining for its rewards.
This is simply not true. No matter how big the attack incentive is, if
you're assuming my 52560 contest period example and that the attacker
doesn't control the majority of the hashing power on the sidechain,
the probability of achieving a one-year reorg is negligible. In the
meantime honest nodes are getting some reward, let's say 0.1 BTC per
block. That's 5256 btc/year to the honest nodes vs 0 btc/year for the
attacker.
If the attacker controls, say, 10% of the network, he's losing 525.6
btc/year in opportunity costs for an extremely small chance of getting
1000 btc.


We're not claiming that the security model is the same, we just
compare it to Bitcoin's because it's similar in many senses.


Yes, that's precisely the kind of reorganizations the BITCOIN
WHITEPAPER is talking about in section "11 Calculations":
reorganizations caused intentionally by an attacker. Please read it
again.
"q_z = probability THE ATTACKER will ever catch up from z blocks behind".


If it sounds to you like we're claiming that attacker-induced
reorganizations are not likely, maybe we could have expressed it some
other way. That was certainly not the intention.
That's not true for Bitcoin itself and that's not what we're claiming.


Exponentially harder with the number of blocks is good enough for me.


That would be a reorganization too, you can't create a completely fake
history for a sidechain, the attacker will share some of the chain's
history.
Yes, the attacker can create an SPV proof of a fake chain and in that
sense, this is different from a regular double-spend.
If honest miners control the majority of the hashing power, they will
produce a valid chain longer than the fake chain. And then anyone can
use that reorg proof to stop the attacker before the contest period.
You see, "SPV security" is not the same as "SPV security with more
than 52560 confirmations of the transaction I'm receiving".


Proof of work is not free, that's the whole point of proof of work.
As said, sidechains, like Bitcoin itself, relies on the assumption
that an attacker won't control a majority of the network. Satoshi's
paper just says that p must be greater than q.
We go beyond that precisely at the beginning of the "6.1 Hashpower
attack resistance" section:

"The main thrust of this paper surrounds two-way peg using SPV proofs,
which are forgeable by a
51%-majority and blockable by however much hashpower is needed to
build a sufficiently-long
proof during the transfer’s contest period. (There is a tradeoff on
this latter point — if 33%
hashpower can block a proof, then 67% is needed to successfully use a
false one, and so on.)"

I'm happy to keep trying to clarify things. But I think we will
advance faster if you first tell me what do you think the contest
period is for.
Because that's I think the source of your misunderstandings. From what
you're saying, I don't think you're having the contest period into
account at all.


-------------------------------------
I agree that 'version' field of bip32 is not necessary and xpriv/xpub
should be enough for all cases; there's actually no need to use different
BIP32 roots for different altcoins.

I'm happily using one xpub for Bitcoin/Testnet/Litecoin at once, and by
having the "cointype" distinction in the bip32 path itself, I'm sure that I
don't reuse the same pubkey across blockchains which may be a privacy issue
otherwise.

Marek


On Thu, Mar 27, 2014 at 5:28 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:

-------------------------------------
On Wednesday 23 Apr 2014 08:55:30 Mike Hearn wrote:


Just pedantry: 100% of credit card transactions _can_ be fradulantly charged 
back but arent.  In fact, only 2% are ever attempted.

If N was 5%, then only 5% of bitcoin transactions _could_ be fraudulantly 
"charged back"; so then why wouldn't only 2% of those bitcoin transactions 
be fraudulant too, just as in the CC case?

The comparison would then be 2% chargebacks for credit cards, equivalent to 
0.1% (5%*2%) for bitcoin.


Not that I think that makes anything else you say invalid.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Mon, Jan 13, 2014 at 01:13:08AM -0800, Jeremy Spilman wrote:

I think what stealth addresses is showing is that the concept of an
address being "instructions on how to generate a txout/tx that results
in me getting Bitcoins" is actually quite valuable; it and
BIP32-derivation addresses with chaincodes are pretty clear cases where
just replacing address with scriptPubKey isn't sufficient.


Yeah, I don't see anything wrong with stealth addresses whatever length
they wind up being. It's a good intermediate step, and without them
people will just pass around unsigned payment requests and other stuff.


At the DarkWallet hackathon we had discussed how to integrate stealth
addresses into OpenPGP keys as a new user id type for instance, and
similarly into x.509 certs.

The big advantage here is the identity of *who* you are paying is
important, not just "I got this signed payment request". Basically the
concept becomes "identity signed payment address" and the signature
binding the identity to the address is a one time and offline thing; an
issue with the payment protocol as it stands is that it encourages
signing keys to be kept online to issue payment requests. If you have a
scheme where the private keys that bound the identity to the address can
be kept offline you're much better off, because the attacker can only
create a fake payment request, they can't divert the funds to
themselves.

So with that in mind, I strongly suggest sticking with defining a
reasonable stealth address spec. But when you do, keep in mind that you
may want to upgrade it in the future, preferably in a backwards
compatible way. Also, it shouldn't be limited to exactly 2-of-2
CHECKMULTISIG, there's no reason why n and m can't be picked as needed.
Sure, it means the addresses are not fixed length, but for something
that is mostly an internal detail and only occasionally visible to
advanced users, I see no issues there.

Along those lines: what would a BIP32 chain code address look like? What
happens when you want to use that with a multisig-protected wallet?


I think you're missing the bigger picture here, not least of which is
that backwards compatibility is a bit of a misnomer for an unreleased
standard. :)

Why put this into the PaymentDetails? That a stealth address is to be
used for the payment is a property of the outputs being requested, not
the payment itself. We're better off if that goes into the Output
message, and further more it suggests that the Output message shouldn't
contain raw scriptPubKey's but rather addresses. After all, IsStandard()
means we have to inspect the scriptPubKey to see if we can even pay to
what the sender is requesting.

Once you establish that it's addresses that Outputs specify, then it's
easy enough to make a stealth address type, or a BIP32-chain-code
address type, or whatever else comes up in the future.



Agreed.

-- 
'peter'[:-1]@petertodd.org
00000000bda8ab55740699711a11572c4eec9dc9f714e4896559aac310a115ff
-------------------------------------
On Fri, May 23, 2014 at 9:48 AM, Kyle Jerviss <bitcoin-devel@jerviss.org> wrote:

PGP in general is not very thoughtful about security. There are a lot
of things it does poorly. This is easily excusable considering the
historical context it came from— it was the first real cryptographic
tool I used, at the time its distribution had concerns about legality,
just getting things into people's hands was an achievement enough.

now, but there is a long way to go in figuring out how to many any
cryptographic tool usable to people.

PGP is a general purpose tool— which is the hardest kind to write— its
also used in a lot of irreversible contexts: If your key deploys a bad
software release and it steals everyone's data or wipes their disks—
thats not an irreversible action by any means.

If you want threshold pgp though— it's possible. The RSA cryptosystem
is directly compatible with threshold cryptography. It's just that no
one has written the tools. There are implementations of the bare
cryptosystem however.

One of my longer term would-be-nice goals for a upgrade bitcoin script
2.0 would be being thoughtful enough in the design that it could be
adopted as a signing cryptosystem in other applications (e.g. tools
similar to GPG)— allowing for things like creating a public key which
can only issue trust level 0 certifications, only certifications for
certain organizations (e.g. *.debian.org) unless thresholded with an
offline key, or only signing for messages meeting a certain
programmatic predicate generally.


-------------------------------------
Companies can have a Cert with their name via CAcert. It requires some work though to get assured as an organisation.
Did you already think about what CA is to be trusted or do users need to do that. The least good decision in my POV would be to accept OS/browser built in CAs only.

Am 27.03.2014 um 11:08 schrieb Mike Hearn <mike@plan99.net>:

-------------------------------------
Oh, I absolutely agree that this type of attack is NOT the weakest link in security. There are MANY far easier targets in bitcoind and typical use scenarios of it. If we want to dramatically improve the security of a typical bitcoin wallet, the FLUSH+RELOAD attack is probably not where our efforts would be best rewarded trying to prevent.

However, this thread IS about this particular attack vector - and my suggestion IS specific to this thread.

-Eric Lombrozo


On Mar 5, 2014, at 2:17 PM, James Hartig <fastest963@gmail.com> wrote:


-------------------------------------


As per Gavin at the top of the thread, the intent is to give the customer
reassurance that their payment will be processed. The merchant trying to
get the tx confirmed is presumably a part of that as it'd make no sense for
a merchant to give that assurance and decide they don't care about the
money.

But nothing stops the user broadcasting the tx as well, once the receiver
has given that assurance.
-------------------------------------
Here is a solution to the problem of having 0 confirmation
transactions that relies on game
theory and most miners implementing replace-by-fee and child-pays-for-parent.

This has been proposed before
http://sourceforge.net/p/bitcoin/mailman/message/30876033/
I'm just going to describe the general idea in more detail.

Here's a small draft on how this could work:

Alice goes to Bob's store and wants to buy something cheaper than a
car, say a smartphone.
So Bob says, "it's 200 usd in btc, please pay me 400 usd in btc"
So Alice signs a tx with 400 and no fee with her old phone and she
just sends it to Bob rather than the network.
Bob creates a child transaction keeping 200 and giving 199.9 (0.1 usd
fee) back to Alice.

But you know, Alice wants to double spend.
She double spends 399.8 to herself (0.2 fee)
Bob thinks "last chance", he double-spends the child: 200 to Bob, back
199 to Alice (1 usd fee).
Alice is stubborn: 398 to Alice (2 usd fee).
Bob is really pissed off, double spends the child: 400 in fees.

So, ok, Bob lost the phone and got nothing but Alice has paid twice as
she needed for the phone.
Nobody's happy thus everybody's happy.

This is similar to the general game theory "stag hunt" case.
The payoff matrix could be something like this:

                        Bob returns change   Bob burns in fees
 ---------------------+--------------------+-------------------
  Alice behaves         + 1 , + 1            - 1, + 1
 ---------------------+--------------------+-------------------
  Alice double-spends   + 3, - 1             - 1, - 1

The game has two Nash equilibria, but cooperation is Pareto efficient.

Replace-by-fee and child-pays-for parent cannot be prohibited by a
protocol rule.
I believe all miners will eventually implement these policies because
it is the more rational way for them to prioritize transactions.
Finally I hope they do because it would make 0-confirmation
transactions possible as described in this post.
So I can't find any reasoning against replace-by-fee unless my example
is terribly flawed.
Am I missing something?

-- 
Jorge Timn

http://freico.in/


-------------------------------------
Hey Rusty,

This is intriguing, do you have a writeup somewhere I can read more about ?

Thanks,

Charlie

CharlieShrem.com | *Please **encrypt messages with my PGP key
<http://charlieshrem.com/contact/>*


On Tue, Jun 3, 2014 at 8:45 AM, Rusty Russell <rusty@rustcorp.com.au> wrote:

-------------------------------------
On Sunday, 13 July 2014, at 7:32 pm, Richard Moore wrote:

Even if you could find such a transaction that contained its own digest, and even if such a transaction were valid, it still couldn't conjure new coins into existence. The sum of the outputs must be less than or equal to the sum of the inputs (except in the case of a coinbase transaction). If a transaction were to spend its own output, then the input would be completely used up by the output, leaving no balance for a second output.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512



A recent comment on this (I think)...

https://github.com/bitcoin/bitcoin/issues/4564#issuecomment-49558760

Reflecting on an approach from a different but related project, as a
result of an issue discussion in DW, stealth and coinjoin from that
project were broken out as distinct repositories - see:

https://github.com/darkwallet/stealth.js
and
https://github.com/darkwallet/coinjoin.js

installable using npm


I'm probably missing something here, but it seems to me like breaking
things out as distinct repositories might be a good approach.  The
question is what would be in a distinct repository or repositories?
Currently if someone is looking at core, everything is seen here:
https://github.com/bitcoin/bitcoin/

<slips away for holidays>




Wladimir:
Download BIRT iHub F-Type - The Free Enterprise-Grade BIRT Server
_______________________________________________

- -- 
http://abis.io ~
"a protocol concept to enable decentralization
and expansion of a giving economy, and a new social good"
https://keybase.io/odinn
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUd4SAAAoJEGxwq/inSG8Che8H/3PMt0NQSrVSqnC6WC9scXdD
aqGnsdZkhnLRs0szJSTjiQm+xCk6aUcEsKCGu298Xhkv38S4DSfWa+OhFZGPKmOZ
wlfnXAz3SprQ8xzy/NVqavtFRk+pGDRxgBIzzgBfbz3BdPKxMywi9BNnaK0YA6UA
08giKmtqblHTKmKuguK23YIYjAAk3Csg0Vg4BgN2MgeEXl9PJI6vh4+jNckXWtAT
/gKjPXG/Q+f9wl5pxSY/+ZfmRUtjHye3f8hHjpSEmxjpB9QzeeDg63DzAhOH0ip5
vXaIePZED//SmN3eH+S22vAx/a83URkr5B2+8Cffx/oO5laYRthoMHLi/2+XkO4=
=UWhs
-----END PGP SIGNATURE-----


-------------------------------------
On 03/29/2014 01:19 PM, Matt Whitlock wrote:

I do not believe this is a good tradeoff.  It's basically obfuscation of
something that is already considered secure at the expense of
usability.  It's much more important to me that the user understands
what is in their hands (or their family members after they get hit by a
bus), than to obfuscate the parameters of the secret sharing to provide
a tiny disadvantage to an adversary who gets ahold of one. 

The fact that it fails silently is really all downside, not a benefit. 
If I have enough fragments, I can reconstruct the seed and see that it
produces addresses with money.  If not, I know I need more fragments. 
I'm much more concerned about my family having all the info they need to
recover the money, than an attacker knowing that he needs two more
fragments instead of which are well-secured anyway.




-------------------------------------
Note that one of the reasons why this is insecure is because EC point
addition is invertible.  EC-scalar multiplication is not, thus why EC
Diffie-Hellman is secure even when this timing asymmetry exists.

A good cryptosystem doesn't have strange restrictions, like "your public
key can only be public sometimes, but needs to protected like your
private key other times."  If you have to worry about things like that,
you're doing it wrong :)  And why we always recommend sticking to
well-known, well-studied operations.

-Alan


On 03/08/2014 03:51 AM, Edmund Edgar wrote:

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 27 May 2014 02:19:39 GMT+03:00, Andreas Schildbach <andreas@schildbach.de> wrote:

I meant running a seed yourself. Note that I've only received funds to cover expenses and a trivial amount on top to cover some time - about one and a half hours at my usual rates.

Gavin: Speaking of, given it looks like my work will be frequently keeping me out of country and unable to provide any more than a "best effort" attempt at running a seed, I'd like to give back the grant funds for doing so. Email me privately with an address to send them too. I have no plans to take it down, however the expectations users have for it aren't something I can provide.


I checked via the same proxy both times; I believe the endpoint is located in Europe.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJTiFKwMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhQFCB/4jypD+xzKVp6fqRUxu
v22Rc6PeCbeaPYKmdNu0LbY1G5spB8C8ooaZX6z0Ib/CYobzDPJ+rJNB+c1Fna4N
1IdH7ZsrX0GFaEn7Grnp7D2rtOXGZV+1XGFAateIA/caQ9+rJfqkHLuvOI0Fh+Ua
/m857rxUNtA1kObLFS7gfhi2gwXGO6KQ3muS3462hXVVc9j7DhOWQQwJba5PL+Je
Eob4WtnF2gVFlCEWevxvflF7j4lW9I/S81yZQDnNW9ATF2mfZVqo26sB0yL6Tm4l
KgdKx7+w3khv6QfW9Ilx0Ov3Ml2ZMRhBimpbnENbW4jfklsuRQcM0yx6vXS/lIMz
LO5s
=Up3N
-----END PGP SIGNATURE-----



-------------------------------------
On Fri, May 30, 2014 at 5:40 PM, Andreas Schildbach
<andreas@schildbach.de> wrote:

That's what Matt's implementation is doing. You don't have to run mine :)

I chose not to do so, as I wanted to be able to serve a different
response to every query, but more diversity is a good thing.

-- 
Pieter


-------------------------------------
Now we're starting to see the first companies deploy BIP70, we're
encountering a need for identity delegation. This need was long foreseen by
the way: it's not in BIP70 because, well, we had to draw the line for v1
somewhere, and this is an issue that mostly affects payment processors. But
I figured I'd start a thread anyway because people keep asking me about it
:)

*Objective*

Identity delegation means that a payment request can be signed by someone
who is not holding the certified private key. The most obvious use case for
this is payment processors like BitPay and Coinbase who currently have to
sign payment requests as themselves. Other use cases might involve
untrusted sales agents who want to be able to accept payment as their
employer, but cannot be trusted with a long-term valuable secret, e.g.
because they take their phone into areas with high crime rates.

The lack of this is ok for v1 but not great, because:

1) It requires the name of the *actual* recipient to be put in the memo
field, otherwise you don't have the nice receipt-like properties. The memo
field is just plain text though, it doesn't have any exploitable structure.

2) It gives a confusing UI, the user thinks they're paying e.g. Overstock
but their wallet UI tells them they're paying Coinbase

3) Whilst these payment processors currently verify merchants so the
security risk is low, in future a lighter-weight model or competing sites
that allow open signups would give a weak security situation:  a hacker who
compromised your computer could sign up for some popular payment processor
under a false identity (or no identity), and wait until you use your hacked
computer to make a payment to someone else using the same payment
processor. They could then do an identity swap of the real payment request
for one of their own, and your Trezor would still look the same. Avoiding
this is a major motivation for the entire system!

Also it just looks more professional if the name you see in the wallet UI
is correct.

*Proposed implementation*

We can fix this with a simple extension:

enum KeyType {
  SECP256K1 = 1
}

message ExtensionCert {
  required bytes signature = 1;
  required bytes public_key = 2;
  required KeyType key_type = 3;
  required uint32 expiry_time = 4;
  optional string memo = 5;
}

// modification
message X509Certificates {
  repeated bytes certificate = 1;
  repeated ExtensionCert extended_certs = 2;
}

message PaymentRequest {
  // new field
  optional bytes extended_signature = 6;
}

This allow us to define a so-called *extended certificate*, which is
conceptually the same as an X.509 certificate except simpler and Bitcoin
specific. To create one, you just format a ExtensionCert message with an
ECDSA public key from the payment processor (PP), set signature to an empty
array and then sign it using your SSL private key. Obviously the resulting
(most likely RSA) signature then goes into the signature field of the
ExtensionCert. The memo field could optionally indicate the purpose of this
cert, like "Delegation to BitPay" but I don't think it'd ever appear in the
UI, rather, it should be there for debugging purposes.

The new ExtensionCert can then be provided back to the PP who adds it to
the X509Certificates message. In the PaymentRequest, there are now
*two* signature
fields (this is for backwards compatibility). Because of how the mechanism
is designed they should not interfere with each other - old implementations
that don't understand the new extended_signature field will drop it during
reserialization to set signature to the empty array, and thus signature
should not cover that field. On the other hand, extended_signature would
cover signature. Thus, for full backwards compatibility, you would:

1) Sign the payment request using the PP's SSL cert, i.e. sign as
coinbase.com

2) Then sign again using the PP's delegated ECDSA key, i.e. sign as the
merchant

The finished protobuf would show up in old clients as signed by
coinbase.comand by new clients as signed by
overstock.com even though Overstock did not provide their SSL key to
coinbase.

If you have *only* an ExtensionCert and not any X.509 cert of your own,
then you cannot of course make backwards compatible signatures in this way,
and in that case you would miss out the signature field and set the
pki_type to a new value:  "x509+sha256+excert". Old wallets would see that
they don't understand this pki_type and treat the request as unverified.

For maximum security the merchant may choose to set very short expiry times
(like, a day) and then have a cron job that uploads a new ExtensionCert at
the end of each expiry period. This means in the case of PP compromise, the
system reseals very fast.

*Alternatives considered*

We could always use a new pki_type and not bother with the two signature
fields. However, this means old wallets will show payment requests as
untrusted during the transition period. Some signing is still better than
none, security-wise.

We could attempt to fix the above by introducing a use of User-Agent field
to the case where a payment request is fetched via HTTP, so the server can
customise the PaymentRequest according to the capabilities of the client.
However, sometimes payment requests are not fetched via HTTP, for example,
they may be attached to an email, sent via an IM network or sent over a
Bluetooth socket. Nonetheless this may be a useful thing to consider for
future cases where the protocol may not be extended in a backwards
compatible manner.

We could create the extension cert as an X.509 cert, rather than a custom
type. However most CA's set path length constraints on their intermediate
certs that forbid this kind of extension (I forgot why, possibly some kind
of anti-DoS mitigation). Also re-using X.509 for the extension cert would
open up the risk of it being accepted by a bogus SSL stack that didn't
check the key usage constraints extension, and that would allow for SSL
delegation as well. It seems safer to just use a different format that
definitely won't be accepted.



Feedback welcome.
-------------------------------------
On Tuesday, 22 April 2014, at 4:11 am, Matt Whitlock wrote:

Testnet encodings are added: https://github.com/whitslack/btctool/blob/bip/bip-xxxx.mediawiki


-------------------------------------
Sam,

On Sun, Mar 16, 2014 at 8:04 AM, Sam Michaels <sam@samtheham.org> wrote:


Thanks for your effort.

However the current idea is to phase out reliance on centralized external
services completely in favor of peer-based address detection.

See https://github.com/bitcoin/bitcoin/pull/3461

Wladimir
-------------------------------------

On 02/05/2014 10:56 a.m., Joseph Bonneau wrote:
The second interpretation is the correct one.
Including an uncle can be done at any time before a coinbase matures
(100 blocks) (of course the term "uncle" is misleading in those cases) .
So, for example, the uncle can be included 50 blocks afterward. So it's
very difficult that a miner prevents other miners from including the
uncle and taking the reward given by uncle inclusion.

Same ineffective attack:
A big miner could try to bribe all other miners not to include the
uncle, but this would be terribly costly. Suppose that I mine a block
ignoring an uncle Z and then I publish this message: "Every miner from
block number X to block number Y that does not include this uncle Z will
be given Q Bitcoins". How much would Q be? Since by including the uncle
the miner gets 5 BTC of reward (in the example case where block reward
is 50 BTC), then each bribery payment would have to be higher than 5
BTC, totaling 500 BTC ! much more than the 25 BTC the miner will loose
by including the uncle.

Just by sending a transaction with a lot of fees that depends on my
block does not prevent subsequent miners from including the supposedly
banned uncle.

Then, I think there are no kickback-style attacks.

In the DECOR protocol, I think selfish miners cannot get any advantage,
because the blocks that loose the latency race will come back as uncles
and get their reward share anyway. Maybe Ittay Eyal and Emin Gun Sirer
can say more about this...

Best regards, Sergio.


-------------------------------------
Just keep in mind that if it turns out we need to retrofit messages with
length prefixes I fear we will have to restart with new mime-types. The
nature of prefixes being always at the start means this rules out simply
incrementing a protocol version number.

Correcting myself:


Of course I only mean the "root" messages, namely PaymentRequest,
Payment, and PaymentACK. The embedded messages don't need length prefixes.


On 01/26/2014 11:00 PM, Mike Hearn wrote:




-------------------------------------
An interesting experiment would be a transaction "proof of publication"
chain.

Each transaction would be added to that chain when it is received.  It
could be merge mined with the main chain.

If the size was limited, then it doesn't even require spam protection.

Blocks could be "discouraged" if they have transactions which violate the
ordering in that chain.  Miners could still decide which transactions they
include, but couldn't include transactions which are double spends.

The locktime/final field could be used for transactions which want to be
replaceable.

The chain could use some of the fast block proposals.  For example, it
could include orphans of a block when computing the block's POW.



On Wed, Apr 23, 2014 at 9:53 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------
On 26/04/14 01:28, Mike Hearn wrote:

Are you sure there isn't room for just a touch of "religion"? :) As you
state below, all that protects my money from confiscation is strong
group consensus that it's mine - "a social rule, not a mathematical one."

Everything ultimately balances on that. People being a little bit
"religious" about following the protocol faithfully are the linchpin of
Bitcoin security, not PoW.



Agree.



Wholeheartedly agree. "21 million" is just shorthand for the
preservation of artificial scarcity. No rational person could argue that
what you described violates the social contract.

I do see what you're driving at - that there exists a situation where it
would be justified to change the interpretation of data in existing blocks.

But, please consider: if I controlled a single UTXO worth 1% of the
total money supply before your change, the network would still recognise
that I control a single UTXO worth 1% of the total money supply after
your change. So you haven't really changed the interpretation of
existing blocks at all there. It's just semantics :)

Contrast this with invalidating a coinbase before maturity, which
clearly has a very real impact. At the point the vote passes, you're ***
sidestepping the PoW mechanism and rewriting the meaning of an existing,
validated block ***.



Agree. That's my whole point :)

I recognise my security is in the hands of the users (the economic
majority.) Tomorrow they could all decide to patch their nodes to
reallocate my UTXOs, and there's not a damn thing I could do about it,
PoW and private keys notwithstanding. I must simply trust that they will
not do this.

So we can have:
1. "Neutral Bitcoin", where everyone is committed to prevention of theft
by following a simple set of mathematical rules which treat all
validated blocks as equal.
Or:
2. "Political Bitcoin", where everyone is committed to prevention of
theft based on human judgements, and the contents of some validated
blocks are more equal than others.

I recognise that the latter allows for a lot of flexibility in combating
fraud, but with (substantial) due respect, it isn't Bitcoin.

-Gareth

-------------------------------------
On Wed, Apr 9, 2014 at 8:42 AM, Brian Hoffman <brianchoffman@gmail.com> wrote:

If Bitcoin core activates pruning a full node can be supported in—
say— 4GBytes or so. (That gives enough space to store the utxo about
350MB now, and a couple gigs for blocks to serve out).

I'd imagine getting information from SPV wallet developers how much
disk usage agility they think is required is part of what Wladimir is
looking for.


-------------------------------------
My apologies for posting to the wrong thread.



On Fri, Jul 18, 2014 at 5:51 PM, Emin Gün Sirer <el33th4x0r@gmail.com>
wrote:

-------------------------------------
So, just to be clear, we're adding, say, a memory limited mempool or
something prior to release so this fee drop doesn't open up an obvious
low-risk DDoS exploit.... right? As we all know, the network bandwidth
DoS attack mitigation strategy relies on transactions we accept to
mempools getting mined, and the clearance rate of the new low-fee
transactions is going to be pretty small; we've already had problems in
the past with mempool growth in periods of high demand. Equally it
should be obvious to people how you can create large groups of low-fee
transactions, and then cheaply double-spend them with higher fee
transactions to suck up network bandwidth - just like I raised for the
equally foolish double-spend propagation pull-req.

Of course, there's also the problem that we're basically lying to people
about whether or not Bitcoin is a good medium for microtransactions.
It's not. Saying otherwise by releasing software that has known and
obvious DoS attack vulnerabilities that didn't exist in the previous
version is irresponsible on multiple levels.

-- 
'peter'[:-1]@petertodd.org
0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2
-------------------------------------
namecoin + SIN[1] or namecoin + PGP identity.

[1] https://en.bitcoin.it/wiki/Identity_protocol_v1

On Mon, Mar 31, 2014 at 6:21 AM, vv01f <vv01f@riseup.net> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Ok, one more idea:
r= is used for the first URL, and we *think* of it as r0=
additional URLs are appended as
r1=
r2=
and so on. This would also define an ordering in case we need it.


On 07/01/2014 05:07 PM, Michael Wozniak wrote:




-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 19 May 2014 17:09:07 CEST, Mike Hearn <mike@plan99.net> wrote:


Meh. The world is much bigger than the USA. Secondly that rule makes it difficult to educate people about why patents are as bad as they are.

Feel free to continue censoring your own discussion within closed corporate environments. But to say keeping patent discussion off mailing lists is appropriate or wise when the tech news is full of such discussion is silly.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJTekz8MxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhX0TB/wNZoi5sWj6n3fM7O7T
emVbrVpuBwOvUEJAFYGmXgb2KXGdheVRhXfcwteQybLG+M+Ra/HAqLq+1YrPmopE
QeldiSc31KAkVLYXQMIfD6QO1PBlvKP7qPLqBEpCc9ocd8XLppTPQ2K8o5soV8VF
z6Jt/Hh74xhkhhb/kEzsQ8YKkg+m26WY9Yggu0Qxtb0OTjL86IhEKpH9ijr08jvV
TKs+PHwou5rt0dT3vqLd8ogb7xihTPx/7tciaXHCOfvxGsEgtqdTsjdHlCJ6cR9a
DrZcrIQnX+s1+YbHs3P4kyBfzNHBwwVuwaf5W5pU6vFp276jhsgT/65J7PqoRmxK
AkXg
=dk4R
-----END PGP SIGNATURE-----



-------------------------------------
Not to get snarky or OS elitist but as I understand it windows security,
even during its support period has been measured in low digit number of days
in the year when is NOT an outstanding known remote root compromise or
combination of remote user compromise + priviledge escalation.  Add in
phishing, watering holes, malware and the average windows computer is
probably compromised a dozen times over.  Apparently for sometime it was not
easily possible to secure it install boot - install OS, connect to network
to download security updates, IP range scanned and compromised faster than
you can patch it.

Adam

On Wed, Apr 16, 2014 at 05:28:27PM +0200, Wladimir wrote:


-------------------------------------
Hi guys,

I with all thats happening now I think (yea no hard proof) most of it is
being done on purpose (transaction mutation) by some pool/entity.
I have posted here https://bitcointalk.org/index.php?topic=463350.0 of how
to go about finding out if its some pool doing it. This does in no way
solve "fix" the malleability issue BUT IMHO it might help "alleviate" the
problem we are facing at a network level.
Please have a look if possible.

Kind Regards,
thenoblebot


On Wed, Feb 12, 2014 at 2:26 AM, naman naman <namanhd@gmail.com> wrote:

-------------------------------------
I have done some work on incentives arising from block propagation times and it turns out that Bitcoin is already quite good at establishing the primacy of blocks by time despite what people think. Part of the reason for this is the way that partitions on the network evolve as a block is propagated. Typically at the moment, blocks reach over 50% of the network in 5 seconds. Reach being defined as a node receiving and validating a block. If we make an assumption that the hashing power of the network is uniformly distributed over the nodes (I know it is not a good assumption but can discuss it off the list). Then 50% of the hashing power are already building a block that builds on top of the block that is already circulating. The probability that there is a collision on the network therefore falls fast and then the probability that the miner who propagated the first block wins given a collision occurs is rising. I think that block propagation times might actually be a bigger issue for miners who are less well connected to the network in the sense that they spend more time mining redundant problems and during that time may find blocks to compete with blocks that are already spreading throughout the network.

I have a paper that models this more formally and has some numerical simulations but cannot publish it on the internet at present (University Regulations) but I am happy to share a version privately if anyone is interested.

Best,

Jonathan

--
Jonathan Levin
Co-Founder Coinometrics
http://www.coinometrics.com/
Postgraduate Economist | St Antony's College | Oxford University
@jony_levin
@Coinometrics




-------------------------------------
2014-03-08 8:52 GMT+00:00 Jan Vornberger <jan@uos.de>:
​​

No, devices on this video are not on the same network, and even if they
would - I cannot control what ​​remote hosts my phone would connect to, so
transaction may anyway travel around the globe before coming to the POS
even if they would be on one LAN.
As for transaction times - I'd say it varies. ​From my extensive testing
most of transactions usually come through within 2-5 seconds, but roughly
one in ten transactions may take more time, sometimes much more time.


You probably share this view, but I just wanted to repeat, that from my
​Yes, ​I'm certain about that we need to switch to BIP70 asap. As I said
earlier - support among the wallets is the biggest problem here really.
Only Andreas' Wallet supports it right now AFAIK, and even in there it's
only as "LABS feature", so will be turned off for most of users.


In the context of this discussion, I would also like to share a video of
Yes, I've seen this demonstration, I think it was on reddit about two
month​​ ago. Looks interesting, but by that time most of my client software
was already done, so I couldn't really use this.




​NFC
​as ​
back channel
​definitely ​
will not work
​. Mike proposed something ​like a threshold to define minimal amount
available for spending without confirmation, but I don't see this thing
becoming widely used any time soon, and before that we will need to have
"confirm" button tap.


One problem with Bluetooth I see is, that it seems to be mostly turned
Yes, this is a problem, I think bluetooth is offline on many devices, and
keeping it on all the time will harm security (if not real security, then
at least perceived by users) and also harm battery life, which will be seen
as huge problem by the users.
​Would be great to be ​able to control BT state automatically from within
the wallet app with user permission given once on installation time, but
not sure if it's possible in Android.



-------------------------------------
On Fri, Jan 03, 2014 at 09:59:15AM +0000, Drak wrote:

'make' should check the hash. The binary should check it's own hash. The
operating system should check the hash.

How about if I sell your Grandma an android table loaded only with free 
software, and use the existing infrastructure android provides to only
allow software to be installed that can be integrity-verified from a 
public key that can be downloaded from the blockchain?

Would you pay $50 (or 2 litecoin) more for at tablet with free software
that protects you and your grandma's interests, rather than selling them
to google/apple/microsoft?

I'm working on eventually being able to build hardware for which the 
entire design specifications, from case to cpu core verilog, all they way
up to the pre-installed cryptographic currency wallet(s) are all signed
and released as part of the Debian archive. 

But I need people like you to explain to your Grandma why this hardware
costs more than hardware that monetizes eyeballs and sells your private
information to the highest bidder.


-------------------------------------
On Sat, Mar 22, 2014 at 10:08:36AM -0500, Troy Benjegerdes wrote:

Lol! Granted, I guess I should "disclose" that I'm working on tree
chains, which just improve the scalability of blockchains directly. I'm
think tree-chains could be implemented as a soft-fork; if applied to
Bitcoin the datacoin 1% might face market risk.  :P

-- 
'peter'[:-1]@petertodd.org
0000000000000000bbcc531d48bea8d67597e275b5abcff18e18f46266723e91
-------------------------------------

This is subjective though. To me the first price looks like the price of a
cup of coffee (or I just mentally double it). The second looks like the
price of an expensive holiday.

If users really find this so terrible, merchants have a simple solution: do
the rounding before presenting the price. Then the price looks like "3.12
mBTC" which is sort of what I'd expect it to look like. But some wallets
already make digits >2dp smaller so visually you can get precision whilst
still looking similar to what you might expect (this is what Bitcoin Wallet
does).



That's the good argument!
-------------------------------------
On Thu, Apr 24, 2014 at 10:25 AM, Wladimir <laanwj@gmail.com> wrote:

Does anyone know of the timeframe in which tails will switch to a
newer version of Qt?

As it's debian based: will switch to a Wheezy/7.4. Wheezy has Qt 4.8
so is decidedly unproblematic.

I see they're working on migration at least:

- https://tails.boum.org/blueprint/Wheezy/
- https://git-tails.immerda.ch/tails/log/?h=feature/wheezy

Wladimir


-------------------------------------
Agreed. If the POW is most efficient on general purpose CPUs, that
means Intel, AMD and maybe IBM would be the only entities capable of
producing competitive mining equipment.

Aaron


Aaron Voisine
breadwallet.com


On Fri, Jul 4, 2014 at 11:39 AM, Ron Elliott <ronaldbelliott@gmail.com> wrote:


-------------------------------------
I wonder whether we actually want to support this kind of advertisement in
the P2P protocol. We have a working mechanism for protocol extensions in
the P2P network (service flags) so this is obviously only for services that
are not P2P extensions, so why have them in there at all?

I'd argue that a parallel network, external to Bitcoin, could take over the
task of advertising external services.

Regards,
Chris

--
Christian Decker


On Fri, Aug 8, 2014 at 11:26 AM, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------
Not a lawyer, but I don't see what would prevent me from writing contracts like:

"I owe the holder of this contract 10 usd" (IOU)

"I owe the holder of this contract 10 usd in beer" (voucher)

"I owe the holder of this p2p asset 10 usd in beer" (p2p voucher)

Of course, there must be a legal contract outside of the chain for
this contracts to be enforceable.
Some p2p assets will have them and other's won't. Say Alice pays the
dinner (20 usd) and her friend Bob pays her half of the price in p2p
usd not legally enforceable IOUs issued by him (10 bob:USD).
That's not legally enforceable, so what?
If Bob doesn't pay back Alice would lose 10 usd and would not accept
bob's IOUs anymore, much like it would had happen with a verbal IOU.
The difference is that Alice can sell those bob:USD to other people
who trust Bob.

Different p2p assets have different legal needs.

In any case, I think Peter summarized it very well:

"[...]no amount of code can, **by itself**, make data
represent a physical or legal entity. Only consensus and/or authorities
in the "real world" can do that."


On 2/9/14, Troy Benjegerdes <hozer@hozed.org> wrote:


-- 
Jorge Timn

http://freico.in/


-------------------------------------
Absent a concerted effort to move to something else other than 'bits', I
would be willing to bet the nomenclature moves in that direction anyway.
'Bits' is just a shorten word for 'millibits' (or microbits, if you
will). It's easier to say and my guess is people would tend to use it
naturally own their own. Kind of like 'bucks' for dollars.

The other synergies are:
-bit is part of the word Bitcoin. The currency unit bit is part of a
whole bitcoin.
-bit symbolically represents the tech nature of the bitcoin.
-bit used to be a unit of money way back when. This largely reclaims it.
-when used as money bit when in references to a precession metal coin.
The name 'bitcoin' references that as well as the mimicking of the gold
standard in the protocol rules.

All around I don't think there is a better fit. I doubt people will get
confused by it. The context it's used in will distinguish it from other
uses of the word.

On 05/03/2014 12:27 PM, Mike Caldwell wrote:



-------------------------------------
On Sun, Feb 09, 2014 at 05:25:41PM +0000, Luke-Jr wrote:

I don't quite see how, There is nothing that 'forces' me to upgrade,
unless I have chosen to run an operating system (MacOS, Windows, Android)
that have automatic don't-ask-the-user update mechanisms.

The bigger problem with 'asset transfer' of assets which do not exist 
soley in the blockchain is including the consensus of relevant local and
distributed legal jurisdictions.

For example, just because the 'colored coin' and blockchain consensus is
that I 'electronically' signed a mortgage document giving some random 
internet company the rights to foreclose on my home does not mean that 
my local county Judge or Sheriff are going to do anything if the internet
company cannot produce the original paper document with ink signature.

The only 'assertion' of central authority here is people who download and
run the code and submit to whatever the code asserts they are supposed to do.

At least with the 'central authority' of the big-business bitcoin developer
cabal I can read the code before I submit to it's central authority, and
this is a significant improvement over amgibuous legislation or proprietary
high-frequency trading algorithms.


-------------------------------------
On 03/12/2014 04:17 AM, Jean-Paul Kogelman wrote:

Are you aware of BIP-0039?

https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki



-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
I'm not convinced that headers first will result in miners hashing on
top of the block with more work without knowing if it's valid yet
instead of just keep hashing on top of the longest known-to-be-valid
chain.
Both options are risky for the miner in some way, and I guess the
probability of someone hashing an invalid block above difficulty is
too low to be the main concern, but there's intermediate solutions,
like say, waiting to validate at least 5% of the block.

But I don't see how miners mining headers first would result in empty
blocks either.
Why wouldn't them validate and include transactions after they have
received the full block?
They will likely know most of the transaction before receiving the block anyway.
In a future where they ONLY live on transaction fees, why would they
refuse to validate and include transactions? What are they hashing for
then?
If anything, looks like a threat to the current situation with huge
mining subsidies coming from the seigniorage, not a problem that you
would have when the the seigniorage is gone.

In any case, it is true that this is mining policy and therefore out
of the realm of what the protocol can regulate, so we should assume
miners will do whatever it's best for them.

The trade-off between tps and centralization remains: if you want
higher tx volume, less full nodes will be able to process it.

On 4/21/14, Tier Nolan <tier.nolan@gmail.com> wrote:


-- 
Jorge Timn

http://freico.in/


-------------------------------------
I could play the game where I say, "You don't understand," and, like you,
not address any of your points.

First, there is no dependence on implementation in my arguments.  If a
system can prevent replay by some set of rules, it necessarily must be able
to answer the question if a message is publishable.  Non publishing proofs
are thus possible and even required.

The argument that proof of audience isn't part of an anti-replay system is
not one I picked up on, but an publicly auditable anti replay system
necessarily must define its audience. Again, not an issue for an auditable
system.
On Dec 21, 2014 9:23 AM, "Peter Todd" <pete@petertodd.org> wrote:

-------------------------------------
What is the procedure for dealing with it? Is it considered abuse to reply
to and quote the entire digest for the sake of a few lines of content? Am I
the only one annoyed by this (if so I'll just shut right up).

Rodney
-------------------------------------


Le 23/04/2014 21:44, Luke-Jr a crit :


To clarify:
Electrum plans to have bip32 accounts; Multibit will not, afaik.

I think Pavol just wanted to make an example.


-------------------------------------
On Fri, 28 Feb 2014 23:26:57 -0800, Wladimir <laanwj@gmail.com> wrote:


Yeah, good point. If you have a cert, we have the CN from the cert, which  
becomes the string displayed as 'Pay To' and alternatively 'Merchant'.

But if there's no cert then all you have is memo.

So the best way to differentiate signed requests is by prominently  
displaying that Merchant string. Really the green part should just be the  
'Pay To' line, the rest is content. If it showed a BLANK 'Pay To' that  
would make the lack of certificate highly apparent.
-------------------------------------
This is probably the best, most complete resource available for those who
don't want to (or don't know how to) wade through the code. Well done.


On 7 July 2014 19:57, JMOlmos GMail <colonizare@gmail.com> wrote:

-------------------------------------
On Wed, Jan 15, 2014 at 04:05:27PM -0800, Jeremy Spilman wrote:

I'm very against the name "reusable addresses" and strongly belive we
should stick with the name stealth addresses.

You gotta look at it from the perspective of a user; lets take standard
pay-to-pubkey-hash addresses: I can tell my wallet to pay one as many
times as I want and everything works just great. I also can enter the
address on blockchain.info's search box, and every transaction related
to the address, and the balance of it, pops up immediately.

What is that telling me? A: Addresses starting with "1" are reusable. B:
Transactions associated with them appear to be public knowledge.

Now I upgrade my wallet software and it says I now have a "reusable"
address. My reaction is "Huh? Normal addresses are reusable, what's
special about this weird reusable address thing that my buddy Bob's
wallet software couldn't pay." I might even try to enter in a "reusable"
address in blockchain.info, which won't work, and I'll just figure
"must be some new unsupported thing" and move on with my life.

On the other hand, suppose my wallet says I now have "stealth address"
support. I'm going to think "Huh, stealth? I guess that means privacy
right? I like privacy." If I try searching for a stealth address on
blockchain.info, when it doesn't work I might think twig on "Oh right!
It said stealth addresses are private, so maybe the transactions are
hidden?" I might also think "Maybe this is like stealth/incognito mode
in my browser? So like, there's no history being kept for others to
see?" Regardless, I'm going to be thinking "well I hear scary stuff
about Bitcoin privacy, and this stealth thing sounds like it's gonna
help, so I should learn more about that"

Finally keep in mind that stealth addresses have had a tonne of very
fast, and very wide reaching PR. The name is in the public conciousness
already, and trying to change it now just because of vague bad
associations is going to throw away the momentum of that good PR and
slow down adoption. Last night I was at the Toronto Bitcoin Meetup and I
based on conversations there with people there, technical and
non-technical, almost everyone had heard about them and almost everyone
seemed to understand the basic idea of why they were a good thing. That
just wouldn't have happened with a name that tried to hide what stealth
addresses were for, and by changing the name now we risk people not
making the connection when wallet software gets upgraded to support
them.

-- 
'peter'[:-1]@petertodd.org
0000000000000001b0e0ae7ef97681ad77188030b6c791aef304947e6f524740
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1



On 9/26/2014 5:16 AM, Matt Whitlock wrote:
This sounds rational - is this already implemented nowadays or *SHOULD
BE* implemented to prevent this attack type in the future?
Meet PCI DSS 3.0 Compliance Requirements with EventLog Analyzer
_______________________________________________

- -- 
s7r
PGP Fingerprint: 7C36 9232 5ABD FB0B 3021 03F1 837F A52C 8126 5B11
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBAgAGBQJUJZPVAAoJEIN/pSyBJlsRfgoIAI4x4qITdCDyYx/I1+z4eGz3
u7zDbVGQEPsUlrgEZLf503TNUIKmEgYQvgQDGEdOQk615XlkrTJeqt5oLh9DVJKj
TaXRqKgBp4iNd6BIIs1gKl0CzmH9sJ7U9ojhTS5aV7ZUhinO0WZlgISYaBZ3t9Kw
t//jb8QNLqISOeotiO9A2jb06UVRf9Gh0FUSBYTJ/st0UvLWt286zT+4XOaeVI/c
9I9nkTsd/jdw1Eorfcd5T8iHBORcdn9g+5+UpuXVq7d3KA5FA6oetzBVHgUfTMjF
q9LAe0W9IUVSiRj+wWvADzlxeUwWjsHnJDxdGihBg/g+k6SfPnOAxEC1UjCH+OU=
=kaIX
-----END PGP SIGNATURE-----


-------------------------------------
I'd be very cautious of security implications of embedding files into
the payment request. Even file formats one would presume safe, such as
images, have had security issues (i.e.
https://technet.microsoft.com/library/security/ms11-006 )

Longer term I was wondering about embedding the PaymentRequest into web
pages directly via the <object> tag, which could eliminate need for
BIP0072 and potentially improve user interface integration that way.
Obviously this would require browser plugins, however.

Ross

On 26/04/14 18:36, Mike Hearn wrote:



-------------------------------------
I think it's mostly a UI issue. The recipient needs to understand that what
he received is nothing more than an IOU that can be revoked at any time. If
the UI makes it clear and the user trusts the sender, no problem. BIP70
would work as before.


On Sat, Mar 22, 2014 at 6:24 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
I'm doing a hard fork, too. In my version 78% of the wealth will go to me,
which I will redistribute on based on personal preferences. Come and join
me into a new and obviously superior system.

More seriously though: the paper is not bad, but I can guarantee you that
Bitcoin will *never* change that drastically. That's the whole point. It
has an indestructible kernel (think DNA). Rather it will do a slow death,
probably in 5-10 years. If you care for PoS than just launch your own.


On Tue, May 20, 2014 at 6:42 PM, Nick Simpson <nick@mynicknet.com> wrote:

-------------------------------------
Here is a summary of current developments in the space of decentralised
2-factor Bitcoin wallets. I figured some people here might find it
interesting.

There has been very nice progress in the last month or two. Decentralised
2FA wallets run on a desktop/laptop and have a (currently always Android)
smartphone app to go with them. Compromise of the wallet requires
compromise of both devices.

Alon Muroch and Chris Pacia have made huge progress on "Bitcoin
Authenticator", their (HD) wallet app. The desktop side runs on
Win/Mac/Linux and the mobile side runs on Android. Sending money from the
desktop triggers a push notification to the mobile side, which presents the
transaction for confirmation. Additionally the desktop wallet has a variety
of other features like OneName integration. It's currently in alpha, but I
suspect it will be quite popular once released due to its focus on UI and
the simple mobile security model. I've tried it out and it worked fine.

https://www.bitcoinauthenticator.org/
https://github.com/cpacia/BitcoinAuthenticator/commits/master    (mobile)
https://github.com/negedzuregal/BitcoinAuthWallet   (desktop)

Bitcoin Authenticator uses P2SH/CHECKMULTISIG to provide the 2-factor
functionality. However, this has various downsides that are well known:
 less support for the address type and larger transactions that waste block
chain space + result in higher fees.

To solve this problem Christopher Mann and Daniel Loebenberger from Uni
Bonn have ported the efficient DSA 2-of-2 signing protocol by MacKenzie and
Reiter to ECDSA, and implemented their own desktop/Android wallet app pair
showing that it works and has good enough performance. This means that P2SH
/ CHECKMULTISIG is no longer required for the two factor auth case, and
thus it's as cheap as using regular addresses.

https://github.com/ChristopherMann/2FactorWallet
https://eprint.iacr.org/2014/629.pdf

Their protocol uses an interesting combination of ECDSA, Paillier
homomorphic encryption and some zero knowledge proofs to build a working
solution for the 2-of-2 case only. Their app bootstraps from a QR code that
includes a TLS public key and IP address of the desktop: the mobile app
then connects to it directly, renders the transaction and performs the
protocol when the user confirms. The protocol is online, so both devices
must be physically present.

Their code is liberally licensed and looks easy to integrate with Alon and
Chris' more user focused work, as both projects are built with Android and
the latest bitcoinj. If someone is interested, merging Christopher/Daniel's
code into the bitcoinj multisig framework would be a useful project, and
would make it easier for wallet devs to benefit from this work. I can write
a design doc to follow if needed.

Currently, neither of these projects implement support for BIP70, so the
screen you see when signing the transaction is hardly user friendly or
secure: you just have to trust that the destination address you're paying
to isn't tampered with. Support for sending a full payment request between
devices is the clear next step once these wallets have obtained a
reasonable user base and are stable.
-------------------------------------
I will drink to that!

Bitte ein Bit! (A Bit please - aka Bitburger Beer)

Mike

Sent from my iPhone



-------------------------------------
The rationale doesn't seem to apply to rule #4, what's so special about
that one?

Although I agree not having to support all of DER is nice, in practice I
think all implementations do and libraries to parse DER are widespread.
Given that the last time we modified tx rules without bumping version
numbers we managed to break the only functioning iPhone client, I've become
a big fan of backwards compatibility: seems the default choice should be to
preserve compatibility over technical niceness until the old versions have
been fully phased out.
-------------------------------------
I was wondering if there would be merit in a kind of BIP for a payment
protocol using multisig?

Currently, setting up a multisig is quite a feat. Users have to exchange
public keys, work out how to get the public keys from their addresses. If
one of the parties are not savvy enough, an malicious party could easily be
setup that was 2 of 3 instead of 2 of 2 where the malicious party generates
the multisig address+script and thus be able to run off with funds anyway.

It's also terribly complex to generate and keep track of. There's been a
nice attempt at creating an browser interface at coinb.in/multisig but it
still lacks the kind of ease with created by the payment protocol. If there
was a BIP then it would go a long way to aiding future usability of
multisig wallet implementations.

What are your thoughts?

Drak
-------------------------------------
Hello,

I had a thought after reading Mike Hearn's blog about it being impossible to 
have an ASIC-proof proof of work algorithm.

Perhaps I'm being dim, but I thought I'd mention my thought anyway.

It strikes me that he's right that it's impossible for any algorithm to exist 
that can't be implemented in an ASIC.  However, that's only because it's 
trying to pick an algorithm that is CPU bound.  You could protect against ASCI 
mining (or rather, make it irrelevant that it was being used) by making the 
algorithm IO-bound rather than CPU-bound.

For example, what if the proof-of-work hash for a block were no longer just 
"hash of block", which contains the hash of the parent block, but instead were 
hash of 

   [NEW_BLOCK] [ALL_PREVIOUS_BLOCKS] [NEW_BLOCK]

[ALL_PREVIOUS_BLOCKS] is now 20GB (from memory) and growing.  By prefixing and 
suffixing the new block, you have to feed every byte of the blockchain through 
the hashing engine (the prefix prevents you caching the intermediate result).  
Whatever bus you're using to feed your high speed hashing engine, it will 
always be faster than the bus -- hence you're now IO-bound, not CPU-bound, and 
any hashing engine will, effectively, be the same.

I'm making the assumption that SHA-256 is not cacheable from the middle 
outwards, so the whole block-chain _has_ to be transferred for every hash.

Apologies in advance if this is a stupid idea.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com



-------------------------------------
Answering today's concerns with yesterday's facts is dangerous,
especially with bitcoin on a 4 years period. I personally consider all
arguments like "we went through once, and nothing special. So no
disturbance worthy of discussion to expect" baseless.
Also, starting a topic with mentions of "death" is not leading to any
useful discussion.

@Topic starters: don't oversell your topic with that kind of
vocabulary hype. "death by halving", seriously?
@Everybody else: don't focus on the chosen vocabulary, or use it to
discard what might be a relevant discussion topic.

The fact that a topic was brought up many times since a long time,
does not mean it is not relevant. It only means it is a recurring
concern. I read no convincing argument against a significant
disturbance of the mining market to come. The fact that it is known in
advance is no counter argument to me.
Environmental conditions will have changed so much, the next halving
occurence might have nothing to do with the previous one, and it
should be perfectly ok to discuss it instead of putting the whole
thing under the carpet.

What is most important to the discussion to me: the main difference
between the last halving and the one to come is the relative weight of
ideology vs. rationality in miners's motivations. Effectively putting
us closer to the original bitcoin premises (miners fully rational).
Miners were close to being 100% individuals last halving, they are now
largely for-profit companies. This isn't a change we can overlook with
pure maths or with previous experience.


Jeremie DL





2014-10-28 21:36 GMT+01:00 Gregory Maxwell <gmaxwell@gmail.com>:

2014-10-28 21:57 GMT+01:00 Alex Mizrahi <alex.mizrahi@gmail.com>:


-------------------------------------
Luke,

Eric Lombrozo is doing work similar to that. You may wish to connect.

He's building a BIP to standardize a multisig application of BIP32.
Like there are xprv and xpubs for single keychains, he is developing a similar construct that would embed all information necessary for a "multisig xpub" (total keychains in system, minimum # of keys required, and which derivation paths on each keychain are to be combined to make the resultant multisig wallet)

The result would be taking an xpub style string and piping it through a BIP32-like algorithm to pop off P2SH addresses in a deterministic order, just like BIP32 pops off standard addresses in deterministic order.

I will ping Eric to connect with you in case the both of you are working on something similar and you can help each other.


Michael Perklin
Bitcoinsultants Inc.

On Thu, Dec 4, 2014 at 7:42 AM, Luke Dashjr <luke@dashjr.org <mailto:luke@dashjr.org>> wrote:
-------------------------------------
On Wednesday 23 Apr 2014 12:07:25 Mike Hearn wrote:

True; the effort of a chargeback is non-zero on credit cards; but that's my 
point: it's non-zero for bitcoin too.


You're still being unfair to bitcoin.  Not everyone who uses bitcoins will 
be dishonest.  The dishonest 5% hashing power is not going to be used in 
100% of any given merchants transactions.  That's all I'm saying.  You're 
original statement that we could end up in a position that bitcoin has a 
higher failure rate than credit cards seems unfair to me.

who were systematically trying to defraud merchants, we'd already be having 
worse security than magstripe credit cards.

"[If] there was a large enough population" -- why are bitcoin users more 
dishonest than credit card users?  Most people are honest, so it seems 
unlikely that that 5% attack surface would be used at 100%; or even 40% 
necessary to equal the 2% chargeback rate with CC.  

I really didn't want to get into an argument over this: all I'm saying is 
that things aren't as bad as you painted them.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
Hi,

On this list there has been some discussion around techniques to speed up
block propagation, with a particular focus on reducing the extra orphan
risk carried by larger blocks.

The current store-and-forward method means that larger blocks will
propagate with higher latency.  One proposed solution has been to broadcast
two separate messages: a fast, fixed-size header message, and a 2nd, slower
body message containing the full block.  Whilst this allows larger blocks
to compete equally with smaller blocks on the "which came first" rule, it
creates a new area of uncertain delay between receiving the header, and
receiving the body, where there may be perverse incentives to mine empty
blocks on top of not-yet-valid headers.

So I would like to propose another method which is hopefully a less
significant change to the existing protocol rules, but should help reduce
the latency gap between large and small blocks.

* Skip the inv/getdata sequence for new blocks - just push them out
directly to save 1 roundtrip per hop
*  When receiving a new block from a peer, as soon as we have the first 80
bytes (header) we can validate the PoW and, with only a low-level change to
the networking code, begin streaming that block to our peers (in the style
of cut-through switching).
* No other rules need to change.  Block primacy can still be determined as
of the moment they are fully validated and accepted, but now the latency
caused by larger blocks is only (1 * BlockSize * BottleneckHopSpeed),
instead of (Sum[n=0 to NumHops](BlockSize * NodeBandwidth(n))).
* As far as I can tell, this shouldn't change any game theory or incentives
because nodes still receive blocks exactly as they do now, just sooner.
 The difference is, invalid blocks that meet the PoW will be broadcast to
everyone, but this is nothing new since someone can peer with you and send
you an invalid block already.  Network DoS should not be a possibility
since it is very expensive to make invalid blocks that meet network PoW.

Thoughts?

Thanks
-------------------------------------
We've coded and tested changes to the Bitcoin testing framework to allow
the creation and processing of blocks in unit test cases in order to
test ProcessBlock(), CheckBlock(), ActivateBestChain(),
ActivateBestChainStep() and ConnectTip(), including block-chain
reorganizations, majority rules, block version changes and more.
Several new test cases were added to enrich the test suite.

Please review and comment the pull request:

https://github.com/bitcoin/bitcoin/pull/4688

Best regards,
 Sergio Demian Lerner & Timo Hanke


-------------------------------------
On Fri, Jun 13, 2014 at 10:12 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:

I was just doing what was always done. In practice, the translations
follow a very different cycle than the rest of the code. Entering
translations as well as reviewing them happens inside Transifex.

Sure, someone could "maliciously change strings". It's typical that
this little bikeshedding topic attracts so much attention.

But if it makes all of you happy I won't do the translation update.

Wladimir


-------------------------------------
On Sat, Sep 13, 2014 at 10:03:20AM -0400, Jeff Garzik wrote:

That's consistent with what everyone else is saying:
https://twitter.com/petertoddbtc/status/509614729879642113


Doesn't seem like there's any evidence of that either. For instance the
archive.org Jan 31st 2009 capture of bitcoin.org with v1.3 has a link to
his PGP key, but the release itself is unsigned:
https://web.archive.org/web/20090131115053/http://bitcoin.org/

Similarly the Nov 29 2009 capture of the sourceforge download directory
has releases v0.1.0, v0.1.2, v0.1.3, and v0.1.5, none of which have
signatures:

https://web.archive.org/web/20091129231630/http://sourceforge.net/projects/bitcoin/files/Bitcoin/

The earliest signature I can find is from v0.3.20 from Gavin Andresen:

https://web.archive.org/web/20110502125522/http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.20/

Earliest sig in the git commit history is the v0.3.21 tag, again from
Gavin.


My best guess is Satoshi only created the PGP key in case
someone needed to send him a security-related bug report. Which leads to
a related question:

Do we have any evidence Satoshi ever even had access to that key? Did he
ever use PGP at all for anything?

-- 
'peter'[:-1]@petertodd.org
00000000000000000ce4f740fb700bb8a9ed859ac96ac9871567a20fca07f76a
-------------------------------------
I just upgraded to Bitcoin 0.9.0 and I got this:

"""
$ ./bitcoind
./bitcoind: /lib/libc.so.6: version `GLIBC_2.15' not found (required by
./bitcoind)
./bitcoind: /lib/libc.so.6: version `GLIBC_2.14' not found (required by
./bitcoind)

$ ./bitcoin-qt
./bitcoin-qt: /lib/libc.so.6: version `GLIBC_2.15' not found (required
by ./bitcoin-qt)
./bitcoin-qt: /lib/libc.so.6: version `GLIBC_2.14' not found (required
by ./bitcoin-qt)
"""

Sniff.

Red Hat Enterprise Linux uses glibc 2.12.

-- 
Jess Cea Avin                         _/_/      _/_/_/        _/_/_/
jcea@jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/
Twitter: @jcea                        _/_/    _/_/          _/_/_/_/_/
jabber / xmpp:jcea@jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/
"Things are not so easy"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/
"My name is Dump, Core Dump"   _/_/_/        _/_/_/      _/_/  _/_/
"El amor es poner tu felicidad en la felicidad de otro" - Leibniz

-------------------------------------
On Sun, Dec 21, 2014 at 06:10:47PM +0000, Adam Back wrote:

Introducing a bunch of clever ECDSA math doesn't change the fact that
the clever math isn't what is preventing double-spending, clever
economics is. Just like Bitcoin itself.

No sense getting people potentially confused by a bunch of complex
equations that aren't relevant to the more fundemental and much more
important principle that math alone can't prevent double-spending.

-- 
'peter'[:-1]@petertodd.org
00000000000000001bc21486eb6e305efc085daa6b9acd37305feba64327342e
-------------------------------------
On 4/23/2014 3:55 AM, Mike Hearn wrote:
I have some questions:
1.  How can we work towards solving the double-spending problem?
2.  Is it possible to "scan" for double-spending and correct it?
3.  Is the network at large not secure enough?


-- 
Kevin

-------------------------------------
Another idea: Integrate torrent download of bootstrap.dat into bitcoind.
Normal user (especially a beginner) won't learn how to download bootstrap
separately and import it into bitcoind; he simply give up the
synchronization once he realize it takes too much time. From my experience
downloading the bootstrap significantly improves catching the blockchain,
which may attract some more users to run bitcoind.

Not sure about C++, but simple torrent client in python is like 30 lines of
code (using libtorrent).

Marek


On Wed, Apr 9, 2014 at 10:12 PM, slush <slush@centrum.cz> wrote:

-------------------------------------
On Mon, Nov 17, 2014 at 11:43 AM, Flavien Charlon <
flavien.charlon@coinprism.com> wrote:


While I am not opposing the proposal, I am not sure about your statistics
because while Counterparty is not currently using OP_RETURN encoding, you
should factor in the number of CP transactions that would have been
OP_RETURNs if they had been permitted (100,000 since inception according
their blog[1] with monthly charts at their block explorer[2]).

Refs:
[1]
http://counterparty.io/news/celebrating-100000-transaction-on-the-counterparty-network/
[2] http://blockscan.com/
-------------------------------------

No.
Different approaches have different trade-offs, and thus different areas of
applicability.

Proof-of-work's inherent disadvantage is that it takes some time until
transaction becomes practically irreversible. On the other hand, it has
advantages like neutrality, censorship-resistance, high degree of security,
etc.

TTP can be very efficient, but doesn't have advantages mentioned above.

It is possible to combine several different approaches into one hybrid
systems. For example, classic Bitcoin PoW blockchain can be used for
settlements, large transactions, savings and so on. While TTP-based payment
system will be used for small-value transaction like buying coffee.

In this case you get benefits of both approaches. Censorship-resistance is
irrelevant when one buys a cup of coffee with his pocket money, isn't it?

For some reason, instead of considering these hybrid solutions (which can
also address scalability problems), you want to make PoW-based system more
complex to be applicable for real-time transaction too.

This will, likely, weaken advantages provided by PoW, and also it won't
provide any hard guarantees, and, if implemented, will undermine
development of alternative solutions.
-------------------------------------
I believe tx have to be ordered sequentially within a block. Also
since a tx is referenced by it's hash, it's practically impossible to
make a self referential tx.

Aaron Voisine
breadwallet.com


On Sun, Jul 13, 2014 at 4:32 PM, Richard Moore <me@ricmoo.com> wrote:


-------------------------------------
tl;dr;

It is dangerous to expect that other seed than "xprv" does not contain
bitcoins or that "xprv" contains only bitcoins, because technically are
both situations possible. It is still safer to do the lookup; the magic
itself is ambiguous.

Marek

On Tue, Apr 8, 2014 at 3:40 PM, slush <slush@centrum.cz> wrote:

-------------------------------------
Hello,

This Friday I tagged 0.9.2rc2, with the following changes compared to 0.9.2rc1:

- #4282: cwallet init fix
- #4295: upgrade OpenSSL to 1.0.1h
- #4261: Use pnode->nLastRecv as sync score

We still need more gitian builds - I'd like to do the 0.9.2 final
release end of this week as I haven't seen any new problems reported,
but it'd be useful to get these last-minute fixes tested too.

Wladimir


-------------------------------------
I'm pretty sure that all the side effects of assertions have been removed
before 0.9.0.

However, the assertion checks are extremely important to the proper sanity
of the client and network, so IMHO it's fair to still require building with
them enabled.

Wladimir
-------------------------------------
Im afraid this is a highly simplistic view of the costs of running a full node.

My node consumes fantastic amounts of data traffic, which is a real cost.

In the 30 days ending Apri 6, my node:

* Received 36.8 gb of data
* Sent 456.5 gb data

At my geographic service location (Singapore), this cost about $90 last month for bandwidth alone. It would be slightly cheaper if I was hosted in the US of course.

But anyone can understand that moving a half-terrabyte of data around in a month will not be cheap.


On Apr 7, 2014, at 8:53 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:


-------------------------------------
On Wed, Apr 23, 2014 at 7:42 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:
...Except that you're loosing flexibility (serialization, deserialization)
which gives you BIP32 node.

I see "bip32 seed" as some transitional, internal state from raw entropy to
bip32 master node and this seed should not be handled by the end user in
any form. In the oposite, well-serialized bip32 node (in xpriv, or even in
mnemonic format) can be used very widely and have no downsides against
using raw "bip32 seed".


I also don't care too much about altcoins, but people want them so me, as
infrastructure developer, need to think about it. And I don't see any
reason for breaking compatibility between Bitcoin and other altcoins. I
would be happier if there will be another sentence than "Bitcoin seed", but
honestly, who cares. It is just some magic string for hashing the raw
seed...



The truth is that even existing software which handle bip32 don't care
about 'version' at all. I think that "xpub/xprv" distinction is the only
useful feature of version, so user se if it stores public or private
information.

But using prefixes which doesn't enforce anything is even more dangerous.
If somebody exports node "dogeblablabla", it creates false exceptations
that there's only dogecoin stored.

 Marek
-------------------------------------
You have plenty of good points, but they are not relevant to this mailing list. I suggest you take them elsewhere.
--
Jameson Lopp
Software Engineer
Bronto Software, Inc

On 02/10/2014 01:25 PM, Troy Benjegerdes wrote:


-------------------------------------
On Wednesday, April 23, 2014 8:43:57 PM Pavol Rusnak wrote:

Then BIP 64 is pretty restrictive. Most end users really have no need for 
subwallet support.


-------------------------------------
This will easily create too much data in the block chain.
I think it's probably better to trust online wallets to handle complex
financial transactions such a debits or credits.
If Bitcoin achieves Visa-levels of popularity, that would mean one megabyte
of transactions per second (even assuming script isn't used), or ~30
terabytes per year. After a decade the Bitcoin blockchain can only be
stored by Amazon or Google or the Web Archive, even assuming Kryder's Law
continues.
If the Bitcoin blockchain instead becomes cheque clearinghouse style
transaction system, many problems involving blockchain growth become
negligible.
Sure, this is supposed to be a trustless system, but there's a reason why
everyone relies on trust in the real world.


On Tue, Jan 28, 2014 at 7:13 PM, <
bitcoin-development-request@lists.sourceforge.net> wrote:

-------------------------------------
Hello all,

it was something I planned to do since a long time, but with the
recent related issues popping up, I finally got around to writing a
BIP about how we can get rid of transaction malleability over time.

The proposed document is here: https://gist.github.com/sipa/8907691

I expect most rules to not be controversial. Maybe rules 1 and 3, as
they require modifications to wallet software (Bitcoin Core 0.9 and
BitcoinJ already implement it, though) and potentially invalidate some
script functionality. However, these new rules remain optional and
controlled by an nVersion increase.

Comments please!

-- 
Pieter


-------------------------------------
Isodor: Rational Miner will include burn transaction for fee, no doubt. Censoring transactions is against Bitcoins core values, unlikely to get wide support for any form of that.

Patrick: Mining is at cost even if following the rules. No change to that.

Tamas Blummer
Bits of Proof
-------------------------------------
I think not all alts (will) have magic numbers, at least not those defined e.g. with colored coins on top of an other chain.

Also note that the index should have MSB cleared as it would otherwise indicate private derivation. 

Regards,

Tamas Blummer
http://bitsofproof.com

On 27.03.2014, at 16:57, Allen Piscitello <allen.piscitello@gmail.com> wrote:


-------------------------------------
"I suggest that Bitcoin Core should generate a public/private key pair and
share the public one with peers."

I've not read the p2p protocol of Bitcoin core, but I suppose the initial
handshake between 2 peers would be the ideal place to exchange a public
keys.

would it make sense to generate a new random pair of keys per each peer you
connect to?
then each subsequent message to every peer gets encrypted differently,
keeping each conversation isolated from each other encryption-speaking.

These keys would have nothing to do with your wallet, they're just to
encrypt any further communication between peers post-handshake. Would that
be of any use to "This could provide privacy and integrity but not
autentication."?

http://twitter.com/gubatron


On Tue, Aug 19, 2014 at 12:38 PM, Gregory Maxwell <gmaxwell@gmail.com>
wrote:

-------------------------------------
I believe that the Payment Protocol works that way, the merchant broadcast
the Tx.
El 10/06/2014 13:23, "Chris D'Costa" <chrisjdcosta@gmail.com> escribió:

-------------------------------------
It would make more sense to introduce a new script opcode that pushes the current block height onto the operand stack. Then you could implement arbitrary logic about which blocks the transaction can be valid in. This would require that the client revalidate all transactions in its mempool (really, only those making use of this opcode) whenever the chain tip changes.


On Thursday, 31 July 2014, at 5:58 pm, Kaz Wesley wrote:


-------------------------------------
Big picture/mid-term I think air-gaps and zero-trust ecosystem components
are the only solution.  (zero-trust meaning like real-time auditability, or
type 2/type 3 exchanges based on atomic-swap, trustless escrow etc).

Need a mass-production and air-drop of trezors :)

There is one more problem address-substitution via untrusted network/user
and weak site with 1mil lines of swiss-cheese security app-store.  So some
kind of address authentication TOFU.  Aside from X509 bloatware which could
be extended from payment protocol to do that, I'd argue for a native simple
TOFU format like Alan Reiner's multiplier * base approach (where base is the
TOFU handle).  And/or something like the IBE address proposal (which gives a
bandwidth efficiently SPV queryable way to check if funds received).  Worst
case if weil-pairing gets broken it auto-devolves to the current status
quo.

Btw not to reignite the stealth vs reusable address bike shedding, but
contrarily I was thinking it maybe actually better to try to rebrand address
as "invoice number".  People understand double paying an invoice is not a
good idea.  And if they receive the same invoice twice they'll query it.

Adam

On Wed, Apr 16, 2014 at 11:41:48AM +0200, Wladimir wrote:





-------------------------------------
On Thu, Feb 20, 2014 at 6:08 AM, Mike Hearn <mike@plan99.net> wrote:

You mean P2SH... which your implementation has only picked up support
for in the last month or so?


-------------------------------------

On 25/04/14 20:17, Mike Hearn wrote:

My argument does not concern what a bitcoin means, just what data in the
blockchain means. People are free to value an individual bitcoin however
they like. But it's useful if we all agree on a standard that defines
who owns them - ie. the protocol as described in Satoshi's whitepaper. I
recognise that your ability to provide a valid scriptSig for /any
existing UTXO in the blockchain/ as proof of your ownership of the
corresponding bitcoin. You want to pick and choose which UTXO (well,
coinbase; same diff) you consider valid and spendable /after they've
become part of the blockchain/, regardless of the fact they're buried
under PoW.

As an illustration, consider Counterparty - an altcoin whose TXns are
embedded as unvalidated data in the bitcoin blockchain. A lot of people
imagine that an XCP transaction buried under 100 blocks and a BTC
transaction buried under the same 100 blocks are equally secure. You
tell me: are they? It's the same PoW chain after all.

Hell no they're not! The way Counterparty interprets that data in the
blockchain is anything but stable or well documented. On more than one
occasion they've gone "whoops, found a bug that caused some transactions
to occur that we don't consider valid - we'll just fix that." A suddenly
the reference client doesn't consider the XCP in your wallet valid
anymore - they just magically disappear - because the parent of the TXn
that paid you was actually invalid. Nobody rewrote history via PoW; they
simply tweaked their interpretation of the existing history.

When you have a *bitcoin* TXn buried under 100 blocks you can be damn
sure that money is yours - but only because the rules for interpreting
data in the blockchain are publicly documented and (hopefully)
immutable. If they're mutable then the PoW alone gives me no confidence
that the money is really mine, and we're left with a much less useful
system. This should be more sacred than the 21m limit.






-------------------------------------
On 4/24/14, Mike Hearn <mike@plan99.net> wrote:

This solves regular double-spends, not Finney attacks, but finney
attacks (which are not really the easiest attacks in the world) don't
get any worse.

On 4/24/14, Chris Pacia <ctpacia@gmail.com> wrote:

This scheme wouldn't be mandatory. You can still wait for
confirmations or rely somehow on existing trust instead if that's
better for you on that situation.


Sybil attacks aside, Alice can't save anything, period. If she tries
she will end up losing it all.
I don't see how signing a longer term contract protects her in any way.


They would do that to avoid having to wait for a confirmation or two
(I think one is good enough for most small purchases) when being paid
by people they don't trust just before they leave.
Maybe they prefer to just make people wait if they think that will
make them pay up-front.
This is completely optional and only an improvement on the current situation.

Of course if we're not comparing this with Bitcoin today and we're
comparing it to some theoretical mechanism for instant p2p
serialization without requiring proof of work then, yes, this concept
is not very interesting.


-------------------------------------

If it's explicit, I think it's a non starter and nobody will bother with
it, especially not just for instant payments.

If it's just a case of "link your wallet with your Facebook account" and
requires no more effort than that, some people might, but of course the
user experience would be rather random. Hey why did that guy in front of me
get instant payments and I had to confirm even though we bought the same
things?

I'm not a big fan of UX's that appear totally random to the user.
-------------------------------------
On Fri, Apr 11, 2014 at 5:54 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:


If each "block" is really 512 blocks in sequence, then each "slot" is more
likely to be hit.  It effectively reduces the number of blocks by the
minimum run lengths.

ECC seemed cooler though.



Interesting too.


That's true.  Scaling up the transactions per second increases the chance
of data lost.

With side/tree chains, the odds of data loss in the less important chains
increases (though they are by definition lower value chains)
-------------------------------------
Seems like a nice idea.


On 24 June 2014 14:27, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
With Java, in theory, you can use SSLSocketFactory.createSocket(btsocket,
address, 1234, true) to wrap a bluetooth socket in SSL. However I have not
tried it.

For now, just prototype and build your product without the security. We can
find someone to experiment with this, if you don't want to .

Bluetooth needs encryption and MACs as well as signing to be secure,
because there could be radio MITM. Yes, this overlaps somewhat with the PKI
signing in BIP70, but not entirely - you might want to serve unsigned
payment requests, but still have confidentiality and authenticity for a
local face to face transaction. The signing and encryption does different
things.


On Thu, Mar 20, 2014 at 7:20 PM, Alex Kotenko <alexykot@gmail.com> wrote:

-------------------------------------
I think this is the only project where people are concerened wether commit
messages are signed or not.

Commit messages should be merged only upon their correctness, not their
signature.

I could care less if I receive a buggy patch that's signed.

http://twitter.com/gubatron


On Sat, Aug 23, 2014 at 2:17 AM, Troy Benjegerdes <hozer@hozed.org> wrote:

-------------------------------------
On Wednesday, April 23, 2014 8:35:50 PM Pavol Rusnak wrote:

It is. Accounts have been a bitcoind feature since before 0.4.


I don't see how. The user knows he has money in different subwallets. As long 
as he has a way to specify which subwallet he is accessing in single-subwallet 
clients, there shouldn't be a problem.

Luke


-------------------------------------
On Saturday, 29 March 2014, at 1:52 pm, Alan Reiner wrote:

For what it's worth, ssss also omits from the shares any information about the threshold. It will happily return a garbage secret if too few shares are combined. (And actually, it will happily return a garbage secret if too *many* shares are combined, too. My implementation does not have that problem.)


-------------------------------------
On Fri, Jun 13, 2014 at 3:24 PM, xor <xor@freenetproject.org> wrote:

As a general principle, I agree.  Other projects have translation
freeze points to address this.  Although it is a small holistic risk,
in theory, someone could maliciously change strings at the last minute
in a language maintainers don't know well.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Please see also the following:

https://cpunks.org//pipermail/cypherpunks/2014-November/005971.html

Respect,

- -Odinn

Jeff Garzik:
Download BIRT iHub F-Type - The Free Enterprise-Grade BIRT Server
_______________________________________________
Download BIRT iHub F-Type - The Free Enterprise-Grade BIRT Server

- -- 
http://abis.io ~
"a protocol concept to enable decentralization
and expansion of a giving economy, and a new social good"
https://keybase.io/odinn
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUdgpQAAoJEGxwq/inSG8CBCMIAI8IyyzxbhC0NVY8wyLXaHnW
um0HkmrP0bknL0ugjXDXHIBJmadH9uwOT5g1WpJ1siJbjm7nTNn2EXui8EKaX133
SkdZu0IVV5wDZB0OnIDxxx4cyuwNBWbxLh0boVCzydUlZaxQCx88SriKLNj4NrAT
oPBuOSL9Z/EsscO8PIh73+t7rdsAQo7koFcwVB8OgjKKATZpAgu4/hwBDoSnhv/U
F/X1EcQifg5j2DPmPmJo2/u9PmfHjgDUevw7qJOYNDFMPq4zhi6IC+x2aAXZg0rk
jHF79loJ5vueMaU6APVcIQ4izbyzU0y0JaY4Rukq0YkuXCMgZB8BJlS/BPntZdY=
=K2tn
-----END PGP SIGNATURE-----


-------------------------------------
I was talking about a DOS attack in
https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only applicable
to entitys doing the tracking with txids).

Amazing how I did not get a response from any of the devs (except Greg's
response
https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789 but
that too was short and not concerning the attack scenario plausibiity as I
replied to him).

Today they are apparently at work here
https://github.com/bitcoin/bitcoin/pull/3651

Amazing how nobody acknowledges it until later when the attack already
happens. The devs need to show some greater level of responsibility.

Don't get me wrong - I am not trying to claim credit for the attack scheme
described (though I do not know of any other place where this was mentioned
earlier as an attack scheme), but I am trying to make the point that people
should just be around and at least make others feel that their concerns are
being read. Now putting this on some place like reddit will only give the
community a bad name.

On a lighter note I messaged some of the devs (as my previous mail says)
saying the attack should be called "thenoblebot" attack (after my handle,
which would inspire me to pursue crypto studies further). It was meant to
be a lame joke. But I had no idea how it would start causing so much
disruption in the ecosystem.

Regards
thenoblebot


On Tue, Feb 11, 2014 at 2:03 AM, Vocatus Gate <vocatus.gate@gmail.com>wrote:

-------------------------------------
On 4/17/14, Gavin Andresen <gavinandresen@gmail.com> wrote:

There's no difference, the -timedtest mode does exactly that. But
automatically instead of having to manually ask for a new block every
second.
I assume your position is that the difference is too small to justify
a new mode, or that you just don't see any value in it.

The -private mode, on the other hand, would allow you to simulate
proof of work attacks as described in the previous post, but maybe
there's a simpler way to do the same solely using regtest/timedtest.

Maybe I should have asked the following questions before proposing anything:

1) How does someone simulate a pow race situation without doing any
pow right now?
Does anybody try these things? How?

2) If I wanted to measure validation performance, to get the number of
peak tps that could be processed without taking block sides or network
latency into account, how would I do that? Has anybody tried this
before?


-------------------------------------
On Mon, Feb 10, 2014 at 11:47 AM, Oliver Egginger <bitcoin@olivere.de> wrote:

At this point the attack should fail. Before crediting the funds back Gox
should form a new transaction moving at least one of the coins the prior
transaction was spending and wait for that transaction to confirm.

Without performing this step— even if there were no malleability at all
you'd have the risk that someone would go resurrect the old transaction
and get a miner to mine it. Then it goes through.

With performing it, even if they missed the mutated transaction in the chain
their cancellation transaction could not confirm (because its a double spend).


Back in September a lot of people were having stuck transactions and
when I looked it was because Mtgox was spending immature coins: newly
generated coins which cannot be spent for 100 blocks since their creation.
(A rule since Bitcoin's started)

Then later it was noticed that they were producing transactions with invalid
DER encodings (excessively padded signatures). The Bitcoin network used
to accept these transactions, but in order to more towards eliminating
malleability
Bitcoin 0.8 and later will not relay and mine them.

Then after people started using mutation to fix those excessively padded
transactions and/or someone was exploiting Gox's behavior— it seems that
Gox's wallet may have been in a state where it thought a lot of coins weren't
spent that were and was reusing them in new transansactions... this one
is harder to tell externally— I saw it appeared to be producing a LOT of
double spends with different destinations, but I'm guessing as to the exact
cause.


-------------------------------------
On 01/18/2014 03:05 AM, Wladimir wrote:

https://github.com/bitcoin/bitcoin/pull/1647


-------------------------------------
The process described in BIP70 might be ok for a simple "happy path" 
scenario, but what if things don't work so smoothly. I'm not talking 
here about technical issues, but _very common_ business scenarios such as:

e.g. Merchant cancels request before payment is sent, such as when:-
- the merchant realizes that they charged the wrong amount
- the merchant realizes that they send the payment request to the wrong 
customer
...

e.g. the Merchant or Customer decides to cancel the transaction after 
the payment request is sent because:-
- the customer decides to pay by some other mechanism like cash or 
credit/debit
- the customer doesn't have sufficient funds and decides not to purchase
- the customer changes their mind and decides not to purchase
...

It strikes me that a "Cancel Payment Request" message is required
and a "Reject Payment Request" may also be required (or maybe use the 
same message for both).

Tim Tuxworth


-------------------------------------
On Wed, Aug 20, 2014 at 08:24:33AM +0200, Wladimir wrote:

http://bitspjoule.org/hg/upstream/bitcoin

I guess I should update it more than every 6 months and then the updates
won't take so long. It would also go a lot faster if I had a couple of 
dedicated servers, but that won't happen until I sell someone a support
contract for crypto-commodities trading. I figure a bitcoin a month should
support the hardware, 24x7 monitoring, and maybe a couple of full nodes
running on the servers as well.

And to pick up from another comment on this thread if you don't understand
some of the differences between git and mercurial, or how to set up servers
that pull from git and mirror to mercurial, you will have a lot harder time
tracking down and removing malicous code that could get injected if someone
gets root on a Github server.

It is also a very usefull excercise in distributed systems design to 
understand how distributed revision control systems in theory converge to a
coherent global state, and what is similiar or different to Bitcoin's 
global consensus model of what the balance of every bitcoin address is.



-------------------------------------
On Saturday, 29 March 2014, at 2:08 pm, Alan Reiner wrote:

Okay, you've convinced me. However, it looks like the consensus here is that my BIP is unneeded, so I'm not sure it would be worth the effort for me to improve it with your suggestions.


-------------------------------------
On Sat, Oct 4, 2014 at 8:58 AM, Mike Hearn <mike@plan99.net> wrote:


That is easy to change; I'll submit a pull request. It is a good idea to
get an -alertnotify sooner rather than later for EITHER a hard fork or a
soft-fork. Better to be told you have to upgrade while the block.version is
on its way to being a super-majority than after you are either hard-forked
off the main chain (or soft-forked).

I don't have any opinion on the hard- versus soft- fork debate. I think
either can work.

-- 
--
Gavin Andresen
-------------------------------------
On Mon, Oct 13, 2014 at 07:34:16PM -0700, Pieter Wuille wrote:

I noticed this awhile back myself. More interestingly, I remember
noticing some non-std scripts on mainnet that had opcodes that appeared
to be attempts to solve this issue with variations of the following:

    DUP
    IF
        1 EQUALVERIFY
        <do stuff>
    ELSE
        0 EQUALVERIFY
        <do stuff>
    ENDIF

I'll have to admit, I decided to keep quiet about it because it's a good
example of how relying on BIP62 for specialty contract applications that
absolutely need to avoid malleability for security reasons is a dubious
idea; it's hard to be sure that we've really gotten every relevant case
correct.

I think a decent argument *for* doing this is that if a script author
fails to properly 'bool-ize' every boolean-using path that can have
non-minimal encodings in normal execution, you can always create a
nVersion=1 transaction manually to spend the output, preventing funds
from getting lost. Meanwhile in the general case of a compenent script
author having the canonical bool testing in every boolean-using opcode
saves a lot of bytes.

-- 
'peter'[:-1]@petertodd.org
0000000000000000147fe2005d7d4490938a7ab96901b8256dcd9d4eac78cb8c
-------------------------------------
I'm just repeating the rationale Gavin gave me for adding this to the spec
last year when he was implementing it. Perhaps it only applied to some
versions of PHP or something like that.

Jeremy, good comments. A pull request to fix those would be good.

One issue I seem looming on the horizon is that we'll need a version of the
payment protocol document that's living. Trying to reverse engineer the
current spec by manually reading all the BIPs and layering them in your
head is a non starter.




On Sun, Mar 2, 2014 at 9:52 AM, Drak <drak@zikula.org> wrote:

-------------------------------------
On Tue, Jun 17, 2014 at 9:40 PM, Gavin Andresen
<gavin@bitcoinfoundation.org> wrote:

Agreed!


Soungs good to me - to lift the restrictions and increase flexibility,
but also to be a careful and keep the DoS limits.


That's of course completely separate. As we all know, most wallet
innovation doesn't happen in the reference implementation wallet, and
it should not be used as the guide here.

Wladimir


-------------------------------------
On Wed, May 7, 2014 at 9:57 PM, Jameson Lopp <jameson.lopp@gmail.com> wrote:

Depends on just how much stuff it is. The idea is primarily to have an
installer for running a (wallet-less) node as an OS background
service.

Having some statistics available would be worth some extra download
size, otherwise it would be pretty much invisible.

We'd already decided that we would need something like Python for the
stats service. Implementing things like web services in C++ is just
not realistic given the time constraints and the great already-written
code that is out there. As an optional tool it should be external, not
part of bitcoind itself.

I suppose the chart rendering happens client-side? In that case the
web service just has to collect and provide the data, and serve static
html/js files.

Wladimir


-------------------------------------

On 27/04/2014 02:05 p.m., Mark Friedenbach wrote:
The problem is not having or not access to a honest full node. The SPV
client MUST have access to a honest full node sometime.
The problem is WHEN. One can make the security assumption that during an
attack (someone gives you a fake block) you also loose the possibility
to reach any honest node. Then SPV proofs come into play.

Here are the security assumptions I added to my post about SmartSPV to
clarify this:

*Security Assumptions
*

First lets review the main security assumption of headers-only SPV:

  * The attacker does not control all your communications with the
    payment network.

This means that there is at least a single connected peer that behaves
honestly. This assumption is quite strong and may not hold during short
periods of time, such as during application power-on (when only a few
peers have been connected), or when moving to a place where the ISP is
untrusted. For SmartSPV well require weaker security assumptions:

  * The attacker cannot control all your communications with the payment
    network for more than a fixed period of time (e.g. 2016 blocks for
    Bitcoin or approximately 15 days)
  * The attacker is rational: it wont spend an huge amount of money to
    steal a much smaller amount.

This assumptions imply that the attacker may control all your Internet
connections while he sends you a malicious block branch containing a
fake payment to you.


Since in my use case (SmartSPV) I proposed you start from the most
recent block and go backwards, the attacker must compete in PoW with the
real current difficulty informed.
Suppose the SPV client looks for 6-block chains backwards starting from
the last current block. Suppose you know or estimate the current network
difficulty. Suppose a malicious peer creates a fake 6-block chain Cm and
the honest peer gives you the 6-block chain Ch. If Ch has not the
expected work it's discarded. If both has the expected work, then you
better not true any of them and walk their parents until you find a
common parent. That's the block you should trust. If you don't have an
honest node connected, then the only decide to trust or not Cm is by
it's accumulated work (and you have already a bound for it)


So you agree that:  you need a periodic connection to a honest node, but
during an attack you may loose that connection. This is the assumption
we should be working on, and my use case (described in
http://bitslog.wordpress.com/2014/04/25/smartspv-a-better-simplified-payment-verification-for-smartphones/)
assumes that.

-------------------------------------

You've got a major social engineering problem here. 

1) who is marketing privacy 
2) how do you validate 'privacy providers' 

Just like all the scamcoins, there will be scamprivacy providers, which will
drive the market price of privacy down to zero.

Who's paying the network/development/bandwidth/etc cost for privacy?

I'd guess 85% of real users don't really care about some abstract 'privacy'
ideal, they just want payments to work and to download cat pictures.

If you say 'regular address re-use is deprecated, and the top 1% in bitcoin
weatlh who own 95% of the miners want privacy', well fine. But you just 
opened yourself up to 'OccupyBitcoin', and an altcoin that ENCOURAGES plain
old regular address re-use and transparency.

Does this stuff still work if regular address re-use is a transparency feature
and not a bug?


-------------------------------------
On Mon, Apr 7, 2014 at 6:46 PM, Matt Whitlock <bip@mattwhitlock.name> wrote:

Yes thats only a decode but the same process (long division with
manual carries) works just fine the other way. There is absolutely no
need to use big integers for this.


-------------------------------------
Would it make sense to pull that stuff in and add Peter with commit access
since your repo is top of the fork tree.

Drak


On 15 March 2014 16:47, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
Keep in mind that links don't always come embedded in html. Think of native
mobile apps.



On Sat, Apr 26, 2014 at 10:43 AM, Ross Nicoll <jrn@jrn.me.uk> wrote:

-------------------------------------
quote:

Well, as soon as miners learn about the merits of controlling the
blocks' contents, this issue may get solved by the market pressure
of miners expecting this kind of service from their pool.

I mean, the dev community constantly has some level of disagreement
about the best policies for what to include in blocks. But seen from
the perspective of some Bitcoin business or another, certain policies
might be more preferable. So if miners start to understand that they
could take a stake for their favourite Bitcoin businesses by choosing
a mining pool which employs a preferable transaction inclusion policy,
the question would not anymore be "which pool gives me the most
Bitcoins or the lowest variance, regardless of the technical
background", but "which pools does the best for my Bitcoin economy
needs". And this may be a very economically driven decision by itself,
considering that the exchange rates for Bitcoins depend on Bitcoin
businesses doing well.

If we get to this point with respect to user (miner) education, then
it is probably only a matter of time until people start to find it
cumbersome to mine on a black-box pool and having to manually verify
that they still have an agreeable transaction inclusion policy, when
they can just mine on a GBT pool and configure things in their mining
software.

[...]

Bear with me, but this piece of rhetorics struck me. Why even mention
those who think it's not harmful, when your next sentence states
that their opinion should be ignored completely?

Best regards,

Isidor
-------------------------------------
On Fri, Sep 12, 2014 at 6:35 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

I've made another change in the PR, as language about strictly only
compressed or uncompressed public keys was missing; please have a
look.

-- 
Pieter


-------------------------------------
Let's suppose I have an alternate blockchain that specifically encourages
address *RE* use, and charges those that desire privacy higher transaction
fees to cover the network cost in computation and storage.

Does the static address privacy system still work, or does it fall apart
because 95% of the transactions re-use addresses, making them 'effectively 
static', just like my DHCP IP that has not changed as long as I've used it?


On Wed, Jan 15, 2014 at 03:44:17PM -0500, Jeff Garzik wrote:



-------------------------------------
On Sun, Oct 19, 2014 at 9:17 AM, xor <xor@freenetproject.org> wrote:


The problem is not one of traffic, but of confusion of concerns, and of focus.

That specific questions about Bitcoin Core are being asked, for
example about watch-only functionality, in the same list where changes
to the entire system (BIPs) should be decided on doesn't make sense.

This has in practice caused some developers of alternative clients to
not subscribe to this list, even though they *should* follow BIP
discussion otherwise it makes no sense to have a process in the first
place.

Wladimir


-------------------------------------
I saw in the math version you had said Q'=Q+H(S) and I presumed it was a
typo, but your code says the same thing.  I presume you meant Q'=Q+H(S)*G
and therefore that Util.SingleSHA256() multiplies by G internally?

Adam



-------------------------------------

Bitcoin's competition is not some theoretical perfect p2p system but
rather, bank notes and credit cards.
-------------------------------------
On 09/28/2014 10:35 PM, Peter Todd wrote:

Can't this be solved with a single update to the address format,
allowing a tx version number to be part of the address serialization? 
Then the sending software will apply that version to the payment tx.   
Of course, I'm not sure if allowing nodes to create transactions with
version numbers outside of their programming is safe.  It seems like it
should be since we're talking about soft forks anyway, but there's
probably some subtleties I'm overlooking.



-------------------------------------
How about a prize for anyone who can spot any "malicious" strings within next hour?

;-)



-------------------------------------
On Fri, Jun 06, 2014 at 09:58:19AM -0700, Gregory Maxwell wrote:

Again, you *don't* have to use brute-force prefix selection. You can
just as easily give your peer multiple prefixes, each of which
corresponds at least one address in your wallet with some false positive
rate. I explained all this in detail in my original blockchain data
privacy writeup months ago.

-- 
'peter'[:-1]@petertodd.org
000000000000000029d945c3832c7f4afabce11e6cb1c27b6f5e8c0f2bbb356c
-------------------------------------
On Sun, Jul 27, 2014 at 7:40 PM, Peter Todd <pete@petertodd.org> wrote:

Or its a complete snipe hunt, I'm unable to find any nodes with it
connected to them. Does anyone here have any?

Last discussion on the measures for anti-global-resource-consumption
was at https://bitcointalk.org/index.php?topic=310323.0  but it hasn't
seemed to be a huge issue such that adding more protocol surface area
was justified.


-------------------------------------
You give them a hard to interpret thing like mBTC and then wonder why
they rather look at local currency. Because the choices you gave them are bad.

I think Bitcoin would have a better chance to be percieved as a currency
of its own if it had prices and fractions like currencies do. 

3.558 mBTC or 0.003578 BTC will never be as accepted as 3558 bits would be.


Tamas Blummer
Bits of Proof

On 14.03.2014, at 15:05, Andreas Schildbach <andreas@schildbach.de> wrote:


-------------------------------------
On Sat, Mar 29, 2014 at 10:38 AM, Matt Whitlock <bip@mattwhitlock.name> wrote:

Yes.

No.


Yes.

But see the first question.  Basically you can do an interactive step
to generate a master pubkey and then use BIP32 non-hardened derivation
to build thresholded children.

On Sat, Mar 29, 2014 at 10:42 AM, Matt Whitlock <bip@mattwhitlock.name> wrote:

BIP38 is a bad example (because it was created without public
discussion due to a technical snafu).

In this case I don't see anything wrong with specifying secret
sharing, but I think— if possible— it should be carefully constructed
so that the same polynomials and interpolation code can be used for
threshold signatures (when encoding compatible data).

If it requires entirely different code than the code for threshold
signing it might as well be a file generic tool like SSSS.


-------------------------------------
On 04/23/2014 11:42 PM, Pieter Wuille wrote:

Right. See my previous email where I describe hypothetical creation of
BIP65 and BIP66 which the exact thing you describe.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
That piece of horse equipment is called a bit in the US too.  But the point
stands: most people don't use "bit" on a daily basis other than referring to
"a little bit of <something>."

-----Original Message-----
From: Wladimir [mailto:laanwj@gmail.com] 
Sent: Sunday, April 20, 2014 11:27 AM
To: Chris Pacia
Cc: Bitcoin Dev
Subject: Re: [Bitcoin-development] "bits": Unit of account

On Sun, Apr 20, 2014 at 6:19 PM, Chris Pacia <ctpacia@gmail.com> wrote:

That's a very anglocentric way of thinking.

Here in the Netherlands, a "bit" is something you put in a horses's mouth.
It's also used as imported word (in the information sense).
We've never used the term for money.

Wladimir

----------------------------------------------------------------------------
--
Learn Graph Databases - Download FREE O'Reilly Book "Graph Databases" is the
definitive new guide to graph databases and their applications. Written by
three acclaimed leaders in the field, this first edition is now available.
Download your free book today!
http://p.sf.net/sfu/NeoTech
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------------------------------
I'm in favor of BIP43.

Adding a "Purpose" node can be used as an identifier for what kind of
tree is in the wallet file we're reading.   I can envision a few
different, common tree structures.  Perhaps using a non-hardened
first-layer derivation (we have clients who want this).  Similarly, my
proposal for a "No-collision mode" for multisig BIP32 trees
<http://sourceforge.net/p/bitcoin/mailman/message/32860512/> is another
variant that might get some traction but not everyone will use it. 
These things could be "supported" by simply changing the BIP43 "Purpose"
index and wallet software could be designed to recognize and react to
the Purpose node for any number of different tree structures, and ignore
any trees that it doesn't recognize (or maybe be able to view the
balance across all the leaves of the tree but not expand it)

We have clients with special use-cases (complex multi-layer trees) that
are unlikely to be recycled across users.  In such cases we might just
use a "random" Purpose that is recognized by their system, and know that
other software won't mess with it.  Though it would be better if that
field was encoded in the root seed, instead.

Nonetheless, putting that extra layer between the root and the
"important" tree nodes provides flexibility to BIP32 as a whole.
-Alan


On 09/25/2014 09:53 PM, Gregory Maxwell wrote:

-------------------------------------
On Wed, Oct 15, 2014 at 4:54 PM, Adam Back <adam@cypherspace.org> wrote:


Please not sourceforge.




Mailman is good enough...
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

==Abstract==

In simple payment verification (SPV) proofs it is currently necessary
that every intervening block header be provided between two blocks in
order to establish both connectivity and proof of work. By committing to
a hash tree of past block headers in each block, these back references
can be exploited to demonstrate in logarithmic space that an elided
sequence of block headers actually represents the claimed work. This is
particularly useful in the construction of 2-way pegging between chains,
and as an efficiency optimization for SPV clients and headers-first
synchronization.

==Overview==

The miner of a block is allowed to choose some subset of the block
history which it creates direct links back to. These links include the
block hash, height, and work distance from the new block, and are
organized into a hash tree structure. The root of this hash tree is
committed to the coinbase string, or some other identifiable position in
the block. Bitcoin is soft-forked to include verification of the
accuracy of the contents of this structure - if present - as a
validation rule.

When constructing an SPV proof, the prover is allowed to choose
back-links from this structure whose relative work distance is less than
or equal to the apparent work of the proof-of-work which contains the
back-link structure. Apparent work in this context means the expected
work that would be required to meet or exceed the actual block hash.
Since back-links can only be used if the apparent work is greater than
or equal to the distance back, constructing such a fraudulent proof is
expected to require just as much or more work as recreating the
underlying sequence of blocks.

The result is skip list structure where "lucky" proofs of work are used
to skip back further than a single block (recall that if you search for
a 64-bit leading-0 proof of work, half the time you get 65 leading-0's,
a quarter of those cases have 66 leading-0's, and so on). When
constructing very long proofs, the solver will follow links back to the
nearest lucky block, then use the back-links contained within that block
to skip back to a prior lucky block, and so on until it reaches a block
which points directly to the desired target block. Given the
distribution of "lucky" blocks, it is expected that such compact proofs
require revelation of log2 N links in order to prove the work required
to build a chain of length N.

==Back link selection==

In fully general form, this compact SPV proof scheme works no matter the
back-links chosen by miners, so long as they are either revealed or
selected in a deterministic way such that full nodes can check their
validity. In choosing which back-links to include, the primary trade-off
is that more back-links results in better connectivity, whereas a
limited number of links results in smaller tree structures and therefore
fewer hashes.

At one extreme you can commit to every single header in the entire
history of the block chain, by building an incremental data structure
such as a binary heap. Such a structure would require log N storage per
chain and log N hash operations per block update, where N is the total
number of blocks in the chain. The root hash of this structure is then
committed to the block chain in a known location.

At the other extreme one could allow the miner instead to commit
whatever back-links he or she desires, and force these the hash tree
structure to be revealed prior to block validation. This allows the
miner to be selective in choosing back-links which provide the most
value, although there is not yet a clearly optimal mechanism for
choosing these links.

This is an area which requires more research with the purpose of
determining the best structure for the hash tree of block header
commitments, and the selection of back-links.

==Use cases==

For SPV clients, a client that has just come online could quickly
ascertain which block represents the most work, and retrieve compact
proofs-of-inclusion for its transactions without having to download
every intervening block header. This further eliminates the need for
checkpoints in an SPV client as it can instead obtain very compact
proofs back to the genesis block instead of the most recent checkpoint,
at a comparable cost. Similar optimizations apply to the initial stages
of headers-first synchronization of full nodes.

Assuming the availability of (U)TxO hash-tree commitments, a compact SPV
proof would allow a mobile client to very quickly fast-forward to the
current most-work block from which it could then query the spend status
of its wallet outputs.

For merged-mined or slow proof-of-work side chains, the savings from
not including every intervening block header could be very significant
in bandwidth and processing time.

Compact SPV proofs allow side chains or private accounting servers to
experiment with very short block intervals without having a detrimental
effect on SPV proof sizes, as the compact proofs scale logarithmically
with the number of blocks.

Finally the most important and driving use case: symmetrical two-way
pegging between bitcoin and side-chains is made efficient enough to be
reduced to practice by the availability of compact SPV proofs[1]. The
compact SPV proofs allow both the necessary proofs-of-spend and
proofs-of-reorg to fit within current blockchain size limitations, and
provide incentives for keeping this data out of the block chain until it
is absolutely necessary.

==References==

This specific compact SPV proof proposal arose from pegging discussion
involving a number of people #bitcoin-wizards: Greg Maxwell, Matt
Corallo, Pieter Wuille, Luke-Jr, Jorge Timon, and Mark Friedenbach. It
is believed that the first explanation of this general idea is due to
Andrew Miller in his 7 Aug 2012 forum post titled "The High-Value-Hash
Highway"[2].

[1]http://sourceforge.net/p/bitcoin/mailman/message/32108143/
[2]https://bitcointalk.org/index.php?topic=98986.0
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJTJy/eAAoJEAdzVfsmodw4zC4P/izBRTutwypwQ70TxPxxHYfH
I4QOpf+MgWHxrD+DKKyqkC2icgUBQz96K1vEhA86PrmK8DITs5yGHLSw7CEF/rlG
hZErVY65IpowPt+JnlwOqHcqaoJ277s+4qpd/D9F7L1ROAMUDzzonf7V1Znr/fax
lL4b8whfUI5jeRQby/tMiGPUB/1YJcbGmFccTW9gkGWMvoqZiiXcW7ZKuLrq5tbW
RFIsrSt7rv3D0Cp2Fiyaxnryr2F0QOTqahHLn50+585eHpVFrA9A5T6xiBcEMzlQ
l5cHRZb+lVIktWuYomBiqWljPLo5qercVDrehIq9FFSYuJqzudNx9ZXrpF1ZR4in
UfZvlYqMFO/ZOTG33JWeeMonKlVwfHH2WreggzSq/JD/cH8dUj63A266Gaf6cl83
vEfhgVBDTXZnl5H9Z7wymja6R9m9Eo/Xf+GwRV4vyx1b9gcZXML4Zm4bTp4EXFHA
StBGrYKmMpEb/gguk/hxJLsm0i9pVaQpMC0u3kClHTA5o0IFF9F5+mVjOb59HlDX
AQx96TSwJzhl0l0jcxYye8bXmZFJvpzpsKRPwNISllLEagjplwK2Ub8q5du27lH5
R2qukcso6N5weGggUu1f7NrqcBALdz4E80SSpwu4YtJ6wdI4zsypaq4leqbSRSKh
/hLKeOV5fEGNmwTtrDmN
=j9cm
-----END PGP SIGNATURE-----


-------------------------------------
Jeff's arguments are understood and supported by those who worked in finance.

Existing financial applications have often problems dealing with more than 2 decimals.
People who work in finance are used to two decimals.

Neither systems nor people in finance have a problem with large numbers though.

For above practical reasons I am also for moving to a unit that equals 100 satoshi.
I heard the name bit for it which I like.

Regards,

Tams Blummer
Founder, CEO
Bits of Proof
http://bitsofproof.com

-------------------------------------
Hello,

I wanted to just add a very brief note to this discussion, that presently
for multisignature creation and management (new transaction etc) I've been
using this: https://coinb.in/multisig/

There were some initial bumps in the road but they were worked out,

see full thread more or less beginning from here:

https://bitcointalk.org/index.php?topic=390046.msg4687868#msg4687868

Curious as to what wallets actually support multisig / P2SH at this point?
Unsure.  Am assuming more than previously.







-------------------------------------
I believe Luke means scanning chains as defined by the structure, but not
handing out addresses from other accounts than the first one.

That's certainly a possibly way to compatibly implement BIP64, but it
doesn't reduce all that much complexity. I hope people would choose that
over defining their own accountless structure though.
On 23 Apr 2014 22:06, "Pavol Rusnak" <stick@gk2.sk> wrote:

-------------------------------------
quote:
[...]

Considering hotel or car rental payments where the credit card
processor reserves a higher amount in order to cover risks, it
doesn't seem like anything new or particularly inconvenient that a
payment system may require a larger amount than the final price being
available.

Which brings us to the question: Is it an important characteristic in
a payment system that it is capable of quickly spending your last
penny?

Best regards,

Isidor


-------------------------------------
On Monday, January 20, 2014 5:42:37 PM slush wrote:

How are they compatible if they could be using entirely different word lists??


Maybe I'm missing something, but shouldn't this be a client-side thing, not 
implemented in the Trezor firmware at all?? O.o;;

Luke


-------------------------------------
On 07/01/2014 10:18 AM, Mike Hearn wrote:

I think the way to go here is using multiple r= parameters.


Either that, or just use the other ones as a fallback. Currently,
Bitcoin Wallet just falls back to BIP21 if fetching the PR via the r=
URL fails.


Its "specced" in code and implemented by several parties. I think its
clear that link-layer encryption has to be an add-on to the current
unencrypted connection, just like HTTPS is on top of HTTP. Anyway,
that's unrelated to the question of how to provide fallback URLs.

One more thought: We have a similar problem with the BIP70 payment URL.
It doesn't allow for fallbacks either. I brought this issue up in the
discussion phase of BIP70, but it was dismissed I think because of
"let's not get too complex for the first version". The fallback here is
to send the transaction via the P2P network.

(I think BIP70 via P2P radio will get used more often in future. I plan
to look into Bluetooth 4 LE as soon as I have devices and wanted to try
WIFI Direct again also. I hope we can skip BIP72 for both of those, but
lets see.)




-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

I just renamed myself on IRC (freenode) to aschildbach. The old name
was Goonie. I will most likely only use the new name from now on, at
least for Bitcoin-related purposes (-:
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)

iEYEARECAAYFAlMbarAACgkQymYr4YuHemCjRwCgmjiod+yXeUg5Mtn83k9pXY9U
rfAAoMxBaNL0e+BuGSXWDCrAtb+77w69
=UhVB
-----END PGP SIGNATURE-----



-------------------------------------
On 03/29/2014 01:30 PM, Mike Hearn wrote:

I guess what I was asking is whether or not all BIP70 compatible clients
will support the creation of all standard output types, including
OP_RETURN outputs.

-- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-------------------------------------
Perhaps I missed it somewhere, but I don't recall it ever being a goal of Bitcoin to act as a stable long-term store of value.

- Jameson

On 04/30/2014 01:06 PM, Troy Benjegerdes wrote:


-------------------------------------
The goal is to have an opportunity cost to breaking the rules.

Proof of Burn is a real cost for following the rules.

On 12/10/2014 01:35 AM, Tamas Blummer wrote:

-------------------------------------
Hello,

I'm trying to create a bit of process around the
https://github.com/bitcoin/bips repository.

A) Currently a lot of pulls are open for various BIPs and it is not
clear who should comment on them, or who decides on changes to be
merged.

Currently all BIP changes have to go through the Bitcoin Core team,
which is a narrow bottleneck and makes little sense when you think
about it. But I don't want to go back to the wiki state in which
everyone can make arbitrary changes to any BIP - we need to distribute
the process somehow.

I'd like to propose to make the author (or someone they delegate to)
the primary contact for each BIP. They should comment on changes, and
either accept or reject them. If they accept them, the change will be
merged.

Of course this means that there is a responsibility for the author to
adhere to BIP 1. For example if your BIP is final, don't allow any
technical changes. To do small clarifications, spelling or adding
implementations or examples is OK, but changing or adding to a
protocol is not - this needs a new BIP. Changing your BIP status
without community consensus is also not OK.

B) I also think it makes sense to move the BIP discussion (both about
the BIP process and individual BIPs) to a separate mailing list.

bitcoin-development currently has a dual function: discussion of
Bitcoin Core implementation concerns, as well as global changes to
Bitcoin (in the form of BIPs).

This makes the list too busy for some people, but it is critical that
everyone writing a Bitcoin node or client is up-to-date with proposals
and can comment on them.

Wladimir


-------------------------------------


Haven't seen any material discussion of this paper in this mailing list, so
I'll start.
(Otherwise, I've seen Peter Todd's reaction on reddit.)

This paper fails to demonstrate that sidechains are anything more than a
wishful thinking.
It can be distilled down to this:
"We want such and such features, hence we'll use DMMS, the same thing
Bitcoin uses, thus it will be secure!"
Um, no.
Alt-coins also use DMMS, but aren't as secure as Bitcoin.

So DMMS does not work by itself, it is a mechanism to secure a blockchain
using economic incentives.
The sidechains paper does not mention this, as far as I can tell.

In my opinion, this is not acceptable. If you're making a proposal, you
need to describe what conditions are required for it to work.

Authors are clearly aware of the problem and mention it in section 6
"Future directions" 6.1. "Hashpower attack resistance".
The problem is they do not make it clear that the proposal just makes no
sense until this is solved.

In the discussions on reddit I've noticed that pretty much everybody
believes that release of sidechains paper implies that the proposal is
complete and now we are just waiting the implementation.

It doesn't help that the paper itself tries to sweep the problem under the
rug and has misleading statements.
Particularly, I'm talking about section "4.2. Fraudulent transfers":

"Reorganisations of arbitrary depth are in principle possible, which could
allow an attacker to
completely transfer coins between sidechains before causing a
reorganisation longer than the contest
period on the sending chain to undo its half of the transfer. ... If the
attacker is allowed to return the transferred coins to  the original
chain, he would increase the number of coins in his possession at the
expense of other users of the sidechain.
Before discussing how to handle this, we observe that this risk can be made
arbitrarily small by
simply increasing the contest period for transfers."

Wow, really? Is this risk stochastic?

The first sentence implies that attacker is able to cause a reorganization
of an arbitrary depth, but the rest of the section implies that
reorganizations are a naturally occurring phenomenon.

All in all, I find this paper really disappointing. It's going to be
influential (9 co-authors, many of which are regarded as Bitcoin core
developers, must be good!) and hyped, and thus might focus research on an
area which is fundamentally flawed.
-------------------------------------
Hi Ryan,

Probably the most neutral way to go about this is to lexicographically
sort by encoded representation bytes.  In java, that would be
ECPoint.getEncoded.

This is what we currently do in our watchdog Oracle.

On Wed, 2014-03-12 at 13:10 -0400, Ryan X. Charles wrote:




-------------------------------------
Thanks Peter,

Having tried to write a bug-for-bug compatible code with Satoshi, I can only second that it is rather close to impossible. 

The aim of BIP62 is noble, still it does not feel right for me to increase the complexity of the code with e.g. soft-fork-ready versioning.
Freezing the consensus code, studying its bugs appears more appropriate to me. What we learn could define a hard fork or a better
chain we migrate to as discussed by blockstream.

Tamas Blummer
-------------------------------------
On Wed, Mar 05, 2014 at 12:54:04PM -0800, Gregory Maxwell wrote:

I think you're misunderstanding me: I'm assuming one of the n parties
signing transactions in my multi-factor authentication scheme is
uncompromised - much easier to do when it's a low-bandwidth box sitting
in a secure location.

Not re-using keys is nice too of course, and while not perfect - your
above scenario - certainely helps limit losses.

-- 
'peter'[:-1]@petertodd.org
0000000000000000afcad9265e8b44bf1171a08165c09b329fab2893bf13ec69
-------------------------------------
Hi All,

This is a bit tangential to the conversation, but since the genesis of 
this conversation is Mike's decentralization blog post, I decided to 
post here.

Perhaps the solution to the mining problem lies in the reward structure 
rather than in the proof of work/asics.

Is it possible instead to allocate a portion of the reward to " a # of 
runner up(s)" even though the runner-up(s) block will be orphaned? For 
example, X% of the block reward goes to Y number of runner-ups based on 
some type of criteria?

This will appear to be a bit like a tax on the winner, but it could 
potentially solve the problem, since a large pool would not want to 
split the pool up to solve multiple blocks.

There are some possible downsides, like probably having to keep those 
orphaned blocks around in the future, etc.

If this is possible, the question that remains then, what would be the 
criteria for the X% payout/allocation?

-Randi


-------------------------------------
On Nov 17, 2014 7:39 AM, "Pieter Wuille" <pieter.wuille@gmail.com> wrote:


I agree but right now wallets not using stealth will only lose metadata,
not coins, if their computer crashes and they have the seed backed up.

But if a user wants to upgrade to stealth, they then risk losing metadata
AND coins if they either didn't manually back up after every transaction or
use a centralized cloud backup service.

That's if OP_RETURN is not utilized for storage.
-------------------------------------
Actually Peter, coinbase confiscations are a much worse mechanism for
enforcement of widespread censorship rules than simple orphaning. They
lose their power when the transaction miners are punished for can
build up over time without losing their usefulness:

Assume a world where 75% of the hashpower is coerced into
stealing/burning the coinbases of miners who allow transactions to and
from a particular set of addresses (the actual rule isn't that
important). Then the following would be a rational behaviour from the
remaining 25%:

- Mine according to the enforced rules most of the time.
- Accept banned transactions paying you with an output (no real
miners' fees) and keep them in an ever-accumulating pool.
- When there's so much of those to make it worth your while, mine a
block filled with them.

If miners don't orphan your block, you made money. They can't
retaliate further, because you can publish the block anonymously, not
tying it to your previous identity. Hell, some of the 75% might be
able to do the same right under the authorities' noses (it would be
really hard to spot by an external observer).

Note that I, banned user, can submit to all these non-enforcing miners
at once (with a different fee txout for each). I get a severe
degradation of service, especially if I'm part of an extremely small
minority, but ultimately as long as a single miner can accumulate
enough transactions with enough fees, I'll eventually get through.

Of course, in such a dystopian future, orphaning would be the
enforcement mechanism. It would be stupid to rely on coinbase
reallocation/burning to do this task when the existing tools work so
much better.

What's interesting is that this mechanism is especially tailored to
blocking time sensitive transactions (that need to be confirmed
now/soon, or are worthless), such that their total out-of-band fees
can't build up over time. Double spending is one such category. I'm at
a loss to come up with something else, but maybe someone has a good
example?

On Thu, Apr 24, 2014 at 10:09 AM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
On Fri, Feb 21, 2014 at 04:11:06PM +0530, Mike Hearn wrote:

The seccomp mechanism would work well here - it's a syscall whitelister,
which makes ptrace useless, among other things. Used by Chrome as of v23
to sandbox the renderers.

We'd probably need to use it with chroot and whitelist the open() call
so that the existing code can create new blockfiles and do whatever
leveldb does.

-- 
'peter'[:-1]@petertodd.org
000000000000000112c53364597954e79cc38f1ba7826a6420ad22a6f3be2932
-------------------------------------
I'm all for fixing bugs, but I know from bitter experience that outside the
BMP dragons lurk. Browsers don't even expose Unicode APIs at all. You end
up needing to ship an entire pure-js implementation, which can be too large
for some use cases (too much time sunk on that issue in my last job).

I'm hoping BIP 38 doesn't get widely used anyway, to be frank. People
moving private keys around by hand has caused quite a few problems in the
past, sometimes people lost money. It's better to work at the level of a
wallet and ideally ask people to move money using regular transactions. Way
less potential for errors.

Regardless, I'll file a JVM bug and see what the outcome is.


On Wed, Jul 16, 2014 at 12:23 AM, Aaron Voisine <voisine@gmail.com> wrote:

-------------------------------------

The spot price for ammonia fertilizer, refined gasoline at terminals, 
and price of tea in china are not 'public information', yet these are
some of the largest traded commodities in the world, far exceeding 
the drop in the bucket that all cryptocoin transactions make.

I'd further argue that the *actual* price of corn (cash bid price at
elevators and ethanol plants) is not public information either. There
is a great deal of money traded in collecting and then distributing the
'cleared price' information. Have a look at 
http://www.interquote.com/template.cfm?navgroup=aboutlist&urlcode=12&view=1

 

You just made my long-term strategic argument for investing in my own
mining hardware so I can be sure to trade reliably.

 
People who take money from buyers and sellers care most about 'accurate 
historic market data'. I just want to exchange my corn for e85, fertilizer,
and electricity, and audit the code that runs accounting for the exchange.

I really don't give a shit if there is 'accurate historic market data' as
long as **MY** personal trade data is accurate and I got a good enough price,
and I know who I'm dealing with.

I know someone smarter than me and with more money, market leverage, and 
political connections **WILL** game the system and distort the market data
history so they can take more money from buyers and sellers without actually
doing some usefull market function. 

As long as use buyers and sellers can see the code, and have a good eye for
knowing when someone's pushing the market around, we can just put our orders
in and relieve some speculators of their money.

Just get me working code for cross-chain trades, and we'll work on the 
accurate historic data problem later.

----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
We should aim to use perfect forward secrecy between all nodes by default.

This forces the attacker to do a MITM attack that is far more expensive on
the large scale.

I don't see why this is seen as so controversial.  It is relatively cheap
to implement on our side,  and has a dramatic increase of cost for any
attackers.

Cam.
On 20/08/2014 5:49 am, "Un Ix" <slashdevnull@hotmail.com> wrote:

-------------------------------------
On Fri, Jan 10, 2014 at 11:28:33AM +0000, Drak wrote:

Needs a prototype implementation first. The version with no prefix is
the simple one and doesn't have any other dependencies; the prefix
version is harder because it isn't clear yet what's the best way to
force the prefix, or for that matter whether scriptPubKey or
H(scriptPubKey) indexes will be available.

It's on my todo list, but as you've probably noticed my todo list is
rather long. :)

-- 
'peter'[:-1]@petertodd.org
00000000000000028a5c9edabc9697fe96405f667be1d6d558d1db21d49b8857
-------------------------------------
These BIPs should go to Final state - they are implemented all over
the place, and are thus entirely fixed in place now. Any changes would
require a new BIP as amandment:

- BIP 14 (BIP Protocol Version and User Agent)

- BIP 21 (URI Scheme)

- BIP 22 (getblocktemplate - Fundamentals)

- BIP 31 (Pong Message)

- BIP 34 (Block v2, Height in coinbase)

- BIP 35 (mempool message)

- BIP 37 (Bloom filtering)

Let me know if you (don't) agree.

Wladimir


-------------------------------------
Please be aware that your emails are being spamfoldered by Gmail. This is
because Yahoo has enabled DMARC enforcement for mail sent from Yahoo and
that renders it incompatible with Sourceforge mailing lists.

There are two fixes:

1) Don't use Yahoo.

2) The real fix which is, we should stop using Sourceforge mailing list
software

Fundamentally all Yahoo is saying with their policy is that rewriting of
mails sent from their service is not allowed. This is a highly reasonable
policy, akin to forbidding SSL MITM attacks, but for email.

There are several ways to be compatible with this policy: unfortunately
sf.net doesn't do any of them.




On Fri, Apr 25, 2014 at 12:35 PM, Stephen Reed <stephenreed@yahoo.com>wrote:

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512



On 10 April 2014 05:17:28 GMT-04:00, Mike Hearn <mike@plan99.net> wrote:

You're both missing a more important issue: a core security assumption of bitcoin is that information is so easy to spread that censorship of it becomes impractical. If we're at the point where nodes are charging for their data we've failed that assumption.

More concretely, if my business is charging for block chain data and I can make a profit doing so via micro payments I have perverse incentives to drive away my competitors. If I give a peer a whole block they can sell access to that information in turn. Why would I make it easy for them if I don't have too?

Anyway, much of this discussion seems to stem from the misconception that contributing back to the network is a binary all or nothing thing - it's not. Over a year ago I myself was lamenting how I and the other "bitcoin-wizards" working on scalability had quickly solved every scaling problem *but* how to make it possible to scale up and keep mining decentralised.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCgA6BQJTRmi9MxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhT/BB/98DudTV85hmruk0WRS
xVt7gGK6DJ2Isc7iJE09i9wSQc/PbHu7rZ2MYPreOdVzRmlHYhOV2ShnZaZJ7A9g
qB8pwy1wVrZgbrFeXXOLegNxGF2Xzc8OtL1E0bkNtTUUkuPIvT3UV4xn/Z+UZToR
XImXpfakfJvyRH80cbMNu4xG/t7Ym4K63nEpCCdsEKNm5a1vHTNRTNfGYMC1wrSV
XI3boZk7BQjqFDZADnonUU9zQ1WOmpdaVBYm+Xtgc+HXl3QODLcwGCY9hIRvaxek
L+IYX9yTVbgngDGy70BYG4ekWxvMtNzRU+9HG5DgA1/Er9r1KIaf/98xiFR7RVB4
Yfia
=34aD
-----END PGP SIGNATURE-----



-------------------------------------
* Transaction *

I spent 1BTC on TestNet to a stealth address...
    TxID: df092896c1347b303da299bc84c92bef1946f455dbdc80ffdb01a18ea4ed8b4c

http://blockexplorer.com/testnet/tx/df092896c1347b303da299bc84c92bef1946f455dbdc80ffdb01a18ea4ed8b4c#i8166574

* Code *

Code which generated this transaction is here:  
https://gist.github.com/jspilman/8396495

Note, one minor change from the protocol we discussed is I'm just using  
the 32-byte x coordinate for the shared secret, not the compressed pubKey  
(so, throwing away the first byte) before hashing with SHA256.

* How it Looks *

After importing the privkey for the TxIn to that transaction  
(importprivkey "cNL8XqRtqwC1YEc9kKspbX2aukWnXfgHQSvjsPYbuPif5Q3DJkEs"  
rescan) you will see two rows in the Transaction List of Bitcoin-QT...

Both rows simply say 'Sent to' with a blank address. One has 1BTC amount  
which is the 2-of-2 stealth multisig, the other has 0BTC amount, and it's  
the OP_RETURN.

I wonder if the 0BTC OP_RETURN transactions should be hidden from the  
Transaction List? 'Transaction Details' truncates the <data> after  
OP_RETURN anyway, so it's not even particularly useful for seeing what  
data you embedded.

* Next Steps *

I'm not quite sure. If we're going to try to deploy this, I think we need  
to fully understand what users who are making these payments should see in  
their wallet software while making a payment, and after a payment has been  
made.

Right now I'm thinking...

   1) Define the PaymentRequest extension
   2) Update Gavin's PHP to generate PaymentRequests for stealth payments
   3) Get Bitcoin-QT loading the PaymentRequest and generating transactions  
 from those PaymentRequests
   4) Write an agent to detect incoming stealth payments

But we would still be showing meaningless rows in the payer's Transaction  
List without some additional work.

If there is a place to add TxOut meta-data with the pubkeys used to  
generate it... well, there must be since the 'Merchant' field is attached  
somehow. So we could probably use the same method to keep the pubKeys  
around.

Maybe the simple way to punt on this is to just show 'Merchant' in the  
address column if it is available and an address is not. We could skip  
saving the pubKeys for now, so there would be no way to send follow on  
stealth payments, but at least the Transaction List would make sense  
instead of looking like two empty transactions.

* Other Open Questions *

I think the biggest is if/how to receive P2P stealth payments in  
Bitcoin-QT as an end-user not a merchant.

I can probably make the necessary changes to IsMine, but I don't know  
where we should keep 'd2'/'Q2' unencrypted so it's available for doing the  
necessary tests, but has no chance of ever be used as a stand-alone  
private key?

And then there's still the question of: when 'd1'/Q1 is available  
decrypted, we must fully verify the transaction, and how to indicate if  
that has or has not been done yet.

It really seems crippled to me without fully integrated support for  
receiving P2P stealth payments in Bitcoin-QT. It doesn't seem like that  
much code, just some details to work out first.



-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Thanks,

Followup question on https://github.com/bitcoin/bitcoin/pull/3959 :

This describes current dust change handling:

(gavinandresen)
https://github.com/bitcoin/bitcoin/pull/3959/files#r13494256

Related Question:  This describes how wallets would let you know a
transaction is 'precious' with a flag --
(jgarzik)
https://github.com/bitcoin/bitcoin/pull/3753#issuecomment-49464772

- -- however, it doesn't appear to be part of 0.10 anymore ~ what is it
that would keep it from being incorporated into 0.10?
(or was that addressed by a later commit?)

Possibly also related (suggested dusting feature):
https://github.com/bitcoin/bitcoin/issues/4079#issuecomment-41010593

Thanks in advance for your responses.


Wladimir wrote:
(for Core 0.10)

- -- 
http://abis.io ~
"a protocol concept to enable decentralization
and expansion of a giving economy, and a new social good"
https://keybase.io/odinn
-----BEGIN PGP SIGNATURE-----

iQEcBAEBCgAGBQJUTTq8AAoJEGxwq/inSG8C8PYH/jrZIgecpEiwUYdRGT/dxvrE
qHrlsJz8aPY/E/ojNE4MY4Con5seH2IRL+qg14pZvIQNJSipRYejh0BeqQ2YkfAF
leEt8PlpblNqV0Ieq1VmdJK5wnF3crNZsNdPv73Z7UXplXo8sG+lYGENgC11s+wN
QI29F3Kkrqk66aa6VmRbNzRIgL1JYfTkZLba9ApZNxJsugeOgmlOQw6+q5hgChKy
lxN5s+P/wohH0n047ksYdiMnXbZwPL2scUEN87D74KYqYdCa6AB7vMkLETO2msSg
ndC9ge8LfTODlEuFA9rQ8CgLAkwVWCaCbqph7iqTt6Cvdnqeo9XvlrpcB2B31hI=
=xn6P
-----END PGP SIGNATURE-----


-------------------------------------
Hi all,

while thinking about what use cases the stealth addresses covers, in
particular in addition to the payment protocol, I found it useful to
bring this up again.

currently, BIP70 says for "payment_url": Secure (usually https)
location where a Payment message (see below) may be sent to obtain a
PaymentACK.

The fact that this is optional makes the "memo" and "refund" and
"merchant_data" fields in the Payment message useless, as merchants
cannot rely on it, thus need to provide an alternative, thus nobody
would have a use for trying to use the in-Payment versions. If we
truly want the use of this Payment being sent be optional, I'd vote to
get rid of these and just send the transaction.

In particular in the case of more anonymous senders, if the Payment
message isn't sent, it may result in funds being transferred without a
way to know who to refund it to if something goes wrong.

That would be a pity. I think having bi-directional communication in
the protocol is one of the nicest things the payment protocol can add.
I would prefer to at least formulate it in the BIP as "location where
a Payment message must be attempted to be sent to". In case it fails,
it should probably be stored in the client and retried later.

As an optimization (and I believe this is what Mike plans to implement
in BitcoinJ), if a payment_url is present, it should be encouraged to
only send the payment there, and not broadcast the transaction at all
on the P2P network (minimizing the risk that the transaction confirms
without the payment being received; it can't be guaranteed however).

-- 
Pieter


-------------------------------------

Individually rational strategy is to vote for coinbase reallocation on
every block.

Yes, in that case nobody will get reward. It is similar to prisoner's
dilemma: equilibrium has worst pay-off.
In practice that would mean that simple game-theoretic models are no longer
applicable, as they lead to absurd results.



Miners work to get rewards.
It absolutely doesn't matter whether they are deliberately trying to
double-spend or not: they won't be able to double-spend without a collusion.
-------------------------------------
On Wed, Jul 30, 2014 at 12:32 AM, Caleb Roger Davis <moabtek@gmail.com> wrote:

Low-level unit tests are in `src/test`. These use the boost
unit-testing framework. You can run them with 'make check' or
`src/test/test_bitcoin`.

High-level RPC tests are in `qa/rpc-tests`. These are Python scripts
that can be invoked manually, and are based on our own simple
framework.

There is also a java-based 'comparison tool' that tests high-level
behavior with regard to the block chain. It is based on bitcoinj and
acts as an external node. This is not part of the github bitcoin
repository itself, but of bitcoinj (AFAIK).


See https://www.bitcoin.org/en/developer-guide


All of the wallet code is in `src/wallet.cpp` and `src/walletdb.cpp`.
If the purpose is just studying, the bitcoin core wallet is not the
most readable wallet code around, and also hard to port as it relies
on a full node in the same process. It's better to look at SPV
wallets, for example the bitcoinj-based ones.


Something like that would be useful, yes.


If you want to work on Bitcoin Core, a Linux box (or VM) is the best
development environment. Getting started building on WIndows or Mac is
harder (but possible). There is work in progress to make building the
dependencies easier for those.

Wladimir


-------------------------------------
On Wed, Dec 10, 2014 at 3:45 PM, Austin Walne <austin.walne@gmail.com> wrote:

Fanquake already started on that (but didn't even mention it here!)
https://github.com/bitcoin/bitcoin/pull/5468

Wladimir


-------------------------------------
Christophe Biocca wrote:


"before" implies T=0.  That is a much too optimistic choice for T; 50% 
of nodes would misidentify the respend.





-------------------------------------
On Sun, Oct 5, 2014 at 4:40 PM, Gregory Maxwell <gmaxwell@gmail.com>

Ah, I should also mention a somewhat more far out approach which helps
here as a side effect:

If transactions were using the BLS short signature scheme (a very
compact EC signature based on pairing cryptography) there is a scheme
so that you securely can aggregate the signatures from multiple
messages into a single signature (also has nice bandwidth properties)
and still verify it. It also works recursively, so aggregates can be
further aggregated.

A consequence of this is that you cannot remove a (set of)
signature(s) from the aggregate without knowing the (set of)
signature(s) by itself.

If the coinbase transaction also contains a signature and if some
non-trivial portion of fee paying users relayed their transaction
privately to miners it,  then other miners would only learn of the
transaction in aggregated form.  Without knowing the transaction by
itself they could not pull it out of a block separately from the
coinbase payment and add it to their own block in a fork.

(In general this provides several anti-censorship properties, since if
someone passed you an aggregate of several transactions you could only
accept or reject them as a group unless you knew the members
separately).

The use in aggregation can be done in a way which is purely additive
(e.g. in addition to regular DSA signatures), so even if the
cryptosystem is broken the only harm would be allowing
disaggregation... but unfortunately the pairing crypto is pretty slow
(verification takes a 0.5ms-ish pairing operation per transaction).


-------------------------------------
On 07/04/14 15:50, Gregory Maxwell wrote:

What options are out there for people caring about 20GB blockchain?
Depending of third party server is not an option.

-- 
Jess Cea Avin                         _/_/      _/_/_/        _/_/_/
jcea@jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/
Twitter: @jcea                        _/_/    _/_/          _/_/_/_/_/
jabber / xmpp:jcea@jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/
"Things are not so easy"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/
"My name is Dump, Core Dump"   _/_/_/        _/_/_/      _/_/  _/_/
"El amor es poner tu felicidad en la felicidad de otro" - Leibniz

-------------------------------------
On Tue, Feb 11, 2014 at 11:59:19AM -0600, Troy Benjegerdes wrote:

Cross-chain trading is a different thing entirely; it doesn't allow for
the clever 2-party-trade trick. (as far as I know)

-- 
'peter'[:-1]@petertodd.org
0000000000000000c34e2307bf2d8e1de9db0351acfe7320a08826a5de3c146a
-------------------------------------
To clarify, there are proposals to make miners recognize this
situation and account for it, only eligius is running it at the moment
IIRC:
http://bitcoin.stackexchange.com/questions/8390/are-there-any-pools-or-large-miners-running-child-pays-for-parent-patch
Right now if you were to try it likely wouldn't result in inclusion.
But this is on the radar, and I suspect it'll eventually get merged
into mainline.

On Thu, Jan 16, 2014 at 9:06 PM, Dniel Fraga <fragabr@gmail.com> wrote:


-------------------------------------
I think it's a little disingenuous to talk about encrypting the P2P protocol
as a security improvement, when all the organized crime agencies need to do is
borrow a Fedex/UPS truck and deliver some laptops to Github employees and they
can insert whatever monitoring/0-day they want.

Encryption is complicated stuff to actually **get right**, and the more stuff
you throw crypto around, the more likely it is you'll get a Heartbleed 0-day

If you want to increase security, make it simpler. I'm not even sure it can
be easily simplified... how could you separate the P2P network transport from
the core blockchain functionality?

On Wed, Aug 20, 2014 at 04:37:24PM +0200, Mike Hearn wrote:




-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
On Fri, Mar 14, 2014 at 3:38 AM, Jack Scott <jack.scott.public@gmail.com>wrote:


Some practical nits:

- Physical keys are vulnerable to photography-based reproduction attacks.
That gets even worse if you use them to identify to a digital system as you
can leave out the tiresome manual reproduction step.

- The output from computer vision algorithms is notoriously noisy. If you
use that as input for hashing a private key, it may become hard/impossible
to reproduce (also, physical objects may deform over time).

Wladimir
-------------------------------------

How is eventual expiration of a tx that started life with an nLockTime 
in the future "breaking", any more than any other tx expiring?


On 8/6/2014 6:54 AM, Mike Hearn wrote:


-------------------------------------
On Wed, Jun 11, 2014 at 5:39 PM, Wladimir <laanwj@gmail.com> wrote:


Another one:

- SOCKS5 supports IPv6

Last call...

Wladimir


-------------------------------------
On Tue, Apr 1, 2014 at 4:47 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:


What about BIP 420?  Everyone knows if you add zero it's still the same
number.
-------------------------------------
On Tue, Dec 31, 2013 at 01:14:05AM +0000, Luke-Jr wrote:

You assume the value of a crypto-currency is equal to all miners, it's
not.

Suppose I create a merge-mined Zerocoin implementation with a 1:1
BTC/ZTC exchange rate enforced by the software. You can't argue this is
a scamcoin; no-one is getting rich. There's a 1:1 exchange rate so the
only thing you can do with the coin is get some privacy. But inevitably
some miners won't agree that enabling better privacy is a good thing, or
their local governments won't. Either way, they can attack the Zerocoin
merge-mined chain with a marginal cost of nearly zero.

OTOH if the Zerocoin scheme was implemented by embedding ZTC
transactions within standard Bitcoin transactions - even without any
attempt at hiding them - the attackers would need a 50% majority of
hashing power to succeed. Of course potentially slow confirmations is a
trade-off, but that's likely a perfectly OK trade-off in this case.

-- 
'peter'[:-1]@petertodd.org
000000000000000f9102d27cfd61ea9e8bb324593593ca3ce6ba53153ff251b3
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

While we might be able to get away with a retroactive change in meaning right now in the future that won't be so easy. There are lots if proposed applications for nLockTime-using protocols that depend on transactions (or parts of transactions) being possible to mine as is. Making existing transactions impossible to mine in the future will break those types of applications. We might as well use this as a learning experience for what a version bump would look like infrastructures wise.

Note how the above is a particularly bad example of gmaxwell's generic "don't break things" objection. Equally, remember that lots of infrastructure *does* handle malleability just fine already.

On February 19, 2014 3:28:24 PM EST, Michael Gronager <gronager@mac.com> wrote:
-----BEGIN PGP SIGNATURE-----
Version: APG v1.0.9

iQFQBAEBCAA6BQJTBRjcMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhbuuCADHHZvCbWNR+hj3lq2u
Xjr8POSsMWk4XorvLftgXSzAzypr7n0BP7+fmz/v0J98XfeOHxf8NHB2VXzFMCzI
mstYyFC+gdsPf9eIMoN2S9EB9d4Lh1Y7Zv5BGqopuHCUIVMpzk2QDaFlLe+gW8Ai
p4Yv/jGib8ym1ahJ24nZ89l7Psa+uXDw8N2VX5PcyDNVRwzuXwa0h2Kix/gt8uJb
RV5Sj3duxUE6mOGN07j6lPu9VcrtD0ydvAO3DoEJqkBqjhbC33h05H96KPQKuGcg
5DOKXUV5ChW5CF3DH5HN/LdduLgbTevtLbkBhdLKo+z5GKaU7Qpc5i6dIeAKl3uA
KCQE
=DiAE
-----END PGP SIGNATURE-----



-------------------------------------
On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:

This asserts a central authority and gives developers too much power.


-------------------------------------
On Thu, Nov 06, 2014 at 02:47:29AM -0800, Pieter Wuille wrote:

Indeed.

I actually was thinking about SCRIPT_VERIFY_MINIMALDATA, CScript(), and
FindAndDelete() Specifically that if you were to change CScript() to
convert single-character PUSHDATA's to OP_<number> you'd be making a
consensus-critical change due to how FindAndDelete() is called with a a
CScript() signature. You didn't make that mistake, and I couldn't find a
way to exploit it anyway, but it reminded me of this STRICTENC stuff.


It should be enough to just duplicate the CheckInputs() call in
the AcceptToMemoryPool() function:

    if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))
    {
        return error("AcceptToMemoryPool: : ConnectInputs failed %s", hash.ToString());
    }
    if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))
    {
        return error("AcceptToMemoryPool: : BUG FOUND Standard verify flags passed yet mandatory flags failed. %s", hash.ToString());
    }



Ok, then given we have to support hybrid encoding for awhile longer
anyway - I noticed your secp256k1 library supports it - lets do the
latter as a "least invasive" measure. I can't think of any case where
that'd be triggered other than delibrately. Doing that should make
STRICTENC a soft-fork-safe change, and we can decide at a later date if
we want to get rid of hybrid-encoded pubkeys in a further tightening of
the rules.

-- 
'peter'[:-1]@petertodd.org
000000000000000019b3c625f667bd0b93011c0a37950545a6a8fccf0b08ae73
-------------------------------------
On Tue, May 6, 2014 at 5:12 AM,  <odinn.cyberguerrilla@riseup.net> wrote:

Values 2 and 3 are only needed in theory. They together shouldn't
occur more than once in 2**127 (when the signature value is between
the group size and the field size).

That said, this is indeed a bug.

-- 
Pieter


-------------------------------------

OK, sure, let's say most Bitcoin users will be honest (we hope). But
unfortunately in a situation where fraud is possible users wouldn't
necessarily distribute evenly over transactions.

Back when I worked on Gmail, we did a little study where we selected a
random subset of email accounts from Nigeria and waited to see if they
received abuse reports, showed up on dating site blacklists etc. It turned
out about 2/3rds of them did. This obviously doesn't imply that 2/3rds of
all Nigerians are scammers, but unfortunately the few that are are
responsible for a disproportionate number of account creations.

If a merchant is selling something of value repeatedly, then a small number
of scammers can go back and try their luck over and over. I'm not sure how
many trades fall into such an exploitable category, though.

Also, there's the philosophical question of how honest people really are
when there's no consequences to their actions. For instance, if most people
were honest, then piracy would be not a big problem. But game studios that
have cracked DRM quite often report piracy rates of 95%, i.e. for every 5
sales they make, they get 100 people playing on their servers - the vast
majority of their users are not honest.
-------------------------------------
Mike Hearn <mike <at> plan99.net> writes:
[snip]
message might not scale in a world where there are huge numbers of instant-
confirmation providers, but I'm hoping that we never have to scale to that 
size, because if we did that'd rather imply that Bitcoin has become useless 
for in-person payments without trusted third parties and avoiding that is 
rather the whole point of the project :) So I'm OK with some theoretical 
lack of scalability for now. 

Hard to say for now. I like the current simplicity but if someone can come 
up with some use case for other options we should discuss and investigate 
them. I don't see more than a bunch of accepted payment methods anywhere I 
ever been in my life, I don't see merchants trusting more than a handful of 
third parties.

signature of their "instant provider" every time and the merchant just 
chooses whether to ignore it or not, but as Lawrence points out, this is 
incompatible with the provider charging extra fees for "instantness". But 
should we care? I'm trying to imagine what the purchasing experience is like 
with optional paid-for third party anti-double-spend protection. Ultimately 
it's the merchant who cares about this, not me, so why would I ever pay?

I think you are wrong here.
Just because up to date credit cards charged the merchant which in turn 
charged you and the ordinary cash payer doesn't mean a newer and better 
system can't be transparent from day one.

Ultimately you care because the alternative is to wait.

merchant: after all, I'm honest.

It's quite simple, in a low amounts world people will probably accept zero 
confs, just like occasionally people can walk out with a bag of crisps 
without paying from a Pret in London. Guards would cost more than what 
they'd save from thefts.

With higher amounts they will either not accept bitcoin unless instant 
confirmed or they will make you wait if that's even feasible (unlikely in a 
supermarket or petrol station but perfectly fine at the restaurant maybe).

the receiver who cares about confirmations, not the sender.

You care too: time and money, or just money if you want to use the old 
simplification.

details of their instantness provider and we just don't allow for optional 
selection of instantness. I'm not sure that works, UX wise, so is having a 
less scalable design to support it worthwhile?

We would not support that I think. Explicit is better than implicit.

We will charge for instant confirmation and wouldn't want the user charged 
unless pre-agreed, especially if then they also have to wait because the 
instant tx was not recognized as such.

Yeah we can charge the merchant that can then in turn charge you, we may as 
well charge you and be transparent about it but also have deals with 
merchant where they pay fixed amounts per month for unlimited tx and make it 
free for their users.

Perhaps just like today people ask you which card you are going to use and 
they may not accept Amex or Diners the same will go for instant and they, 
the merchants, will just pick the instant provider from a touch screen 
before allowing the payment in. 




-------------------------------------

The the current spec with TREZOR's wordlist is also implemented by Bits of Proof
https://github.com/bitsofproof/supernode/blob/master/api/src/main/java/com/bitsofproof/supernode/wallet/BIP39.java

and deployed in two projects, one being btc1k also open sourced at our github.

Regards,

Tams Blummer
http://bitsofproof.com

-------------------------------------
I agree with this.
Some combinatorics shows that 3 persistent connections instead of 8 results in
a low success rate of the entry-peers fingerprinting attack.

I agree ('Addnodes' are already excluded in the example code from the pull request)

On Mon, Aug 18, 2014 at 04:51:34PM -0700, Gregory Maxwell wrote:

-- 
Ivan


-------------------------------------
BTW, its not like this would be the first time this was raised, instead the "ship left" while ignoring arguments.

The idea of is up there for votes since March 2013 https://bitcointalk.org/index.php?topic=149150.0
and received the most votes. 

I remembered this last time on this list here:

http://sourceforge.net/p/bitcoin/mailman/message/31640769/

Regards,

Tamas Blummer
Founder, CEO
Bits of Proof
http://bitsofproof.com

-------------------------------------
Extra encoding for testnet is quite useless complexity in face of many alt chains.
BIPS should be chain agnostic.

Regards,

Tamas Blummer
http://bitsofproof.com

On 22.04.2014, at 10:35, Matt Whitlock <bip@mattwhitlock.name> wrote:


-------------------------------------
On Wed, Mar 12, 2014 at 05:41:33PM +0100, Mike Hearn wrote:

Why?

It's the raw transaction API and Bitcoin Core wallet. What should be
carefully and loudly documented is the simple advice "Don't use to hold
customer funds; use Bitcoinj or something instead." followed by a
warning that SPV isn't secure enough for a business unless you run your
own full node.

The raw transaction API has no support to handle fees at all.

-- 
'peter'[:-1]@petertodd.org
00000000000000008aebcc3db3f73302ba290392eb783c509c5c7c4dd3971136
-------------------------------------
Nobody is exactly thrilled by IsStandard, but it's not a deal-killer. If
you have a use for a new type of script it can be added, and people do
upgrade:

http://getaddr.bitnodes.io/dashboard/chart/?days=30

As you can see the 0.9 rollout is going OK. If a new script type had been
made standard for 0.9 like OP_RETURN was, I'm guessing it'll only be
another month or so and it'll be quite usable.


On Sat, Mar 29, 2014 at 3:55 PM, Matt Whitlock <bip@mattwhitlock.name>wrote:

-------------------------------------
Jerry, some feedback on generating space-efficient QR codes. QR codes
have 4 possible encodings, see "Storage":
http://en.wikipedia.org/wiki/QR_code

The encoding you're proposing in BIP81 switches you to binary mode
without actually using all the bits. So you'll end up with bloaty QR
codes. One fix would be of course use all the available bits.

However, binary QR codes cannot be used to auto-dispatch to apps on
Android. If you want a wallet app to automatically open upon scan, you
need to encode your data as an URI. That pretty much locks you into
using alphanumeric mode QR codes.

I've implemented that in Bitcoin Wallet for efficiently encoding
transactions and BIP70 payment requests into QR codes. Since the allowed
alphabet is 43 chars, I've named the encoding Base43 (it uses the same
algorithm as Base58 or Base64). Tell me if you're interested in the details.


On 05/17/2014 05:31 PM, Jerry Felix wrote:




-------------------------------------

-------------------------------------
On Tue, Feb 25, 2014 at 10:09:23AM -0800, Jeremy Spilman wrote:

That's exactly the problem.

Of course every time we make a new transaction type standard we also run
that risk, but at least it's a temporary situation and we can expect to
get hashing power on-board fairly quickly. With such a low MIN_RELAY
that's not true, and in an absolute sense, the funds required to DoS
attack the network are fairly low.


There's currently no expiration policy at all; that's the root of the
DoS problem I was referring too.


Have you seen the mempool superblock design that keeps getting
suggested? jgarzik has the most recent write-up here:
https://github.com/bitcoin/bitcoin/issues/3723

I was working on a relatively ambitious version of it last summer that
calculated the fee/KB for transactions, including depedencies, and then
simply ordered the mempool with highest fee/KB first. The idea was you
could then easily limit the total size of the mempool and drop
transactions with the lowest fee/KB first. Transactions that paid less
than the lowest fee/KB in a max-size mempool simply would not get
relayed at all. Pity had to put it off for higher-priority work.

What's interesting is how this makes zero-conf transactions even less
safe: all you have to do to double-spend one (or more!) that pay X
fee/KB is broadcast enough transactions paying X+e fee/KB to push out
the unconfirmed tx from mepools around the network, then broadcast your
double-spend. Obviously the economics of this are going to make attacks
frequently profitable, especially if you can attack multiple targets at
once. You can of course have schemes where you don't entirely drop
transactions, saving, say, the inputs they spend and a transaction id,
(so a rebroadcast can succeed) but that just reduces the effectiveness
of the attack by a constant factor and makes it possible to get into
complex situations where your funds are locked and unspendable.

-- 
'peter'[:-1]@petertodd.org
00000000000000011ffdfe2bfdf8f1f983bebfa160670b85afeebbd815fdf484
-------------------------------------
RE: process:

I like author == primary control, and an "assume they will do the right
thing, revert if they don't"

RE: separate mailing list for BIP discussion:

Great idea. Jeff Garzik was looking for a better mailing list solution than
SourceForge, but assuming
there isn't a clearly better solution I think "we" should create a strictly
moderated bitcoin-bips@lists.sourceforge list.

-- 
--
Gavin Andresen
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

The next logical step may be for us to offer a public instance of these graphs; I'd be happy to work with you to set one up.

I agree that it would be awesome to offer these types of stats with the installer; unfortunately the route I've taken has dependencies on several other other pieces of software to do all the heavy lifting of stats aggregation and chart rendering. I'm assuming that you would not want to build any of that processing into Bitcoin Core itself; would you be opposed to packaging other software along with the installer?

- - Jameson

On 05/07/2014 03:46 PM, Wladimir wrote:
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQEcBAEBAgAGBQJTapAsAAoJEIch3FSFNiDcyMEIAIds0yo9zeWcqNqGZ+UNltoH
hNt8NhYOgL/6WNeLVYdRmCrrdNn/KMSLcAZmOQ0U+W/qL3xh1RB59o3BcBnW05Yr
ZxY5ajKKq+oz70ShMNUkVnzFSStMhH9fKnolrF0mgSx4CU9e0YTx/LBc/u9ulypO
QNZydiiegwvTFjMxHItgU5xo/wzySazmyxN9x3Gls98vDfSjE3Rt/DTqAwHleD3t
SlIu4RU2iPpAW/6MgfWqAw+CrbZ2NNKp7a7+0gsUlbdDP1h6WEvoae5sUzRmvLB3
rHMmRoRvTl4Hl1bG7CKyM4D3piBkpDf/nMqnAAFNYkocS5xVpHM1WrTMDAmkSLk=
=/TPp
-----END PGP SIGNATURE-----


-------------------------------------
This is outright ridiculous.

Zero-confirmation double-spending is a small problem, and possible
solutions are known. (E.g. trusted third party + multi-sig addresses for
small-value transactions.)

On the other hand, protocol changes like described above might have
game-theoretical implications which are non-trivial and hard to understand.

The above approach works as long as the majority of hashpower is honest,

No. Bitcoin should work if miners are merely individually rational, i.e.
they try to maximize their pay-offs without colluding with others.

I guess word "honest" might have different meanings, that can be a source
of confusing.
1. Honest -- not trying to destroy bitcoin
2. Honest -- following rules which are not required by the protocol
-------------------------------------
# Death by halving

## Summary

If miner's income margin are less than 50% (which is a healthy situation
when mining hardware is readily available), we might experience
catastrophic loss of hashpower (and, more importantly, catastrophic loss of
security) after reward halving.

## A simple model

Let's define miner's income margin as `MIM = (R-C_e)/R`, where R is the
total revenue miner receives over a period of time, and C_e is the cost of
electricity spent on mining over the same period of time. (Note that for
the sake of simplicity we do not take into account equipment costs,
amortization and other costs mining might incur.)

Also we will assume that transaction fees collected by miner are negligible
as compared to the subsidy.

Theorem 1. If for a certain miner MIM is less than 0.5 before subsidy
halving and bitcoin and electricity prices stay the same, then mining is no
longer profitable after the halving.

Indeed, suppose the revenue after the halving is R' = R/2.
   MIM = (R-C_e)/R < 0.5
   R/2 < C_e.

   R' = R/2 < C_e.

If revenue after halving R' doesn't cover electricity cost, a rational
miner should stop mining, as it's cheaper to acquire bitcoins from the
market.

~~~

Under these assumptions, if the majority of miners have MIM less than 0.5,
Bitcoin is going to experience a significant loss of hashing power.
But are these assumptions reasonable? We need a study a more complex model
which takes into account changes in bitcoin price and difficulty changes
over time.
But, first, let's analyze significance of 'loss of hashpower'.

## Catastrophic loss of hashpower

Bitcoin security model relies on assumption that a malicious actor cannot
acquire more than 50% of network's current hashpower.
E.g. there is a table in Rosenfeld's _Analysis of Hashrate-Based Double
Spending_ paper which shows that as long as the malicious actor controls
only a small fraction of total hashpower, attacks have well-define costs.
But if the attacker-controlled hashrate is higher than 50%, attacks become
virtually costless, as the attacker receives double-spending revenue on top
of his mining revenue, and his risk is close to zero.

Note that the simple model described in the aforementioned paper doesn't
take into account attack's effect on the bitcoin price and the price of the
Bitcoin mining equipment. I hope that one day we'll see more elaborate
attack models, but in the meantime, we'll have to resort to hand-waving.

Consider a situation where almost all available hashpower is available for
a lease to the highest bidder on the open market. In this case someone who
owns sufficient capital could easily pull off an attack.

But why is hashpower not available on the market? Quite likely equipment
owners are aware of the fact that such an attack would make Bitcoin
useless, and thus worthless, which would also make their equipment
worthless. Thus they prefer to do mining for a known mining pools with good
track record.
(Although hashpower marketplaces exist: https://nicehash.com/ they aren't
particularly popular.)

Now let's consider a situation where mining bitcoins is no longer
profitable and the majority of hashpower became dormant, i.e. miners turned
off their equipment or went to mine something else. In this case equipment
is already nearly worthless, so people might as well lease it to the
highest bidder, thus enabling aforementioned attacks.

Alternatively, the attacker might buy obsolete mining equipment from people
who are no longer interested in mining.

## Taking into account the Bitcoin price

This is largely trivial, and thus is left as an exercise for the reader.
Let's just note that the Bitcoin subsidy halving is an event which is known
to market participants in advance, and thus it shouldn't result in
significant changes of the Bitcoin price,

## Changes in difficulty

Different mining devices have different efficiency. After the reward
halving mining on some of these devices becomes unprofitable, thus they
will drop out, which will result in a drop of mining difficulty.

We can greatly simplify calculations if we sum costs and rewards across all
miners, thus calculating average MIM before the halving: `MIM = 1 - C_e/R`.

Let's consider an equilibrium break-even situation where unprofitable
mining devices were turned off, thus resulting in the change in electricity
expenditures: `C_e' = r * C_e`. and average MIM after the halving `MIM' =
0`. In this case:

    r * C_e = R/2
    C_e / R = 1/2r
    (1 - MIM) = 1/2r
    r = 1/(2*(1-MIM))

Let's evaluate this formulate for different before-halving MIM:

1. If `MIM = 0.5`, then `r = 1/(2*0.5) = 1`, that is, all miners can remain
mining.
2. If `MIM = 0.25`, then `r = 1/(2*0.75) = 0.66`, the least efficient
miners consuming 33% of total electricity costs will drop out.
3. If `MIM = 0.1`, then `r = 1/(2*0.9) = 0.55`, total electricity costs
drop by 45%.

We can note that for the before-halving MIM>0, r is higher than 1/2, thus
less than half of total hashpower will drop out.

The worst-case situation is when before-halving MIM is close to zero and
mining devices, as well as cost of electricity in different places, are
nearly identical, in that case approximately a half of all hashpower will
drop out.

## MIM estimation

OK, what MIM do we expect in the long run? Is it going to be less than 50%
anyway?

We can expect that people will keep buying mining devices as long as it is
profitable.

Break-even condition: `R - C_e - P = 0`, where P is the price of a mining
device, R is the revenue it generates over its lifetime, and C_e is the
total cost of required electricity over its lifetime. In this case, `R =
C_e + P`, and thus:

    MIM = 1 - C_e / (C_e + P)

`f = C_e / P` is a ratio of the cost of electricity to the cost of
hardware, `C_e = f * P`, and thus

    MIM = 1 - f * P / (f * P + P) = 1 - f / (f + 1) = 1 / (1 + f)

MIM is less than 0.5 when f > 1.

Computing f is somewhat challenging even for a concrete device, as it's
useful lifetime is unknown.

Let's do some guesstimation:

Spondoolies Tech's SP35 Yukon unit consumes 3.5 KW and costs $4000. If it's
useful lifetime is more than 2 years and a cost of KWh is $0.1, the total
expenditures on electricity will be at least $6135, thus for this device we
have `f > 6135/4000 > 1.5`.

If other devices which will be sold on the market will have similar specs,
we will have MIM lower than 0.5. (Well, no shit.)

## Conclusions

Reward halving is a deficiency in Bitcoin's design, but there is some hope
it won't be critical: in the equilibrium break-even situation hashpower
drop is less than 50%.
Hashrate might drop by more than 50% immediately after the halving (and
before difficulty is updated), thus a combination of the halving and slow
difficulty update pose a real threat.
-------------------------------------

Sure, that makes more sense I think.

As a motivating use case, Bitcoin Wallet for Android currently has a
hard-coded block explorer (biteasy.com) which it uses to find UTXOs for a
given key. This is used for its "Sweep paper wallet" feature. It must work
this way because P2P nodes don't calculate such indexes.

If there was a way to do block index autodiscovery, that'd help us remove
this hard-coded block explorer and increase decentralisation. But because
it's a GUI app we don't want users to look at a spinner for more than a few
seconds, so a slow discovery process would make it unworkable. With
API-based categories of service bits we could implement such a scheme.
-------------------------------------
On Tue, Mar 11, 2014 at 10:23 AM, Gavin Andresen
<gavinandresen@gmail.com> wrote:

Disagree.  It is an unnecessary restriction.  People are already
writing and starting to deploy multisig wallets in the field, that do
not match this assumption.

In general, HD is really cool, but even the barest amount of
infrastructure is lacking.  Popular libraries and the reference client
all lack support.  Building a protocol that assumes HD is optimistic
at this stage.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Just a thought. Using the payment protocol for stealth would mean we
would likely have to return to backing up wallets all the time would it not?

The nonces cannot be derived from your wallet seed and, since they
aren't in the blockchain, would have to be stored in your wallet. I
suppose they could be stored on the server, but you would probably want
a backup for that anyway. So we would end up having to back up all the
time, something we're trying to get away from. Am I correct about this?

On 05/09/2014 02:38 PM, Pieter Wuille wrote:



-------------------------------------
On Wed, Apr 23, 2014 at 2:43 PM, Christophe Biocca <
christophe.biocca@gmail.com> wrote:



If everyone votes to reallocate everyone elses blocks all the time, then
you'd end up losing your own coins too, so this doesn't seem like a
workable strategy.



I'm OK with burning actually. The total amount of coins in the system
essentially defines its maximum price resolution. Ideally we'd not lose
resolution, but it's less important than having a system that does actually
work. Moreover, this sort of system is like double spending defence itself
- if it does work, it doesn't need to actually be done very frequently
because people know the safeguards work and don't try. So in practice total
loss of resolution should be limited.




Right. It's indeed an assumption that block rewards matter to miners, even
the ones that have double spend revenues.
-------------------------------------
Thanks Alex!

About the video - I'm curious how your device is better than just a regular
tablet. Could you give us the elevator pitch? :)

On Thu, Mar 6, 2014 at 3:39 PM, Alex Kotenko <alexykot@gmail.com> wrote:


I guess fees will wander up and down depending on system load rather than
real world value - but maybe you're right. That said, all wallets sync
exchange rates automatically already.

In some Star Trek future, perhaps we would want Bitcoin to be independent
of other value units. But I'm not convinced such a world will ever exist.
Arguably, a stable currency would slowly become worth more over time in
line with economic growth. But then for stable prices you would need
something like a fake currency that was "backed by" (really: represented
by) a basket of goods. Otherwise over time your rent would go up in real
terms, for good real reason.
-------------------------------------
Would it be a terrible idea to amend BIP 70 to suggest implementors include
a "Access-Control-Allow-Origin: *" response header for their payment
request responses? I don't think this opens up any useful attack vectors.

I ask because this would make it practical for pure HTML5 web wallets to
use the payment protocol entirely in-browser. Without this I think it would
be necessary for the server hosting the wallet's HTML to fetch payment
requests on the browser's behalf. This is somewhat inelegant and has
security/resource implications for the back-end.

-Andy
-------------------------------------
You're very quick to point at others. Especially since they run software
that had the time to mature for about 30 years, and the protocol didn't
really change since then...

The last time it didn't work, the bug -- non RFC-conformance -- was on
the bitcoin seeders side. ISPs do weird things with DNS, but usually
they stay within the RFC.

Anyway, without logs we don't have a chance to debug this issue. Any
chance you could add simple logging to the seeder?

DNS via HTTP? Never heard of that, at least it sounds weird as well.


On 05/26/2014 06:37 PM, Peter Todd wrote:




-------------------------------------
On 03/12/2014 04:45 PM, Jean-Paul Kogelman wrote:

Which is better IMO. I can't imagine anyone writing down a long Base58
encoded string.


Not true, BIP39 supports 12/18/24 words (= 128/192/256 bits of entropy).


This is nice addition, indeed. But we needed to limit the data as
possible in order not to increase the number of words needed to be noted
down.


It has a detection. Not correction though.


True, but having one or two solid options are better than having
gazillions of possible options.


True, but they are encouraged to use the list provided. Possibility to
outsource KDF outside of your "standard" breaks much more compatibility
than this.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
Seeing this on one of my public nodes:
2014-07-30 13:13:26 receive version message:
/getaddr.bitnodes.io:0.1/: version 70001, blocks=313169,
us=162.219.2.72:8333, peer=11847
2014-07-30 13:13:33 receive version message:
/getaddr.bitnodes.io:0.1/: version 70001, blocks=290000,
us=162.219.2.72:8333, peer=11848
2014-07-30 13:14:21 receive version message:
/getaddr.bitnodes.io:0.1/: version 70001, blocks=313169,
us=162.219.2.72:8333, peer=11849

That is abusive, taking up public slots.  There is no reason to
connect so rapidly to the same node.

Other seeders are also rapidly reconnect'ers, though the time window
is slightly more wide:
2014-07-30 13:09:35 receive version message: /bitcoinseeder:0.01/:
version 60000, blocks=230000, us=162.219.2.72:8333, peer=11843
2014-07-30 13:12:42 receive version message: /bitcoinseeder:0.01/:
version 60000, blocks=230000, us=162.219.2.72:8333, peer=11846

The version message helpfully tells me my own IP address but not theirs ;p

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Putting the efficacy of coinjoin to one side:

On Mon, Aug 11, 2014 at 1:38 PM, Tim Ruffing <
tim.ruffing@mmci.uni-saarland.de> wrote:



Bear in mind that getutxo does not return the spending transaction - it
can't because the UTXO set doesn't record this information (a spent txo is
deleted).

However, if you have sufficient peers and one is honest, the divergence can
be detected and the operation stopped/the user alerted. If all peers are
lying i.e. your internet connection is controlled by an attacker, it
doesn't really make much difference because they could swallow the
transaction you're trying to broadcast anyway. Ultimately if your peers
think a TXO is spent and refuse to relay transactions that spend them, you
can't do much about it even in the non-SPV context: you *must* be able to
reach at least one peer who believes in the same world as you do.
-------------------------------------
Related:  Current multi-sig wallet technology being rolled out now,
with 2FA and other fancy doodads, is now arguably more secure than my
PGP keyring.  My PGP keyring is, to draw an analogy, a non-multisig
wallet (set of keys), with all the associated theft/data
destruction/backup risks.

The more improvements I see in bitcoin wallets, the more antiquated my
PGP keyring appears.  Zero concept of multisig.  The PGP keyring
compromise process is rarely exercised.  2FA is lacking.  At least
offline signing works well. Mostly.



On Wed, May 21, 2014 at 5:02 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Hello,

I haven't heard of any new issues with either Bitcoin Core 0.9.2rc1 or
0.9.2rc2. This means that it is time to tag 0.9.2 final.

If you have a critical issue that you haven't reported yet please let
me know as soon as possible. If I do not hear anything, I will do a
last-minute language import and tag the release at the end of the
(UTC) day so that gitian builds can be started.

Corrections to the release notes
(https://github.com/bitcoin/bitcoin/blob/0.9.2/doc/release-notes.md)
should also be submitted before then.

Thanks,
Wladimir


-------------------------------------
2014-03-20 17:31 GMT+00:00 Jeff Garzik <jgarzik@bitpay.com>:

​Hmm, in this case I think base43 discussion is irrelevant. Even with best
space utilization we can get ​we will not be able to fit in anything bigger
than a smallest unsigned payment certificate. And that is not so useful. So
probably we should stick with BIP73 approach and bluetooth URI scheme we're
inventing.



-------------------------------------
BtcDrak was working on rebasing my CHECKLOCKTIMEVERIFY patch to master a few
days ago and found a fairly large design change that makes merging it currently
impossible. Pull-req #4890, specifically commit c7829ea7, changed the
EvalScript() function to take an abstract SignatureChecker object, removing the
txTo and nIn arguments that used to contain the transaction the script was in
and the txin # respectively. CHECKLOCKTIMEVERIFY needs txTo to obtain the
nLockTime field of the transaction, and it needs nIn to obtain the nSequence of
the txin.

We need to fix this if CHECKLOCKTIMEVERIFY is to be merged.

Secondly, that this change was made, and the manner in which is was made, is I
think indicative of a development process that has been taking significant
risks with regard to refactoring the consensus critical codebase. I know I
personally have had a hard time keeping up with the very large volume of code
being moved and changed for the v0.10 release, and I know BtcDrak - who is
keeping Viacoin up to date with v0.10 - has also had a hard time giving the
changes reasonable review. The #4890 pull-req in question had no ACKs at all,
and only two untested utACKS, which I find worrying for something that made
significant consensus critical code changes.

While it would be nice to have a library encapsulating the consensus code, this
shouldn't come at the cost of safety, especially when the actual users of that
library or their needs is still uncertain. This is after all a multi-billion
project where a simple fork will cost miners alone tens of thousands of dollars
an hour; easily much more if it results in users being defrauded. That's also
not taking into account the significant negative PR impact and loss of trust. I
personally would recommend *not* upgrading to v0.10 due to these issues.

A much safer approach would be to keep the code changes required for a
consensus library to only simple movements of code for this release, accept
that the interface to that library won't be ideal, and wait until we have
feedback from multiple opensource projects with publicly evaluatable code on
where to go next with the API.

1) https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
2) https://github.com/bitcoin/bitcoin/pull/4890

-- 
'peter'[:-1]@petertodd.org
00000000000000001b18a596ecadd07c0e49620fb71b16f9e41131df9fc52fa6
-------------------------------------
On Wed, Apr 30, 2014 at 7:59 PM, Luke Dashjr <luke@dashjr.org> wrote:


Sorry, that is the names come from the original thread, where I was
outlining the idea.  I updated the names.




The bail in transactions are only signed by one of the parties.  They are
kept secret until the refund/payout transactions are all properly signed.

There is a malleability risk though, hence the need for the 3rd party.

It works on the same refund principle as payment channels.

After TX0 is signed, but before TX2 is signed, either party could


TX0 is not broadcast until the refund transactions are complete.



This is a draft at the moment.

There is an implementation of (almost) this system but not by me.  This
proposal reduces the number of non-standard transaction types required.

A full implement is the next step.



That is a typo, I have updated it.




I can do that.



I wanted it to be as simple as possible, but I guess MIME is just a
different way of doing things.


I would have no objection.


-------------------------------------
There is a discussion about clarifying how BIP70 signs payment requests
here:
  https://github.com/bitcoin/bips/pull/41

The issue is what to do with the signature field before signing. The code
Mike and I initially wrote does this:

    request.set_signature(string(""));

(sets signature to the empty string)

I think that is a mistake; it should be:

   request.clear_signature();

(clears signature field, so it is not serialized at all).

So: if you are implementing, or have implemented, the payment protocol,
please chime in. I'd like to change the spec and the reference
implementation NOW, while BIP70 is still a 'Draft'.

Because this type of "hey, I'm implementing your standard and it doesn't
work the way I think it should" mistake is exactly why BIPs take a while
before being declared 'Final.'


-- 
--
Gavin Andresen
-------------------------------------
What I'm trying to achieve, is to have a very simple way of authenticating
yourself with one Bitcoin address from your wallet.
For most of the people using Bitcoin, their wallet is on their phone.

The UX is clear and simple :
1. click on "connect with Bitcoin" (the audience is normal people)
2. flash the QRcode with your wallet (blockchain.info, mycelium, ...)
3. accept the authentication request (same style than OpenID or Facebook
connect)
4. user is autologged and identified by the chosen Bitcoin public address

It makes sense only if major wallets are supporting the protocol. If you
need to install a plugin or download a third party software, no one will do
it.
I see only benefits for the entire ecosystem, and if I'm working on such a
proposition it is because I really need this feature.

Of course, it can be done without a BIP, I just need to convince wallet
developpers one by one to implement the feature.
But I thought it was much better to start the "official" way, so all wallet
could easily find and implement the same authentication mechanism.


I respectfully disagree. Many services require your Bitcoin address, and to
do that they artificially request an email/password to store it.
This is not about authentication as an identity (as "I'm Eric
Larcheveque"), but as in "I'm proving to you that I control this address".

Without such a standard protocol, you could never envision a pure Bitcoin
physical locker rental, or booking an hotel room via Bitcoin and opening
the door through the paying address.

Eric



On Fri, Apr 4, 2014 at 3:08 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
Can someone explain to these guys and the public why promising to limit
yourselves to *only* a 50% chance of successfully double-spending a 6
confirm transaction is still not acceptable?

q=0.4
z=0	P=1
z=1	P=0.828861
z=2	P=0.736403
z=3	P=0.664168
z=4	P=0.603401
z=5	P=0.550625
z=6	P=0.50398
z=7	P=0.462301
z=8	P=0.424782
z=9	P=0.390828
z=10	P=0.359976
z=11	P=0.331858
z=12	P=0.306167
z=13	P=0.282649
z=14	P=0.261083
z=15	P=0.24128
z=16	P=0.223076
z=17	P=0.206324
z=18	P=0.190896
z=19	P=0.176676


On 07/17/2014 06:59 AM, Melvin Carvalho wrote:


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 11/06/2014 05:26 PM, Peter Todd wrote:> For the same reason we
don't do hard-forking upgrades of basically every


This explanation is completely incoherent.

Because Bitcoin has a extra consensus requirements, requirements which
are really rare in engineering, the necessity of fixing bugs is even
greater.

There are two general ways to fix bugs: either as part of a
controlled, planned, and managed process, or as a response to an
immediate disaster.

The alternative to scheduling and planning the upgrades which are
necessary to fix the bugs in the protocol, where such fixes can be
written, tested, and documented at leisure, is to wait for some crisis
and slap on another bandaid when the network breaks again (like it did
March of last year).

Who benefits from not fixing bugs in Bitcoin?

- -- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-----BEGIN PGP SIGNATURE-----

iQEcBAEBAgAGBQJUXAYVAAoJEMP3uyY4RQ21YxMH/3O+vFK2jDXV5V8IIsJnU/u1
D4gYyVm89E0zmGTyLAUYCJGj0eg5tMyUUzu62hOECOeQuKdVi+mbkLi4TiF0sHIb
8k25MgqJgzH/021eoI2g2w1FrDlZut02LNX/V09+owd1yhp+SEXZ3/+HlqsZXhsv
/u9u5OayzhGlzS6apQtrosl5P+KIquHqIbtwBtPOb2rvlL0miJ6sRcAH2JCXCBDT
HMcswMtIGZbgqL/K7e/6vH7dUWdp0866RZXvt7aWGNUgvxHbGMs+zsnxp4nNslxM
wqL71gTmtMnLcw0GtqmXPjcjo+adrPnqp45xc9lSt23PGjxxfR0FKYIPb2uZdq8=
=9GOY
-----END PGP SIGNATURE-----
-------------------------------------

Sure. I buy this. Although the credit card market is a great example of
what we *don't* want: a stagnant duopoly of trusted third parties who
rampantly abuse their position. So I'd hope we see either (a) nobody really
caring about this BIP because Bitcoin gives good enough double spend
protection or (b) lots of anti-double-spend providers (hundreds seems fine).



No, I will never wait. Neither me nor the merchant wants to me to be
pointlessly hanging around for an hour. The alternative is to pay by credit
card or cash. Outside of experiments there is no such thing as a shop that
only accepts only Bitcoin and will require me to wait for a block because I
didn't use a TTP to guarantee anti-double spends.

So this seems like a fundamental problem to me: having the ability to say,
"here is a proof I won't double spend" is fine, but it doesn't achieve
anything if the merchant would have sold me the goods in return for a
normal Bitcoin tx anyway, which in practice they always will because this
system starts out from zero users and would have to work upwards. I
*especially* will never use this system if I have to pay for it - I'd much
rather just put my money into a wallet that can't generate these proofs and
pay the sticker price.

Maybe what this BIP needs is an extra field that lets the merchant say, I
will give you a discount of X satoshis if you give me a no-double-spends
proof. In other words invert it: the sticker price is what normal Bitcoin
transactions cost, and then your wallet shows you the regular BIP70 price
minus the discount plus the third parties fee as what you finally pay. I
compare it to the sticker price the merchant is asking and if it's lower
I'm happy, and if it's higher my wallet would automatically avoid using the
TTP because I don't want to ever pay more, only less.

The market would then figure out if the fees the TTP charges are worth the
lower losses due to double spending fraud.
-------------------------------------
On 04/07/2014 08:26 AM, Pieter Wuille wrote:

I agree, but if we don't quantify "demand" then we are practically blind. What is the plan? To wait until SPV clients start lagging / timing out because their requests cannot be handled by the nodes?

For all I know, the network would run just fine on 100 nodes. But not knowing really irks me as an engineer.

- Jameson


-------------------------------------
I'm cracking my head for many months with the idea of using TREZOR for web
auth purposes. Unfortunately I'm far from any usable solution yet.

My main comments to your BIP: Don't use bitcoin addresses directly and
don't encourage services to use this "login" for financial purposes. Mike
is right, mixing authentication and financial services is wrong. Use some
function to generate other private/public key from bitcoin's seed/private
key to not leak bitcoin-related data to website.

Cheers,
Marek


On Fri, Apr 4, 2014 at 4:42 PM, Eric Larchevque <elarch@gmail.com> wrote:

-------------------------------------
On Tue, Apr 8, 2014 at 9:13 AM, Angel Leon <gubatron@gmail.com> wrote:

We don't form or need to form a great many connections.


We don't use UDP.


Yes, TCP has a congestion window too, still sometimes some poorly
designed or configured routers suffer from buffer bloat.


Adding our own UDP network stack involving a ton of exposed code
sounds like a great way to gain inadvertent bugs or backdoors.

But there doesn't have to be and shouldn't just be one network
transport for Bitcoin. You can gateway to other protocols and run them
in parallel.  I think it would be great for someone to go build an
alternative transport protocol to gateway to and see what useful
things they can accomplish.


-------------------------------------
You can always use a secure multiparty computation algorithm to do it.

https://en.wikipedia.org/wiki/Secure_multi-party_computation

But those aren't the fastest algorithms in the world, and usually both
participants needs to be online at the same time. I guess most people would
prefer a two-step algorithm that can be performed asynchronously.

- Sent from my phone
Den 8 mar 2014 18:44 skrev "Adam Back" <adam@cypherspace.org>:

-------------------------------------
On Tue, Jul 15, 2014 at 10:23 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:

Couldn't these services return a payment message instead of an address?

I agree that there is currently an UI issue here: there is no way in
current wallets to store a payment message and pay to it later. We
will need something like that for recurring payments as well.

Bitcoin addresses were never designed with extensibility in mind.
Before the payment protocol there have been lots of ideas to add
functionality to them, but the underlying idea that they have to be
handled by users manually means that they have to be as short as
possible, which is a conflicting aim with extensibility...

Wladimir


-------------------------------------
On Fri, Apr 25, 2014 at 10:14 PM, Peter Todd <pete@petertodd.org> wrote:



Removal of isStandard() would be even better/more flexible.

A whitelist of low risk opcodes seems like a reasonable compromise.

My thoughts behind these two BIPs are that they are a smaller change that
adds functionality required for a particular use-case (and some others).

Changing the entire philosophy behind isStandard() is a much bigger change
than just adding one new type.
-------------------------------------
On Fri, Apr 4, 2014 at 9:05 AM, Matt Whitlock <bip@mattwhitlock.name> wrote:

Well, if you're not doing anything homorphic with the result the
computation should probably be over a small field (for computational
efficiency and implementation simplicity reasons) and the data split
up, this also makes it easier to deal with many different data sizes,
since the various sizes will more efficiently divide into the small
field.   The field only needs to be large enough to handle the number
of distinct shares you wish to issue, so even an 8 bit field would
probably be adequate (and yields some very simple table based
implementations).

If that route is taken, rather than encoding BIP32 master keys, it
would probably be prudent to encode the encryption optional version
https://bitcointalk.org/index.php?topic=258678.0 ... and if we're
talking about a new armored private key format then perhaps we should
be talking about Mark Friedenbach's error correcting capable scheme:
https://gist.github.com/maaku/8996338#file-bip-ecc32-mediawiki
(though it would be nicer if we could find a decoding scheme that
supported list decoding without increasing the complexity of a basic
implementation, since an advanced recovery tool could make good use of
a list decode)

I'd think that changing to a small field with a simple implementation,
and encoding the form with encryption, etc. probably makes it distinct
enough from an implementation of ECDSA thresholding that redundancy
isn't a problem.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 07/30/2014 09:50 PM, Alan Reiner wrote:


Before rolling your own service, it might be a good idea to add
Bitmessage integration to provide the P2P communication layer.

Even if you resolved to create such a service without creating any
negative privacy or confidentially side effects, I'd be more inclined
to trust Bitmessage to get that right in the long term, because the
service you'd create isn't your primary product or core competency.


- -- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-----BEGIN PGP SIGNATURE-----

iQEcBAEBAgAGBQJT2ovhAAoJEMP3uyY4RQ21zw4H/3vjcZXP6e0/5IG745PDy/AC
Br1ChlyQjBpU7X9CQfrxDmUUGs7HDrwLjd/SZAV1/PUUXXfE3nDr24hsF8+PlGex
AiZhO7k92xfwRMWxMmcVVt/kuaOldHZUqHDUenT3drJ/bPnV+R3FJ9O6Ougu/YVy
H2BRjpdPGrZx9NP/hE/7evA7rPF8pcshpMBiwq6RiHFdu/+2jcThFZoMIaJsAcif
1vZOzP6vTUKkr3E7tRt5ZQrdb4vvGxX+xMomm8fzPmV3GkpJ/Kyyypx+ovaH74V5
oXXg62XRz4lSziWV5Sp4p/18VjRyUkxwvfXXMt9sW6vNvRDxtJNP8/ZKpkMjO3s=
=ClEd
-----END PGP SIGNATURE-----
-------------------------------------
On Sunday, March 02, 2014 11:02:14 PM Tom Geller wrote:

We've been working on moving the wiki to new hosting, but it isn't a very high 
priority (at least for MtGox). PM SomeoneWeird on IRC, as he is currently 
handling manually approving new accounts for editing.

Luke


-------------------------------------
On Mon, Oct 27, 2014 at 03:33:45PM -0400, Alex Morcos wrote:

I don't have time to look at the details of your statistical methods
unfortunately due to some deadlines, but a quick comment:

You should think about the malleability of your estimates to attackers.
For instance the current fee estimation code has a serious issue where
it'll happily estimate ludicriously high fees based on very little date.
There is a 'insane fees' failsafe, but it's IIRC set to allow
transactions with fees of less than 100mBTC/tx, roughly $50 at current
exchange rates. It's relatively easy to get a wallet into a condition
where this happens as the estimations are considered valid even based on
very little data - a simple sybil attack suffices. (e.g. the recently
published paper(1) on Tor sybil attacks comes to mind as one example of
many ways to do this) Obviously this could empty someone's wallet pretty
quickly; an exchange that makes a few dozen transactions an hour could
easily lose tens of thousands of dollars due to this exploit. Someone
correct me if I'm wrong, but last I checked in git HEAD this exploit is
still unfixed.

A user-configurable failsafe limit is a pretty obvious solution here,
albeit a crude one; it'd be interesting to see if a plausible security
argument could be made for something more sophisticated, like taking
into account coin-age of observed transactions that estimates are based
on.

1) "Bitcoin over Tor isn't a good idea",
   http://arxiv.org/abs/1410.6079

-- 
'peter'[:-1]@petertodd.org
0000000000000000098d3c9095b47ff1fd692fef5ac6731340802c7c63d38bb0
-------------------------------------
How can there be any kind of lottery that doesn't involve proof of work or proof of stake? Without some resource-limiting factor, there is no way to limit the number of "lottery tickets" any given individual could acquire. The very process of Bitcoin mining was invented specifically to overcome the Sybil problem, which had plagued computer scientists for decades, and now you're proposing a system that suffers from the same problem. Or am I wrong about this?


On Monday, 16 June 2014, at 1:12 am, Odinn Cyberguerrilla wrote:



-------------------------------------
To each his own, but if I say "Please don't charge me for YOUR privacy
by putting junk like stealth addresses in the blockchain", I think I'd
get laughed out of most rooms.

Either the transaction fees are sufficient to pay the cost for whatever
random junk anyone wants to put there, or they are not, and if they are
not, then I suggest you re-think the fee structure rather than trying
to pre-regulate me putting 80 character pithy quotes in the blockhain.


On Mon, Feb 24, 2014 at 09:23:12AM -0800, Mark Friedenbach wrote:

-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
When I asked a non-tech friend to do a BIP 70 payment using our wallet as a first round of user experience testing, he made the remark the he wanted to do a payment to a merchant, but instead our software shows a payment to BitPay, Inc.

This can be problematic for a couple of reasons:
- As a user you dont need to know and trust individual payment processors. As long as you can identify and authenticate the merchant, you should be able to rely on the merchants choice for a payment processor.
- An attacker can become a client of a payment processor, use it to create a PaymentRequest message and send this message to a victim as part of a MITM attack; the victim now thinks he is paying a merchant through the payment processor, but is actually paying the attacker through the payment processor.

I have a proposal that can be transformed into a BIP or into an extension of BIP 70 and adds a way to include merchant identity in the PaymentRequest message and Id like to see a discussion on this topic.

At this moment, the PaymentRequest message contains a pki_data field with a certificate chain to authenticate the entity that generates the message, which in the above case is the payment processor.

Im proposing to extends the PaymentRequest message with three more fields:
- payee_pki_type
- payee_pki_data
- payee_mandate

The payee_pki_type and payee_pki_data fields can be of the same format as the pki_type and pki_data fields, except that they authenticate the identity of the merchant, instead of the identity of the payment processor. The payee_mandate fields contains a claim by the merchant, signed using his own private key, that he grants the payment processor the right to collect the payment on his behalf.

The solution is backwards compatible, since existing wallets can ignore these fields. They will not show the identity of the merchant, but keep showing the identity of the payment processor, they are still able to verify the signature in the PaymentRequest message and therefore can complete the payment process.

A wallet that understands this extension, needs to check the validity of both certificate chains when present and also the validity of the mandate. If all is fine, it can now show the identity information from the merchant certificate instead of (or besides) the identity of the payment processor and allow an end user to correctly identify the merchant.

A payment processor supporting this extension may offer it as an optional service to clients. A client that wishes to use this extension needs to obtain his own certificate from a CA and use it to sign a mandate. One potential obstacle is that this process probably needs to be repeated both when the certificate of the merchant or the certificate of the payment processor expires, but we may be able to address that when defining the format of the mandate.

/Mark

-------------------------------------
On Tuesday, July 15, 2014 3:11:25 PM Jeff Garzik wrote:

https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#Serialization_format


There's no reason deposits cannot use a unique payment request or address 
every time...


-------------------------------------
On Wed, Jan 15, 2014 at 05:02:10PM -0800, Jeremy Spilman wrote:

Agreed.


Well only a linear increase, which is not any kind of realistic security
defense for even an academic researcher analysing flows.  More concern is
that it could be expensive enough discourage adoption by full-nodes as an
open/free service to support SPV clients in finding their reusable address
payments.  Its possibly an I/O DoS multiplier: send requests to the full
nodes at a moderate network rate and and watch as its disk thrashes.


Its not a decision with user localised effect.  If most users use it with
parameters giving high elimination probability, that affects everyone else's
privacy also.  Also statistical effects are accumulative as more plausibly
related addresses are eliminated at each potentially linked transaction.  I
think once the network flow analysis guys are done with incorporating it,
and if reusable addresses saw significant use, my prediction is the result
will be pretty close to privacy game over and it will undo most if not all
of the hard-won privacy benefit of CoinJoin.  (Recalling CoinJoin is only
adding a bit or two of entropy per join, this elimination effect could
easily undo more than that).


The point of the stealth security objective is to avoid creating a new and
smaller anonymity set.  If all reusable addresses are easily recognizable as
reusable, thats far more revealing and useful to the network flow analysis.

Adam


-------------------------------------
I haven't done the math on this, so it may be a terrible idea. :)
I've been wondering if block propagation times could also be improved by allowing peers to request the list of transaction hashes that make up a block, and then making a follow-up request to only download any transactions not currently known. I'm not sure what percentage of transactions a node will usually already have when it receives a new block, but if it's high I figure this could be beneficial.

 		 	   		  
-------------------------------------
Does anyone see a value in a standardized PGP-style message,
which would allow someone performing a bitcoin transaction to
send signed encrypted messages using only public and private
bitcoin keys ?

I'd like to propose a signed encrypted message protocol, in case
someone see's value in encoding such a thing into a BIP.
-------------------------------------
Relocating this conversation to the dev list. Feedback / continued 
discussion welcome.

https://github.com/bitcoin/bitcoin/issues/3624


-------------------------------------
Same here.

I feel incredibly lucky to know some of you, and to be able to contribute in some small way to what this is ultimately becoming. It's been an amazing ride, and I'm pretty sure that 2014 is going to totally blow our minds.

-wendell

hivewallet.com | twitter.com/hivewallet | pgp: B7179FA88C498718

On Jan 1, 2014, at 1:33 PM, Mike Hearn wrote:




-------------------------------------
On Mon, Feb 10, 2014 at 12:47 PM, Tier Nolan <tier.nolan@gmail.com> wrote:
MtGox had a php script that returned base64 data for all their stalled
transactions.

Not just attackers used that, some people trying to unstick their
transactions tried manually fixing them with honest intent and no idea
it would potentially confuse mtgox's software.


-------------------------------------
a million thanks for this FYI

http://twitter.com/gubatron


On Thu, Jul 3, 2014 at 11:56 AM, Gavin Andresen <gavinandresen@gmail.com>
wrote:

-------------------------------------
On Sat, Apr 26, 2014 at 7:29 PM, Kristov Atlas
<author@anonymousbitcoinbook.com> wrote:

I've fixed the issue; at least on Debian 6 - which is a lot more
conductive to development than tails :-). See
https://github.com/bitcoin/bitcoin/pull/4094 for the gory details. New
test build available:

https://download.visucore.com/bitcoin/linux-gitian-3cbabfa.tar.gz
(sigs: https://download.visucore.com/bitcoin/linux-gitian-3cbabfa.tar.gz.sig
)

Wladimir


-------------------------------------
On 6/16/2014 8:48 AM, Mike Hearn wrote:

I have trouble seeing how could the real-time anonymous payments market 
can be cleanly separated from everything else.  If trusted third parties 
become the norm for that market, there will inevitably be a huge overlap 
effect on other markets that bitcoin can serve best, even today.  I 
don't see how any currency, any cash, can concede this market.



-------------------------------------
On Sat, Mar 22, 2014 at 02:53:41PM +0100, Jorge Timn wrote:

Well remember that my thinking re: UTXO is that we need to move to a
system like TXO commitments where storing the entirety of the UTXO set
for all eternity is *not* required. Of course, that doesn't necessarily
mean you can't have the advantages of UTXO commitments, but they need to
be limited in some reasonable way so that long-term storage requirements
do not grow without bound unreasonably. For example, having TXO
commitments with a bounded size committed UTXO set seems reasonable; old
UTXO's can be dropped from the bounded sized set, but can still be spent
via the underlying TXO commitment mechanism.


Like I said the real issue is making it easy to get those !IsStandard()
transactions to the miners who are interested in them. The service bit
flag I proposed + preferential peering - reserve, say, 50% of your
peering slots for nodes advertising non-std tx relaying - is simple
enough, but it is vulnerable to sybil attacks if done naively.


Right, but there's also a lot of the community who thinks
proof-of-publication applications are bad and should be discouraged. I
argued before that the way OP_RETURN was being deployed didn't actually
give any reason to use it vs. other data encoding methods.

Unfortunately underlying all this is a real ignorance about how Bitcoin
actually works and what proof-of-publication actually is:

    14-03-20.log:12:47 < gavinandresen> jgarzik: RE: mastercoin/OP_RETURN:
    what's the current thinking on Best Way To Do It?  Seems if I was to do
    it I'd just embed 20-byte RIPEMD160 hashes in OP_RETURN, and fetch the
    real data from a DHT or website (or any-of-several websites).
    Blockchain as reference ledger, not as data storage.


I think we're just going to have to agree to disagree on our
interpretations of the economics with regard to attacking merge-mined
chains. Myself, I'm very, very wary of systems that have poor security
against economically irrational attackers regardless of how good the
security is, in theory, against economically rational ones.

Again, what it comes down to in the end is that when I'm advising
Mastercoin, Counterparty, Colored Coins, etc. on how they should design
their systems I know that if they do proof-of-publication on the Bitcoin
blockchain, it may cost a bit more money than possible alternatives per
transaction, but the security is very well understood and robust. Fact
is, these applications can certainly afford to pay the higher
transaction fees - they're far from the least economically valuable use
of Blockchain space. Meanwhile the alternatives have, at best, much more
dubious security properties and at worse no security at all.
(announce/commit sacrifices is a great example of this, and very easy to
understand)

-- 
'peter'[:-1]@petertodd.org
0000000000000000bbcc531d48bea8d67597e275b5abcff18e18f46266723e91
-------------------------------------
Hmmm, not for me:

$ nslookup bitcoin-seed.alexykot.me
Server:		127.0.1.1
Address:	127.0.1.1#53

** server can't find bitcoin-seed.alexykot.me: SERVFAIL

$ nslookup testnet-seed.alexykot.me
Server:		127.0.1.1
Address:	127.0.1.1#53

** server can't find testnet-seed.alexykot.me: SERVFAIL


Can you look up in the logfile what requests I just made?



On 05/21/2014 01:10 PM, Alex Kotenko wrote:




-------------------------------------
‎The reason it is in fact wanking is because pgp tried to solve a problem that can't be solved.
It tried to provide distributed trust to a system of identity, while still depending on the local government (i.e centralized) for the upstream ID...

It's a marriage that has no benefit.

What we really want is (decentralized) identity management that allows me to create a new anonymous ID and use that as something more secure than trusting a behavior pattern to proof it's me. 

Sent on the go. Excuse the brevity.
  Original Message  
From: Brian Hoffman
Sent: 15:35 mandag 15. september 2014
To: Jeff Garzik
Cc: Thomas Zander; Bitcoin Dev
Subject: Re: [Bitcoin-development] Does anyone have anything at all signed by Satoshi's PGP key?

I would agree that the in person aspect of the WoT is frustrating, but to dismiss this as "geek wanking" is the pot calling the kettle. 

The value of in person vetting of identity is undeniable. Just because your risk acceptance is difference doesn't make it wanking. Please go see if you can get any kind of governmental clearance of credential without in-person vetting. Ask them if they accept your behavioral signature. 

I know there is a lot of PGP hating these days but this comment doesn't necessarily apply to every situation. 






-------------------------------------
The Bonneau's Kickbacks problem is interesting because it is a
destabilizing incentive.
Just by luck yesterday I was working on the same problem. I found a way
to prevent Kickbacks and provide a conflict resolution strategy that
benefits all member of the network.
I will repost my blog post here, but the original has very nice diagrams
and is full of hyperlinnk, so I recommend you see the original post...

Even faster block-chains with DECOR protocol

One of the most interesting papers ever written about the Bitcoin
block-chain design is Accelerating Bitcoins Transaction Processing by
Sompolinsky and Zohar. The paper presents the GHOST protocol which aims
to achieve higher TPS securely by changing the way nodes decide which is
the best chain fork. One of the issues that is not considered by the
paper is the existence of a selfish bias independent of the miners
hashing power. When a miner solves a block, and a competing block is
also received, the miner will mine on top of his own solved block. This
is not only a consequence of the best-chain selection policy, there is a
strong incentive to do so. By mining on top of your own solved block,
you double the expected reward while keeping the same winning
probabilities. As a informal comparison, in Satoshis security model,
the rogue miner is irrational and malicious. For example, the
confirmation interval computations assume a rogue miner having 10% of
the network hashing power will try to mine a selfish chain in order to
try to outperform the global best-chain even if the odds are against
him. In Sopolinky/Zohar security model, the miners are rational, but use
a sub-optimal strategy. For example when two blocks compete, all miners
will chose one of them arbitrarily (all choose the same block). Although
this may be optimal for a fully cooperative network its not what miners
will optimally choose for themselves. In Eyal/Sirer security model, the
rogue miner is rational and uses an strategy believed by the authors to
be optimal.
In this post we improve Sopolinky/Zohar model assuming the attacker uses
Eyal/Sirer selfish strategy and the standard double-betting strategy.

Double-betting Strategy by Default

The double-betting is a mining strategy pre-programmed in the in Satoshi
reference miner. When a miner mines a block and a competing block is
also detected, the miner wont switch to the other chain because is has
the same length, so mining will continue on the selfish fork. Of
course there is nothing inherently selfish with this strategy since the
miner has not enough information about which of the two forks is the one
which the majority of the miners are mining on top of. Nevertheless the
division of hashing power in forks is against the common good and
reduces both the network TPS and the network confirmation time.

Tit for Tat and identities

If the two competing miners could detect the other miners identity in
blocks, they could apply a cooperative strategy like Tit for Tat.
Whenever two competing blocks are found by two miners without having any
previous interaction, the conflict is resolved by both miners mining on
top of the block with lower hash digest. If the two miners have
interacted before, the conflict is resolved by both miners mining in the
block that was solved by the opposite miner chosen in the previous
interaction. If a miner acts selfishness and breaks the ties, then the
other miner opts to apply an equivalent retaliation in the next block
conflict. The retaliation is only considered successful if the miner who
retaliates wins the ties. This strategy may in practice for at least
four reasons:

Sometimes a miner may solve two blocks in a row without noticing that
the first one had a conflicting sibling. Then the competing miner would
retaliate.
If more than two miners are competing, its more complex to decide which
block should be chosen as parent.
All miners must dynamically maintain information of all previous
interactions between all other miners.
Some miners want to preserve anonymity and wont publish identifying
information.

The first two reasons can be disregarded since the conflicting events
may have a very low probability. The third is only a minor technical
difficulty. But the last reason may be very strong.

DECOR (DEterministic COnflict Resolution)

I present here a reward strategy I called DECOR that incentives
resolving conflicts in a deterministic way that benefits all conflicting
miners at the same time. This strategy practically eliminates any
possibly block-chain reversal when miners are rational. To make this
explanation clearer well assume that all block rewards and fees are
equal so each miner receives exactly the same net payment for a block.
Also the reward percentages proposed can be varied as long as some
relations between are maintained. The idea is that whenever two miners
Alice and Bob mine two competing blocks (a block conflict) both decide
to mine on top of the block with the lower hash. First, all conflicting
blocks headers that are not very old are forwarded to allow all peers to
compare block hashes. If a miner Carol (or Alice or Bob) solves a
following block, she includes in his block a reference to the uncle
block header that was left out of the main chain. This reference is
stored either in the block header, the coinbase field or in a special
transaction. The uncle block owner will get automatically 50% of the
reward of his main-chain sibling if uncle hash is higher than sibling
hash or 35% if not. The sibling also pays a 10% to Carol. Also the
sibling burns 10% if the uncle hash is higher than the sibling hash or
35% if not. This strategy sets incentives for conflicting miners to
choose always the parent with the lowest hash and to always reference a
lost uncle in the following blocks.

Mining strategy:

If there is no block Y having a sibling X in the main chain whose reward
has not matured then mine in the standard way and exit this procedure
Add a reference to Y in the new block that is being prepared.
Let x := BlockRewardPlusFees(X)
Let q := x*0.5
Let z :=x*0.1
If Hash(X)>Hash(Y) then q :=q-(x*0.2) and z :=z+(x*0.2)
Add a transaction that has as input the coinbase output of X and has
four outputs: the first output pays q coins to the address specified in
the coinbase output of block Y, the second output pays (x*0.1) coins to
an owned address, the third output burns z coins, and the forth output
pays the remaining coins to the same address as the input address. All
users accept this transaction as valid even if its unsigned if a
correct uncle is referenced.

The following diagrams show an example of how two miners Alice and Bob
will prefer mining on top of the same parent (A1) after a block A1
(created by Alice) is in conflict with a block B1 created by Bob. Carol
is a third miner that is not in conflict with neither Alice nor Bob. In
the diagrams the first letter indicates who created the block and the
number following indicates the block height. The arrows point to each
block parent.Bob-op


Although Im giving no formal proof, Its evident that the best strategy
for Alice and Bob is to choose the same parent for the following block.

GHOST+DECOR

The DECOR strategy can be implemented along with the GHOST protocol. In
fact both protocols have things in common, such as the need to forward
block headers that are siblings of blocks in the best chain. Using both
protocols together, along with route optimizations proposed here, maybe
2000 TPS can be achieved today.



Best regards,
Sergio.


-------------------------------------
Thanks for all the feedback, and for everyone who read through the docs.  

My BIP numbering was a blunder, and I have revised the numbering to be PCP-0 (Paper Currency Proposal Number 0) through PCP-4.   I think I was brain-dead on that, sorry, and I am now on PCP.



Please allow me to walk you through my thought process on Paper Currency, if you aren't sold that there's merit.

At present time, paper currency undeniably serves a major purpose in society and has a huge value.  Whether all-digital transfers can totally replace paper is still unknown.

And we citizens currently pay a lot to create paper money that is hard to counterfeit.  That too has tons of value, and it can be measured by looking at how much is spent to design, print, and protect fiat currencies from counterfeiting.  And you can add to that cost the societal costs of successful counterfeiting.  US Numbers exceed $800M annually, and are a fraction of the worldwide numbers.

And travelers routinely pay currency exchange fees, to acquire paper currency that is accepted in particular locales.  So a single internationally accepted, border-less paper currency would have high value, as it could potentially eliminate exchange fees for travelers.

Add all the above costs together, and you can see that this is a multi-billion dollar market that Bitcoin could disrupt.   We could actually eliminate all of those costs, while at the same time put Bitcoins into the hands of people in a form that is more familiar.

That's why this feels like a huge need that can be satisfied by creating a single standard for hard-to-counterfeit, cheap to print, paper currency.    I think the key is a "single standard" that the public recognizes.



I think that there are things that you can do with paper now that can't be done with all-digital transfers.  Maybe my perspective is too US-centric due to tipping customs, but it seems much easier to rapidly leave money for someone without their involvement via paper than digital transfers ever will be.   

A recent video showed a stripper/dancer stop dancing and pose to have her QR Tattoo scanned for payment.  (Not that this is all about strippers and PCP, but...) paper would be a much more practical medium than digital transfer in a lot of scenarios.  
http://blogs-images.forbes.com/kashmirhill/files/2014/05/Bitcoin-stripper-QR-code.jpg 
If you think about it, whether you slipped her a Bitcoin Paper note or digitally transferred payment to her QR code, in neither case is she able to verify receipt of payment until she steps off stage.  But remember, we're typically talking about a buck or ten or twenty, not 3 bitcoins as shown in the video!



I saw a Reddit or bitcointalk comment, I believe credited to Mike Caldwell, saying that the author envisioned transactions where the buyer simply handed over private keys (paper wallets), and the merchant had all the electronics.  Reducing the electronics necessary for transfers seems to be desirable.  Should I have to carry a $300 cell phone to be able to carry and spend $20?  This would be moot if 100% of people had their electronic devices with them 100% of the time they need to spend money, and the device is 100% reliable.  I know for me that's not the case.

So, if the currency medium of paper has value, and Bitcoin can make paper currency more counterfeit-proof, and Bitcoin can eliminate costs, and it's a huge market, and the public is familiar with the paper paradigm, all that's left is for the community to come up with a standard.  That's why I took a crack at it, but I certainly welcome improvements!

Questions: 
1)  Is paper a valuable medium for currency?  I contend yes.  
2)  What's the proper tradeoff between convenience and security for paper Bitcoin Notes?  I opted for splitting the private key over two QR codes on opposite sides of the page, as opposed to BIP-38, and I explained my rationale in the documents.

The rest of the technical details (the splitting algorithm, for instance) need to be resolved.  But I took a crack at it.
And the marketing details (note size, shape, color, layout, text, do we call them "Bits", etc.) all need to be resolved.  again, I gave it my best effort, but I'm quite certain the community can do better than me!


First step, though, is to determine whether there's consensus to define a standard for paper bitcoin currency.



Thanks for hearing me out! 
Docs are here:   
https://github.com/jerfelix/provisional_bips/blob/master/README.mediawiki 



 		 	   		  
-------------------------------------
On 6/19/2014 12:58 PM, Sergio Lerner wrote:
Why do you want to punish pools?


-- 
Kevin

-------------------------------------
On 17/06/14 11:46, Wladimir wrote:

Under Ubuntu 10.04:

jcea@ubuntu:/tmp/bitcoin-0.9.2-linux/bin/64$ ./bitcoin-qt
./bitcoin-qt: symbol lookup error: ./bitcoin-qt: undefined symbol:
_ZN10QTextCodec11validCodecsEv

-- 
Jess Cea Avin                         _/_/      _/_/_/        _/_/_/
jcea@jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/
Twitter: @jcea                        _/_/    _/_/          _/_/_/_/_/
jabber / xmpp:jcea@jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/
"Things are not so easy"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/
"My name is Dump, Core Dump"   _/_/_/        _/_/_/      _/_/  _/_/
"El amor es poner tu felicidad en la felicidad de otro" - Leibniz

-------------------------------------
On 05/17/2014 02:02 PM, Alex Kotenko wrote:


Yes, that's my understanding too.


Yes, definately.


Afaik this is what most of the other seeds are using, yes.


Sound great! Let me know if you've got something to test.




-------------------------------------
On Sat, Mar 15, 2014 at 09:43:40AM -0400, Peter Todd wrote:

Also, for those who don't know the history of python-bitcoinlib, credit
where credit is due: my fork is based on Jeff Garzik's implementation(1)
and the bulk of the code structure is his work, modulo "pythonizing"
that I have done.

1) https://github.com/jgarzik/python-bitcoinlib

-- 
'peter'[:-1]@petertodd.org
000000000000000090aa23d86521312897686912946b38e93a71a98a8c287d4a
-------------------------------------
You must be new here. MtGox very rarely comments on things like this publicly, outside of irc or their website. 

Second, MtGox problem is a MtGox problem. You have no right to demand access to their private code. If you feel wronged as a customer, sue them. Otherwise, they have no obligation to you.

I believe you are "barking up the wrong tree".

Respectfully,

Nick

On February 10, 2014 10:14:02 AM CST, Troy Benjegerdes <hozer@hozed.org> wrote:
-------------------------------------
I do think we need to move beyond this idea of Bitcoin being some kind of
elegant embodiment of natural mathematical law. It just ain't so.

Every time miners and nodes ignore a block that creates >formula() coins
that's a majority vote on a controversial political matter, as evidenced by
the disagreement with mainstream economics and that it's one of the most
common things for alt coins to change. Indeed Satoshi's chosen inflation
formula is a highly political statement on the value of inflation - he
could have programmed Bitcoin to inflate forever and avoided a whole area
of politics, but he chose not to.

So please, let's agree to accept that Bitcoin is ultimately just a piece of
software that encodes rules helping us run our little community in some
specific ways. It's not physics and we should believe our own hype by
pretending it is.

On Mon, Apr 28, 2014 at 11:41 PM, Adam Back <adam@cypherspace.org> wrote:


It's the other way around. If miners decide to fork the chain then that
leaves no proof (beyond the old blocks, which could have been a natural
fork - there's no way to know - and nodes don't want to keep them around
anyway). If they explicitly vote to get the same effect but without
actually forking, it leaves a proof in the form of the votes in the
coinbase that can be seen afterwards.




It only works if the majority of hashpower is controlled by attackers, in
which case Bitcoin is already doomed. So it doesn't matter at that point.
-------------------------------------

The use of any 'prefix' is one of choice and entirely unnecessary, and there
are already established 'divisions' in u/mBTC for those that feel they need
to use such things.


Exceptionally unlikely - I deal every day with currencies with 0, 2 and 3
dp's in amount ranging from 'under 1 whole unit' to tens of thousands - Not
once in 20 years has anyone ever 'sent' more or less than intended - oh,
they've 'intended' to underpay just fine, but never *unintended*.


I propose that for people unable to understand what a bitcoin is, they can
just use satoshi's and drop this entire proposal.

Rob



-------------------------------------
On Thu, Jan 16, 2014 at 7:26 AM, Gary Rowe <g.rowe@froot.co.uk> wrote:


Simple and clear, I like it too.

I see the term is routing is used in finance in the USA, but as a Dutch
person I associate "routing address" with network routing, not with
banking. It's non-trivial to translate to a local term.

Wladimir
-------------------------------------
On Sat, Aug 23, 2014 at 8:17 AM, Troy Benjegerdes <hozer@hozed.org> wrote:

Note that we're generally aiming (though not yet enforcing) to have
merges done through the github-merge tool, which performs the merge
locally, shows the resulting diff, compares it with the merge done by
github, and GnuPG signs it.

That allows using github as easy-access mechanism for people to
contribute and inspect, while having a higher security standard for
the actual changes done to master.

-- 
Pieter


-------------------------------------
40 bytes is small enough to never require an OP_PUSHDATA1, too, which will
make writing the OP_RETURN-as-standard BIP simpler.


On Mon, Feb 24, 2014 at 11:39 AM, Wladimir <laanwj@gmail.com> wrote:




-- 
--
Gavin Andresen
-------------------------------------
On Thu, Mar 20, 2014 at 8:12 AM, Adam Back <adam@cypherspace.org> wrote:

Extremely limited.  Preferably under 100 bytes.  You will see
increasingly poor operating in varying light conditions, such as
paying via QR code on a printed receipt in a pub at night.  That was
one of the motivations for BIP 73.


On Thu, Mar 20, 2014 at 4:09 AM, Andreas Schildbach
<andreas@schildbach.de> wrote:

Yes.  Internet connectivity is not a rarity these days.  Near-field
web servers also work fine.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Does r[]= really need to be encoded as r%5B1%5D= ? In this case, I'd
advocate for a simple array parameter name, like rs= ("plural" of r).
Length really does matter for QR codes.

I'm fine with either multiple r= params or exactly one r= plus zero to
many r[]= params. Although I think it is a violation of the (current)
spec to choke on more than one r= parameters, I admit that bitcoinj is
currently implemented that way. (We could however fix this in a
maintenance release.)

However, r= should also allow all other protocols, exactly like any of
the r[]= params. I don't think we should do a distinction here. Also
because of backwards compatibility to the status quo.


On 07/01/2014 03:03 PM, Alex Kotenko wrote:




-------------------------------------
I don't know about financial software.

I really don't get what you mean by weird notation? Bitcoin Wallet is
made for ordinary users. They are used to real-world prices like EUR
1.63 / USD 2.26 (that would be the Espresso example). How can mBTC 3.56
be weird to these people?

Granted, there are exceptions, like in Japan. Maybe those would be
better served with µBTC as default. Maybe. Up to now, outside of this
mailing list nobody requested µBTC. Then again, Japanese userbase is
tiny compared to US.


On 03/14/2014 04:12 PM, Tamas Blummer wrote:




-------------------------------------
The spec has been updated a bit.

Even if the bulk of the key-stretching work has been outsourced to another
device, and that device is compromised, the passphrase is now protected by
minimum 8192 rounds of salted PBKDF2-HMAC-SHA512.

The idea is that more powerful devices (mobile phones, laptops, etc.) can
do all the key-stretching on their own, whereas weaker devices with access
to another device with more computing power (like Trezors) do a fair amount
of key-stretching on their own, but can safely export the rest of the
key-stretching to the other device.

Will

On Tue, Mar 11, 2014 at 10:17 PM, Jean-Paul Kogelman <
jeanpaulkogelman@me.com> wrote:

-------------------------------------
Let's keep fund raising off this mailing list, please.  PS bounties don't
work.


On Tue, Jan 28, 2014 at 1:08 AM, Odinn Cyberguerrilla <
odinn.cyberguerrilla@riseup.net> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------------------------------
On Mon, Apr 21, 2014 at 01:30:28AM +0000, Jonathan Levin wrote:

CC'ing bitcoin-research - may be more appropriate to move the discussion
there as this discussion is delving into future scenarios.


They're probabilistic; mining is progress free so per unit hashing power
every miner has an equal chance of finding a block. As for resolution,
well, currently nodes (and miners) mine on the block they saw first; if
they learn about another block at the same height they stick to the
block they are already mining on. First seen at same height is probably
generally economically rational as the first block you see probably
propagated to the most nodes, although tweaks to that are probably
possible.


Not at all, in fact mining on top of the block is the best thing to do
because it *prevents* your block from ending up as an orphan. Basically
imagine I find block b1a, and you find conflicting block b1b. What I
need to do is find block b2a, which is on top of b1a, before you find
block b1b to avoid my block being orphaned. The best way to do that is
mining on top of my block - that's what's most rational for me.


Sure thing.



So looking at the replies your post got in the past few days it looks
like there's some misinformation going around. First of all is the
question of how harmful it is if miners mine on top of blocks that they
haven't actually validated, and yes, that's extremely harmful. For
instance if I were an attacker I could mine an invalid block that makes
coins out of thin air and use it to defraud SPV-wallet-using clients;
everyone who is mining without validating is helping me succesfully pull
off that attack by increasing the chance I'll get enough confirms to
trick my target into thinking the coins are real. (remember I could have
stolen the hashing power by hacking into a pool)

Mark Friedenbach suggested headers first where the block header and
block contents are propagated around the network separately. What that
results in has a few different scenarios:

1) Fee's don't matter and miners aren't forced to validate

This is the scenario we're in right now. The block reward comprises the
supermajority of mining income, and it is possible to mine a block
without first validating the contents of the previous block. When a
miner receives a block header that extends the longest known blockchain
they can immediately switch to it and start mining.

Whether or not doing so is rational is just a matter of what's the
probability that the previous block was invalid? If it was, the miner
mining it just wasted 25BTC, $12.5k, so you can be almost sure it is
valid and you don't need to wait. Of course, if you then find a block,
you can pull the same trick all over again and the next guy might be
mining on top of two blocks they haven't validated, and so on.

Obviously this presents a very nasty failure mode if the majority of
miners follow this behavior and a block is invalid, or even just gets
lost. Similarly in the majority scenario there's no direct incentive to
actually propagate your blocks - they'll still get accepted to the main
chain anyway.

That said, small and large miners make roughly the same amount as the
block reward dominates and blocks of any size will get confirmations
fairly quickly.


2) Fee's do matter and miners aren't forced to validate

Now transaction fees represent a non-trivial portion of a miner's
income. Centralization incentives would depend on to what extent fees do
matter. Again, there's some nasty failure modes possible. That large,
slow-to-propagate blocks still get confirmed, yet small miners can't
mine transaction fees is likely a major centralization incentive.

3) Miners are forced to validate

Or at least, we can force miners to actually have the previous block.
Andrew Miller's Permacoin is one approach; some varients of UTXO
commitments have this as a side-effect too. On the one hand this solves
the really nasty failure modes that headers-first has; on the other hand
you're back to the centralization incentives we have right now.


What's important however to remember is that any attempt at saying
things like "[A]s soon as [Miners] receive and process the contents of
block A, they switch to that." - as Mark suggested(2) - doesn't belong
in an economic analysis as such rules are unenforcable. For instance
that'd suggest that in the forced-validation headers-first scenario a
large miner who received a block header, then found block themselves,
would switch to mining the block they *didn't* find simply because they
"got the header first". Obviously this is not economically rational for
them to do so they won't, leading to the same centralization incentives
as always.

As for why that's economically irrational: so the large miner finds that
second block and broadcasts it around the network. Do you the small
miner keep mining on the shorter chain just because the large miner
broke the gentlemans agreement to respect header times? Of course not,
time is relative and you have no idea whether or not anyone else is
doing so. If you mine on the shorter chain you're side is going to need
to find two blocks to catch up - not likely. Secondly you risk forking
the network due to a consensus failure, say by a divergent times the
headers were received.

1) http://cs.umd.edu/%7Eamiller/permacoin.pdf

-- 
'peter'[:-1]@petertodd.org
0000000000000000278031f86c71265f6eaf1fe9ce6cc831dc4f956676a7a7f7
-------------------------------------
It cannot, it is just data.

Wladimir
-------------------------------------


Yes, I know you rejected this design, which is why I'm now proposing it
instead. I think you made the wrong design call, but at any rate, it's
something reasonable people can disagree on.

Payment messages are sent directly to the merchant, who takes
responsibility for broadcast. Once you delivered transactions to the
merchant successfully, from your perspective the payment is made. A good
store and forward network doesn't allow messages to go missing - email is
an example of that (ignoring spam filters that explicitly want messages to
go missing). It either gets delivered or it doesn't. So I'm not worried
about atomicity.
-------------------------------------
On Sun, Jul 27, 2014 at 7:54 PM, mbde@bitwatch.co <mbde@bitwatch.co> wrote:

As I pointed out above, — it isn't really.  Without the exit flag, I
believe no tor node will select it to exit 8333 unless manually
configured. (someone following tor more closely than I could correct
if I'm wrong here)



dsnrk and mr_burdell on freenode show that the bitnodes crawler showed
it accepting _inbound_ bitcoin connections 2-3 weeks ago, though it
doesn't now.

Fits a pattern of someone running a bitcoin node widely connecting to
everyone it can on IPv4 in order to try to deanonymize people, and
also running a tor exit (and locally intercepting 8333 there),  but I
suspect the tor exit part is not actually working— though they're
trying to get it working by accepting huge amounts of relay bandwidth.

I'm trying to manually exit through it so I can see if its
intercepting the connections, but I seem to not be able.

Some other data from the hosts its connecting out to proves that its
lying about what software its running (I'm hesitant to just say how I
can be sure of that, since doing so just tells someone how to do a
more faithful emulation; so that that for whatever its worth).


-------------------------------------
An IOU written in a gold plate sure makes no sense. I see what you are
saying, the inconvenience comes from the fact that the buyer has to buy
some amount of BTC at the same time as he buys a share.

That's why I was making the point that you could have a colored coin
representing a single share, a different colored coin representing 10
shares, and another one representing 100 shares (like the different
denominations of dollar bills). Assuming you have a proper application
layer/UI that can hide this from the user, the need for padding is greatly
reduced. My opinion is that the protocol should do the minimum required and
remain as simple as possible. If a proper UI can work around this, then it
might not be worth complicating the protocol for this. Also, the dust rule
may disappear all together one day (it's already been slashed heavily to
540 satoshis), at which point we'll be left with a useless padding
parameter. It's easier to add something when you need it than to remove it.

But I am posting here to see how people feel about this, and I see you are
on the opinion that satoshi_value and color_value should have a degree of
freedom between each other. Thanks for the feedback.


On Mon, Apr 7, 2014 at 7:23 PM, Jorge Timn <jtimon@monetize.io> wrote:

-------------------------------------
Suppose am m-of-n multisig wallet receives a bunch of dust deposits due
to somebody advertising the Olympics, or any other reason, and the users
of the wallet don't want the few satoshis involved.

What is the best way to allow all these dust outputs to be re-mined in
order to clean up the utxo set, keeping in mind the scripts may include
large values of n?

-- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-------------------------------------
Matt, could you expand on use cases for which you see Shamir's Secret Sharing Scheme as the best tool for the job? In particular, when do you see that it would be superior to simply going with multisig in the first place? Perhaps you see these as complimentary approaches, toward defense-in-depth? In any case, the Motivation and Rationale sections of the BIP in its current form are silent on these questions.

On Mar 29, 2014, at 9:05 AM, Matt Whitlock <bip@mattwhitlock.name> wrote:


-------------------------------------
rOn Mon, Jan 13, 2014 at 08:57:33PM +0100, Mike Hearn wrote:

Yes, sorry, I miscontrued the thread here and now see that your
message was exactly talking about using stealth addresses within the
payment protocol.

Sorry for the confusion.

roy



-------------------------------------
I was considering names like getcheckpoints() to use the terminology that already seemed to be in place, but they were too long :)

I have been using getheaders() in my thick client to quickly grab all the headers before downloading the full blocks since I can grab more at a time. Even with getblocks(), there is the case for a  getgist() call. Right now you call getblocks(), which can take some time to get the corresponding inv(), at which time you can then start the call to getdata() as well as the next call to getblocks().

With a gist, for example of segment_count 50, you could call getgist(), then with the response, you could request 50 getblocks() each with a block_locator of 1 hash from the gist (and optimally the stop_hash of the next hash in the gist) to 50 different peers, providing 25,000 (50 x 500) block hashes.

Currently:
<<< inv()
<<< block(), block(), block(),  (x 500)

Saturates one peer, while leaving the rest un-used. Step 1 and 2 can be repeated and dispatched to different peers, but there is still the latency between the two calls.

Gist:
<<< inv()
<<< inv(), inv(), inv(),  (x segment_count, 1 per peer)
<<< block(), block(), block(),  (x (500 * segment_count), ie. 500 in per peer)

Each peer can be saturated.

I will try to run some experiments this weekend to get numbers as to whether there is actually any performance improvement using a gist, or whether the getdata(), block() latency ends up dominating the time anyways.


RicMoo


On Jun 4, 2014, at 11:42 PM, Mike Hearn <mike@plan99.net> wrote:


.`..`..`..`..`.><(((>

Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo@geneticmistakes.com
www: http://GeneticMistakes.com

-------------------------------------
On 10/04/14 18:59, Pieter Wuille wrote:

AFAIK, current bitcoin code code already set blockchain checkpoints from
time to time. It is a garanteed that a longer chain starting before the
checkpoint is not going to be accepted suddently. See
<https://bitcointalk.org/index.php?topic=194078.0>.

Could be perfectly valid to store only unspend wallets before last
checkpoint, if during the blockchain download the node did all the checks.

Would be interesting, of course, to be able to verify "unspend wallet
accounting" having only that checkpoint data (the merkle tree can do
that, I guess). So you could detect a data corruption or manipulation in
your local harddisk.

-- 
Jess Cea Avin                         _/_/      _/_/_/        _/_/_/
jcea@jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/
Twitter: @jcea                        _/_/    _/_/          _/_/_/_/_/
jabber / xmpp:jcea@jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/
"Things are not so easy"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/
"My name is Dump, Core Dump"   _/_/_/        _/_/_/      _/_/  _/_/
"El amor es poner tu felicidad en la felicidad de otro" - Leibniz

-------------------------------------
Hi all,

I've also been spending a few months coding upon the change's Pieter has
been making with the headersfirst8 pull request.

My code updates are also ready to test, and are available on github at
https://github.com/rebroad/bitcoin/  and the branch is
"sipa-headersfirst8-patches".

I've made a number of improvement. Namely that it tracks the block as it
downloads and won't disconnect if the block is downloading at a reasonable
speed. The current stall logic of Pieter's is broken in that it will
continue to disconnect a peer that is providing a block - particularly the
next block needed to advance the current tip. I've raised this issue, but
so far haven't been able to communicate the problem in a way that's been
understood.

I've also added logic to avoid the node stalling due to many blocks being
added to the ActiveTip (which would cause timeouts both from our node, and
nodes we are connected to). It will also log and determine bandwidth per
node, and the next changes I will be adding will be to make it prefer to
download from the faster nodes (coming shortly).

I have also added code ready to adapt the window size for the download.
Currently the start setting for blocks in flight is 3 per node, but for
early on on the block chain this will be too small, so once it realises
this after a few downloads and determines the average block size and speed,
it will automatically adjust the number of blocks to request per node and
revise this each minute.

Please do take a look at my code, and feel free to test it. It also
improves some of the debug.log output to make it easier to read and provide
useful information about concurrent downloads, etc.

Edmund

On Sun, Oct 12, 2014 at 7:34 AM, Pieter Wuille <pieter.wuille@gmail.com>
wrote:

-------------------------------------
On Tue, 2014-03-11 at 16:18 +0100, Mike Hearn wrote:

Interestingly, Blockchain's android wallet is based on Android Wallet /
bitcoinj.  So with HD in bitcoinj we would get Multibit, Android Wallet
(Andreas Schildbach's) and remove one roadblock to Blockchain going HD.
Electrum HD seems more or less ready.  So I'm optimistic that we'll see
a pretty fast transition to HD for the majority of the user base.

HD is important for some multisig flows, including the watchdog type
where you want to detect change going back to the wallet.


We have a proposed flow for watchdog type multisig
here:

https://cryptocorp.co/technology.htm

and a reference implementation off the Electrum 2.0 branch.

It actually works just like a regular spend from a UX point of view,
unless the watchdog decides that it needs a second factor for a risky
transaction.  With a risky transaction, the user just gets a
callback or enters an OTP.

-- 
Miron




-------------------------------------
On Saturday 25. October 2014 13.27.30 Adam Back wrote:

mining equipment has a much shorter lifetime than 4 years, so the halving 
makes it easy to base purchases on.
Also, divide by two is the cleanest way to get to zero after a specific amount 
of divisions.


-------------------------------------
I believe stealth addresses and the payment protocol both have their
use cases, and that they don't overlap.

If you do not want to communicate with the receiver, you typically do
not want them to know who is paying or for what (otherwise you're
already talking to them in some way, right?). That's perfect for
things like anonymous donations.

In pretty much every other case, communicating directly with the
receiver has benefits. Negotiation of the transaction details,
messages associated with the transaction, refund information, no need
to scan the blockchain for incoming transaction... and the ability to
cancel if either party doesn't agree.

Instead of adding stealth functionality to the payment protocol as a
last resort, I'd rather see the payment protocol improve its
atomicity. Either you want the data channel sender->receiver, or you
don't. If it isn't available and you want it, things should fail. If
you don't want it, you shouldn't try to use it in the first place.

On Fri, May 9, 2014 at 5:34 PM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
I would echo the need for some kind of moderation. 

I believe Peter Todd is an extremely intelligent individual, who has a
lot to offer the Bitcoin community.  He has a firm grasp of a lot of
really deep Bitcoin concepts and his *technical* insight is generally
positive.  Technically.  But the way he communicates on this list is
*extremely* corrosive and breeds hostility.  It makes it a scary place
to discuss things, with frequent, public ridicule of everything posted. 

I agree that I would rather have a friendly environment to discuss
technicals, even if it means losing additional technical insight. 
People who would explicitly insult other contributors intelligence and
character on a public list should be subject to some kind of negative
reinforcement.   Maybe there's solutions other than outright banning.

-Alan



On 03/25/2014 01:37 PM, Jeff Garzik wrote:



-------------------------------------
On 03/26/2014 09:49 PM, Mike Hearn wrote:

There is one "altcoin" that is pretty important even today and it is
Testnet.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
On Thu, Mar 13, 2014 at 3:32 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:


That ship sailed months ago. If you wanted a big push for uBTC, then would
have been the time. Though given that it'd have made lots of normal
balances incredibly huge, perhaps it's a good thing that didn't happen.
Also "milli" is a unit people encounter in daily life whereas micro isn't.
Is it milli / micro / nano or milli / nano / micro? I bet a lot of people
would get that wrong.

If you have to export to financial packages that can't handle fractional
pennies, then by all means represent prices in whatever units you like for
that purpose, but in software designed for ordinary people in everyday life
mBTC is a pretty good fit.

Besides, fractional pennies crop up in existing currencies too (the famous
Verizon Math episode showed this), so if a financial package insists on
rounding to 2dp then I guess it may sometimes do the wrong thing in some
business cases already.

Fundamentally, more than two decimal places tends to violate the


Lots of people use currencies that don't have any fractional components at
all ! So perhaps all prices should be denominated in satoshis to ensure
that they're not surprised :)

The (number) line has to be drawn somewhere. Wallets are free to suppress
more than 2dp of precision and actually Andreas' app lets you choose your
preferred precision. So I think in the end it won't matter a whole lot, if
the defaults end up being wrong people can change them until wallet authors
catch up.
-------------------------------------
On Mon, Jul 14, 2014 at 2:37 PM, Mike Hearn <mike@plan99.net> wrote:


thank for the frank reply
-------------------------------------
On Tue, Feb 18, 2014 at 02:14:24PM -0500, Ryan X. Charles wrote:

Note that merge-avoidance implemented in conjunction CoinJoin doesn't
have this problem - the CoinJoin'd transaction either does or doesn't
confirm. Meanwhile being able to avoid merges, or more precisely, being
able to be flexible with them, makes achiving good value-privacy much
easier.

Secondly merge-flexibility also makes cut-thru payments possible. For
example BitPay can direct customers paying for goods to pay to addresses
controlled by merchants and other parties who are owed money by BitPay.
This skips a step, saving on transction fees as well as increasing
privacy. Notably in this case the only parties that have to deal with
accounting complexity are BitPay and the merchants - consumers' wallet
software needs no changes beyond generic payment protocol support, and
notably you can even use this technique without the payment protocol.

See my post "DarkWallet Best Practices" for more info:

http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03508.html


What specifically do you dislike about X.509? The technical standard or
the infrastructure around it? (IE the centralized authorities)

-- 
'peter'[:-1]@petertodd.org
000000000000000051ad2df596f45df71320fb44b3c5f1b50231a591ffeb1d24
-------------------------------------
On Sunday 19. October 2014 09.17.51 xor wrote:

I gather that actual code changes to bitcoin-core and naturally all the other 
clients are already done in another place. Which is likely the reason for your 
impression.
 

I agree with your stance that more discussion in public is always good.

Lets allow people that work on bitcoin java, or completely other bitcoin based 
stuff to have a simple way to filter out the topics they are interested in.
Mailinglist handling is pretty trivial in practically all email software, 
people can equally trivially subscribe to multiple lists as their interests 
go.

As a long time open source developer, my experience is that more lists has 
never really caused fragmentation in the way that you fear.


-------------------------------------
So, I'm having some problems getting a multi input/multi output transaction
working. My code below works with 1 input and 2 output, but when adding
more inputs/outputs the transaction gets rejected. I'm sure whatever I'm
doing wrong in pretty simple, any ideas?

Code works for this (1 input, 2 outputs):

CTransaction(hash=01a3204517476812df2c2f77735a72a6d3e7eb8b9a5d5330ca433dd875fc4c3c,
ver=1, vin.size=2, vout.size=4, nLockTime=0)

CTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,
0), scriptSig=304502204cdfd276ff9c53bb)
    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 b07e181ce438)
    CTxOut(nValue=1.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)

Code doesn't work for this (2 input, 4 outputs):

CTransaction(hash=01a3204517476812df2c2f77735a72a6d3e7eb8b9a5d5330ca433dd875fc4c3c,
ver=1, vin.size=2, vout.size=4, nLockTime=0)

CTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,
1), scriptSig=304502204aef3f393c273835)

CTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,
0), scriptSig=304502204cdfd276ff9c53bb)
    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)
    CTxOut(nValue=491.00000000, scriptPubKey=OP_DUP OP_HASH160 0796b7f3430f)
    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 b07e181ce438)
    CTxOut(nValue=1.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)

Pseudo code showing working transaction:

    // These are how the vout's are made
    CScript scriptPubKey;
    scriptPubKey.SetDestination(address);
    CScript s;
    s << OP_DUP << OP_HASH160 << scriptPubKey.GetID() << OP_EQUALVERIFY <<
OP_CHECKSIG;

    CTxOut out(nValue, s);

    ---------------


    CTransaction txNew;
    txNew.vin.clear();
    txNew.vout.clear();

    // vin and vout are already populated
    for(unsigned int i = 0; i < vout.size(); i++){
        txNew.vout.push_back(vout[i]);
    }

    //add all vins
    for(unsigned int i = 0; i < vin.size(); i++){
        txNew.vin.push_back(vin[i]);
    }

    //add all vins
    for(unsigned int i = 0; i < vin.size(); i++){
        // this is signed with 2 separate keys for each vin
        if(!SignSignature(*keystore, prevPubKey, txNew, i,
int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)))
            printf('signing failed!\n');

        // I was told I might need to serialize the inputs? Not sure how
that would work
    }

    RelayTransaction(txNew, txNew.Hash());


---

CryptoFish
-------------------------------------
I have been noticing for some time the problem which Mike H. identified as
how we are bleeding nodes ~ losing nodes over time.

This link was referenced in the coindesk article of May 9, 2014:

http://sourceforge.net/p/bitcoin/mailman/bitcoin-development/thread/CANEZrP2rgiQHpekEpFviJ22QsiV%2Bs-F2pqosaZOA5WrRtJx5pg%40mail.gmail.com/#msg32196023

(coindesk article for reference: http://www.coindesk.com/bitcoin-nodes-need/)

The proposed solution is noted here as a portion of an issue at:
 https://github.com/bitcoin/bitcoin/issues/4079

Essentially that part which has to do with helping reduce
the loss of nodes is as follows:

"a feature similar to that suggested by @gmaxwell that would process small
change and tiny txouts to user specified donation targets, in an
incentivized process. Those running full nodes (Bitcoin Core all the
time), processing their change and txouts through Core, would be provided
incentives in the form of a 'decentralizing lottery' such that all
participants who are running nodes and donating no matter how infrequently
(and no matter who they donate to) will be entered in the 'decentralizing
lottery,' the 'award amounts' (which would be distinct from 'block
rewards' for any mining) would vary from small to large bitcoin amounts
depending on how many participants are involved in the donations process.
This would help incentivize individuals to run full nodes as well as
encouraging giving and microdonations. The option could be expressed in
the transactions area to contribute to help bitcoin core development for
those that are setting up change and txouts for donations, regarding the
microdonation portion (which has also has been expressed conceptually at
abis.io"

This addresses the issue of how to incentivize more
interested individuals to run full nodes (Bitcoin Core).  The lottery
concept (which would be applicable to anyone running the full node
regardless of whether or not they are mining) is attractive from the point
of view that it will complement the block reward concept already in place
which serves those who mine, but more attractive to the individual who
doesn't feel the urge to mine, but would like to have the chance of being
compensated for the effort they put into the system.

I hope that this leads to additional development discussion on these
concepts regarding incentivizing giving. This may also involve a process
BIP.  I look forward to your remarks.

Respect,

Odinn



-------------------------------------

Yes, it is true that you can't do a soft-fork, but you can do a hard-fork.
Using scheduled updates: client simply stops working at a certain block,
and user is required to download an update.

In Bitcoin we can operate with some assurance that hard-forks will almost

You assume that an ability to operate with zero maintenance is very
important, but is this a case?

There was a plenty of critical bugs in bitcoind, and in many cases people
were strongly encouraged to upgrade to a new version.
So, you urge people to keep their clients up-to-date, but at the same time
claim that keeping very old versions is critically important.
How does this make sense? Is this an exercise at double-think?

An alternative to this is to make updates mandatory. You will no longer
need to maintain compatibility with version 0.1 (which is impossible) and
you can also evolve consensus rules over time.

It looks like people make a cargo cult out of Bitcoin's emergent
properties.
-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512



On 10 April 2014 06:44:32 GMT-04:00, Tamas Blummer <tamas@bitsofproof.com> wrote:

No problem!

I'm sure we'll see payment channels implemented sooner or later
the form of "hub and spoke" payment networks. The idea there is you have one or more centralised hubs who in turn have payment channels setup to and from payors and payees. So long as the person you want to pay is connected to the same hub as you are, or in more advanced versions connected via a ripple style chain, you can push payment to the hub and get proof they did the same for the recipient. Your loss is always limited to the incremental payment amount and payment is essentially instant.

Of course, it's got some disadvantages compared to standard bitcoin transactions - its less decentralised - but when compared to other forms of off-chain payment in most situations its a strict improvement, and having the capability available is always a strict improvement. Like fidelity bonded banks the trust required in the hubs is low enough that with some minor effort applied to anti-DoS you could probably get away with using even hubs run by anonymous actors, making the centralisation less important. (hubs are essentially interchangeable) Unlike pure fidelity bonded banks the effort required to build this is relatively minor!

You can even combine it with chaum tokens for anonymity. You'll want to hold the tokens for some amount of time to thwart timing analysis, leaving you somewhat vulnerable to theft, but in that case fidelity bonded banking principles can be applied. Other than that case the idea is probably made obsolete by micropayment hubs.

Regulatory issues will be interesting... If you wind up with a few central payment hubs, without chaum tokens, those hubs learn all details about every transaction made. Obviously if a big actor like BitPay implemented this there would be a lot of pressure on them to make those records available to law enforcement and tax authorities, not to mention marketing and other data mining. Equally I suspect that if an alternative more decentralised version was implemented there would be strong government pressure for those approved hubs to not interoperate with the decentralised hubs, and equally for merchants to not accept payment from the decentralised hubs.

But all the same, if widely implemented this reduces pressure to raise the block size enormously, keeping the underlying system decentralised. So the net effect is probably positive regardless.

Oh yeah, credit goes to Mike Hearn for the payment channels, and if I'm correct, for the hub concept as well.

Amir: You should think about adding the above to dark wallet. It'd be good if the protocols are implemented in an open and decentralised fashion first, prior to vendor lock in.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCgA6BQJTRoIlMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhW26B/9A9OtYjoSHo620XZzF
VqfnnVFCPr3DpD/HuT3JYhF1kkL2vTt5wkRIHmHmfJ29Sduj8St7EFiLOyUg2mvt
q9heZgzCnqxLJm9zMiiQnb3Y/plvhTLfaONnHI+OPSfrABL6DA04nEe8OBPuFfv/
NowJ74DP/65YBq3EqbqG0dJExKm1BhdrEpWNq0v5YoCVuEYkWgFHL8SdRHnfFyxA
XTkP8avzlG82r98k55IrV0O/6VQNHjE0+xF4EHjEYBacy6OwlpEYeLrqx/VDAQ5R
RufXeAltNZI0tzLQ8nY0aMBH3YFxF0+14/sbmOAtmnD6EW49gEcV9MnSJc5ct4m7
Szq5
=aC39
-----END PGP SIGNATURE-----



-------------------------------------
On Sun, Dec 21, 2014 at 12:51 PM, Peter Todd <pete@petertodd.org> wrote:



Math alone describes all of Bitcoin's structure; as math is a way to model
reality, it has no limits. Saying Math can't prevent double-spending is
near equivalent to saying it cannot be done.
-------------------------------------
On Fri, Jul 04, 2014 at 06:53:47AM -0400, Alan Reiner wrote:


Anything involving lots of unpredictable memory accesses to a large
chunk of fast memory is unASICable. That data vector could be derived
by the same means as an one time pad, and loaded and locked into
memory after boot. If you make it large enough it won't profit from
embedded RAM bandwidth/speedup. The only way to speed up would be clustering,
which doesn't offer economies of scale.


-------------------------------------
btw. None of Bitcoin Wallet's users complained about confusion because
of the mBTC switch. In contrast, I get many mails and questions if
exchange rates happen to differ by >10%.

I suspect nobody looks at the Bitcoin price. It's the amount in local
currency that matters to the users.


On 03/13/2014 02:40 PM, Andreas Schildbach wrote:




-------------------------------------
On Tue, Mar 25, 2014 at 2:03 PM, Mark Friedenbach <mark@monetize.io> wrote:

I don't think it would be entirely unfair to describe one of the
possible ways a secondary coin becoming unbacked can play out as
inflation— after all, people have described altcoins as inflation. In
the worst case its no _worse_ inflation, I think, than an altcoin is—
however.


I think that chain geometries which improve the scale/decentralization
trade-off are complementary. If PT's ideas here do amount to something
that gives better scaling without ugly compromise I believe it would
still be useful no matter how well the 2-way peg stuff works simply
because scaling and decenteralization are both good things which we
would pretty much always want more of...


-------------------------------------
The world is rapidly becoming a place in which a solid grasp of orders of
magnitude could be considered a basic mathematical skill.  People are very
likely to learn what mBTC and µBTC are simply because they risk their money
if they do not.  This is not a bad thing and I think stands only to help
people who learn about these monikers for orders of magnitude this way.

Any appropriate nicknames for these denominations is sure to develop in due
course.  Promoting an already-overloaded term that could just as easily be
applied colloquially to refer to a small amount of value in any currency
seems problematic.
 I've been a staunch supporter of "microbitcoin" and would like to do
anything I can to make sure that we jump directly to it if we're going to
promote changing the default units.  And I'm happy to integrate it into
Armory as a default (with appropriate explanations and settings/options).
I'm not so convinced about the "bits" name though -- I do like it, but I do
also think that word is too overloaded.  Though, I think we could get away
with it.

(Sadly, I still use "microbes" occasionally (as in *microb*itcoin) when I'm
talking to coworkers, because it slips off the tongue and is actually a
good combination of brevity and self-explanatory -- it just doesn't instill
the right visuals...)

We started integrating alternative units into Armory.  But, of course,
there were a few more loose ends than I expected, which will require some
work.   We want to put it in but not necessarily change the default right
away.  I'd *prefer* we get some commitments from some other wallet
developers, so we can make a unified push for it.  I'm happy to lead that
and make it default as long as I'm not the only one in the world doing it.

-Alan



On 04/20/2014 11:05 AM, Tamas Blummer wrote:

Here is an earlier reference to bits:


https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04248.html<https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg04248.html>

 I forgot that Alan Reiner was also supporting a unit equals to bits :


https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04264.html<https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg04264.html>

 and here the earlier going back to March 2013 and a poll at that time
pushing for XBT being 1 bit


https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg04256.html<https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg04256.html>

 Regards,

Tamas Blummer
http://bitsofproof.com

 On 20.04.2014, at 16:53, Pieter Wuille <pieter.wuille@gmail.com> wrote:

I told him specifically to bring it here (on a pull request for
Bitcoin Core), as there is no point in making such convention changes
to just one client.

I wasn't aware of any discussion about the "bits" proposal here before.

On Sun, Apr 20, 2014 at 4:28 PM, Tamas Blummer <tamas@bitsofproof.com>
wrote:

People on this list are mostly engineers who have no problem dealing with
magnitudes and have rather limited empathy for people who have a problem
with them.
They also tend to think, that because they invented money 2.0 they would not
need to care of finance's or people's current customs.

The importance of their decisions in these questions will fade as people
already use wallets other than the core.

Bring this particular discussion elsewhere, to the wallet developer.

BTW the topic was discussed here several times, you have my support and Jeff
Garzik's.

Regards,

Tamas Blummer
http://bitsofproof.com

On 20.04.2014, at 15:15, Rob Golding
<rob.golding@astutium.com><rob.golding@astutium.com>wrote:

The average person is not going to be confident that the prefix they
are using is the correct one,


The use of any 'prefix' is one of choice and entirely unnecessary, and there
are already established 'divisions' in u/mBTC for those that feel they need
to use such things.

people WILL send 1000x more or less than
intended if we go down this road,


Exceptionally unlikely - I deal every day with currencies with 0, 2 and 3
dp's in amount ranging from 'under 1 whole unit' to tens of thousands - Not
once in 20 years has anyone ever 'sent' more or less than intended - oh,
they've 'intended' to underpay just fine, but never *unintended*.

I propose that users are offered a preference to denominate the
Bitcoin currency in a unit called a bit. Where one bitcoin (BTC)
equals one million bits (bits) and one bit equals 100 satoshis.


I propose that for people unable to understand what a bitcoin is, they can
just use satoshi's and drop this entire proposal.

Rob


------------------------------------------------------------------------------
Learn Graph Databases - Download FREE O'Reilly Book
"Graph Databases" is the definitive new guide to graph databases and their
applications. Written by three acclaimed leaders in the field,
this first edition is now available. Download your free book today!
http://p.sf.net/sfu/NeoTech
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



------------------------------------------------------------------------------
Learn Graph Databases - Download FREE O'Reilly Book
"Graph Databases" is the definitive new guide to graph databases and their
applications. Written by three acclaimed leaders in the field,
this first edition is now available. Download your free book today!
http://p.sf.net/sfu/NeoTech
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development





------------------------------------------------------------------------------
Learn Graph Databases - Download FREE O'Reilly Book
"Graph Databases" is the definitive new guide to graph databases and their
applications. Written by three acclaimed leaders in the field,
this first edition is now available. Download your free book
today!http://p.sf.net/sfu/NeoTech



_______________________________________________
Bitcoin-development mailing
listBitcoin-development@lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development



------------------------------------------------------------------------------
Learn Graph Databases - Download FREE O'Reilly Book
"Graph Databases" is the definitive new guide to graph databases and their
applications. Written by three acclaimed leaders in the field,
this first edition is now available. Download your free book today!
http://p.sf.net/sfu/NeoTech
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
On 7/31/2014 5:58 PM, Kaz Wesley wrote:

Reorg-frendliness is the opposite of the rationale behind #2340, which 
proposes setting nLockTime at current-height + 1 to prevent 
"fee-sniping" reorgs...



One way to proceed is implement #3753 (mempool janitor) in such a way 
that transactions with nLockTime are allowed to live a bit longer in the 
mempool (say 500 blocks) than those without (72 hours).  In other words, 
as a first step, just actually start expiring things from the mempool in 
bitcoin core, and leave any relay fee adjustments or rate limiting for 
later.  The isStandard change would be a good complement to #3753, to 
avoid relaying a tx that will soon expire by the nLockTime rule anyway.




-------------------------------------
Decided to take a break yesterday and write some code...


Timelock
========

Create a secret key that can be decrypted in a known amount of time
using parallel-serial hash chains. The creator can compute the timelock
in parallel, taking advantage of the large amount of cheap parallelism
available today, while others are forced to compute it serially,
constrained by the lack of scalar performance growth.

The chains are constructed such that Bitcoin addresses can be derived
from them and bounties placed, incentivizing third-parties to crack the
timelocks. This gives us a valuable chance to incentivize others to push
the envelope of scalar performance - important knowledge if we are going
to have any hope of knowing how soon our timelocked secrets will
actually be revealed! The Bitcoin secret keys and addresses are
constructed from the chains as follows:

    iv -> <chain> -> privkey -> pubkey -> secret -> hashed_secret

    secret        = SHA256(pubkey)
    hashed_secret = RIPEMD160(secret)

Unlocking a given chain starting from the initialization vector gives
the person doing the work the private key, giving them an exclusive
opportunity to collect the bounty. Collecting that bounty forces them to
reveal the pubkey, from which the secret is derived. The hashed_secret
is then just a standard Bitcoin address, letting everyone see how large
the bounty is for unlocking the timelock.

Only a single algorithm - SHA256 - is supported by design: timelock
encryption works best if we're all on an even playing field.

Sourcecode: https://github.com/petertodd/timelock

Credit goes to Amir Taaki for helping develop the idea.


To make things interesting I've made a ~256 hour timelock with 32
chains, 8 hours per chain. The addresses associated are as follows:

1ERvMr5J8FETF7zj4QM98u8ZANaL1o9XGZ
18h7LwKpd9c6u8zJka3vMCASa8BfbiZFd4
1DBJDp57QmbigLEbUsFeqJT3mkArGzH3gv
1C1d6Tj7mZADurfj5yJ64p5BeRstquk7pu
1FsH58jnq5Kc6D7hb7vmUhjh8fwnijiWss
1PDwPYStrrkKpGtV2zX71XCDYL3E2g3KM7
1BF6oYLeTG7WxNWJjC8p4SHz62q7vgZhXX
1DxFiHr9ehVvi8JR2Cc5pcD4DEURUeFFda
1NKg3buX5BzhYgSY6Yvws9kMqZ6F1xnneD
1Kptov9sgDqQcavz1rVsuQvfi8PcQcL4rc
1P9k1HEfe3Z8LaiFejqsuDLjWXPZk1coDL
1Mw25mU89Wp2b9zyMCSnjAVQ7x4AVWx3sf
1B8gdbd1StpVnV99Few1ae1XXfKH6iry1D
13bisx8T42CzmFA2oAm1evEytcijrHJ2iR
1DyR6aNSbrJCzwqdeo9UN5obGR9L73Y2sa
1Fx7j3gU3q7bQdoni2zZhGQx7BnLt8xNeK
19q541m17opVcAxwisem7ak7YPuSpdS3Uj
1DYWzBpLBDd7fpta2JYLf7QZ7nAYiZiamR
13sZYBMdyzffwvCkzhGTu49pCGGR5C5B9v
1DFSjViJLTNhNj5wvsqRwoqPyR9UTAzLgW
13Zi9eawpkzZwRC8RgHJausQmUS4ECBzho
1BCQ5GVkAEzNYZ5WroAwXSspgpYfhQrojd
1K1gbE7qGLwbJDEoRyrCGxCsgJ4mHcFKwP
14Z4EawE1Kd3HRut43vWjgYUWYR3ZV5i2p
1NZTFVXVzKXvPMsFKZfkhZCBcbzqm7cGCj
1GFBBahQC5DzpLuJc6X1yVvvSKP2kCpUGf
184PkQFdzhPR3TjoCxddsNK7sr3DVVhJ45
14SLK5fXWdajoQZ2AX5WmAGbvRtLpdTgMq
1LagrzYykb8w4NveKrw2SDcpKMezwxX72Z
16XdtV2U3ksdhKkByRpiq3VN61aB62Ndgh
1Mu1SaUBu7aV4DHzEc4hxcgGzaYWdvuaAh
1EJWWxwZckP9eLS2VzgbUwqzxFDZKZcF9b

I've funded them with 10mBTC each, 320mBTC total. The full timelock
definition is as follows:

{
    "chains": [
        {
            "algorithm": "sha256", 
            "encrypted_iv": null, 
            "hashed_secret": "1ERvMr5J8FETF7zj4QM98u8ZANaL1o9XGZ", 
            "i": 0, 
            "iv": "353b124909ec8774325d3f2f6b0a01c839e79e3ce687ee6e893310368afdf336", 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "495c6092c9004dc23c2deefb1db1deba88f8895a319f5d9f7ce8a53b2a9ecfe9", 
            "hashed_secret": "18h7LwKpd9c6u8zJka3vMCASa8BfbiZFd4", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "8cbdf731374a71f22d59251890997ea001c2efa6e9c0bf808700c3d432ccf269", 
            "hashed_secret": "1DBJDp57QmbigLEbUsFeqJT3mkArGzH3gv", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "bc4d75fa5ec8f28e121cd73806ce058e82036577130cffb3bd596f2aa59b2a7f", 
            "hashed_secret": "1C1d6Tj7mZADurfj5yJ64p5BeRstquk7pu", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "80c622521c7aed318dac2b3c7d929e4e504d3c60650009b1abc0bae18fff979b", 
            "hashed_secret": "1FsH58jnq5Kc6D7hb7vmUhjh8fwnijiWss", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "1ba76f9a694f987e1758dbc65cf104984dbedfae01b134fe09135b64cb8c4034", 
            "hashed_secret": "1PDwPYStrrkKpGtV2zX71XCDYL3E2g3KM7", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "1cedd5a71a96f439c20e9f4f5957b8c159b23d472063fa07a05121333888cdf5", 
            "hashed_secret": "1BF6oYLeTG7WxNWJjC8p4SHz62q7vgZhXX", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "30d88e0fd113ce38d22a210012914e5331bd89dda408d85dfa9e9bfcbd40d8eb", 
            "hashed_secret": "1DxFiHr9ehVvi8JR2Cc5pcD4DEURUeFFda", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "5e654bfc1534b03e45548b59d407518b5915c3ae51c266e374ea8a368f72433c", 
            "hashed_secret": "1NKg3buX5BzhYgSY6Yvws9kMqZ6F1xnneD", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "10095f9aa85ceb221d00975a1db66fcffcae516c1d3d5dee66995567522f68ab", 
            "hashed_secret": "1Kptov9sgDqQcavz1rVsuQvfi8PcQcL4rc", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "6ecfd5282c650b1ebabbf39f5e72dd0e8e9724456e6b357e83c53a9a144b49eb", 
            "hashed_secret": "1P9k1HEfe3Z8LaiFejqsuDLjWXPZk1coDL", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "197796e5010f189165c2010cd7cfb0f3b933670276231292555b5540765bb6fa", 
            "hashed_secret": "1Mw25mU89Wp2b9zyMCSnjAVQ7x4AVWx3sf", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "58fe436839724b03f3ffd41e864d5dc030de2eeb5a3c4df19ed65ef9abe21cc2", 
            "hashed_secret": "1B8gdbd1StpVnV99Few1ae1XXfKH6iry1D", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "d2af3dd9cdfbb081149212ead19cbd85f6dcc31177de586d1c6dd6139c16141f", 
            "hashed_secret": "13bisx8T42CzmFA2oAm1evEytcijrHJ2iR", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "512f20d2a4f342cb635d5c73a0c3ad30272bdd84d73f2bb0f2849d17557f162f", 
            "hashed_secret": "1DyR6aNSbrJCzwqdeo9UN5obGR9L73Y2sa", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "75cb98d4abfd84318347220547f017f8285333dd55b41622c9220ece49e227e2", 
            "hashed_secret": "1Fx7j3gU3q7bQdoni2zZhGQx7BnLt8xNeK", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "d1d264674ba9b1c4baba189809a0d37ca4b8f402f91a145303907c3730ff890c", 
            "hashed_secret": "19q541m17opVcAxwisem7ak7YPuSpdS3Uj", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "31f2df6ae00e118f72063cb640c150bad5c0c015d12533826439d45f593ebb89", 
            "hashed_secret": "1DYWzBpLBDd7fpta2JYLf7QZ7nAYiZiamR", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "8113452a165b673957f6d707f19d6b407683499ef6a08e03ba35ca79306b8e3b", 
            "hashed_secret": "13sZYBMdyzffwvCkzhGTu49pCGGR5C5B9v", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "c0b8e246cd4a2a1abe760b1d2763931c8e04960e6a2e69f0f6723dd4892413ae", 
            "hashed_secret": "1DFSjViJLTNhNj5wvsqRwoqPyR9UTAzLgW", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "c4d0bc902093f21e1745193345909e080dee5b4cc410108a637ded75fcdc9e01", 
            "hashed_secret": "13Zi9eawpkzZwRC8RgHJausQmUS4ECBzho", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "588d778adb3180a9783781a175171790d8099d7942190fa853b235262c074a99", 
            "hashed_secret": "1BCQ5GVkAEzNYZ5WroAwXSspgpYfhQrojd", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "643b3afe4b674b44fee943507559d6218c5f53671ab01b09c8aaafa65f9f2e37", 
            "hashed_secret": "1K1gbE7qGLwbJDEoRyrCGxCsgJ4mHcFKwP", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "62e65d48eb215734c00165130027a6cb04842d95cc570a278968f7070d41936f", 
            "hashed_secret": "14Z4EawE1Kd3HRut43vWjgYUWYR3ZV5i2p", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "f89566d49c4765522cd382c16589486b90702cc99caff6801a4e8b504694ab6b", 
            "hashed_secret": "1NZTFVXVzKXvPMsFKZfkhZCBcbzqm7cGCj", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "3d9acd9785f12890b88f30576d81d583ba0ada2d98c9a17f6cc79a0ed1b7e027", 
            "hashed_secret": "1GFBBahQC5DzpLuJc6X1yVvvSKP2kCpUGf", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "4d886799cfef728add5c14b27e780f96511b78060d86d3b77b0d0ed5130f6f02", 
            "hashed_secret": "184PkQFdzhPR3TjoCxddsNK7sr3DVVhJ45", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "24b495c95129ca0062297b019af3684b12303382e4282e032ba5fd2ab805b127", 
            "hashed_secret": "14SLK5fXWdajoQZ2AX5WmAGbvRtLpdTgMq", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "0eec24b55713a85a41c996904def8f8b5b61a9efa2491dacf63f7161a71a6514", 
            "hashed_secret": "1LagrzYykb8w4NveKrw2SDcpKMezwxX72Z", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "1b3ecc11b7f6cd80a5111b11a15fa2cb8b1c006041f8ad5b7c7316947de2e3fa", 
            "hashed_secret": "16XdtV2U3ksdhKkByRpiq3VN61aB62Ndgh", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "7fed7012e601fb9431d48c072d060c391b1985fd9717d51b12bbcb7e271f656f", 
            "hashed_secret": "1Mu1SaUBu7aV4DHzEc4hxcgGzaYWdvuaAh", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }, 
        {
            "algorithm": "sha256", 
            "encrypted_iv": "7f3a0c156be2c08714b9296999dddca8c178385e145aa3156ea00ffd742075f8", 
            "hashed_secret": "1EJWWxwZckP9eLS2VzgbUwqzxFDZKZcF9b", 
            "i": 0, 
            "iv": null, 
            "midstate": null, 
            "n": 86400000000, 
            "seckey": null, 
            "secret": null
        }
    ], 
    "version": 1
}

-- 
'peter'[:-1]@petertodd.org
00000000000000002d204cce4ee5e7976a0a485d658b4a15ebf31cdbce8a4915
-------------------------------------
Just an FYI: The Bitcoin wiki (https://en.bitcoin.it) is down.

Is there a communication procedure or point person for such things?

---
          Tom Geller  *  Oberlin, Ohio  *  415-317-1805
           Writer/Presenter * http://www.tomgeller.com
         articles, marketing, videos, user guides, books







-------------------------------------

DoS attack? Nice try.

Performance is subtle, disk iops especially so. I suspect you'd find - if
you implemented it - that for the kinds of loads Bitcoin is processing both
today and tomorrow prefix filtering either doesn't save any disk seeks or
actively makes it worse.

Consider a client that is syncing the last 24 hours of chain. bitcoind
pre-allocates space for blocks in large chunks, so most blocks are laid out
sequentially on disk. Almost all the cost of a disk read is rotational
latency. Once the head is in place data can be read in very fast and modern
kernels will attempt to adaptively read ahead in order to exploit this,
especially if a program seems to be working through a disk file
sequentially. The work of Bloom filtering parts of the chain for this
client boils down to a handful of disk seeks at best and the rest of the
work is all CPU/memory bound as the block is parsed into objects and tested
against the filter. A smarter filtering implementation than ours could do
SAX-style parsing of the block and avoid the overhead of turning it all
into objects.

Now consider a prefix filtering implementation. You need to calculate a
sorted list of all the data elements and tx hashes in the block, that maps
to the location in the block where the tx data can be found. These
per-block indexes take up extra disk space and, realistically, would likely
be implemented using LevelDB as that's a tool which is designed for
creating and using these kinds of tables, so then you're both loading the
block data itself (blocks are sized about right currently to always fit in
the default kernel readahead window) AND also seeking through the indexes,
and building them too. A smart implementation might try and pack the index
next to each block so it's possible to load both at once with a single
seek, but that would probably be more work, as it'd force building of the
index to be synchronous with saving the block to disk thus slowing down
block relay. In contrast a LevelDB based index would do the bulk of the
index-building work on a separate core.

At *some* block size and client load the additional data storage and
increased pressure on the page cache would probably make it worthwhile. But
I find it unlikely to be true at current traffic levels, or double or
triple today's levels. So I'd rather we spend our very limited collective
time on finding ways to increase usage rather than worrying about resources
which are not presently scarce.

(as an aside, some of the above analysis would be invalidated if most nodes
end up running on SSDs, but I doubt most are. It'd be neat to export
storage tech via some kind of stats message - LevelDB is designed for HDDs
not SSDs so at some point a new storage subsystem might make sense if the
network switched over).
-------------------------------------
I've advocated for this in the past, and reasonable counter-arguments I
was presented with are: (1) bittorrent is horribly insecure - it would
be easy to DoS the initial block download if that were the goal, and (2)
there's a reasonable pathway to doing this all in-protocol, so there's
no reason to introduce external dependencies.

On 04/09/2014 01:31 PM, slush wrote:


-------------------------------------
We do not want BIP64 to be incompatible with BIP32 in any way. BIP64 is
just set of some recommendations for wallet developers how to browse bip32
tree.

Modifying serialization format would break the compatibility.

However we have our solution for storing wallet birth time, which is out of
scope of BIP64, but we'll communicate it as soon as we'll write down that
idea to some more specific format.

Marek


On Wed, Apr 23, 2014 at 9:36 PM, Tamas Blummer <tamas@bitsofproof.com>wrote:

-------------------------------------
On 04/23/2014 08:39 PM, Tier Nolan wrote:

Such merchant would surely use some merchant system instead of generic
wallet software.


Not if you have 100 accounts on 10 different devices.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick@gk2.sk>


-------------------------------------
Signed executables are available for 0.10.0 release candidate 1, at

https://bitcoin.org/bin/0.10.0/test/

Preliminary release notes for the 0.10 release can be found here:
https://github.com/bitcoin/bitcoin/blob/0.10/doc/release-notes.md

Please report bugs using the issue tracker at github:
https://github.com/bitcoin/bitcoin/issues

Cheers,
Wladimir


-------------------------------------
Hi,

What is the status of watch-only addresses in Bitcoin Core? Is it merged in
master and usable? Is there documentation on how to add a watch-only
address through RPC.

Also, I believe that is going towards the 0.10 release, is there a
rough ETA for a release candidate?

Thanks
Flavien
-------------------------------------
Thanks Mike.

Indeed, I am aware of current approach, which is why I was suggesting 
this as an alternative.
I haven't thought about it enough, and perhaps it was too radical a 
rethinking - just wanted to see what the smarter minds thought.

Thanks again.

-Randi

On 7/5/14, 4:43 AM, Mike Hearn wrote:

-------------------------------------
Ah, good point. For some reason I was thinking the k value was
generated only from the hash being signed, but it's derived from both
the private key and the hash, so as you say there's no way for the
verifier to tell if the scheme is being followed.



Aaron Voisine
breadwallet.com


On Fri, Jul 18, 2014 at 11:56 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:


-------------------------------------
2014-03-06 17:03 GMT+00:00 Mike Hearn <mike@plan99.net>:



sure, here:
- tougher than phone/tablet. Phone dropped on the tiled floor is likely to
die instantly. Our device is designed to survive everyday intense use and
drops on the floor also.
- cheaper than phone/tablet. Usual phone/tablet costs few hundred bucks,
our device on mass scale will be definitely cheaper than that. Maybe a
noname chinese tablet will match on price, but then again what about
reliability?
- simpler than phone/tablet. Phone app needs some basic understanding to
operate. Cheap cashier employees hired by small corner shops might find
this a challenge.
- safer than phone/tablet. No option to install random apps on it. And no
temptation to steal it from the counter.
-------------------------------------
Make a transaction with two outputs.  Output A is your payee.  Output B is a fee to whoever transmits the transaction to the network.  Sign and print the transaction, along with private key controlling address of output B.  Put it in the mail with instructions to 1 or more greedy people who don't know you.   

Does namecoin allow mixing outputs for name registration with pay to hash outputs ?  If so, you could use namecoin for anonymous publishing via post.  Or just make output A in bitcoin scripted with op_return if its a 40byte tweet.


-------------------------------------
On 02/18/2014 08:14 PM, Ryan X. Charles wrote:


I would like to understand why this happens at BitPay? If this is
because people use cut and paste to copy the address and then type the
amount by hand... well this kind of usage will go away.

A program (like an app) should be capable of paying the exact amount. If
not, that's a bug of the app not the protocol.


+1


Sounds interesting, let us know as soon as you have anything.


In which case does it make sense to duplicate the root cert? I'm asking
because it should already be present in the trusted root store, right?

Maybe can you tell about which measures you needed to take to get X.509
working? To me it felt there very several problems.


TLS? We're not using that for pki_data -- its just a byte array.


--> https://github.com/bitcoin/bips/pull/20




-------------------------------------
How about research projects into node distribution? Specifically I
wonder whether the collection and analysis of DNS query origin is
allowed when queries are anonymized and aggregated. This would prevent
the identification of a single user, which I assume is the rationale
for point 4.

Other than that I'm perfectly fine with accepting the rules for
seed.bitcoinstats.com

Regards,
Christian
--
Christian Decker


On Mon, Jul 21, 2014 at 2:43 PM, Wladimir <laanwj@gmail.com> wrote:


-------------------------------------
We could however introduce a new field in a new tx version. We know we need
to rev the format at some point anyway.


On Wed, Aug 6, 2014 at 2:55 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
On 1/10/14, Peter Todd <pete@petertodd.org> wrote:

Namecoin, Devcoin and Ixcoin are also currencies and therefore compete
with Bitcoin.
How is that even Ixcoin (clearly a scamcoin that indirectly damages
the image of Bitcoin) has survived?

My explanation is that miners aren't necessarily holders. It's certain
that there's holders who don't mind and "can't do anything about it".
In fact, I think many miners sell their mined coins for fiat to cover
their investment and costs. The profit margin is reduced as the mining
market becomes more competitive, so even for miners it will get very
expensive and risky to do stupid things.
Talking about stupid things, I don't see many bitcoiners throwing
rocks at local currency users or barter clubs nor burning down banks
to "protect their investment". Barter is just another competitor in
the media of exchange market.


What percentage of Bitcoin/Namecoin miners do you think own namecoins?
How much can they afford to lose to attack competition?


No, the "harm to the old system participants" is distributed among all
the participants, not only miners (assuming miners have any
speculative position at all).
I'm not denying that people do crazy and stupid things, but let's at
least allow the "anti-competition attacker" be equally crazy in both
cases.
Miners attacking "competition" for one or more of the chains they mine
are acting irrationally in both cases.
You're trying to rationalize the actions of the MM attackers, but
they're just being stupid, since if they weren't, they would just try
to maximize profits.


I have many other explanations for the few currencies that died with
MM (can you remember any name?). At the beginning all altcoins were
much smaller and easier to attack, all of them. Bitcoin mining pools
didn't wanted to update to merged mining and didn't acted very
rationally about it.
Namecoin went through a really delicate situation just before
hardforking to MM, but now is by far the most secure altcoin of them
all, all thanks to MM.
All rational bitcoin miners should also mine namecoin. Period. All
those who consider it competition with their current Bitcoin
speculative position, should just "attack in the market" by selling
the namecoins as soon as they get them.
Providing security for a chain DOES NOT give it an utility or rise its demand.
Operation COSTS DO NOT CAUSE VALUE.

About Luke-Jr's thinking, I don't think it's along those lines.

If you create a new chain for the long term, you should try to
maximize its security and that currently means you should merged mine
with bitcoin.
The main rational reason to never do merged mining is to prevent
competitive and rational miners from crashing the price of your
currency, which is everything a scamcoiner cares about, the price and
market cap.

Of course Luke-Jr can correct me if that's not how he thinks.


-------------------------------------
The most useful meta data to optimize chain scan is the key birth date, then the allowed gap size. 

Tamas Blummer
http://bitsofproof.com

On 23.04.2014, at 20:39, Tier Nolan <tier.nolan@gmail.com> wrote:


-------------------------------------
IMO, CHECKLOCKTIMEVERIFY should be included in that list, too.

RE soft fork vs. hard fork:  It's about this time at Mike Hearn will
chime in, on the side of hard forks.  Hard forks are in a sense much
cleaner, and permit solving problems not otherwise solvable with a
hard fork.  However, hard forks clearly have risks, notably the Big
Risk akin to a US Constitutional Convention:  once you open the door,
anything can happen, any rule no matter how "sacred" can be changed.

Soft forks are not without their own risks, e.g. reducing some things
to SPV levels of security.

Leaning towards soft fork, but it is a good discussion to have.  A
poorly implemented soft fork may potentially require a hard fork to
fix rollout bugs.


On Thu, Nov 6, 2014 at 11:05 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
I must say, this shed is mighty fine looking. It'd be a great place to
store our bikes. But, what colour should we paint it?

How about we split the difference and go with "privacy address"? As Peter
notes, that's what people actually like and want. The problem with stealth
is it's got strong connotations with American military hardware and perhaps
thieves sneaking around in the night:

   https://www.google.com/search?tbm=isch&q=stealth

But everyone loves privacy.


On Fri, Jan 17, 2014 at 8:49 AM, Drak <drak@zikula.org> wrote:

-------------------------------------
On Fri, Apr 4, 2014 at 3:22 PM, Eric Larchevêque <elarch@gmail.com> wrote:


Why do you need it? Because you don't want to implement a login system?
Very, very few websites are the sort of place where they'd want to
authenticate with only a Bitcoin address. If for no other reason than
they'd have no way to email you, and if you lost your wallet, you'd lose
all your associated data.



In future there often won't be a simple paying address. For instance, if my
coins are in a multi-sig relationship with a risk analysis service, there
will be two keys for each input and an arbitrary number of inputs. So does
that mean the risk analysis service gets to open my locker? Why?

What if I do a shared spend/CoinJoin type tx? Now anyone who took part in
the shared tx with me can get into my hotel room too?

These are the kinds of problems that crop up when you mix together two
different things: the act of paying, and the act of identifying yourself.
You're assuming that replacing a password people can remember with a
physical token (their phone) which can be stolen or lost, would be seen as
an upgrade. Given a choice between two physical lockers, one of which lets
me open it with a password and one of which insists on a cryptographic
token, I'm going to go for the former because the chances of me losing my
phone is much higher than me forgetting my password.

All the tools you need already exist in the form of client certificates,
with the advantage that web servers and web browsers already support them.
The biggest pain point with them is backup and cross-device sync, which of
course wallets suffer from too!
-------------------------------------


That case raised the bar a bit, but the core problem remains - if you learn
about a patent you definitely violate (and there is very likely to be at
least one and possibly many), via whatever means, then by continuing
business you become a wilful violator. Which makes sense: how could it be
any other way?

It still never makes sense to read patents. You can only lose.
-------------------------------------
Hi there,

quote:
[...]

Using the same set of nodes for posting transactions using unrelated
inputs kind of limits the privacy improvement that can be gained from
using unrelated inputs in the first place.

Similar to how Tor uses different circuits for different hosts to
connect to, it may make more sense to only use the same set of nodes
for posting a subsequent transaction when the input addresses are also
the same.

[...]

I also find the topic of banning Tor exit nodes interesting.

I wonder if it makes more sense not to ban IP addresses completely,
but instead to throttle them using a PoW-based access control
scheme. Misbehaving addresses can have their connecting difficulty
scaled up, which should make it uneconomic to try to DoS the usage of
Tor exit nodes for connecting to Bitcoin.

It may also help nodes behind a NAT router if they share their global
IP with misconfigured nodes.

Best regards,

Isidor


-------------------------------------
Introduction
============

While not a new concept proof-of-publication is receiving a significant
amount of attention right now both as an idea, with regard to the
embedded consensus systems that make use of it, and in regard to the
sidechains model proposed by Blockstream that rejects it. Here we give a
clear definition of proof-of-publication and its weaker predecessor
timestamping, describe some usecases for it, and finally dispel some of
the common myths about it.


What is timestamping?
=====================

A cryptographic timestamp proves that message m existed prior to some
time t.

This is the cryptographic equivalent of mailing yourself a patentable
idea in a sealed envelope to establish the date at which the idea
existed on paper.

Traditionally this has been done with one or more trusted third parties
who attest to the fact that they saw m prior to the time t. More
recently blockchains have been used for this purpose, particularly the
Bitcoin blockchain, as block headers include a block time which is
verified by the consensus algorithm.


What is proof-of-publication?
=============================

Proof-of-publication is what solves the double-spend problem.

Cryptographic proof-of-publication actually refers to a few closely
related proofs, and practical uses of it will generally make use of more
than one proof.


Proof-of-receipt
----------------

Prove that every member p in of audience P has received message m. A
real world analogy is a legal notice being published in a major
newspaper - we can assume any subscriber received the message and had a
chance to read it.


Proof-of-non-publication
------------------------

Prove that message m has *not* been published. Extending the above real
world analogy the court can easily determine that a legal notice was not
published when it should have been by examining newspaper archives. (or
equally, *because* the notice had not been published, some action a
litigant had taken was permissable)


Proof-of-membership
-------------------

A proof-of-non-publication isn't very useful if you can't prove that
some member q is in the audience P. In particular, if you are to
evaluate a proof-of-membership, q is yourself, and you want assurance
you are in that audience. In the case of our newspaper analogy because
we know what today's date is, and we trust the newspaper never to
publish two different editions with the same date we can be certain we
have searched all possible issues where the legal notice may have been
published.


Real-world proof-of-publication: The Torrens Title System
---------------------------------------------------------

Land titles are a real-world example, dating back centuries, with
remarkable simularities to the Bitcoin blockchain. Prior to the torrens
system land was transferred between owners through a chain of valid
title deeds going back to some "genesis" event establishing rightful
ownership independently of prior history. As with the blockchain the
title deed system has two main problems: establishing that each title
deed in the chain is valid in isolation, and establishing that no other
valid title deeds exist. While the analogy isn't exact - establishing
the validity of title deeds isn't as crisp a process as simple checking
a cryptographic signature - these two basic problems are closely related
to the actions of checking a transaction's signatures in isolation, and
ensuring it hasn't been double-spent.

To solve these problems the Torrens title system was developed, first in
Australia and later Canada, to establish a singular central registry of
deeds, or property transfers. Simplifying a bit we can say inclusion -
publication - in the official registery is a necessary pre-condition to
a given property transfer being valid. Multiple competing transfers are
made obvious, and the true valid transfer can be determined by whichever
transfer happened first.

Similarly in places where the Torrens title system has not been adopted,
almost always a small number of title insurance providers have taken on
the same role. The title insurance provider maintains a database of all
known title deeds, and in practice if a given title deed isn't published
in the database it's not considered valid.


Common myths
============

Proof-of-publication is the same as timestamping
------------------------------------------------

No. Timestamping is a significantly weaker primitive than
proof-of-publication. This myth seems to persist because unfortunately
many members of the Bitcoin development and theory community - and even
members of the Blockstream project - have frequently used the term
"timestamping" for applications that need proof-of-publication.


Publication means publishing meaningful data to the whole world
---------------------------------------------------------------

No. The data to be published can often be an otherwise meaningless
nonce, indistinguishable from any other random value. (e.g. an ECC
pubkey)

For example colored coins can be implemented by committing the hash of
the map of colored inputs to outputs inside a transaction. These maps
can be passed from payee to payor to prove that a given output is
colored with a set of recursive proofs, as is done in the author's
Smartcolors library. The commitment itself can be a simple hash, or even
a pay-to-contract style derived pubkey.

A second example is Zerocash, which depends on global consensus of a set
of revealed serial numbers. As this set can include "false-positives" -
false revealed serial numbers that do not actually correspond to a real
Zerocash transaction - the blockchain itself can be that set. The
Zerocash transactions themselves - and associated proofs - can then be
passed around via a p2p network separate from the blockchain itself.
Each Zerocash Pour proof then simply needs to specify what set of
priorly evaluated proofs makes up its particular commitment merkle tree
and the proofs are then evaluated against that proof-specific tree. (in
practice likely some kind of DAG-like structure) (note that there is a
sybil attack risk here: a sybil attack reduces your k-anonymity set by
the number of transactions you were prevented from seeing; a weaker
proof-of-publication mechanism may be appropriate to prevent that sybil
attack).

The published data may also not be meaningful because it is encrypted.
Only a small community may need to come to consensus about it; everyone
else can ignore it. For instance proof-of-publication for decentralized
asset exchange is an application where you need publication to be
timely, however the audience may still be small. That audience can share
an encryption key.


Proof-of-publication is always easy to censor
---------------------------------------------

No, with some precautions. This myth is closely related to the above
idea that the data must be globally meaningful to be useful. The colored
coin and Zerocash examples above are cases where censoring the
publication is obviously impossible as it can be made prior to giving
anyone at all sufficient info to determine if the publicaiton has been
made; the data itself is just nonces.

In the case of encrypted data the encryption key can also often be
revealed well after the publication has been made. For instance in a
Certificate Transparency scheme the certificate authority (CA) may use
proof-of-publication to prove that a certificate was in a set of
certificates. If that set of certificates is hashed into a merkelized
binary prefix tree indexed by domain name the correct certificate for a
given domain name - or lack thereof - is easily proven. Changes to that
set can be published on the blockchain by publishing successive prefix
tree commitments.

If these commitments are encrypted, each commitment C_i can also commit
to the encryption key to be used for C_{i+1}. That key need not be
revealed until the commitment is published; validitity is assured as
every client knows that only one C_{i+1} is possible, so any malfeasance
is guaranteed to be revealed when C_{i+2} is published.

Secondly the published data can be timelock encrypted with timelocks
that take more than the average block interval to decrypt. This puts
would-be censoring miners into a position of either delaying all
transactions, or accepting that they will end up mining publication
proofs. The only way to circumvent this is highly restrictive
whitelisting.


Proof-of-publication is easier to censor than (merge)-mined sidechains
----------------------------------------------------------------------

False under all circumstances. Even if the publications use no
anti-censorship techniques to succesfully censor a proof-of-publication
system at least 51% of the total hashing power must decide to censor it,
and they must do so by attacking the other 49% of hashing power -
specifically rejecting their blocks. This is true no matter how "niche"
the proof-of-publication system is - whether it is used by two people or
two million people it has the same security.

On the other hand a (merge)-mined sidechain with x% of the total hashing
power supporting it can be attacked at by anyone with >x% hashing power.
In the case of a merge-mined sidechain this cost will often be near zero
- only by providing miners with a significant and ongoing reward can the
marginal cost be made high. In the case of sidechains with niche
audiences this is particularly true - sidechain advocates have often
advocated that sidechains be initially protected by centralized
checkpoints until they become popular enough to begin to be secure.

Secondly sidechains can't make use of anti-censorship techniques the way
proof-of-publication systems can: they inherently must be public for
miners to be able to mine them in a decentralized fashion. Of course,
users of them may use anti-censorship techniques, but that leads to a
simple security-vs-cost tradeoff between using the Bitcoin blockchain
and a sidechain. (note the simularity to the author's treechains
proposal!)


Proof-of-publication can be made expensive
------------------------------------------

True, in some cases! By tightly constraining the Bitcoin scripting
system the available bytes for stenographic embedment can be reduced.
For instance P2SH^2 requires an brute force exponentially increasing
amount of hashes-per-byte-per-pushdata. However this is still
ineffective against publishing hashes, and to fully implement it -
scriptSigs included - would require highly invasive changes to the
entire scripting system that would greatly limit its value.


Proof-of-publication can be outsourced to untrusted third-parties
-----------------------------------------------------------------

Timestamping yes, but proof-of-publication no.

We're talking about systems that attempt to publish multiple pieces of
data from multiple parties with a single hash in the Bitcoin blockchain,
such as Factom.  Essentially this works by having a "child" blockchain,
and the hash of that child blockchain is published in the master Bitcoin
blockchain. To prove publicaiton you prove that your message is in that
child chain, and the child chain is itself published in the Bitcoin
blockchain.  Proving membership is possible for yourself by determining
if you have the contents corresponding to the most recent child-chain
hash.

The problem is proving non-publication. The set of all *potential*
child-chain hashes must be possible to obtain by scanning the Bitcoin
blockchain. As a hash is meaningless by itself, these hashes must be
signed. That introduces a trusted third-party who can also sign an
invalid hash that does not correspond to a block and publish it in the
blockchain. This in turn makes it impossible for anyone using the child
blockchain to prove non-publication - they can't prove they did not
publish a message because the content of *all* child blockchains is now
unknown.

In short, Factom and systems like it rely on trusted third parties who
can put you in a position where you can't prove you did not commit
fraud.


Proof-of-publication "bloats" the blockchain
--------------------------------------------

Depends on your perspective.

Systems that do not make use of the UTXO are no different technically
than any other transaction: they pay fees to publish messages to the
Bitcoin blockchain with no amortized increase in the UTXO set. Some
systems do grow the UTXO set - a potential scaling problem as currently
that all full nodes must have the entire UTXO set - although there are a
number of existing mechanisms and proposals to mitigate this issue such
as the (crippled) OP_RETURN scriptPubKey format, the dust rule, the
authors TXO commitments, UTXO expiry etc.

From an economic point of view proof-of-publication systems compete with
other uses of the blockchain as they pay fees; supply of blockchain
space is fixed so the increased demand must result in a higher
per-transaction price in fees. On the other hand this is true of *all*
uses of the blockchain, which collectively share the limited transaction
capacity. For instance Satoshidice and similar sites have been widely
condemned for doing conventional transactions on Bitcoin when they could
have potentially used off-chain transactions.

It's unknown what the effect on the Bitcoin price will actually be. Some
proof-of-publication uses have nothing to do with money at all - e.g.
certificate transparency. Others are only indirectly related, such as
securing financial audit logs such as merkle-sum-trees of total Bitcoins
held by exchanges. Others in effect add new features to Bitcoin, such as
how colored coins allows the trade of assets on the blockchain, or how
Zerocash makes Bitcoin transactions anonymous. The sum total of all
these effects on the Bitcoin price is difficult to predict.

The authors belief is that even if proof-of-publication is a
net-negative to Bitcoin as it is significantly more secure than the
alternatives and can't be effectively censored people will use it
regardless of effects to discourage them through social pressure. Thus
Bitcoin must make technical improvements to scalability that negate
these potentially harmful effects.


Proof-of-publication systems are inefficient
--------------------------------------------

If you're talking about inefficient from the perspective of a full-node
that does full validation, they are no different than (merge)-mined
sidechain and altcoin alternatives. If you're talking about efficiency
from the perspective of a SPV client, then yes, proof-of-publication
systems will often require more resources than mining-based
alternatives.

However it must be remembered that the cost of mining is the
introduction of a trusted third party - miners. Of course, mined
proof-of-publication has miners already, but trusting those miners to
determine the meaning of that data places significantly more trust in
them than mearly trusting them to create consensus on the order in which
data is published.

Many usecases involve trusted third-parties anyway - the role of
proof-of-publication is to hold those third-parties to account and keep
them honest. For these use-cases - certificate transparency, audit logs,
financial assets - mined alternatives simply add new trusted third
parties and points of failure rather than remove them.

Of course, global consensus is inefficient - Bitcoin itself is
inefficient. But this is a fundemental problem to Bitcoin's architecture
that applies to all uses of it, a problem that should be solved in
general.


Proof-of-publication needs "scamcoins" like Mastercoin and Counterparty
-----------------------------------------------------------------------

First of all, whether or not a limited-supply token is a "scam" is not a
technical question. However some types of embedded consensus systems, a
specific use-case for proof-of-publication, do require limited-supply
tokens within the system for technical reasons, for instance to support
bid orders functionality in decentralized marketplaces.

Secondly using a limited-supply token in a proof-of-publicaton system is
what lets you have secure client side validation rather than the
alternative of 2-way-pegging that requires users to trust miners not to
steal the pegged funds. Tokens also do not need to be, economically
speaking, assets that can appreciate in value relative to Bitcoin;
one-way-pegs where Bitcoins can always be turned into the token in
conjunction with decentralized exchange to buy and sell tokens for
Bitcoins ensure the token value will always closely approximate the
Bitcoin value as long as the protocol itself is considered valuable.

Finally only a subset of proof-of-publication use-cases involve tokens
at all - many like colored coins transact directly to and from Bitcoin,
while other use-cases don't even involve finance at all.

-- 
'peter'[:-1]@petertodd.org
00000000000000000681f4e5c84bc0bf7e6c5db8673eef225da652fbb785a0de
-------------------------------------
On Mon, Dec 15, 2014 at 11:21:01AM +0100, Tamas Blummer wrote:

It's not a new idea actually - I outlined a system I eventually called
"zookeyv" based on the notion of sacrificing Bitcoins to achieve
consensus a year and a half ago on #bitcoin-wizards. The discussion
started here and continued for a few days:

https://download.wpsoftware.net/bitcoin/wizards/2013/05/13-05-29.log

I later wrote up the idea in the context of adding Zerocoin to Bitcoin:

http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg02472.html

For key-value mapping I eventually decided that the system didn't
necessarily need to be a strict linear blockchain - a directed acyclic
graph of commitments had advantages as there needed to be less
syncronization between transactions. This also means that the graph
doesn't necessarily need to be revealed directly in the blockchain,
exposing it to miner censorship. OTOH revealing it makes it easy to
determine if an attacker larger than you exists. These days I'd suggest
using timelock crypto to defeat miner censorship, while ensuring that in
principle consensus over all possible parts of the chain can eventually
be reached.

Proof-of-sacrifice for consensus has a few weird properties. For
instance you can defeat attackers after the fact by simply sacrificing
more than the attacker. Not unlike having a infinite amount of mining
equipment available with the only constraint being funds to pay for the
electricity. (which *is* semi-true with altcoins!)

As for your specific example, you can improve it's censorship resistance
by having the transactions commit to a nonce in advance in some way
indistinguishable from normal transactions, and then making the
selection criteria be some function of H(nonce | blockhash) - for
instance highest wins. So long as the chain selection is based on
cumulative difficulty based on a fixed target - as is the case in
Bitcoin proper - you should get a proper incentive to publish blocks, as
well as the "total work information rachet" effect Bitcoin has against
attackers.


1) In honor of Zooko's triangle.

2) This doesn't necessarily take as much work as you might expect: you
   can work backwards from the most recent block(s) if the scheme
   requires block B_i to include the decryption key for block B_{i-1}.

-- 
'peter'[:-1]@petertodd.org
000000000000000018d439a78581d2a9ecd762a2b37dd5b403a82beb58dcbc7c
-------------------------------------
On Wed, Mar 5, 2014 at 12:32 PM, Peter Todd <pete@petertodd.org> wrote:

But it's still incomplete.

Say you have an address— used only once!— with a txout with a lot of value.

Someone starts paying you small amounts to that address over and over
again. You haven't asked them to, they're just doing it.

Do you ignore the funds?— maybe tell some customer that was ignorantly
paying you over and over again to a single address "sorry, those are
my rules: I only acknowledge the first payment, those funds are
lost!".

No, of course not.  You spend the darn coins and if you're on a shared
host perhaps you disclose a private key.

The probability of an attack actually going on is low enough compared
to the cost of spending the coins in that case that even someone with
good knoweldge of the risks will choose to do so.

So absolutely, not reusing addresses massively increases your safety
and limits losses when there is theft. But it isn't enough alone. (Nor
is smarter signing, considering complex software like this has bugs
and its hard to be confident that something is side channel free— esp
when you allow attacker interference).


-------------------------------------
Looking good! I think this is much better than the original draft. Agree
with Andreas that supports_instant is simply equal to
(supported_instant_providers.size() > 1) which makes it redundant.

Daniel is right that putting every possible provider in the Payment message
might not scale in a world where there are huge numbers of
instant-confirmation providers, but I'm hoping that we never have to scale
to that size, because if we did that'd rather imply that Bitcoin has become
useless for in-person payments without trusted third parties and avoiding
that is rather the whole point of the project :) So I'm OK with some
theoretical lack of scalability for now.

A more scalable approach would be for the user to send the name and
signature of their "instant provider" every time and the merchant just
chooses whether to ignore it or not, but as Lawrence points out, this is
incompatible with the provider charging extra fees for "instantness". But
should we care? I'm trying to imagine what the purchasing experience is
like with optional paid-for third party anti-double-spend protection.
Ultimately it's the merchant who cares about this, not me, so why would I
ever pay? It makes no sense for me to pay for double spend protection for
the merchant: after all, I'm honest. This is why it doesn't make sense for
me to pay miners fees either, it's the *receiver* who cares about
confirmations, not the sender.

So I wonder if a smarter design is that the user always submits the details
of their instantness provider and we just don't allow for optional
selection of instantness. I'm not sure that works, UX wise, so is having a
less scalable design to support it worthwhile?
-------------------------------------
On Sunday 28. December 2014 18.25.29 Mike Hearn wrote:

Can you explain further where limitations and problems were hit?

-- 
Thomas Zander


-------------------------------------
Peers exchanging mempool priority policies is great; that accomplishes
the flexibility in what txes to remember that I was going for with the
forget-filters, but much more neatly, with less overhead and some side
benefits.

Here's what I'm picturing now:
- exchange priority policies in peer introductions
- assign unique sequential IDs in the order the transactions were
inved (per peer)
- receiving a getdata for a tx updates last-known-peer-received inv to
all invs up to the one referenced
- include ID-last-received, last-known-peer-received in sparse block
- reference txes in sparse block by index in receiver's
prioritiziation with peer's sent invs up to ID-last-received and
sender's prior invs up to last-known-peer-received

Possible new messages:
- sparseblock
- invack message a node can send at times when it's received a bunch
of invs it already has, so it hasn't acked with a getdata in a while
- gettx: getdata, but using new sequential ID to save 28 bytes per tx

It seems important for ordering policies to be able to be specified in
as much detail as possible. Parameters that should be available:
- total inputs
- total outputs
- bytes
- coin days destroyed
- net UTXO size change
- sigops
- is data carrier
- is output raw multisig
- age in mempool
- what else?
This parameter set should be extensible to allow for unforeseen future factors.

Ordering policies should allow arbitrary algebraic combinations of
their parameters, as well as thresholds. Boolean combinations of
sub-policies would also be desirable. This could be implemented with a
tx-script-like stack-based language, in which each supported tx
property is pushed onto the stack by a particular opcode, and
+-*//min/max/boolean operators combine them to yield the sort key.

Difficult parameters:
* Coin-days-destroyed: changes, peers need agreement on when (if?)
it's recalculated. Probably can just not recalculate, but peers still
need agreement on "time seen" to get CDD.
* Age in mempool: seems intractable in terms of time, but could be
done easily in terms of "how many txes old is this sequential ID"

One potential pitfall: this allows for an environment of completely
heterogeneous mempool policies. I think that's a good thing, but we
need to avoid a situation where only least-common-denominator
transactions make it farther than a hop or two, and we don't want
nodes to have a strong preference for connecting to like-minded peers
since clustering reduces overall connectivity. It may be worthwhile to
add a parallel mechanism for relay policies, to differentiate between
what a node would keep in its mempool vs. what it wouldn't even relay
and doesn't want to see at all. Relay policies could be specified just
like prioritization policies, but with the final stack value evaluated
in a boolean context.

An interesting additional use of policy-scripts would be a
standardized way for miners to include a policy script in a coinbase,
allowing miners a mechanism to advertise things like their relative
price of sigops vs bytes. Nodes may then choose to take this
information into account in order to optimize their mempool policies
for likelihood of consistency with future blocks. Since policy scripts
provide only relative information on prices of different transaction
properties rather than an absolute fee, this should not allow miners
to "vote fees up", although care would need to be taken they wouldn't
be able to drive up prices by claiming common transaction types are at
the high end of the fee scale.


-------------------------------------

This isn't applicable in case of sidechains: anybody with sufficient
hashpower will be able to unlock a locked coin on the parent chain by
producing an SPV proof.
"Only if the miners form a shared valid history" isn't a requirement here,
as miner will get bitcoins which aren't in any way connect to sidechain he
have wrecked.  Thus there is no incentive to behave honestly.

Thus sidechains, in principle, reward their miners
with the same Bitcoin will use in the future: only transaction fees.


Whether it is enough depends on a variety of factors, including existence
of other chains miner can mine.
You cannot assume that it is the same situation as with a simple
single-chain model.

E.g. imagine 1000 BTC were moved to a sidechain. Miners can keep mining
bitcoins as usual, and in parallel work on an SPV proof to claim these 1000
BTC. (I assume that merged-mining is allowed.)
In this case the amount of fees which miners could collect by honest mining
on the sidechain is irrelevant, as long as it is smaller than 1000 BTC.

This is quite different from attacks which can be performed on vanilla
Bitcoin (see below), so I don't think you can say that the security model
is the same.

Also says "Given our assumption that p > q, the probability drops
exponentially as the number of blocks the

Yes, but that doesn't apply to reorganizations which attacker might cause
intentionally.
Hence I think it was disingenuous to include these two very different
treats into one section:
it sounds like you claim that attacker-induced reorganizations are
unlikely, while it isn't the case.

So the longer the contest period is, the harder it is to succeed with

Yes, but "harder" isn't same as "unlikely".

Another problem with this section is that it only mentions reorganizations.
But a fraudulent transfer can happen without a reorganization, as an
attacker can produce an SPV proof which is totally fake. So this is not
similar to double-spending, attacker doesn't need to own coins to perform
an attack.



Yep, thanks. It looks like you assume that sidechain security will be
similar to Bitcoin security in the long term.
Now quite the assumptions I've been looking for, but OK...

I'm sorry for the harsh tone, but I just find it hilarious that people who
explained that proof-of-stake is not going to work because an attacker
might collect everybody's past signing keys to rewrite the whole history
(I'm referring to this: https://download.wpsoftware.net/bitcoin/pos.pdf )
didn't bother to mention that miners can collude to wreck a sidechain and
get an awesome reward, basically for free.
something something the mote in thy brother's eye something something
-------------------------------------
I had Matt's answer already, see below, but then I recognized that the group was not cc:-d, so I repeat:

It would help on the user interface to include into individual shares:

1. Number of shares needed
2. A few bytes fingerprint of the secret so shares that likely belong together can be identified.

I wonder how others weight security vs. usability in these questions.

Regards,

Tamas Blummer
http://bitsofproof.com

On Saturday, 29 March 2014, at 6:22 pm, Tamas Blummer wrote:

I intentionally omitted that information because it's a security risk. If an adversary gains control of one share and can see exactly how many more shares he needs, he may be able to plan a better attack. If he is clueless about how many shares he needs, then he may not be able to execute an attack at all because he may not know whether his information about what shares exist and where is complete.

On 29.03.2014, at 17:54, Matt Whitlock <bip@mattwhitlock.name> wrote:


-------------------------------------
It is a paradigm that is easy to explain and grasp for neurotypical people. 

The average mind has no problem overloading words and distinguishing the intended meaning from context. For most people, overloading a single syllable word with a new meaning is much less complicated than using a unique 3+ syllable word like satoshi or micro-anything.

Doing software development warps our minds to demand fully qualified names for everything. We know our compilers would say "bit? Fatal error 0xaaabbbbwtf, can't continue, not sure if you mean a Boolean or a dog bite".  But this peculiarity should not be projected onto the people we are trying to get bitcoin to appeal to, not if we want them to feel like we think about their experience. 

If I were to say "a Bitcoin can be divided into a million bits", less than 0.1% of average joes would think I was talking about German beers or the thing that goes in horses mouths. Really, most people are good at using context to relate this to "a dollar can be divided into 100 cents" and accepting it.  This requires much less of their mind resources than using SI prefixes correctly or learning 3 syllable words that (to them) have no instantly apparent relationship to Bitcoin. 

Mike

Sent from my iPhone

On Apr 20, 2014, at 11:44 AM, "Arne Brutschy" <abrutschy@xylon.de> wrote:



-------------------------------------
Jorge Timn:
The node would need to first verify a block before mining on top of it.
Basically a receiver would ask a sender for missing transactions if he 
doesn't know them already before propagating or mining the block.

Christophe Biocca:
You're right, my idea doesn't offer any real advantage over 
prebroadcasting of the tree and including only it's header in a block.

Thanks,
Eric


On 22.01.2014 23:10, Jorge Timn wrote:


-------------------------------------

If you do a chargeback the bank double checks this, investigates it and
people who repeatedly try and do fraudulent chargebacks get their accounts
terminated. It's not like your bank offers you a "reverse this payment"
button in the UI that always works, right?



If you attempt fraud against a bank, they know who you are and will come
after you in one way or another. But it's safe to assume that users of a
double spend service would be anonymous and the kind of merchants they go
after are not hassling their customers with strong ID checks, so there
would be no consequences for them. It's a game they can only win.
-------------------------------------
"If you have database problems are you perhaps switching between 0.8.x and
0.9.x with the same directory?"
I think that may have been the issue.

Maybe now that I have a 0.9.0 official binary, when I switch to the source
builds I won't have the issue.

However, I think I'll do what you do and have separate bitcoin data
directories, that's probably the best.

not trying to test anything specifically, just codign, building, launching
over and over, would like to make the startup of the Qt client faster.

http://twitter.com/gubatron


On Wed, Mar 19, 2014 at 2:22 PM, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------
On Thu, Jun 5, 2014 at 7:43 PM, Richard Moore <me@ricmoo.com> wrote:

I don't understand. If you're using getheaders(), there is no need to
use getblocks() anymore. You just do a getdata() immediately for the
block hashes you have the headers but not the transactions for.

In general, I think we should aim for as much verifiability as
possible. Much of the reference client's design is built around doing
as much validation on received data as soon as possible, to avoid
being misled by a particular peer. Getheaders() provides this: you
receive a set of headers starting from a point you already know, in
order, and can validate them syntactically and for proof-of-work
immediately. That allows building a very-hard-to-beat tree structure
locally already, at which point you can start requesting blocks along
the good branches of that tree immediately - potentially in parallel
from multiple peers. In fact, that's the planned approach for the
headers-first synchronization.

The getgist() proposed here allows the peer to basically give you
bullshit headers at the end, and you won't notice until you've
downloaded every single block (or at least every single header) up to
that point. That risks wasting time, bandwidth and diskspace,
depending on implementation.

Based on earlier experimenting with my former experimental
headersfirst branch, it's quite possible to have 2 mostly independent
synchronization mechanisms going on; 1) asking and downloading headers
from every peer, and validating them, and 2) asking and downloading
blocks from multiple peers in parallel, for blocks corresponding to
validated headers. Downloading the headers succeeds within minutes,
and within seconds you have enough to start fetching blocks. After
that point, you can keep a "download window" full with outstanding
block requests, and as blocks go much slower than headers, the headers
process never becomes a blocker for blocks to download.

Unless we're talking about a system with billions of headers to
download, I don't think this is a worthwhile optimization.

-- 
Pieter


-------------------------------------
Haven't seen any message about this on the mailing list yet, so FYI:
0.9.0rc3 has been tagged.

The significant change compared to rc2 is that the mining code fee policy
now matches relay fee policy.

Also a rare crash in the wallet code was fixed.

There are some further small build system, documentation and GUI changes.

Please start your gitian builds.

Wladimir
-------------------------------------
On 1/3/14, Troy Benjegerdes <hozer@hozed.org> wrote:

An attacker could replace that part of the makefile.
Anyway, I think this is more oriented for compiled binaries, not for
people downloading the sources. I assume most of that people just use
git.


I'm afraid this is not possible.


There's package management systems like apt-secure that do exactly this.


-------------------------------------
Getting back to the original topic...

I would recommend first taking a look at how the current tests are built
(via autoconf/automake) in src/test.  There are several surfaces to test,
RPC, REST, P2P, internal unit tests, and more.  Then, Travis applies a
second level of testing via the bitcoinj-based regression tests.

Some automated tests that operate at the Qt level would be interesting.  In
general, the current tests only scratch the surface of what Needs To Be
Tested...  but part of figuring out a good test is (a) knowing bitcoin and
(b) knowing the current test regimes.

Join #bitcoin-dev IRC and ask questions.  Read the bitcoin wiki.




On Sat, Dec 20, 2014 at 2:42 AM, Will Bickford <wbic16@gmail.com> wrote:

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------------------------------
I disagree with this proposal both in spirit and in practice.

We all know satoshi was the best programmer like no one ever was. Clearly he intended this monetary supply from the beginning, who are we but mere mortals to go against satoshi's will?

Also, should we really do this with a soft fork when we can take this opportunity to redesign the whole system with a hard fork? This is out chance to switch to a whole new script engine!

Matt

On April 1, 2014 3:00:07 PM EDT, Pieter Wuille <pieter.wuille@gmail.com> wrote:
-------------------------------------


If you're going to go the direction of a {unitType, unitsPerInterval}  
tuple, then I think the only two units you could ever want are minutes and  
months. All other standard units of time can be expressed in terms of  
those two, right?

Also consider changing "optional uint64 ends = 4;" to be a interval count  
instead of a UTC timestamp, to avoid any ambiguity over how the 'while'  
loop should be implemented.







-------------------------------------
Not true, PHP does support sha2

http://php.net/manual/en/mhash.constants.php
http://php.net/manual/en/function.hash-algos.php#refsect1-function.hash-algos-examples
On 2 Mar 2014 08:44, "Mike Hearn" <mike@plan99.net> wrote:

-------------------------------------
This *could* be a useful feature, but only if it's generalizable to
other processor architectures, and **in particular** has an implementation
using dedicated silicon that has a **public** open-source hardware layout,
so you can X-ray the chip, and confirm with a thermal imager that yes, the
encryption code is actually running where you think it's running.

I was *almost* convinced that the 'new key per address' was a good idea
to mitigate ECDSA side channel attacks. Now, however, I find it quite 
plausible that intelligence agencies are promoting 'new key per transaction'
as a way to make sure all your keys are leaked all over RAM and the nearby
electromagnetic spectrum with side channels intentionally embedded in
commodity hardware.

If you want to convince me otherwise, then help me crowdfund an open-source
hardware Bitcoin ASIC that does the crypto and stores your private keys. 

I expect the 'new key per transaction' crowd will be in for a rude awakening
when they finally understand the silicon area cost to do this securely.

Conclusion: Not only is 'de-prioritizing address re-use' BAD privacy, it 
provides a social engineering/key leakage attack vector where someone can
track you down from the EMF generated by your bitcoin wallet when they send
you money.

If you think otherwise, let's build some ficking open-source hardware and 
find out how much silicon this will cost.

Although it's probably more profitable to just build a bitcoin wallet 
detector and keep your mouth shut.

On Thu, Mar 06, 2014 at 11:00:14AM +0100, Natanael wrote:




-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer@hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash



-------------------------------------
Not when failure is defined as, e.g., extra text pushing a UI element
down such that the button the user needs to click is no longer visible.
You don't test that except by having a human being run through some
example workflows, which is presumably happening during the release process.

On 06/13/2014 10:58 PM, Un Ix wrote:


-------------------------------------


I think you could just put a signed PaymentRequest into an NFC tag and try
reading it from that. It's the same underlying radio tech so the transfer
speeds should be similar, I'd think.

Common X.509 certs are bigger than they need to be for sure, but a lot of
the bulk comes from the use of RSA rather than ECC. An RSA signature alone
can be 256 bytes! There's nothing that states you have to use RSA for
certificates and ECC certs are out there (Google uses one), but I think
they are harder to get hold of. I guess over time SSL will migrate to
mostly ECC (secp256r1) based certs.
-------------------------------------
Multiple parameters is currently undefined as far as I can tell.  Should the client take the first, last, or ignore it completely if there are multiple of any parameter?  I think that’s the point of the parameter pollution discussion, which will define it one way or the other.

I’m only familiar with the Electrum implementation, which is currently checking for any duplicate parameters and treating the entire URI as invalid if duplicate parameters exist (following the parameter pollution suggestions).

-
Michael Wozniak

On Jul 1, 2014, at 10:59 AM, Andreas Schildbach <andreas@schildbach.de> wrote:




-------------------------------------
Guys, you are always talking about the Unicode astral plane, but in fact
its a plain old (ASCII) control character where this problem starts and
likely ends: \u0000.

Let's ban/filter ISO control characters and be done with it. Most
control characters will never be enterable by any keyboard into a
password field. Of course I assume that Character.isISOControl() works
consistently across platforms.

http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#isISOControl%28char%29


On 07/16/2014 12:23 AM, Aaron Voisine wrote:




-------------------------------------
On Mon, Jan 20, 2014 at 08:00:05PM -0800, Jeremy Spilman wrote:

Something to keep in mind is that it's quite likely that the indexes
available will be over H(scriptPubKey). There's really good engineering
reasons for doing this: you need to be able to create succinct proofs of
fraud in indexes, miner committed and otherwise, and the only way they
are succinct is if you limit the length. Hashes naturally do that
because it's so expensive to generate partial collisions.

If you don't do this on the other hand now you have a situation where
the usual case - max 16 level deep tree -  and worst case - hundreds or
even thousands of levels deep - are vastly different. That's hard to
test for and likely to reveal implementation-specific limits in nasty
ways.

Anyway, grinding nonces isn't much of a burden given it's fast hash
functions. The prefixes in question are fairly small and will be small
for the forseeable future. As I said elsewhere in this thread, even
Javascript has performance that's perfectly adequate for the task.

-- 
'peter'[:-1]@petertodd.org
00000000000000003590a8a20ec9ff5b1c1af3f046a1f62dc1ac9a464721fd8f
-------------------------------------
On Fri, Mar 28, 2014 at 12:07:04PM +0100, Mike Hearn wrote:

One of the main goals of steath addresses is actually scalability. In
particular in the refund address case you would use stealth addresses
with a per-order UUID so that refunds can be detected cheaply by just
scanning for payments to your (single) stealth address, then when those
payments are detected, check the UUID against a on-disk database. A
64-bit "UUID" is probably fine, although unfortunately with OP_RETURN
quite unexpectedly dropped to 40 bytes the standard needs to change;
might have to compromise on privacy and re-use a txin pubkey to make
things fit.

-- 
'peter'[:-1]@petertodd.org
0000000000000000f4f5ba334791a4102917e4d3f22f6ad7f2c4f15d97307fe2
-------------------------------------
On Tue, Apr 8, 2014 at 4:13 AM, Mike Hearn <mike@plan99.net> wrote:

-You- are irrelevant, as am I.  We don't mind such things.

But based on personal observations as well as Mozilla and other
browser data, the user populace in general does not install plugins.
Flash is the LONE exception to that ironclad general rule.

PS. Google Earth is not a plugin :)

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
Hey all,

I'm working on the UTXO database for my Python implementation of bitcoind and have found a situation I did not realize was valid, but since it seems to be, had a quick question.

If you look at block #546 the 4th transaction's first input uses its own block's 3rd transaction as an input.
https://blockchain.info/block/000000005a4ded781e667e06ceefafb71410b511fe0d5adc3e5a27ecbec34ae6

My question is, would the other way be valid, that is, could the 3rd transaction of a block, use the 4th transaction from the same block as an input? Or are transactions processed strictly top to bottom?

Thanks,
RicMoo

P.S. If it is valid, another question; what would happen if a transaction was self-referencing? I realize it would be very difficult to find one, but if I could find a transaction X whose input was X and had an output Y, would Y be a new valid utxo, without being a generation transaction input?

.`..`..`..`..`.><(((>

Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo@geneticmistakes.com
www: http://GeneticMistakes.com

-------------------------------------
On Sun, Oct 5, 2014 at 4:54 PM, Jorge Timón <jtimon@blockstream.io> wrote:

You can imagine that instead of subsidy Bitcoin came with a initial
set of nlocktimed transactions that pay fees, one block at a time, for
each block from the start until the subsidy goes away.

Perhaps that mental model might make it clear why some people think
that the nlocked transactions and the block size being lower than the
instant offered demand (there is always a backlog) are both things
which address the concern of this thread. :)


-------------------------------------
Am 12.04.2014 17:34, schrieb Matt Corallo:

Okay, my mistake. Sorry to trouble you, but good to know that you are here.

regards
Oliver



-------------------------------------
On 6/24/14, Mike Hearn <mike@plan99.net> wrote:

Exactly, this is part of my point, the qt-wallet does not support SPV
operation at this point, and that complex work should be done after
the wallet is separated. Thus the first version of the separated
wallet should be functionally equivalent to today's wallet, that is, a
full node wallet (even though I understand Wladimir's arguments
against full-node wallets).


Ok, thanks. So a bitcoin core node which maintains and serves
additional indexes (say, an utxo index via rpc or something else) is
referred to as "an electrum" even though it doesn't use
electrum-server. Strange, but now I get it.

So in summary:

1) I accept the library approach over the "core-wallet protocol".

2) That doesn't necessarily mean that optionally maintaining
additional indexes in the core is not interesting for some use cases
(interesting for bitcoind, I don't care much if electrum-server
currently does this and more [with more dependencies]). Although
Pieter thinks that should also be separated into an "index node" too,
but I think that's another discussion.

3) The wallet doesn't currently operate as SPV and that work should be
done (if there's enough interest) only after the wallet is separated
from the core.


-------------------------------------
	Someone sent me a very small donation (0.00121 BTC) without
paying fees. I don't know who sent it and I know this type of
transaction are usually rejected by miners. Take a look at it below:

https://imageshack.com/i/ngv5g8j

	Even with the a low probability of confirmation, I
was hoping that after a few days it could be included in a block, but
Blockchain.info simply removed it (I know the sender sent from a
Blockchain.info wallet, because he added a note):

https://blockchain.info/pt/tx/3cde47ee3979a46b36bd61bdb0caf9c11dea58ac99f17fb17b95728766de70e0
	
	As you can see now it shows as "Transaction not found".

	My suggestion is: it would be nice if the receiver could have a
chance to pay the fee when the sender didn't pay any fee. For example,
I could pay a fee of 0.0001 BTC and receive 0.00121 BTC. In the end I'd
have 0.00111 BTC. Better than nothing.

	Would it be technically possible to do that or it would be too
much trouble to change the protocol to allow the receiver to pay an
optional fee?

	Ps: I'm not a programmer, but if the receiver could
optionally "attach" some fee to the transaction, even if he/she didn't
sent the transaction, this could be solved. Bitcoin-qt could even warn
the receiver he received a transaction without fee and if he wants 
faster confirmation he could pay a fee.

	Ps2: if this is a silly suggestion, just ignore it. I tried on
Bitcointalk, but nobody answered.

-- 
Linux 3.12.0: One Giant Leap for Frogkind
http://www.youtube.com/DanielFragaBR
http://mcxnow.com
Bitcoin: 12H6661yoLDUZaYPdah6urZS5WiXwTAUgL




-------------------------------------
Now you are talking about Trusted Platform Modules. Like smartcards,
actually. Devices that won't leak their keys but let the holder spend the
coins. It could even have it's own simple SPV wallet client to make it
easier to handle. And they'd use the attestation features provided by the
TPM to prove the software it's unmodified top the current holder.

But then you still have to trust the manufacturer of the device, and you
have to trust it has no exploitable side channels.

- Sent from my phone
Den 18 maj 2014 13:52 skrev "Alex Kotenko" <alexykot@gmail.com>:

-------------------------------------
I'm sure this suggestion will go down like a lead balloon, but Bitcoin Core
is not the first project that's had issues with Linux distros silently
modifying their software as they package it. In this case Luke has changed
things to be closer to what users expect, which is good to see, but I
expect to see the same issue crop up with other Linux distributions in
future. The temptation to "improve" things when you're a middleman is just
too great.

The usual approach to fixing it is trademark the project name and use that
to enforce "clean" packaging. Firefox and Chrome both take this approach.
I'll probably do the same with Lighthouse (need to figure out the
trademarking process first).

The goal here is not to remove choice, rather to ensure people know what
they're getting. It's reasonable to assume if you do "emerge bitcoin" then
you're getting Bitcoin Core as distributed by bitcoin.org, not a highly
opinionated fork of it. Renaming a project and creating a package under the
new name is not only better for end users, but lets the fork grow into
something else and be more usable to people on other distros too.

In this case "Bitcoin" is already a trademark, though I lost track of who
owns it at the moment (the foundation?) but I guess Bitcoin Core is not.
-------------------------------------
Just a small note of caution for those joining in testing.

https://github.com/bitcoin/bitcoin/issues/3529
Currently the master branch has this issue where leveldb renames all of
.sst files to .ldb.  This makes running the 0.8.x version of Bitcoin think
the index is corrupt.  Until a fix is included in Bitcoin master, a
workaround to allow 0.8.x to work again is to simply rename all the files
from .ldb back to .sst.

(This workaround worked for me today but failed yesterday.  It's possible I
made an error yesterday.  If it fails for you please report as we really
need to know if there are other leveldb incompatibilities.)

https://github.com/bitcoin/leveldb/pull/3
The fix for Bitcoin's leveldb is being discussed here.

Warren


On Wed, Jan 15, 2014 at 11:09 PM, Wladimir <laanwj@gmail.com> wrote:

-------------------------------------
On Fri, Jul 18, 2014 at 8:06 PM, Emin Gün Sirer <el33th4x0r@gmail.com> wrote:

Oh that does sound interesting— its the property I was trying to
approximate with the FEC..  It achieves the one-shot, but there is
overhead. One plus we have is that we can do some tricks to make some
computational soundness arguments that we'd actually get average
performance on average (e.g. that someone can't author transactions in
such a way as to jam the process).



Thank you, I've certantly queued the paper for reading.


-------------------------------------
Oh, I see. I misread, thinking you wanted the dev team to have a private key and share the public key, similar to alerts. But each peer would have a public/private key pair and use something akin to ECDH for a symmetric key and transport using a block cipher?

How would you share the public key? If I were a man-in-the-middle, I could intercept the public key, generate my own and pass that along and then decouple the pipe when the other side shares their public key.

Also, you should not ignore your SSH fingerprint, as you exactly open yourself to mitm attacks.



On Aug 19, 2014, at 11:11 AM, Ral Martnez <rme@i-rme.es> wrote:


.`..`..`..`..`.><(((>

Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo@geneticmistakes.com
www: http://GeneticMistakes.com

-------------------------------------

Nope, it's still colored coins. The difference between colored coin model
and Mastercoin model is that colored coins are linked to transaction
outputs, while Mastercoin has a notion of address balances.

The implications of this is that in colored coin model explicit
dependencies allow us to rely on SPV. (Assuming that one can fetch the
dependency graph to link txout in question to genesis.)
While it is not the case with Mastercoin.

While it's pretty far from the original colored coins model, what Flavien
have described is identical to it in majority of aspects.

This is an interesting approach, but OP_RETURN size limitations can be a
significant problem for some kinds of applications.
-------------------------------------
On Fri, Apr 25, 2014 at 7:53 AM, Jim <jim618@fastmail.co.uk> wrote:

I don't believe that wallet interoperability at this level is possible
in general except as an explicit compatibility feature. I also don't
believe that it is a huge loss that it is so.

The structure of the derivation defines and constrains functionality.
You cannot be structure compatible unless you have the same features
and behavior with respect to key management.  To that extent that
wallets have the same features, I agree its better if they are
compatible— but unless they are dead software they likely won't keep
the same features for long.

Even if their key management were compatible there are many other
things that go into making a wallet portable between systems; the
handling of private keys is just one part:  a complete wallet will
have other (again, functionality specific) metadata.

I agree that it would be it would be possible to support a
compatibility mode where a wallet has just a subset of features which
works when loaded into different systems, but I'm somewhat doubtful
that it would be widely used. The decision to use that mode comes at
the wrong time— when you start, not when you need the features you
chose to disable or when you want to switch programs. But the obvious
thing to do there is to just specify that a linear chain with no
further branching is that mode: then that will be the same mode you
use when someone gives you a master public key and asks you to use it
for reoccurring changes— so at least the software will get used.

Compatibility for something like a recovery tool is another matter,
and BIP32 probably defines enough there that with a bit of extra data
about how the real wallet worked that recovery can be successful.

Calling it "vendor lock in" sounds overblown to me.  If someone wants
to change wallets they can transfer the funds— manual handling of
private keys is seldom advisable, and as is they're going to lose
their metadata in any case.  No one expects to switch banks and to
keep their account records at the new bank. And while less than
perfect, the price of heavily constraining functionality in order to
get another result is just too high.


-------------------------------------
If you buy a TREZOR you will of course install the plugin :)

What I mean is that normal people are lazy : if the solution is already in
their hand they will use it, if they need to install/configure something,
they won't do it.

I'm not trying to propose a solution to solve the auth on the web, but to
ease the sign up / login on the Bitcoin ecosystem websites and apps.
More sign ups to new services (whatever the services) = more usage =
expanding ecosystem = more global value to Bitcoin

Wallets are a key element of the equation because :
- everyone has one (desktop or mobile)
- everyone (in theory) has already taken all steps to backup and secure
their keys
- id yourself with a Bitcoin address often makes sense on a Bitcoin related
service

Eric
-------------------------------------
For a p2sh multisig transaction, the serialized script looks like this:

m [pubkey] ... [pubkey] n OP_CHECKMULTISIG

The p2sh address is the hash of this script. The public keys can come in
any order, but the hash depends on the order. If you have a list of
public keys, to which address do you send your money? We need a standard
way of sorting the public keys so that the address generated is always
the same for the same public keys and m.

There are two kinds of public keys: compressed and uncompressed.
Uncompressed are longer than compressed.

There are a few obvious ways we could sort the public keys: as strings,
as big endian numbers, as little endian numbers.

The difference is this. Suppose one public key is 59234 (uncompressed),
and the other is 6903 (compressed). If we sort these as strings, then
6903 > 59234. But if we sort them as big endian numbers, then 6903 is
really 06903, and then 06903 < 59234. So it makes a critical difference.
Sorting as little endian is yet another option that is not the same as
the other two.

I noticed Alan Reiner's comment in an earlier message:

"Just like Jean-Pierre mentioned, we'll be using parallel
trees to generate P2SH addresses after sorting the keys
lexicographically."

It sounds like "lexicographically" probably means sorting as strings. I
have made an implementation of public key sorting in javascript where I
sort them as big endian numbers and fill in the 0s. IMO, the simpler
method is to sort them as strings, which has a simpler implementation
since it doesn't require filling in 0s first. However, I don't actually
care what method we use so long as everyone in the bitcoin world uses
the same standard. Which is the best way to sort public keys?

-- 
Ryan X. Charles
Software Engineer, BitPay
-------------------------------------
On Wed, Apr 23, 2014 at 10:24 PM, Gregory Maxwell <gmaxwell@gmail.com>wrote:


Yes, but that can be fixed with double spend alerts.



No? It's not just your decision that matters, the receiver also has to
trust them. They're like a dispute mediator in this regard. You can pick
whoever you want, but that doesn't matter if the receiver doesn't recognise
them or trust them. You have to find an overlap to make an instant trade.

In practice if people have to think about this, evaluate brands etc then
you'd get a very small number of parties because the value of global
agreement is so high. Then it becomes hard to remove ones that have a lot
of momentum.

The censorship resistance of the block chain doesn't matter if your double
spending partners refuse to help you spend your money (because they're
being coerced). The censorship can just happen at a different place.



..... or, have a majority decide to zero out their coinbase rewards for
blocks that double spent against dice sites. That wouldn't undo the double
spend, but you can't do that with the multisig scheme either. All you can
do is punish the corrupted party post-hoc, either by not using them again,
or by "unpaying" them for the service they did not provide.
-------------------------------------
On Saturday, 29 March 2014, at 9:44 am, Tamas Blummer wrote:

I have expanded the BIP so that it additionally applies to BIP32 master seeds of sizes 128, 256, and 512 bits.

https://github.com/whitslack/btctool/blob/bip/bip-xxxx.mediawiki

The most significant change versus the previous version is how the coefficients of the polynomials are constructed. Previously they were SHA-256 digests. Now they are SHA-512 digests, modulo a prime number that is selected depending on the size of the secret.


-------------------------------------

On 23.04.2014, at 21:55, Luke-Jr <luke@dashjr.org> wrote:

This is a bit idealistic. 
The wallet has to know how it got the UTXO in order to be able to spend it.
-------------------------------------
On Sun, May 4, 2014 at 8:15 AM, Aaron Voisine <voisine@gmail.com> wrote:

+1 good summary

And I think that's a good conclusion to this discussion about unit
names on the development mailing list. Everything has been said now.

Wladimir


-------------------------------------

On 01/13/2014 03:14 PM, Peter Todd wrote:

It's not public.  When I say "please pay me" I also say "use this
multiplier".  The multiplier isn't published, and it's not publicly
discoverable without my wallet (or access to my email).  The address
remains private between you and me.  As you said, it could be
discoverable if the email is discoverable, but I'm not seeing how how
critical that really is.

There's a lot of complexity around this constraint (possibly involving
new/secondary private keys, extra outputs, relying on change outputs,
and/or using 3rd parties to help look for transactions).  I'm not
convinced that what is being gained is really worth that extra complexity.

By contrast, what I proposed, that does require sending sending the
payer a multiplier once, is easy to implement in any BIP 32 wallet,
doesn't require any special address formats, and achieves 98% of the
same benefits without any special computation.   I guess I'm just not
convinced that it's really necessary for people to be able to send
others payments without contacting them (and/or hiding the evidence a
payment was made even if they communications were discovered).

-Alan



-------------------------------------

instruments,


Meni Rosenfeld issued tradeable mining bonds back in 2012:

https://bitcointalk.org/index.php?topic=65569.0

So this is hardly new stuff. But it definitely won't help.
The contract specifies how many bitcoins bondholder would get depending on
difficulty and other factors.
But, usually, bondholder doesn't care (and cannot check) where these
bitcoins come from.

Thus the owner of the mining equipment can temporarily turn off that
equipment off, and instead buy them on the market, as he needs to spend
less money than he would spend on electricity. Then he can pocket the
difference.



Ah, yes, let's forget game theory, business people know it better!
-------------------------------------
If you want to try and argue that the development list is the wrong place
to discuss development, please do so on another thread (or your blog).
Let's keep this thread for discussion of the original proposal - ideally,
discussed with the dryness that a topic as nerdy as distributed consensus
algorithms deserves ;)
-------------------------------------
On Fri, Mar 21, 2014 at 12:02:44AM +0100, Mike Hearn wrote:

The actual example I was thinking of is that of traditional British
pubs.  Often a company will own several pubs - however the pubs
themselves will typically have individual traditional pub names.  The
name of the company might not be at all prominently advertised in the
pubs.

Traders at music festivals are another example that comes to mind (they
often accept credit cards if they sell higher value items so why not
Bitcoin?)  In this example there often are no clearly advertised
business names - at least, that the customer will be aware of.

roy


-------------------------------------
On Mon, May 19, 2014 at 10:48 AM, Wladimir <laanwj@gmail.com> wrote:

Regarding tor-arm, here are some screenshots:
https://www.atagar.com/arm/screenshots.php

It shows, among other things:
- bandwidth up/down graphs
- CPU usage
- debug logging (in real time)
- connected peers+statistics
- currently active configuration

Would be nice to have a similar tool for bitcoind.

Wladimir


-------------------------------------
On Fri, Jan 3, 2014 at 9:59 AM, Drak <drak@zikula.org> wrote:


Maybe a simple compromise would be to add a secure downloader to the
bitcoin client.

The download link could point to a meta-data file that has info on the
download.

file_url=
hash_url=
sig_url=
message=This is version x.y.z of the bitcoin client

It still suffers from the root CA problem though.  The bitcoin client would
accept Gavin's signature or a "core team" signature.

At least it would provide forward security.

It could also be used to download files for different projects, with
explicit warnings that you are adding a new trusted key.

When you try to download, you would be given a window

Project: Some Alternative Wallet
Signed by: P. Lead
Message:

Confirm download Yes No

However, even if you do that, each trusted key is only linked to a
particular project.

It would say if the project and/or leader is unknown.
-------------------------------------
On Wed, Apr 23, 2014 at 12:19 PM, Mike Hearn <mike@plan99.net> wrote:

A finney attack is where you attempt to mine a block with a
transaction paying you, and as soon as you are successful you quickly
make a transaction spending that coin to someone else, then release
the block after they've taken an irreversible action. If everything is
automated it should have something like a 99% success rate, though it
has a cost of some small increase in the number of orphan blocks you
experience.


You might have coined the term, but I don't think the attack you're
describing is the attack Hal described:
https://bitcointalk.org/index.php?topic=3441.msg48384#msg48384

What you're talking about is just disagreement about the content of
the memory pool, but we have no consensus mechanism there (the
blockchain _is_ the consensus mechanism).  Mempools are sometimes
inconsistent all on their own, without any attacker being involved.


I think thats an unsophisticated view.

Consider this protocol.

I take some of my funds and assign them to a 2 of 2 multisig with
myself and Oscar. I do not announce this transaction until I get Oscar
to sign a timelocked anyonecanpay refund to send the coin back to me
(say in 3 months).  Oscar gives me my refund and I announce the
transaction.

Later I can make instant payments with oscar signing up until the
refund time comes clue to anyone who trusts Oscar to never double
spend.  For the receiver this is purely additive with regular
blockchain security: in that even with Oscar's help I cannot double
spend except where I would have been successful absent Oscar. On the
sender side, Oscar cannot up and steal my funds and he can't try to
extort me (except by creating a delay up to the refund time).

Oscar himself can be implemented as a majority M parties to further
increase confidence, though if you're talking about using this for low
value retail transactions— the fact that any cheating by oscar is
cryptographically provable (just show them the double signatures)
maybe be strong enough alone. (Though there is a multitude of other
proposals to provide more evidence of Oscar's honesty). There are also
ways to blind Oscar so he can't reliably identify which transactions
are ones he signed for.

I don't think this is at all a "return to trusted third parties"— that
it's a shrug and an admission of defeat. Its a very narrowly scoped
trust, filling in precisely where large scale decentralized consensus
is fundamentally weak... the result is something which combines
advantages from both classes and is stronger than either trust or
blockchains alone.  (I'm also not trying to say that an implementation
of this is _simple_ by any means, working out all the details is
hard.)

By contrast, I think proposals which overly depend on colluding miners
to behave in very specific ways are themselves just a way of saying
block chains suck unless we turn the miners themselves into a trusted
third party. I'm much more in favor of adding a little bit of
mastercard to transactions where mastercard is really what people
want, than turning mining— and thus bitcoin itself— into mastercard,
especially since miners— self selecting as they are— are a pretty poor
set of parties to act as trusted agents. :)


We have an existence proof that it isn't so— you can say that it
wasn't consistent enough, but what is? There wasn't any major doubt
that they were actually doing it. They're the largest identifiable
pool as we speak.

I think, instead, that strong zero-conf security isn't a part of what
many people think of when they think of Bitcoin's characteristics.
Zero conf is risky, and I think for a lot of people thats okay.  If it
isn't there are ways to improve it that don't involve asking miners to
participate in a majority vote to take away funds from people.


-------------------------------------
It may not be our place to say whether XP is secure or not, but if we say that we support it then we have to run test passes against XP as a platform, and if an XP user reports a bug, then we have to do something to address it.  So, it becomes a test and support issue, not a security issue.

Thats why it doesnt make sense to support an OS platform that the original vendor (MS) no longer supports themselves.

On Apr 16, 2014, at 9:35 AM, Mark Friedenbach <mark@monetize.io> wrote:


-------------------------------------
On Thursday, October 16, 2014 6:22:04 AM Wladimir wrote:

Discussion vs simple ACKing.


-------------------------------------
I would be very happy if we upgraded the P2P protocol with MAC keys and a
simple home grown encryption layer, because:

   1. It's practically guaranteed that 5-eyes intelligence agencies are
   either systematically deanonymising Bitcoin users already (linking
   transactions to real world identities) or close to succeeding. Peter is
   correct. Given the way their infrastructure works, encrypting link level
   traffic would significantly raise the bar to such attacks. Quite possibly
   to the level where it's deemed unprofitable to continue.

   2. Tor is not a complete solution. The most interesting links to monitor
   are those from SPV clients connecting to Core nodes. Whilst Java SPV
   clients have the nice option of an easy bundled Tor client (er, once we fix
   the last bugs) clients that are not based on bitcoinj would have to use the
   full-blown Tor client, which is not only a PITA to bundle as Tor is not at
   all library-fied, but is a giant pile of C which is almost certainly
   exploitable. Even if it runs in a separate address space, for many
   platforms this is insufficient as a compromised Tor client could then go
   ahead and compromise your wallet app too.

Implementing a full Tor client is not a reasonable thing to ask of a wallet
developer, but doing HMAC checks and a simple ECDH exchange + AES would be
quite realistic.
-------------------------------------
On 05/24/2014 08:14 PM, Gregory Maxwell wrote:

Would this not be solved by putting a expiration on application of this
logic?  For instance, if you haven't received the full new block within
5-10 seconds (perhaps adjusted based on local bandwidth), then the
header-received time is ignored.  Or is this too hacky?   I suppose this
is exactly what Ashley is trying to solve, she's just already made a few
more leaps forward in the design process than I have.  I'll stop
derailing it.


-------------------------------------
I agree, it looks very slick.  Well done.

While on the subject of connected peers, what about the idea of adding the ping time from this node to other peers?  The problem with fitting that information into the current design is that the graphs seem to be comprised of overall statistics for this node, not per-peer statistics that can vary between peers (such as ping time).  If a line were to be added to a graph to represent each peer's ping time, the number of lines (statistics) on the graph would have to vary in real time as peers are added or removed, which would be a challenge.

I earlier added the "ping" feature to bitcoind, and it works to measure the ping time, however this feature is on-demand: it won't ping other nodes unless requested.  So, something would have to send the "ping" RPC command on a regular schedule, to ensure the graph is updated with new information.  Also, there is currently no support for overlapping pings (although that would be easy to add), so if a peer is slow enough to not respond at all to the first ping request, and a second ping request goes out in the meantime, any late response from the first ping request would then be discarded.

Great graphs, and these are just brainstorms for future ideas :)

Josh Lehan

Sent from my iPad



-------------------------------------
Thanks for the valuable feedback. I see there is a strong concern with
requiring a large BTC capital for issuing coloring coins, so I am now in
the process of modifying the specification to address that. I will post an
update when this is finished.

By the way, padding doesn't solve the issue entirely (issuing 10 billion
shares sill takes you 100 BTC, even with padding and 1 satoshi = 1 share),
so I am going for the solution where the asset quantity of every output is
explicitly encoded in the OP_RETURN output. That way, whether you are
issuing 1 share or 100 trillions, you never need to pay more than 540
satoshis.


On Mon, Apr 7, 2014 at 8:58 PM, Alex Mizrahi <alex.mizrahi@gmail.com> wrote:

-------------------------------------

+

We shouldn't make any assumptions about the future price of bitcoin to make

Hmmm ;) Didn't you just make an assumption about the future price?



The currencies I'm familiar with are CHF, USD, EUR and GBP, which all have
roughly similar values. I guess such currencies make up the bulk of the
Bitcoin userbase at the moment.




Saying "it's already popular and would take work to change" is not really a
fallacy now, is it?

But anyway, this is getting silly. You don't have to convince me. Go visit
all the services I listed above, plus all the ones I didn't find in my five
minutes of searching, and convince them they're wrong like the flies and
switching is the best use of their time :o
-------------------------------------
On 6/16/2014 8:09 AM, Daniel Rice wrote:

Before considering a hard fork with unpredictable effects on the 
uncertainty window, it would be interesting to look at a soft fork that 
would directly target the goal of reducing the uncertainty window, like 
treating locally-detected double-spends aged > T as invalid (see earlier 
message "A statistical consensus rule for reducing 0-conf double-spend 
risk").

If anything is worth a soft fork, wouldn't reducing the double-spend 
uncertainty window by an order of magnitude be in the running?

Reducing the reasons that transactions don't get relayed, which actually 
seems to have a shot of happening pretty soon, would also make this kind 
of thing work better.



-------------------------------------
Mike Hearn <mike@plan99.net> wrote:
like
Ultimately

Lawrence Nahum <lawrence@greenaddress.it> wrote:

I don't think a whitelist of trust is a practical approach because you are
going to want to have varying levels of trust in different instant
providers. This would be based on how large their past transaction volume
has been. For that reason maybe another approach is an additional
negotiation message between the merchant and wallet. Merchant sends payment
details -> wallet responds with their instant information requesting if an
instant transaction will be accepted for this transaction. Merchant weighs
the risk based on historical data about this particular instant provider
and the amount of the requested transaction -> Merchant responds yes or no.

That approach avoids the scaling issue, but also allows for Lawrence's use
case of charging the user a fee only in the case where the instant
transaction is supported.


On Mon, Jun 16, 2014 at 1:29 PM, Daniel Rice <drice@greenmangosystems.com>
wrote:

-------------------------------------


Unfortunately I think some people already started using XBT to mean the
same as BTC (another ship that sailed: somehow Bhutan will have to live
with it). So if some software started to redefine it to mean something
else, that seems like a recipe for accidentally sending far too much or too
little money by mistake.

The whole area of symbols, denominations etc is a confusing mess right now,
it opens up the potential for mistakes and makes Bitcoin look
unprofessional. Part of the reason I don't want us to revisit this at the
moment is we need to grab onto any consistency we can get. People want to
think in terms of a single unit. BTC vs mBTC is already bad enough, it'd be
easy to miss the denomination and do some sums wrong. Introducing a third
unit, especially one that skips the intervening nanoBTC, seems like a way
to make mistakes even more common!
-------------------------------------
Hi Everyone,

The Armory team is pleased to announce the official release of our
decentralized multi-signature interface, called "Lockboxes".  It is a
"true" multi-signature transaction interface:

  * Decentralized multi-sig (no third-party servers or signers needed)
  * Any multi-sig from 1-of-2 up to 7-of-7
  * Any or all of the signing devices can be *offline*
  * All private keys can be generated and managed independently
  * Works with existing Armory wallets
  * Simultaneous funding ("simulfunding") features for escrow and
    contracts (basically CoinJoin)
  * All wrapped up in a nice graphical user interface!

Armory 0.92 includes a GUI for creating, funding and spending from
multi-signature lockboxes, anything from 1-of-2 up to 7-of-7.  All
private keys can be generated independently and never have to be
co-located.    Most importantly, any number of the signing keys can be
created and managed on offline computers!  Also, all transaction and
signature data is communicated directly between parties/devices using
ASCII-armored blocks of text, so no third-party servers/services are
needed (though, in the future, we hope to provide an optional service to
help synchronize the data between parties).

The release also includes the ability to do simultaneous funding
("simulfunding") which is basically CoinJoin through a GUI, but intended
to be used for contracts and escrow.  Each party creates a "promissory
note" (which is basically just a list of UTXOs and a change address),
and those can be merged into a single transaction to be signed by all
funders.  Either all contributions are made simutaneously, or none of
them are.   There is no other outcome.  This means that no trust is
required between the simulfunders.  It is a basic contract enforced by
the bitcoin network itself.

Simulfunding would normally be used in conjuction with multi-signature
lockboxes -- two parties that don't trust each other together create a
lockbox, and then simultaneously fund it (and subsequently spend it)
according to some agreement.  However, it can actually be used to
simulfund any address.  To promote this feature, Armory Technologies Inc
is offering to match up to 20 BTC in donations to the EFF, FSF, College
Crypto Network, Chamber of Digital Commerce, and the Bitcoin Foundation
(and hopefully wikipedia, as a late addition to the list).    We posted
a list of ATI "promissory notes" for matching donations on our
website:   https://bitcoinarmory.com/donation-match-list/

We're very excited about this release, which has been in testing for
over three months, and we've been using for management of company funds
between officers for the last two months.  We have not seen anything
else that comes close to matching the flexibility and security afforded
by it (and without being exceptionally inconvenient!).   See our
tutorials, and especially the FAQ at the end: 

https://bitcoinarmory.com/about/using-lockboxes
https://bitcoinarmory.com/about/using-lockboxes/#faq
 
We hope that people will try it out and provide feedback.  Maybe even
match some donations!  We've already matched 3 BTC so far and it was
announced less than 24 hours ago. 

Cheers,
-Alan


------
Press Release: 
http://finance.yahoo.com/news/armory-releases-first-decentralized-multi-233500704.html
------
Changelog:

*VERSION 0.92**
**Released July 29, 2014**
*

    - *Multi-Signature Lockboxes!*
          Full-featured interface for creating multi-signature addresses,
          putting money into them, and collecting signatures to spend them.
          See our tutorials at:
https://bitcoinarmory.com/about/using-lockboxes/

    - *Simulfunding for Addresses and Lockboxes*
          Use the "Multi-Sig" menu to do prepare simulfunding to any
          arbitrary address.  Or click on the "Simul" checkbox in the
          lockbox manager if you are simulfunding a lockbox.  As a promotion
          for this feature we are matching up to 20 BTC worth donations
          to organizations that support Bitcoin, digital security, online
          freedoms, and open-source software.  See our donation list (with
          instructions): https://bitcoinarmory.com/about/donation-match-list

    - *Improved Mac/OSX Stability*
          We merged a couple Qt4 patches that dramatically improved
          compatibility on OSX 10.7 and newer.  Should work with the
          upcoming release of OSX 10.10.

    - *Armory Daemon/API Upgrades (Beta)*
          The Armory API has been upgraded substantially since version 0.91.
          This version has tons of new functionality matching bitcoind,
          as well as unique functionality including lockbox operations.
          Plan to have complete functionality implemented and tested by
          version 0.93.

    - *Upgraded Transaction History Export to CSV*
          Added running balance reporting for individual and all wallets.
          Also fixed a bug where internal transfers within wallets were
          not being reported properly.

    - *Root PUBLIC Key Export*
          You can now export just the root public key data that allows
          you to reconstruct your watching-only wallet.  It is five lines
          that are easily printed or copied by hand.  Could be used to
          provide someone a chain of addresses for multiple payments.

-------------------------------------
On Tue, Apr 8, 2014 at 5:58 PM, Andreas Schildbach <andreas@schildbach.de>wrote:


I didn't mean "Bare minimum of some spec", but "spec describing bare
minimum", which is different. I'm sorry for confusion.

Marek
-------------------------------------
Don't most of these coins have a magic number already assigned that is
unique? (0xD9B4BEF9 for Bitcoin, 0x0709110B for Testnet, FBC0XB6DB for
Litecoin, etc...).  This seems like a good candidate for identifying coins,
and also supports Testnet cases well.  Maybe there are some alts without
such a magic number that might prevent that?

-Allen


On Thu, Mar 27, 2014 at 10:43 AM, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
On Sat, Oct 11, 2014 at 11:34 PM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

"Much faster" is an understatement. Benchmarking here shows one hour
five minutes syncing to 295000.   Old code isn't even at 250000 after
7 hours.


(I'm using 295k as the target here because after that point ecdsa
dominates, and then your 6+x faster libsecp256k1 makes more of a
difference)


-------------------------------------
On Thu, Mar 13, 2014 at 1:56 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:


I've kind of given up getting any consensus about this, or even getting
people to care.

Everyone agrees that a decimal shift would be good, but it's the same
boring shed painting discussion every time on how many decimals. In the end
nothing happens.

I can't really blame Andreas for finally taking action and making the
change to mBTC. People in the community are familiar with mBTC because some
exchanges and price sites used mBTC (at least for a while when >$1000),
also mBTC seems to be catching on on reddit etc.

Moving to muBTC (which in itself would be better because it is the final
unit change ever needed without hardfork) would require more coordinated
education effort.

Wladimir
-------------------------------------
I'll implement it in breadwallet (oss SPV wallet, hopefully about to
be in the app store) if other wallet authors are planning to.

Aaron
https://github.com/voisine/breadwallet

There's no trick to being a humorist when you have the whole
government working for you -- Will Rodgers


On Fri, Jun 6, 2014 at 12:00 PM, Jeff Garzik <jgarzik@bitpay.com> wrote:


-------------------------------------
This is another problem that only exists because of the desire to soft
fork. If "script 2.0" is a hard fork upgrade, you no longer need weird
hacks like scripts-which-are-not-scripts.
-------------------------------------
My android wallet is working OK. Yes it isn't great when seeds have
temporary availability problems but things are still working.

There's a couple of pull reqs outstanding to include hard coded seed peers
and getaddr sourced IPs. Once those are finished and merged in there'll be
more backup paths.
On 16 May 2014 11:16, "Andreas Schildbach" <andreas@schildbach.de> wrote:

-------------------------------------
Oops, sorry. I meant: replace the top stack item with the block height of the txin doing the redeeming. (So the script can calculate the "current time" to some reference time embedded in the script.)


On Friday, 3 October 2014, at 10:28 am, Matt Whitlock wrote:


-------------------------------------
On 05/21/2014 10:10 AM, Wladimir wrote:

Honest question: what would signed commits do to help us here anyway?
What's the problem being solved?

Unfortunately git places signatures in the history itself, so it's not
like we could use easily use signatures to indicate acceptance after
code review, like we could if we were using monotone for example. Git
just wasn't designed for a commit-signing workflow.


-------------------------------------
This is very strange...when did you run this test and can anyone else
reproduce this?

Matt

On 05/15/14 11:50, Andreas Schildbach wrote:


-------------------------------------

On 06/07/2014 07:22 AM, Mike Hearn wrote:

Please let me know if we've gone down this path before, but it would
seem that the more different bloom filters you create, the more
information you give away.  It would be most useful to create a single
bloom filter that captures every address you ever intend to use (say a
look ahead of 1000 addresses), and then only ever communicate that. 
Once people see multiple filters that you produce, they can start
looking at the intersection of them to reduce the identity space.  I
would expect that after enough bloom variants, they could figure out a
perfect subset of blockchain addresses in your wallet.  (I suppose you
could intentionally select an extra 20% addresses to include in every
bloom filter, but it's a hack).

Similarly, if you keep updating your bloom filter to include more
addresses, the difference in what passes through the previous one and
the new one gives away information about new addresses you created.


-------------------------------------
I agree with you Jeff. The unit switch needs to happen once and once only,
but that is exactly why I said the defaults really need to change in
Bitcoin-Qt since that is still the main reference implementation and it
will influence others.

Bitpay could also take the lead here and make the switch to their defaults.
That would greatly assist the uBTC movement.

Regardless of what anyone says, Bitcoin-Qt is still the main reference
implementation and the best way to encourage a change in the community at
large is for the default units to be changed here. Core devs can surely
garner enough consensus among themselves to accept and merge a PR to that
effect. That will send a message, more than anything else that can be done.

My two satoshi.

Drak


On 13 March 2014 16:29, Jeff Garzik <jgarzik@bitpay.com> wrote:

-------------------------------------
On Tue, Oct 7, 2014 at 6:08 PM, Mike Hearn <mike@plan99.net> wrote:

The next minor release (0.9.4) could have Gavin's change already.

I don't think CHECKLOCKTIMEVERIFY will make it into the next major
release though. Once headers-first and pruning is merged (which is
expected to be a matter of weeks). I'd like to split off the 0.10
branch and give it some time to stabilize with a feature freeze, then
do a release before the end of the year.

So 0.11, in say 6 months, would be soonest.

Wladimir


-------------------------------------
On Sat, Jan 18, 2014 at 05:12:58PM -0600, Jeremy Spilman wrote:

Keep in mind that Bitmessage uses the same ECDH mechanism as what
stealth addresses will use. They seem to get decent enough performance
from it for a use-case not-unlike that of a Bitcoin wallet.

In any case I'm interested in knowing actual performance numbers for it;
last I talked to Kyle Drake he said he was working on getting ECDH
numbers on Javascript, probably the slowest possible implementation of
the idea. As for send to stealth addresses using prefixes, he's
confirmed that you'll be able to do that will well under a second to
brute-force the prefixes with the proposed OP_RETURN mechanism even with
rather long 8-bit prefixes.

-- 
'peter'[:-1]@petertodd.org
000000000000000190a2900f1a25c507a999fa11116f7bd0126618c1ebc4f5fb
-------------------------------------
Cut it out with the ad hominem attacks please. If you cant be civil, please
go away until you learn some manners.

I think the issue being discussed is do you orphan an entire block causing
distress to users as well, or try to just cause distress just to the evil
miner? This discussion is about exploring the ramifications of all these
options.

I think you are also forgetting that, miners can implement their own
filters and behaviours without anyone's consent. So having an open
discussion and exploring all possibilities can only be a good thing before
someone goes off an implements a change without taking into account other
points of view they may not have considered yet.
 On 23 Apr 2014 19:51, "Justus Ranvier" <justusranvier@gmail.com> wrote:

-------------------------------------
phasing out of bitcoinqt into spv wallets?

2014-04-07 12:34 GMT+01:00 Mike Hearn <mike@plan99.net>:


-------------------------------------
On Tue, 20 May 2014 01:44:29 +0100, Robert McKay wrote:

This stackoverflow describes a similar situation;

http://stackoverflow.com/questions/15338232/how-to-forward-a-subzone

you can additionally specify the port to forward too;

http://www.zytrax.com/books/dns/ch7/queries.html#forwarders

it should be possible to forward to different ports on 127.0.0.1 for 
each dnsseed instance.

Rob


-------------------------------------
only that in the real world most routers suck and people don't even know
how to configure them (reminds me of the convo about people not installing
plugins)
this is why the wheel had to be reinvented for the bittorrent world, and it
works.

http://twitter.com/gubatron


On Tue, Apr 8, 2014 at 12:30 PM, Matt Whitlock <bip@mattwhitlock.name>wrote:

-------------------------------------
I'm not sure I understand why you need any special structure for this at
all. The way I'd do it is just use regular HD wallets for everyone, of the
regular form, and then swap the watching keys. Why do people need to be
given a cosigner index at all, given that they all have unique root keys
anyway?


On Sat, Apr 26, 2014 at 12:27 AM, Manuel Araoz <manu@bitpay.com> wrote:

-------------------------------------
On Apr 21, 2014 3:37 AM, "Un Ix" <slashdevnull@hotmail.com> wrote:
usage I.e. bit.

What units will be called colloquially is not something developers will
determine. It will vary, depend on language and culture, and is not
relevant to this discussion in my opinion.

It may well be that people in some geographic or language area will end up
(or for a while) calling 1e-06 BTC "bits". That's fine, but using that as
"official" name in software would be very strange and potentially confusing
in my opinion. As mentioned by others, that would seem to me like calling
dollars "bucks" in bank software. Nobody seems to have a problem with
having colloquial names, but "US dollar" or "euro" are far less ambiguous
than "bit". I think we need a more distinctive name.

-- 
Pieter
-------------------------------------
On 08/06/2014 01:02 PM, Tom Harding wrote:

Note that this would be a massive, *massive* change that would
completely break bitcoin output frangibility. Merchants would have to
start demanding input history back to a certain depth in order to ensure
they are not exposing themselves to undue reorg-expiry risk.

There are useful applications of a consensus-enforced expiry,
particularly within a private (signed block) side chain, and for that
reason it is useful to have a discussion about the merits of an nExpiry
field or BLOCK_HEIGHT / BLOCK_TIME opcode, and methods for achieving
either. However I don't see this ever becoming part of the public
bitcoin network.


-------------------------------------
Mark Friedenbach wrote:
...

Can we do better than correcting single transcription errors?  I'd
imagine that transposition of two adjacent characters, or insertion or
deletion of a single character, would be very common.  At the very
least, a transposition could be corrected by interleaving the two
"halves of the coded representation", e.g.:

   ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB

insead of
   
   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB

Jim


-------------------------------------
I've renamed it to "Bitcoin Developer Specification" a little while ago.
Maybe it should rather be named "Bitcoin Developer Reference"? Either
way, creating a good description of Bitcoin is an incremental process
and there are certainly many quirks I'm not aware of. I hope that
together we will soon be able to fill in the missing gaps.

Warm greetings,
Krzysztof Okupski

On 07/14/2014 01:26 PM, Mike Hearn wrote:

-------------------------------------
please not google groups *, I'd vote for sourceforge or other simple
open list software over google groups.

Adam

* Google lists are somehow a little proprietary or gmail lockin
focused eg it makes things extra hard to subscribe with a non-google
address if google has any hint that your address is associated with a
gmail account.  Quite frustrating.

On 15 October 2014 16:46, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
On Friday, July 04, 2014 8:21:42 PM Jorge Timón wrote:

Really, if people want to pursue a goal anything like this, they should be 
looking for "ASIC already widely owned" as the property rather than "anti-
ASIC". Thus, a sufficiently memory-hard PoW would really be "RAM is the ASIC". 
Whether it's possible to make this or not, is another question. And then we 
get back to "is is really a desirable property to have people capable of 
mining who have not given any indication of interest?"


-------------------------------------
This is just a guess, but I can imagine sipa's address index branch
might be more suitable for an use case where information about any
address is required - jmcorgan continued to maintain a usually somewhat
up-to-date version:

https://github.com/jmcorgan/bitcoin/tree/addrindex

As for balance queries, that's not possible out of the box and I have my
own branch for this with a few other RPC calls that are noted in the README:

https://github.com/dexX7/bitcoin/tree/master-addrindex-extended

When using the original, you need to ensure a transaction is part of the
main chain and wasn't orphaned. If you consider using my branch, please
consider it twice and review the changes first.

-------- Original Message --------
*Subject: *Re: [Bitcoin-development] About watch-only addresses
*From: *Warren Togami Jr. <wtogami@gmail.com>
*To: *Bitcoin Dev <bitcoin-development@lists.sourceforge.net>
*Date: *Mon, 20 Oct 2014 12:37:40 -1000

-------------------------------------
Alright. I still tend to think it's not a big deal, but there's no reason
both or all mechanisms can't co-exist.

BTW: a QR code next to a cash register can be fixed i.e. printed on paper
when using BIP70. The PoS would upload payment details to the server and
the URL for that particular PoS unit would then serve it when the user
scans the QR code. Alternatively, Andreas' work on Bluetooth may be more
appropriate: the QR code can contain the BT MAC of the device and the
payment request is downloaded that way. That's already implemented! I still
feel that if a seller can scan a users phone, the users phone can certainly
scan some rectangle that's physically near by the sales counter.

The other nice thing about that approach is the QRcode can also be an NFC
tag i.e. have the tag behind it with a little icon in the middle of the QR
code to indicate that touching works as well as scanning.

One project I keep wanting to play with is making these little NFC-QRcode
hybrids and a simple PoS app to go with them. But no time, alas ....
-------------------------------------
That looks OK at a very high level. Things you probably want to think about:

   - How to trigger it off the existing payment protocol (no new top level
   messages or mime types or uri extensions please)
   - Data structures to define the payment schedule
   - Do you allow pre-submission of time locked transactions or not?

I think as you prototype these things will become clearer.  You could try
prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the
PaymentSession class).



On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier
<stephane@kill-bill.org>wrote:

-------------------------------------
I like CRC16.  Do you intend to use it in conjunction with a cryptographic hash?

Regarding the choice of fields, any implementation of this BIP will
need big integer arithmetic to do base-58 anyway.  The operations
required for SSS are nearly the same as for base-58 and can probably
be done by the same subset of the chosen bignum library.  So in fact
using GF(2^8) will add complexity to both the BIP and its
implementations.  However, the maths in GF(2^8) is so simple that this
additional complexity can be considered negligible.

As a co-author of a bitcoin application running on a real
microcontroller (not the sort of big-iron thing Trezor runs on), I was
also going to implement my SSS over a 256-bit prime field.  (I am not
going into 512-bit master seeds at this time.)

Uniform processing of secrets of any size (instead of using different
primes for different cases) is a valid argument in favour of GF(2^8),
though.  I have no preference one way or another.


-------------------------------------
On Tue, Oct 7, 2014 at 7:04 PM, Sergio Lerner <sergiolerner@certimix.com> wrote:

I'm not following this. Perhaps I'm getting lost in terminology here.

It's already to provide double spending bounties to greedy-rational
miners, via a simple approach that has been known since at least early
in 2011.    I pay someone then create a later fraudulent doublespend
which is nlocked at the height the original payment occurred, paying
large fees. Then I spend the output of the fraudulent spend nlocked
one block higher, and spend the output of that one again, nlocked one
block higher, and so on... each step paying fees.

A hypothetical purely greedy miner which considers all sequences of
acceptable forks and transactions would see that they have higher
expected returns assisting the theft (assuming the honest party
doesn't fight back by also adopting a similar strategy), at least if
the population of greedy miners is large relative to altruistic ones.

I don't see how miners being able to roll forward fees makes anything
worse, since the transactions themselves can also roll forward fees.


-------------------------------------
On Fri, Oct 03, 2014 at 07:12:11PM -0400, Jeff Garzik wrote:

Anyway the stuff Mike is saying about being able to detect upgrades is
incorrect - detecting an upgrade is *easier* with a soft-fork, just look
at the block header nVersion numbers and warn the user if they increase
beyond what you know is valid. Bitcoin Core implements this IIRC, and
bitcoinj should.

Someone with more time should write all this up for the bitcoin.org
developer docs BTW... There's extensive discussions on #bitcoin-dev and
others about all of this.

-- 
'peter'[:-1]@petertodd.org
000000000000000012367d385ad11358a4a1eee86cf8ebe06a76add36dfb4622
-------------------------------------
On Jul 18, 2014 4:56 PM, "Wladimir" <laanwj@gmail.com> wrote:
that
scriptSig invalidates it.

Well yes, but that is true for each of the rules and is already covered by
the previous specification in BIP62. Making it mandatory even for old
transaction does not really protect much against malleability as there are
several other sources of malleability that cannot be made mandatory in old
transactions left.

The reason for including #4 is just "allowing this does not benefit anyone".

-- 
Pieter
-------------------------------------

Well, yes, to be fair, in fact it is.  The small divisor and lack of
modulo arithmetic make base-58 encoding and decoding noticeably
smaller and easier than Shamir's Secret Sharing over GF(P256).


-------------------------------------
the command line options mention a -checklevel  parameter.
I've been passing 0 assuming there'd be little to no verification, but it's
happened a few times that when I open the official binary (while not doing
development) there's some sort of database corruption and Bitcoin-Qt needs
to reindex blocks on disk, a process that can take probably a whole day.

how do you guys develop the UI and avoid these issues?

Cheers,
Angel

http://twitter.com/gubatron
-------------------------------------
On Fri, Jul 18, 2014 at 4:53 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Maybe a stupid idea - but couldn't we make that assumption a surety by
starting the 'set synchronization process' as soon as the miner starts
crunching on a certain block, instead of when it broadcasts it? So the
peers are prepared, and the actual block broadcast is just the header
+ coinbase tx.

Wladimir


-------------------------------------
On Wednesday 23 Apr 2014 12:45:34 Mike Hearn wrote:


That's true, but even in the worst that that 5% hashing power attack means 
that 95% of the time, your attack fails.  That means you end up paying for 
what you bought.  Also, you're again changing the comparison basis -- your 
CC figures were for the entire industry, not the most badly affected 
merchant.  You can't say "one particular bitcoin merchant suffers 5% fraud, 
therefore that's worse than the 2% fraud averaged across all CC merchants".


There _are_ consequences though: 95% of the time, you end up buying 
something and paying for it.

Viewed another way, if I buy something repeatedly from an at risk merchant 
(and there won't be many; as you pointed out, mail order is completely 
unaffected as you can simply wait for your confirmations) that costs, say 
0.01 BTC per item, then I have to buy 100 of them to get 5 of them for free.  
Do I really want 100 of them?  Even if I do want them, then I've had to 
supply capital of 1 BTC to earn 0.05 BTC in kind.

If what I'm buying is another form of money (as with exchanges, or perhaps 
casinos) when that "in kind" is just as liquid as the BTC, then fair enough, 
there is a risk, but that just incentivises the merchant in those cases to 
not allow withdrawal/deposit until 6 confirmations have been received.  
Those merchants then move from "at risk" to "not at risk".

I'm still struggling to see how bitcoin could ever be as bad as CC fraud.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Sat, Mar 29, 2014 at 01:42:01PM -0400, Matt Whitlock wrote:

And yet, how many wallets can import BIP38 keys?  If someone gave me
one I would have no idea what software (if any) can understand it (nor
would I have any idea how to generate one in the first place).

Anyway, I'm not arguing against standardising these things - if people
are going to implement this then of course it's beneficial that they
implement it compatibly.  It was just a simple observation - make of
it what you will.

roy




-------------------------------------
What exactly makes bitcoin less of a target than a "scamcoin" which I
suspect means anything that != bitcoin?


On 7 August 2014 20:29, slush <slush@centrum.cz> wrote:

-------------------------------------
Just a few issues with the idea as it currently stands:

1. This provides a very strong incentive to always vote for
reallocating a block if it isn't yours, regardless of whether it's bad
or not (there's a positive expected return to voting to reallocate
coinbases from other miners). The incentive is bigger the more hash
power you have. You can partially address this by:
    a) Requiring supermajorities
    b) Requiring a vote to include proof of a double spend (that's not
a very strong safeguard, since anyone can create them after the fact
if one of their own transactions has been included).
    c) Burning, rather than reallocating, the coins. Miners' immediate
incentive to attack honest pools is much reduced.

2. BitUndo gets paid using additional txouts in the double-spend
transaction, no by miner's fees. This means that the coinbase
transaction will represent a smaller and smaller share of their
revenues over time (however if the total honest transaction fees they
get in their block are high enough, the risk of losing those might
still be enough).

On Wed, Apr 23, 2014 at 3:55 AM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
On 12 Sep 2014, at 11:55 , bitcoin-development-request@lists.sourceforge.net wrote:


Sounds like a good plan.

Do you have a list (possibly incomplete) of apps that perform this kind of checking? Were currently working with some parties in a supply chain to allow a consumer payment on a retail website to automatically pay supply chain parties, the way BIP70 allows with multiple outputs on a transaction. This behaviour would prohibit this use case.

/Mark

-------------------------------------
No, I don't think so. The problem is the 'aa' flag is missing (see the 
'flags' section in dig). Perhaps if you could suppress the authority 
records the recursor would give up and just accept the non-authorative 
answer, but that isn't a good solution even if it might work for some 
resolvers.

Rob

On Fri, 30 May 2014 15:13:36 +0100, Alex Kotenko wrote:



-------------------------------------
Not a bad idea. Semantics of the word abuse not withstanding.

I don't want to become the self appointed mailing list cop, but I notice it
maybe more than others because I almost exclusively read this mailing list
on a mobile device. Hence my asking for feedback without publicly calling
anyone out.

Thanks for taking the time to reply.

Rodney
 On 21/04/2014 3:47 pm, "Wladimir" <laanwj@gmail.com> wrote:

-------------------------------------
On Wed, Mar 5, 2014 at 2:14 PM, Eric Lombrozo <elombrozo@gmail.com> wrote:

Absolutely. I believe these things are worth doing.

My comment on it being insufficient was only that "my signer is
branchless" doesn't make other defense measures (avoiding reuse,
multsig with multiple devices, not sharing hardware, etc.)
unimportant.


No. At a minimum to hide a memory timing side-channel you must perform
no data dependent loads (e.g. no operation where an offset into memory
is calculated). A strategy for this is to always load the same values,
but then mask out the ones you didn't intend to read... even that I'd
worry about on sufficiently advanced hardware, since I would very much
not be surprised if the processor was able to determine that the load
had no effect and eliminate it! :) )

Maybe in practice if your data dependencies end up only picking around
in the same cache-line it doesn't actually matter... but it's hard to
be sure, and unclear when a future optimization in the rest of the
system might leave it exposed again.

(In particular, you can't generally write timing sign-channel immune
code in C (or other high level language) because the compiler is
freely permitted to optimize things in a way that break the property.
... It may be _unlikely_ for it to do this, but its permitted— and
will actually do so in some cases—, so you cannot be completely sure
unless you check and freeze the toolchain)


I wouldn't be surprised.


-------------------------------------
Though I am highly biased :)  Compared to cbitcoin, picocoin's library
(libccoin) is valgrind-clean, can parse and index the blockchain, and
supports all core and P2P data structures.


On Fri, Nov 28, 2014 at 12:49 PM, Btc Drak <btcdrak@gmail.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/
-------------------------------------
On 4 March 2014 14:07, Odinn Cyberguerrilla <odinn.cyberguerrilla@riseup.net


This is true. To rephrase, imagine I gave you an ECC public key <ed_pub>,
you gave me back a public key <odinn_pub> of your own devising, then I paid
some money to the address resulting from add_pubkeys(<ed_pub>,<odinn_pub>)
[1]. Can anyone either:

a) Think of a way that Odinn could make an <odinn_pub> such that they could
spend the resulting money without having <ed_priv>.
b) Opine, somewhat knowledgeably, that this probably wouldn't be an easy
thing to do, and they wouldn't be alarmed to see people running software
that did this kind of thing.

[1]
https://github.com/vbuterin/pybitcointools/blob/master/pybitcointools/main.py#L173

-- 
Edmund Edgar
Founder, Social Minds Inc (KK)
Twitter: @edmundedgar
Linked In: edmundedgar
Skype: edmundedgar
http://www.socialminds.jp

Reality Keys
@realitykeys
ed@realitykeys.com
https://www.realitykeys.com
-------------------------------------
I've thought about [ab]using Tor as a STUN replacement before, but the
issue is a lot of people don't have computers that are switched on all the
time anymore except for their smartphones, which are too weak to calculate
the UTXO set. The trend has been for a while towards laptops, phones and
tablets, all of which are relatively weak.

I think there might be a market for a one-click "bring up an amazon VPS,
sync a full node and make it accessible only to me" type service though!



On Fri, Jan 24, 2014 at 10:58 PM, Jeremy Spilman <jeremy@taplink.co> wrote:

-------------------------------------
This is beyond ridiculous...

Color kernel which works with padding is still quite simple. I think we
have extra 10-50 lines of code to handle padding in coloredcoinlib.
Essentially we have a couple of lines like this :

    value_wop = tx.outputs[oi].value - padding

(value_wop means "value without padding").
And then we have like 10 lines of code which selects padding for a
transaction.

That's not a lot of extra complexity. And it solves the problem once and
for all.

What you propose instead: "a different colored coin representing 10 shares,
and another one representing 100 shares (like the different denominations
of dollar bills)"  is much more complex, and it won't work:

Suppose you have $100 coin, as a single coin.
How do you send $54.23?
That's simply impossible.

So you'd rather push complexity to higher levels (and create inconvenience
for end users, as you admitted yourself) than add 10-50 lines of code to
color kernel?
I just do not understand this.

But I'm not going to argue. I already wrote everything which I could write
on this topic.
-------------------------------------
On Tue, Apr 8, 2014 at 3:53 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:


I've discussed the solution of "Litecoin seed" in BIP32 HMAC with Litecoin
devs already, and after long discussion we've concluded that it is
generally bad idea.

When changing "Bitcoin seed" constant to something different, same
*entropy* will produce different *master node*. That's actually the
opposite what's requested, because xprv serialization format stores *node*,
not *entropy*. By changing HMAC constant, you still won't be able to store
one node and derive wallets for multiple coins at same time.



This is in practice almost the same as your suggestion, except that
Actually I don't understand why there's such disagreement about "cointype"
level here, what it breaks? I see it as the cleanest solution so far. It is
forward and backward compatible, does need any special extension to bip32
(to be strict, bip32 says "Bitcoin seed", so client using "Litecoin seed"
cannot be "bip32 compatible").

Of course, the problem of "cointype" can be solved in zillion ways, but
still using cointype in bip32 path seem to be the most elegant way so far,
because it fullfill all requirements for single backup, for separating
pubkeys and for handling all coins by one master...

Marek
-------------------------------------

Try -logips. Logging peer IPs was disabled by default after #3764.

BTW I'm seeing the same abusive behavior. Who is running these? Why do
the requests need to be so frequent?

Wladimir


-------------------------------------
On that note, I think we have every possibility to make desktop and mobile wallets mind-numbingly simple -- and perhaps even do one better. Is this now a community priority? If so, I would really appreciate some additional contributors to Hive!

https://github.com/hivewallet/hive-osx
https://github.com/hivewallet/hive-android

-wendell

hivewallet.com | twitter.com/hivewallet | pgp 0x8C498718
twitter.com/bitcoinbookclub | campbitcoin.hivewallet.com

On Apr 7, 2014, at 9:15 PM, Eric Martindale wrote:

-------------------------------------
On 14 November 2013 12:45, Melvin Carvalho <melvincarvalho@gmail.com> wrote:

Just a FYI on this topic.  In Gavin's recent interview he described the
block reward as 25,000 millibits (about 25 minutes in).

https://www.youtube.com/watch?v=4pBd-OD9Rns

Decide for yourself whether or not that's meaningful :)

PS very enjoyable and accessible panel ...
-------------------------------------
Ok, I just fixed the String filtering so that it can handle SMP chars
and my implementation behaves exactly like in your modified testcase
quoted below.

Bitcoinj code available on this branch, in case we decide to change the
spec:

https://github.com/schildbach/bitcoinj/commits/bip38-normalize-control-characters



On 07/17/2014 12:02 AM, Andreas Schildbach wrote:




-------------------------------------
A lot of these "should the network..." questions depend on business
rules and business models.

Even if a 0-conf double spend is possible in a given business
situation, the incentives quite often are aligned to avoid
double-spend attempts in any case.  Any physical good being shipped
can "accept" the transaction, and then wait for confirmations before
shipping.  Digital goods might be accepted for 0-conf payment from
users who have a good history with the merchant.  The 0-conf attacker
will tend to /not/ be a regular user, and also have many other typical
markers of a fraudster.

The subset of (a) double-spend attackers making a one-time or
short-term attack on (b) a naive merchant with mistuned business rules
will tend to be very small.


On Wed, Apr 23, 2014 at 12:45 AM, Tom Harding <tomh@thinlink.com> wrote:



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/


-------------------------------------
If you have the resources to attack one of the bigger altcoins, you
probably have a significant investment in the cryptocurrency space, and a
significant interest in protecting it. Compromising even something like
dogecoin would cause a lot of questions to be raised and likely drop the
value of bitcoin as well as all the cryptocurrencies using the same work
function as dogecoin.

Right now, there's very little benefit to attacking a significant currency,
because it would be very expensive and likely traumatize the whole system.
Unless it's some power like the NSA, I don't think there's much to worry
about.


On Tue, Dec 31, 2013 at 2:38 AM, <rob.golding@astutium.com> wrote:

-------------------------------------
On Thu, Nov 27, 2014 at 5:44 PM, Mistr Bigs <misterbg6@gmail.com> wrote:

You're mistaken. :)

If a node is used exclusively via tor it effectively doesn't have a IP address.

(short of bugs of a class that aren't discussed here)

The paper is about fingerprinting approaches that probabilistically
connect transactions to hosts that you can already identify their IPs.


-------------------------------------
For those who have been using this to get faster relays to/from the
network, you may have noticed some instability recently. This is because
the nodes were all being upgraded to use some new relaying code which
should cut down on duplicate transaction relaying in blocks, improving
relay speed within the network and to nodes which run new clients which
use the same relaying technique. Essentially instead of relaying entire
blocks, nodes keep a rolling window of recently-seen transactions and
skip those when relaying blocks.

You can find a simple client which connects to a local bitcoind and a
relay node at http://bitcoin.ninja/RelayNodeClient.jar and the source
for the whole thing at https://github.com/TheBlueMatt/RelayNode.

Matt

On 11/06/13 05:50, Matt Corallo wrote:


-------------------------------------
I somewhat agree with Will (but also with Mike, Jeff, and Charlie.) I
think the idea of letting consumers know advanced details about the
transaction is good and defining these with strong types is also good.
Maybe an arbitrary set of accounting line items would be more
palatable. You could have a line item for state sales tax for example,
or a cash back reward, or a merchant discount like the proposed,
whatever is applicable. It would be a list of amount / label tuples
maybe.

On Tue, Jun 24, 2014 at 12:00 PM, Gmail <will.yager@gmail.com> wrote:



-- 
Andy Alness
Software Engineer
Coinbase
San Francisco, CA


-------------------------------------
If the user creates a password on an iOS device with an astral
character and then can't enter that password on a JVM wallet, that
sucks. If JVMs really can't support unicode NFC then that's a strong
case to limit the spec to the subset of unicode that all popular
platforms can support, but it sounds like it might just be a JVM
string library bug that could hopefully be reported and fixed. I get
the same result as in the test case using apple's
CFStringNormalize(passphrase, kCFStringNormalizationFormC);

Aaron Voisine
breadwallet.com


On Tue, Jul 15, 2014 at 11:20 AM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
Hi everyone.

Is there a mailing list where I can get only notifications about NEW
releases of bitcoin-qt client?

So far I've found only RSS subscription here:
https://bitcoin.org/en/rss/releases.rss

RSS is not convinient at all for me..

Many thanks.
-------------------------------------
On Saturday, 29 March 2014, at 10:08 am, Chris Beams wrote:

I have added two new sections to address your questions.

https://github.com/whitslack/btctool/blob/bip/bip-xxxx.mediawiki


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



On 6 August 2014 10:21:56 GMT-07:00, Mark Friedenbach <mark@monetize.io> wrote:

Bitcoin is already "broken" in that regard due to malleability, and more fundamentally, the existence of anyone-can-spend outputs, known private keys, SIGHASH_ANYONECANPAY, etc.

In any case, reorg-doublespend risk is no different than reorg-expiry risk.
-----BEGIN PGP SIGNATURE-----
Version: APG v1.1.1

iQFQBAEBCAA6BQJT4mcdMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhSdiB/9no/fXR50Zej4l6Hyt
gDvM9GWosGxZydQfplrUYzS9nLWTJgkjNYkrJk1OXPlkiNoHhlpCK6TuEL3DXBo8
txDBhp/xls7aFHELpPhP5iKrEj0J6fyMp9wKRVtUu0J+RhHY22v+iEQf//dGUX4v
hQPwATubmnyeVd71TAKyW6zCPjoEh0IG19tRVvw/v7/qNTXHdSZTkSVzQa4GP2gr
2xVqXTeOycPKqIU+GaNI4aRAL2DUm1kW3jG/+h3BwnJNd5q+0ELpC6xDmkA6hkNz
N6BFCtoghhKNH+FNsZKAzE9w8dYngZQbaA9vVdaR6SXzz9KuG526EymOF7e55IBJ
FMu+
=ii2+
-----END PGP SIGNATURE-----



-------------------------------------
Alan Reiner <etotheipi <at> gmail.com> writes:

gmail.com> wrote:When I say "pass around" I'm not thinking of users copying
and pasting, that would be a terrible user experience; all of that
communication needs to happen automatically behind the scenes. Lets tackle
that after we've got the simpler customer-pays-merchant flow working nicely
(funded-escrow-pays-merchant is a subset of that, anyway).
methods of transparent protocols that occur behind the scenes.  For one,
there's a lot of CONOPs that need to be worked out by getting knowledgeable
people using it, and providing feedback about how it could/should/will be
used and how it could be improved.  The pass-around method is simpler to
implement and still usable by the types of users that will be using it in
the beginning -- experts.  Also, I see that for very large, important
multi-sig tx/contracts/escrow, the "manual" method might be preferred --
much the same way many people prefer manual-transmission cars even though
automatics are "easier" -- some people/organizations will want the control.   
functionality, I'm just saying there should be lower-level access, too.
Another online space wagering stage has been propelled and targets Bitcoin,
Litecoin and Dogecoin fans from everywhere throughout the world. 

Presented in August, Crypto-Games.net is a straightforward space machine
diversion that might be immediately played in any web program with the
utilization of cryptocurrencies, making it one of the first few wagering
destinations that are intended for Slot machine betting. 

As indicated by its site, it emphasizes a four-reel space machine with one
pay line that acknowledges wagers measuring from 50 Credits to a greatest of
9,999 Credits, where playing with most extreme wager yields a gigantic big
stake of 4,999,500 Credits. 

Then, the store exchange routines for this opening machine amusement have
been created to be productive with the stores taking online 2 to 10 minutes
to be transformed and the withdrawals just 6 to 60 minutes without any
transaction charges. Moreover, a QR code has as of now been added to suit
versatile bettors utilizing their cell phones and tablets. 

Also, the administrators have taken the additional mile to guarantee
reasonableness by depending on the random.org API to deliver genuine
arbitrariness that supplements the diversion's reasonable calculation. 

The https://www.crypto-games.net opening diversion, on the other hand,
cautions players to observe their remarkable ID number to abstain from
losing access to their account. This is essential on the grounds that
Crypto-Games does not oblige any type of record enlistment; rather, it
composes into cookies, which are erased following 14 days. 

Besides, it has taken off new extra arrangements for Crypto bettors aside
from the 25% house edge that are up for gets through the referral system.






-------------------------------------
Referring to the subsidy for miners as "wasting it on miners" isn't going to garner you much favor. 


On May 20, 2014 11:12:53 AM CDT, Stephen Reed <stephenreed@yahoo.com> wrote:
-------------------------------------
As far as I'm concerned, the way forward is to scrap BIP 10 and build up
something new that is flexible and extensible.  Also, my understanding
is that there may be room in the payment protocol for this stuff though
I'm not sure if it is really adapted well to all the steps: exchanging
public keys, creating multi-sig/P2SH addresses, proposing multi-sig
spends, bundling meta-data needed for lite/offline nodes, aggregating
signatures, and any other details.

When I start multisig integration into Armory (very soon!) I'll write a
list of requirements for the new format/process and post it here for a
wider discussion.  Certainly, if the payment protocol can already handle
all this, that would be awesome.

-Alan


On 03/10/2014 08:04 PM, kjj wrote:

-------------------------------------
I'd like to point out that there is quite a difference between "what
core nodes should be like" and "what the codebase core nodes are built
from must support".

Given sufficiently modularized code (which I think everyone seems to
be in favor of, regardless of the goals), you can likely build a
binary that does full verification and maintains some indexes of some
sort.

I still believe that what we push for to run as the core nodes of the
network should aim for purely verification and relay, and nothing
else, but people can and will do things differently if the source code
allows it. And that's fine.

On Tue, Jun 24, 2014 at 3:26 PM, Jorge Timn <jtimon@monetize.io> wrote:

IMHO, maintaining a correct view of the current state of the chain
(excluding blocks, just headers) is already sufficiently hard (I hope
that everyone who ever implemented an SPV wallet can agree). You
simplify things a bit by not needing to verify what the peer claims if
you trust them, but not much. You still need to support
reorganizations, counting confirmations, making sure you stay
up-to-date. These are functions the (SPV) P2P protocol has already
shown to do well, and there are several codebases out there that
implement it. No need to reinvent the wheel with a marginally more
efficient protocol, if it means starting over everything else.

-- 
Pieter


-------------------------------------
On Fri, Sep 12, 2014 at 11:29 AM, Andreas Schildbach
<andreas@schildbach.de> wrote:

Sounds like a good idea to me.

I had no idea that some clients were comparing addresses and amounts
in the URI with the payment request for security, that seems like a
hacky and inflexible way. This is much better.

Wladimir


-------------------------------------
So you agree, that SSS should not contain specific flag for testnet?

Or for that matter not even BIP32 needs them since it is not an address to send to.

Regards,

Tamas Blummer
http://bitsofproof.com

On 22.04.2014, at 20:46, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------


The problem is that this is easier said than done. Bitcoin Core won't
notice a remote peer is working but slow and switch to a faster one, and
even if it did, it'd just mean throttling your connection would cause all
remote nodes to give up and hit the other unthrottled peers even more.

The best way to implement this is to do chain pruning, so your node will
still try and shovel bytes as fast as possible, but it's limited by how
many bytes it has to shovel. Remote nodes that are pulling down the block
chain can then switch between nodes depending on what they have available
in order to try and avoid hitting one node too hard. Nodes that were
offline for a while and just catching up would prefer nodes that have less
of the chain.

It'd be great if someone could experiment with this. The first step is
extending the p2p protocol so addr broadcasts and version messages include
how much of the chain (counting blocks from the head?) the peer is willing
to serve, and then updating the downloading code so it tries to be smarter
about peer selection. Unfortunately all this work is sort of backed up
waiting for sipa to finish merging in headers-first downloading.
-------------------------------------
I might be mistaken, but it seems to me this paper discusses unintended
ways of obtaining the IP addresses of clients involved in transactions on
the core Bitcoin network.
Tor was mentioned only insofar as it might be one's first thought of how to
mitigate this risk, yet Bitcoin over Tor has its own problems that prevent
this from being effective.
But the primary "issues" mentioned in the paper are regarding a Bitcoin
node in default operation, no?

"In their new study, researchers at the Laboratory of Algorithmics,
Cryptology and Security of the University of Luxembourg have shown that
Bitcoin does not protect user's IP address and that it can be linked to the
user's transactions in real-time."

"The basic idea behind these findings is that Bitcoin entry nodes, to which
the user's computer connects in order to make a transaction, form a unique
identifier for the duration of user's session. This unique pattern can be
linked to a user's IP address. Moreover, transactions made during one
session, even those made via unrelated pseudonyms, can be linked together.
With this method, hackers can reveal up to 60 percent of the IP addresses
behind the transactions made over the Bitcoin network."

"'This Bitcoin network analysis combined with previous research on
transaction flows shows that the level of anonymity in the Bitcoin network
is quite low,' explains Dr. Alex Biryukov."

M
-------------------------------------
Jonathan -

These are a few things I've been wishing for recent data on:

  - 95th percentile transaction propagation time vs. fees/kb, vs. total fees
  - Count of blocks bypassing well-propagated transactions vs. fees/kb, 
vs. total fees
  - Signed-double-spend confirmation probability vs. broadcast time 
offset from first spend

On 4/20/2014 5:30 PM, Jonathan Levin wrote:




-------------------------------------
On Thu, Nov 06, 2014 at 10:05:54PM +0000, Matt Corallo wrote:

BIP62 is a less-than-ideal way of making contracts secure against
malleability as it relies on a "whack-a-mole" approach to security that
is insecure if any flaw is missed. If you only wanted to make contracts
secure, you'd either implement a new SignatureHash() that could leave
out the prevout field in favor of hashing the previous input's CTxOut()
structure, and/or implement the significantly more limited
CHECKLOCKTIMEVERIFY.

Equally BIP62 fails at making more complex types of contracts secure.
For instance suppose I had a multi-step protocol that required more than
two transactions:

    tx1: Alice -> (Alice, Bob)
    tx1_refund: (Alice, Bob) -> Alice

    tx2: (Alice, Bob) -> Charlie
    tx2_refund: (Alice, Bob) -> Bob

tx1 can only be modified by Alice, so tx1_refund is secure. However the
second stage, where the output of tx1 is spent by tx2, with a refund
transaction giving the funds back to Bob, can't be made secure as BIP62
can't prevent Alice from changing her signature, getting tx2' mined
instead, and making tx2_refund invalid.

OTOH a new form of signature hash that was a signature on tx2.vout
structure rather than it's txid would be secure, as tx2_refund would be
valid regardless of tx2's actual txid.

Obviously there are good reasons to not use such signature hashes in the
general case, as they imply you can't reuse scriptPubKeys securely, but
that's a minor problem for purpose-built contract protocols. It's
certainly a much more minor problem then the huge number of holes
possible with BIP62.

BIP62 does make life easier for wallet authors as they don't have to
deal with malleability - maybe! - but for contracts it's a bad design.


FWIW I've done due-dilligence reviews for investors on projects and
companies that have re-implemented Bitcoin Core consensus-critical code,
and every time my review lists doing so as a major red flag.

-- 
'peter'[:-1]@petertodd.org
0000000000000000166801ed3959dde6b7d979735c290e7c4271ae3cf75ced63
-------------------------------------
