Reposting from the forums:
  https://bitcointalk.org/index.php?topic=47624

Following Gavin tagging 0.5rc1, I have tagged the stable git tree "v0.4.1rc1". 
If you are able, please compile and help test.

See the doc/build-*.txt files in the source tree for instructions on 
compiling. Binary releases for at least unix and mac will be available only if 
someone steps up to the task.

There are no major changes from version 0.4.0, only bugfixes.

None of the features from 0.5 are supported, only those in 0.4.

Run: git shortlog --no-merges v0.4.0..
... to get a complete list of changes, and thanks to everybody who is 
contributing!


-------------------------------------
On Wed, Jun 15, 2011 at 10:27 AM, Mark Visser <mjmvisser@gmail.com> wrote:

That's what -datadir is for.  Unfortunately -all- databases must be in
the datadir, because wallet.dat is a berkeley db, and we need a
transactional environment.  That makes it difficult to move just one
file.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
This evening I'd also like to announce the BitCoinSharp project by
Nathan Baulch. It's big enough to deserve its own email, IMHO.

Nathan has done a complete port of BitCoinJ into C#, thus opening the
world of Bitcoin up to .NET developers everywhere.

You can browse the code here:

  http://code.google.com/p/bitcoinsharp/source/browse/

Visual Studio SLN files are provided to help you get started. The
PingService example is a good place to start reading:

  http://code.google.com/p/bitcoinsharp/source/browse/src/Examples/PingService.cs

I'm hopeful that we've now covered nearly all the bases in terms of
languages and platforms. Everyone should be able to write interesting
Bitcoin apps no matter what their background or preferred toolchain.


-------------------------------------
Oops, should have gone to the list

On Sat, Jul 30, 2011 at 2:07 PM, Matt Corallo <bitcoin-list@bluematt.me>wrote:


BTW, talking about the unit testframework: It doesn't build here by default:

$ make -f makefile.unix test_bitcoin  USE_UPNP=

g++ -static  -o test_bitcoin  obj/test/test_bitcoin.o -Wl,-Bstatic -l
boost_system -l boost_filesystem -l boost_program_options -l boost_thread -l
db_cxx -l ssl -l crypto -Wl,-Bdynamic -l gthread-2.0 -l z -l dl -l pthread
-lboost_unit_test_framework
/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crt1.o: In function
`_start':
(.text+0x20): undefined reference to `main'
collect2: ld returned 1 exit status
make: *** [test_bitcoin] Error 1

Two ways to fix this:

1) Add #define BOOST_TEST_DYN_LINK  to the top of test_bitcoin.cpp. This is
needed for dynamic linking.

2) Link boost_unit_test_framework statically

test_bitcoin: obj/test/test_bitcoin.o
        $(CXX) $(CFLAGS) -o $@ $(LIBPATHS) $^ $(LIBS) -Wl,-Bstatic
-lboost_unit_test_framework -Wl,-Bdynamic

(yes, it needs the switch to dynamic again at the end, otherwise libgcc will
be linked statically which results in an error ...)

JS
-------------------------------------
Hello,

I think my Qt GUI is pretty much ready for merging. I've been using it for a
while and all functionality works.

What is the current roadmap for including the autotools build system, so
that it will be possible to support multiple GUIs? 0.4.0?

JS
-------------------------------------
Hello all,

The description of the password-protected export format has been revised
slightly, and now includes multiple algorithms and a parameter byte for
selecting the encryption parameters.  As before, the thread is here:

https://bitcointalk.org/index.php?topic=36195.0

Unless there is an existing or other planned use for data class 32, or
another specific objection, I would like to use it for
password-protected private keys.  Going by Sipa's description, this
would mean that a password-protected private key for bitcoin is type 32,
and for the testnet, type 79.

Thanks,
-Sam Revitch


-------------------------------------
On Sat, 2011-07-30 at 06:42 -0700, Rick Wesson wrote:

That was my point, it already has been written...twice IIRC.
-------------------------------------
On Sunday, July 17, 2011 6:59:58 AM John Smith wrote:

The "Satoshi Client" doesn't really have a formal name yet.
Don't confuse an implementation with the network itself.


-------------------------------------
On Thu, 2011-07-28 at 14:43 -0400, Alan Grimes wrote:

Seriously? This is the very reason most people dont use the forums
anymore.  This is just a one-off email that says nothing, doesn't ask a
question doesn't make a statement, and doesn't do anything remotely
useful, keep this kind of crap to yourself.



-------------------------------------
Hello,

This is a suggestion with a mind to the future.  In particular, I'm slowly 
working on an alternative client and library (I know, everyone says that).  
I've got a feature that I'd like to have that would need a change in the 
protocol.  It's a change that I think would improve the official client as 
well, so I'm bringing it up here.

It's actually two changes; and both could be acheived by adding new commands 
to the protocol.  I think that would be overkill though; as they fit quite 
nicely into an extended getblocks command.

(1) The getblocks message is a list of inventory items (type MSG_BLOCK) being 
requested.

Imagine this situation though.  I am a light weight client.  I store the block 
headers only.  I am only interested in the history of my own wallet addresses.  
I receive a block broadcast with a transaction that sends coins to one of my 
addresses.  That transaction references other transactions (of course), but I 
haven't stored any transactions.  So; I want to request those transactions and 
ensure they are all valid and in blocks.  I can't.

I can request the transactions themselves; but I have no way of finding out 
what block they were in without downloading the entire full block chain 
myself.  The thing is, a peer with the full block chain is able to do this 
instantly.

Here then is my suggestion:  getblocks should accept inventory items of type 
MSG_TX as well as MSG_BLOCK.  When it finds a MSG_TX request, it shouldn't 
send the transaction (after all that is what the getdata message is for); 
instead it should return the block that contains that transaction.  It's an 
alternative way of requesting a block -- by transaction in that block.

It should be obvious then that it would be easy for a lightweight client to 
request the transaction chain transactions its interested in to create a list 
of relevant hashes for the history it's after; and then put those hashes in a 
getblocks request and have to look only at a few full blocks instead of the 
full block chain.


(2) If you are offline when new transactions are broadcast, there is no way to 
know they are pending.

Transactions that have been broadcast but not yet accepted into a block are 
never resent (nor should they be).  But if I am on a mobile client say, or a 
light-weight, intermittently used client; I have no way of checking if a 
transaction sending coins to one of my addresses is pending.

It should be possible to request the current pending transaction list.

My sugestion then is that a special virtual block request be possible.  The 
all zero block hash can never exist (it's used as the parent for the genesis 
block, so it had better not).  If I send a getblocks that contains an all-zero 
hash, then the virtual block should be returned in a block message.  That 
virtual block will list all the current pending transactions.  Obviously there 
would be a problem that it's actual hash would not be zero; so it would have 
to be marked as the virtual block in some other way (perhaps a zero timestamp 
plus a zero parent hash, or similar).



The combination of the above two protocol changes makes it possible for any 
client to have a large chunk of the facilities available in blockexplorer.com 
and the very useful http://bitcoincharts.com/bitcoin/ information.




Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
I find it likely that we will at some point have supernodes. If we have browser based wallets then the server for these automatically becomes supernodes. Further, if we move along that direction, it becomes much simpler to use both the scheme I proposed or to use a a lot of other schemes for sharing the validation work on a farm constituting the supernode.

However, if we want to keep bitcoin in a real p2p setup and enable scalability in terms of ensuring both thin and fat client to connect then we need to go along the path I propose.

Actually, after thinking a bit more about the possible new attack vector I don't find it that alarming - if you still require 7 confirmations of any bigger transaction before you, as receiver accepts the transaction as payed you will not risk anything. The question is then if it is sufficiently easy to fake small transaction to e.g. gain access to micropayment based web services. I would again say no - the requirement that you have ok from e.g. 8 different A.B nodes will make it extremely difficult to cheat, and that would even require you to gain some level of control over the network that the service you want to cheat is connected through.

This means that you should not divide the hash space more finely than you would at all times be able to find 8 different A.B nodes. As the number of clients grows you can then divide the hash space further. (with 100000 nodes today and a division into 512 parts you would have approx 200 nodes to choose from).

Cheers,

M



On 21/12/2011, at 12:42, Eric Lombrozo wrote:







-------------------------------------
IMO, we should standardize and support public key addresses. While not ideal 
for humans, because of their length, it's a better fit for large QR Codes IMO.


-------------------------------------
On Sat, 2011-07-30 at 07:06 -0700, Rick Wesson wrote:

We already have boost testing framework implemented, it just doesn't
have many tests.
-------------------------------------
A few weeks back I was in discussion with the IANA on getting a bitcoin URI accepted in the standard. As a prerequisite I had to read 5 huge documents. I did not end up writing that RFC.

Skilled developers have even less time than I do. While this particular RFC is really nice for keeping ambiguity at bay, it is one of many small rules that bring marginal improvements. "Rule creep" (like feature creep) starts off with good intentions but degenerates into a situation like Wikipedia or any other system with a heavy bureaucracy that can use the rules for lawyering against you.

We want to encourage skilled developers to help set the standards and participate in discussions. Beyond using good grammar and using the correct formatting (and I even help with those), I defer on the site of trusting common sense and human judgement :)

However this is a good RFC, and I will advise any future BIP contributors to read it. It offers good suggestions.

About what Luke says:

I kind of agree with him. The intention was to specify software stacks rather than end applications. This allows us to more carefully track software evolution and behaviour throughout the network. bitcoin-qt need not be tied to the Satoshi code-base and may in the future use other core systems through its intermediary layer. BitcoinJava has given rise to a bunch of other application like Android Bitcoin and MultiBit- however they are both BitcoinJava derivatives.

However BIPs are a community consensus thing. It depends on the mutual consent of everybody and if there is a commonly agreed sentiment against the wording of an Accepted (or even Active) BIP then it can be amended ad-hoc.

The purpose of BIPs is to enhance development by 1. providing a stable system environment for programmers to work towards an accepted standard 2. serve as an equaliser for smaller groups (the third party clients vs the current behemoth client) by giving them a voice or platform.

And they can only function by those who want them to function.

But personally, I really do think splitting bitcoin-qt into XXX and bitcoin-qt is a smart idea. Starting from lowest to top part of the system is smart: http://www.useragentstring.com/pages/Firefox/

Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0a2) Gecko/20110613 Firefox/6.0a2

Mozilla is the application suite (Mozilla Thunderbird, Mozilla Firefox, ...)

Gecko is the rendering engine
Firefox is the end application

In the original intention for BIP_0014, that would map to:

/Gecko:20110613/Firefox:6.0a2/Mozilla:5.0/

With something like WebKit, it becomes easy to see why that would be useful. You can suddenly do a network wide scan of all browsers using WebKit, rather than having to maintain a database of all WebKit enabled browsers.

So if this is contentious.

Then discuss. I'll update the BIP according to what everyone decides they like.


:)



________________________________
 From: Gregory Maxwell <gmaxwell@gmail.com>
To: Bitcoin Development <bitcoin-development@lists.sourceforge.net> 
Sent: Monday, December 19, 2011 10:29 PM
Subject: [Bitcoin-development] BIP language on normative behavior
 
I've been arguing with Luke-JR on IRC about the interpenetration of
BIP_0014—  Gavin's recent commit uses the same version string for the
GUI interface and the daemon mode.

Luke believes this is a _violation_ of BIP_0014 and an error in
judgement on Gavin's part, and a failure to conform to the community
adopted standard. I believe Luke is mistaken: that BIP_0014 actually
don't have mandatory requirements for what you put in the version
field and even if it did, that they are in fact the same software and
should have the same name.

I don't think an agreement is likely on the second point, but the
first point highlights some ambiguity in the interpretation of BIP
language. E.g. What is permitted vs encouraged vs required.

There is well established standard language for this purpose:

https://www.ietf.org/rfc/rfc2119.txt

I strongly recommend that all BIPs be written using the RFC2119
keywords where appropriate.

------------------------------------------------------------------------------
Write once. Port to many.
Get the SDK and tools to simplify cross-platform app development. Create 
new or port existing apps to sell to consumers worldwide. Explore the 
Intel AppUpSM program developer opportunity. appdeveloper.intel.com/join
http://p.sf.net/sfu/intel-appdev
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
On Sun, Jul 03, 2011 at 12:44:17PM +0200, Pieter Wuille wrote:

Other opinions? Someone actually interested in writing a cmake configuration
for bitcoin?

-- 
Pieter


-------------------------------------
It has been a busy month; here's what I'm thinking about:

 It's great to get 0.5 out; congratulations to Wladimir for doing a
great job with the new GUI.

 The wallet encryption bug was embarrassing and stressful, and chewed
up a lot of my time over the past couple of weeks. Bugs happen, but
I've been spending time thinking about what I can do differently to
make it less likely major bugs slip into releases.

Finding the money to hire some professional QA people to help create
test plans and then execute them (the test plans, not the QA people)
is one possible answer. If you have experience finding funding for
open source projects (or know somebody who does) I'd like to talk with
you--  I would much rather spend my time writing code and thinking
about technical issues instead of trying to figure out if advertising
or sponsorship or a Donate menu entry in the client is a reasonable
way to get more testing resources for the project.

Last month I mentioned I was thinking about Organization; there is a
non-profit organization forming to handle Bitcoin PR and marketing,
which takes care of one big area of work.

 The BIP (Bitcoin Improvement Proposal) process seems to be working
well, with good proposals and good discussions (both here and on the
Forums):
  https://en.bitcoin.it/wiki/Bitcoin_Improvement_Proposals

Things I think are high priority but am not planning on working on:

 Implement BIP 14 (separate the protocol and client versions)

 Rework/rethink wallet handling:  I think we could do a much better
job with both encryption and backups.

 Work on higher-level multi-signature/multi-device transaction
approval; I really want a version of bitcoin-qt that requires me to
poke an "OK" button on my iPhone before it can send coins.

 Code clean-up; I'd like to see more small code refactors that moves
non-performance-critical code from .h files to .cpp files, makes
classes  more self-contained, etc. "Rename the world" or "change every
single file"  pull requests are hard to deal with because there is
never a good time  to pull them, but a steady stream of "makes the
code a little bit easier  to work with" would be a Good Thing.
Especially if you submit unit  tests for whatever you touch...


Thinks I think are high priority and AM planning on working on; if any
of them inspire you, feel free to steal them from me, I still have too
many things on my TODO list:

 Create a pull request for OP_EVAL/multisignature transactions

 Back-port OP_EVAL/multisig to 0.3/0.4 and release patches to  make
it easy for the big mining pools to support it, so the network  is
ready for multisig/multi-device transactions.

 Work on the 'headers-only' branch, so users have a better first-time
experience.

I want to start doing some internal re-architecting, and I think
porting my old monitor transactions/blocks patch to use Boost.Signals
might be a good place to start.  The internal pieces are pretty
obvious (GUI, database, network, wallet, transaction validation, and
block-chain handling) and I think starting to rearchitect to use
Boost.Signals for internal communications would be a big step towards
more re-usable code.

 Get back to the cross-platform testing infrastructure tool, and lots
of good and  bad blockchains that can be used for cross-platform
testing.


I'm probably forgetting several things, but I think that's enough for
now. If you're going to the conference in Prague, have fun!  Please
figure out all the hard questions while you're there, and report
back....

-------------------

Previous Brain Dump:
https://sourceforge.net/mailarchive/message.php?msg_id=28223657

-- 
--
Gavin Andresen


-------------------------------------
Totally agree it really shouldnt be a vote, in the end UPnP is bad for
an individual (more bandwidth usage, etc), but good for the network.
That means people will vote against it, but in the end someone has to
make the tough decision and turn it on.

Also, bitcoind is prebuilt in the daemon folder on the download archives
(though Im not sure about OSX)

Matt
On Fri, 2011-07-01 at 12:47 -0500, Douglas Huff wrote:

-------------------------------------

At least you would have a hunch that something like that had happened as one of your addresses had been part of a transaction (at least in my setup it would pop up immediately...).


I am not sure what you mean by this - just recall that the semi anonymously feature of bitcoin is one of its key features.


Still, how do you solve the end less expansions of bitcoin addresses that each, depending of a leading 1, 2, 3... means a quite specific script inside the OP_EVAL ??? Its not esthetic...

Cheers,

M





-------------------------------------
I really like this proposal with standard URLs. All other proposals like
DNS mapping or email aliases converted to URLs with some weird logic looks
strange to me.

Plain URLs (returning address in response body, redirecting to URI
"bitcoin:<address>" or anything else) are very clear solution, easy to
implement in clients and very easy to understand by people. It's also
extremely flexible - almost everybody can somewhere setup static file
containing his "personal" addresses or it's very easy to integrate such
solution with eshops (providing custom address for given order) etc. I'm
definitely for this solution.

Best,
slush

On Tue, Dec 13, 2011 at 5:22 PM, Andy Parkins <andyparkins@gmail.com> wrote:

-------------------------------------
Same here of course, but I'll keep the String short and fixed. I still
don't think there should be any reason for others to know my OS in order to
communicate with me :-)

On Mon, Nov 14, 2011 at 9:48 AM, Stefan Thomas <moon@justmoon.de> wrote:

-------------------------------------
Hello everyone,

after a discussion on IRC, we decided to try to standardize the version bytes
used by bitcoin for several applications.

There are 3 components that seem meaningful:
* network? (realnet, testnet, alternate chains?)
* data class? (address, private key, master key, ...?)
* version? (real version, per data class defined)

There is no technical reason why different network and different data classes
would need separate version bytes, but i think it is a good thing to keep
them from colliding. People will mix them up, and when things are well
defined, a nice warning message could help a lot ("Oops it seems you entered
a private key instead of an address!").

So, first of all, there is already one actually used alternate chain, namely
namecoin, using version byte 52 for addresses. For this reason, i'd like to
reserve bit 16 in the version byte for "alternate chain". When bit 16 is set,
everything is up to the network itself, and no further semantics are defined.

When bit 16 isn't set:

Then remains the rest of the network. The problem is that testnet already uses
version 111, which is not a single bit. We can use a trick though, namely
choosing bit 1 for testnet, and if bit 1 is set, XOR the rest of the version
number with 111. Otherwise, we could reset testnet (not actually reset, just
change its addresses a bit), and simply state odd=testnet, even=realnet.

That leaves use with 6 more bits to play with, namely 128,64,32 and 8,4,2.
As 128 is already used for private keys, let's use (128,64,32) for data classes,
and (8,4,2) for versions.

So, in full:
* Bits 128/64/32 define data class
** 0 = address
** 32,64,96,160,192 = reserved for future use
** 128 = private key
** 224 = extended data class, another "data class" byte follows
* Bit 16 defines "private"
** 0 = bitcoin
** 16 = alternate chain
* Bits 8/4/2 define version number
** 0 = only thing used for now
** 2,4,6,8,10,12 = reserved for future use
** 14 = extended version, another version byte follows
* Bit 1 defines testnet
** 0 = realnet
** 1 = testnet (possibly using XOR 111, if not reset)

This whole discussion started when Stefan wanted to define a format for master keys from which
to derive deterministic wallet keys, i suggest using data class 192 for that, leaving the
lower numbers for more basic data, like public keys.

Any comments?

-- 
Pieter



-------------------------------------
OK, my thoughts. My order of preference is: web service, server service, DNS TXT records.

FirstBits + Vanitygen is out of the question in my mind. Not robust enough.

I like web service since anyone can trivially set one up. You can provide a PHP script and a text file (that users edit) that people upload to XFreeWebHost and then they're instantly set to go. Setting up a web host is very easy nowadays- as easy as click click click.

The other ideas are not so easy.

Also HTTPS + CA is the most secure of the bunch.

I'm curious to hear any other ideas too.

Thanks.



----- Original Message -----
From: Amir Taaki <zgenjix@yahoo.com>
To: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Cc: 
Sent: Monday, December 12, 2011 10:21 PM
Subject: [BIP 15] Aliases

I wrote this pre-draft:


https://en.bitcoin.it/wiki/BIP_0015

It's merely a starter for discussions.

Aliases are a way to lookup bitcoin addresses so I can type genjix@genjix.net instead of 1jkddsjdskjwnk2j3kj232kjdkj


-------------------------------------
Hello,

Here's a scenario (it's contrived to make the players easy to identify, more 
likely this would be low value automated vendors):

Two scammers get together to buy two Ferraris using only one set of BTC.  They 
travel to opposite ends of the world to two car dealerships that accept 
bitcoins without waiting for confirmations.  They are in contact by mobile.  
They each buy the car and come to pay.  At exactly the same moment, they both 
spend the same coins.  They both walk away with a car.

The current solution is the recommendation that vendors wait for six 
confirmations before releasing goods.  That's a long time though; more than 
most would be willing to wait.

Some points:
 - The bitcoin network is essentially honest
 - If a block chain fork happens, the transactions that are orphaned get added
   to the pending transaction list again, meaning ...
 - A valid transaction will _eventually_ make it into the (longest) block
   chain.
 - Actual distribution time for a transaction through the network is in the
   order of seconds not minutes
 - A double spend attempt has to enter the network near simulateously at
   different places, otherwise the second spend will be rejected instantly by
   the whole network.

New transactions propagate through the network if they are found to be valid.  
If they aren't valid, they are silently dropped.  In the event of a double 
spend attempt one of those transactions goes to (say) half the network, the 
other goes to the other half.  Whichever one reaches a node first is seen as 
the real one, the second being seen as invalid.  One or other of these will 
therefore end up in the "longest" chain; but there is no way to know which.

Here's my proposal then: when a node drops a transaction, it should not be 
silent.  It should be broadcast just as it always was going to be had it been 
valid.  Only it is broadcast with a new "inv" type, let's say 
"MSG_DOUBLESPEND" instead of "MSG_TX".

Now run the Ferrari test again.  The vendor sees the transaction that pays for 
the car appear near instantly (within the propagation time of the network).  A 
short while later they also see a MSG_DOUBLESPEND of the same coins that they 
have just accepted.  They can then operate whatever policy they want: wait for 
six, ten, twenty confirmations.  Call the police.  Whatever.  Miners can also 
significantly lower the priority of any transactions that get flagged in this 
way.

When there isn't a double spend attempt message within the network propagation 
time, they can be sure that their transaction is the one that miners are 
working on, and they'll eventually get their money.  In other words, they can 
accept the payment on zero confirmations.

At first I was concerned that this would make it possible to DOS a 
transaction, but of course it doesn't -- the transaction has to be internally-
valid to result in a MSG_DOUBLESPEND, meaning it can only be DOSed by someone 
with the appropriate private keys.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------

It's closed source, so nobody here can do anything about it (unlike
other software discussed here).


-------------------------------------
Thanks for the heads up. I'll get started there.

On 08/22/2011 11:42 PM, Jay Weisskopf wrote:
fpc

-------------------------------------
Personally, I have little preference, sipa and gmaxwell fall on the side
of cherry-pick, but I think it might be good to do a broad-base test of
CWallet in 0.3.24 so potential bugs can be found in it before crypto and
0.4. In either case, I dont think we should spend too much time as this
is just a minor update release, just get it out the door so we can focus
on 0.4 (hopefully) without interruption.

Matt

On Fri, 2011-07-01 at 20:37 -0400, Jeff Garzik wrote:

-------------------------------------
On Wednesday 13 July 2011 19:37:57 Luke-Jr wrote:

Don't tell me:

bitcoin/src/main.h:41
static const int64 MAX_MONEY = 21000000 * COIN

21,000,000 seems pretty arbitrary to me.


-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On 2011 December 22 Thursday, Joel Joonatan Kaartinen wrote:

Yes; I appreciate that.  It's the very point I'm making.  A node can choose 
what work to do, and should have a way of forwarding the results of that work 
to other nodes.  Transaction verifification is the main one.

Once a negative-announce message exists, it wouldn't be hard to have the other 
two you need as well: positive-announce and neutral-announce.  At present we 
have only neutral-announce.  However, as the need for super nodes and 
distributed verification gets bigger, having the forwarder able to offer an 
opinion on the quality of a transaction seems ideal to me.  Dishonesty will 
get you isolated pretty quickly if you use positive-announce and negative-
announce to lie.

The problem with this is that it requires a web of trust as well as a web of 
connections.  The only way to gain an advantage from this classified 
forwarding is if you have some way of assigning enough trust so that you can 
forward a classified transaction _without_ checking it yourself.  That doesn't 
sound like an easy problem though.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
I know. Please do not take this as a personal attack. Blame MagicalTux's
irresponsible behaviour as of late. :(
On Jun 19, 2011 5:34 PM, "Gavin Andresen" <gavinandresen@gmail.com> wrote:
vulnerabilities in http://clearcoin.appspot.com .
and uses google account auth. So long as you stay logged into your google
account you are vulnerable to this CSRF.
-------------------------------------
With the current system, the timestamp can also be cheated, but miners
have no direct incentive to do it. With your system, they increase
their probability of mining a block by putting a false timestamp.
Also, where's the network clock you're talking about? Isn't it the
timestamps in the blockchain?



2011/11/23, Andy Parkins <andyparkins@gmail.com>:


-- 
Jorge Timn


-------------------------------------
It seems base58 is actually quite terrible for producing nice human-recognizable
addresses, even though base58 is specially intended for human usage. We'll just
have to deal with it, or completely overhaul it and move to a saner encoding.


Luke's proposal is somewhat more drastic than my original one, since it removes
the actual "version" notion from the version bytes, and changes testnet addresses.
However, I think it may be worth it. More data classes have been necessary
before, and new versions haven't. Furthermore, they are far more recognizable to
users, which is something that in particular for OP_EVAL addresses (script hashes)
will be a plus.

Therefore, I'm in favor of the proposal; the new versions would become:

0:   mainnet pubkey hashes ('1', as before)
192: testnet pubnet hashes ('2', instead of 111, 'm' and 'n')
5:   mainnet script hashes ('3'; for OP_EVAL)
196: testnet script hashes ('2', same as normal testnet addresses)
12:  mainnet private keys  ('Q', 'R' or 'S', instead of 128, '5')
204: testnet private keys  ('7', instead of 239, '8' and '9')

Comments?

--
Pieter


-------------------------------------
I need help sanity testing these:
  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.1/test/
  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/test/

-- 
--
Gavin Andresen


-------------------------------------
Gavin wrote:


Here's a strawman use-case for a browser centric flow for a 2-of-3 scenario.

Funding:

* User is on Merchant site on the checkout page
* User selects a transaction Observer (I'm trying to get away from using
the word escrow, because the funds are not held by the third party)
* Merchant redirects to the Observer, passing in the Merchant's payout
address
* The User enters User's address
* Observer presents multisign address
"2,merchant-addr,user-addr,observer-addr" and terms and conditions - i.e.
under what circumstances the Observer will sign
* User copy/pastes the multisign address to their bitcoin client and sends
funds
* After some blocks go by, merchant ships

Redemption:

* Merchant reminds User to release funds
* User creates a partial tx paying out to merchant-addr and emails or
copy-pastes to Merchant
* Merchant signs and publishes the tx

Funding requires two pastes and redemption requires one.  A browser
plug-in would reduce the User effort to a couple of confirmatory clicks -
"do you want to send X BTC to Merchant Y with Observer Z?" and "do you
want to release X BTC to Merchant Y?".

--
Bobby Groff




-------------------------------------
On Mon, 2011-07-04 at 22:26 -0400, Gavin Andresen wrote:
Really, well I disagree but OK, 0.3.24 it is.

-------------------------------------
We've got no power, so it might be a day or two before I can help verify gitian builds or pull patches.

Sent from my iPhone

-------------------------------------
On Sunday, July 10, 2011 3:12:12 PM Matt Corallo wrote:

I just said it exists. I don't expect anyone to promote or merge it.


I suspect because they haven't figured out how. Take it or leave it.


This is a step in that direction, at least, by providing the mode as input.
Since 0.4 is moving to Qt, perhaps moving GetMinFee to QtScript is 
appropriate.


Again, take it or leave it, but in the meantime you're asking for trouble from 
users who feel they're being forced to pay more than they have to. Or perhaps 
rather than trouble, that decision will increase awareness of other clients 
that don't try to control the users. That could be good too.


-------------------------------------

I agree, I definitely want to go about this in a non-jerk way. I would
be pissed if I spent hours coding something, and it was put on the
back burner and eventually closed (especially without notice). The
wording and process could use refinement.


I can definitely do this, and give a wordy notice before I start the
timer. I will write up a message that links to a rebase walkthrough
(any suggestions? I think Gavin has one somewhere...), I would like it
to be more detailed than GitHub's walk-through.

My main reason for pushing this is that it will help clear out some of
the older pulls/issues that exist right now. I'm hoping that in the
future, the QA process will be good enough that pulls/issues won't
fall behind from lack of testing - and the timers will be used very
sparingly. It should only be in place to sort out the pulls/issues
that the majority doesn't want included in the client.


-------------------------------------
potential...

no more than other messages such as transactions.


kind of defeats the purpose of the alert if it takes a long time to issue
one.

I think leave the alert in, but relay alert messages even if they don't use
the correct key.  This means that if we later decide to add new keys to the
alert root trust then older clients will still relay these.

my .02btc

Will
-------------------------------------

Sure. There are lots of non-standard scriptPubKey scripts that will
validate if given <sig> <pubKey> as input:  a simple OP_NOP would work
(do nothing, then check the top value on the stack and validate if it
is not zero-- and <pubKey> is not zero).

If you assume the client has all previous transactions, then you could
get the transaction input's prevout (from the memory pool or disk) and
then ExtractAddress() from it. That is probably a bad idea for
listtransactions, since fetching all the previous inputs from disk
just so you can check to see if they're 'green' violates the "a
feature shouldn't cost anything if it is not being used" design
principle.

You know, just thinking out loud...

Green addresses could be implemented as a second signature in the
scriptSig.  You'd have to hack your bitcoin client, but you could
generate a transaction that had <greensig> <sig> <pubKey>  ... as the
input instead of <sig> <pubKey>.

The <greensig> will be ignored by old clients.  The transactions is
still considered 'standard'.  But you could teach bitcoin to look for
<greensig> signatures in wallet transactions...

-- 
--
Gavin Andresen


-------------------------------------
Various issues with bitcoin-qt's qmake build system still...

Regressions remaining on bitcoin-qt branch:
- Building without DBus still tries to use dbus symbols (and fails linking)
- No way to disable SSL support for JSON-RPC
- UPnP is no longer built/enabled by default

These weren't quite working in the old makefiles either, but it was a lot
easier to workaround with DEBUGFLAGS:
- No way to specify include path or library names for bdb and boost
  (won't build, since bdb C++ includes aren't default on many OS)
- No way to build with out-of-tree/system cryptopp or json


-------------------------------------
On Wed, Aug 10, 2011 at 6:41 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:


I do think to be an successful open source project we need more developers
and more features. Activity is very important, it is kind of the lifeblood.
Yes, a project will generally become more stable and slow in time as it
nears "perfection" (or at least, a local optimum) but the current source is
*far* from that.

Yes -- bugs and scalability issues need to be addressed, but this will be a
lot easier if some underlying problems are solved. And if we ignore the end
users, they may run away and it becomes a pointless exercise.

Taking the "long view" this includes build system, handling of
threads/concurrency, modularization, pluggable DB and storage back-ends,
separating the system into multiple "locked-down" processes, and so on.
This can all be done while remaining P2P-compatible for as long as possible
(we have versioning, don't we?).

My proposal with multiple branches was about looking at the long view as
well as the immediate firefighting.  Yes, some changes might be riskier than
others, but we can't just cargo-cult Satoshi's work forever... so with
multiple branches, people can choose whether they have the balls to try
something newer or just want to run the older version with the issues they
know and love.

It's better to be open. Look at Open Office, it only started to un-stagnate
when it was forked out of Oracle's stranglehold. People want to work on
these things, so why not?

Until this is addressed, developers will prefer creating their own fork or
even alternative client. After this UI stuff is handled I'll probably join
up with one of them.


IMO this should have been your first reply, instead of first discourgaging
me from doing it. Just make a list of what needs to be done.

But I won't bother anymore... Let's just keep lumping everything in one
executable. It's the Satoshi way.

On Wed, Aug 10, 2011 at 7:32 PM, Andy Parkins <andyparkins@gmail.com> wrote:
features;
their

Exactly. My gripe is more about the negative attitude then anything else.
The focus is always on the negative sides of every proposal, a bit of a
climate of fear.

I've had an employer that worked in the same way. Eternally hammering on
"stability" the codebase, hiring 100's of extra developers, all firefighting
and fixing immediate issues with "priority", the code became a minefield.
Even with 8 hours of testcases, the overall structure of the code caused so
many issues that customers feared every new release more. A classic negative
feedback loop.

I understand where it is coming from, many people just come and dump their
"ideas" and never implement a line of code. But if people are actually
proposing to implement something, or implemented it, they should IMO be
given the benefit of the doubt. Not all outside ideas are bad.

JS
-------------------------------------
Yeah, I'm starting to run into real design problems in my attempt to 
write a bitcoin daemon, namely I'm trying to figure out how to manage 
connections and peers and how to interpret and coordinate messages from 
peers.

While spying on the old code, I noticed one major problem that could be 
fixed quite easily. That is, the 1 class-per .h/.cpp rule is completely 
ignored in main.h/cpp and net.h/cpp If all of the classes in the project 
were re-factored to their own files, it would be much easier to audit 
what was interacting with what. I think this work could be done within 
16 programmer hours.

The old codebase doesn't build on my system but I'd be willing to rough 
it in anyway.

I think this should be done in parallel to efforts, such as mine, to 
re-implement major functionality.

-- 
E T F
N H E
D E D

Powers are not rights.



-------------------------------------
Hi Steve,

before attempting to hack BitcoinJ to use NIO you might want to take a look
at BitDroid (https://github.com/cdecker/BitDroid-Network), which is my
attempt to build an easily extensible network client (no crypto stuff so
far) on top of NIO and a simple publish-subscribe architecture. I build a
crawler like yours with just a single class that subscribes to events
published and closes and opens connections to crawl.

HTH,
Christian

On Tue, Sep 6, 2011 at 10:29 AM, Steve <shadders.del@gmail.com> wrote:

-------------------------------------
Nice. I'll check with justmoon when I hopefully meet him at the conference. If all is OK, hopefully 0.6 will be the last protocol version bump for a while.



________________________________
From: Mike Hearn <mike@plan99.net>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Saturday, November 12, 2011 7:31 PM
Subject: Re: [Bitcoin-development] [RFC] BIP 14 - Protocol Version and User Agent


Looks pretty reasonable to me. If Gavin changes the mainline client to use this format I'll change BitcoinJ as well. It'll need a bit of API work so clients are sure to set it up properly.


On Thu, Nov 10, 2011 at 10:16 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

Hi,
-------------------------------------
+1 for something based on git. Github has a dedicated wiki feature that 
is git-backed:

https://github.com/bitcoinjs/node-bitcoin-p2p/wiki/
git://github.com/bitcoinjs/node-bitcoin-p2p.wiki.git

On 10/27/2011 6:15 PM, Daniel F wrote:



-------------------------------------
On Monday, December 19, 2011 1:52:54 PM Jordan Mack wrote:

Bitcoin is a binary system. Not all payment outputs are necessarily 
serializable into addresses, and assuming they are would be broken-by-design.
In other words, why send the user's *software* "pay to address foo" just to 
have it turn that into a script (of limited subset), when you can send the 
script itself and avoid all the possible problems? Doing this right also means 
that if the user's client doesn't support version 255 addresses, it still 
works fine.


JSON isn't problem-free at high-level either. To summarize one of the issues, 
almost every implementation of JSON treats Numbers differently based on 
whether they have a '.' in them or not.

MIME has been around much longer, and should have sufficient support in every 
language by now. For some reason, Python calls the module 'email'.


-------------------------------------
On Fri, Sep 2, 2011 at 8:32 PM, Rob Meijer <capibara@xs4all.nl> wrote:


Oh yes there is interest. I meant to reply but haven't been able to put much
energy in bitcoin development lately.

More strict privilege seperation between applications on a least-authority
basis is something that Ubuntu is certainly going to need if they're serious
with the app store thing (and want to keep up with Android and Macosx...).

This has been needed for a long time, and this would be useful for any
private data managed by applications running as the same user (ssh,
browsers, pgp, ...)

Wallet encryption is useful and necessary but no substitute for OS-level
protection.



You have to rewrite the entire thing from scratch?

This is probably blasphemy but: how can it be compared to the android model,
with a UID per application/user, and thus layering the security on top of
current UNIX/ACL permissions?  Is another FS really needed?

JS
-------------------------------------
On Sun, Sep 4, 2011 at 1:52 AM, Chris Double <chris.double@double.co.nz> wrote:

After a discussion on #bitcoin-dev it is indeed the latter. I was
under the mistaken believe that the GetSerializeSize method in
CTransaction and CWalletTxn were virtual, which would result in the
behavior I was thinking of. But they're not so it works. Please
disregard!

Chris.
-- 
http://www.bluishcoder.co.nz


-------------------------------------
On 10/10/11 18:32, Gavin Andresen wrote:
Compiled on Debian and running it :) I tested to encrypt my wallet
(coming from v0.3) and changed the password a couple of times without
problems.


The new GUI looks nicer and more stylish than previous one. I am also
liking a lot the notifications and the system tray icon on the status bar.


Good work!

-------------------------------------
On 2011 November 23 Wednesday, Christian Decker wrote:


These are reasonable objections.  My counter is this:

Let's view block difficulty as a measure of time, not time itself.  The 
timestamp is merely a convenience for the block.  You cannot fake the 
computing power needed for a particular difficulty; so the hardest chain 
always wins (note: hardest chain).

If I am a miner, I have two choices:

  (a) try to replace the top block on the current hardest chain
  (b) try to append to the current hardest chain

Either of these is acceptable; but in case (a) I have to generate a more 
difficult block to replace it; in case (b), at the start of the window, any 
difficulty is acceptable (however, I'm competing with other miners, so _any_ 
difficulty won't beat them).

The rule then is that you're trying to win the one block reward that is 
available every 10 minutes; and your peers will be rejecting blocks with 
timestamps that are lies.

Perhaps an example...

 - I (a node), download the blockchain
 - The blockchain has N potential heads.  Each of those heads has a time, t
   and a sum_of_difficulty.
 - The next block reward is going to go to the highest difficulty with
   t < timestamp < (t + T) _and_ verified timestamp (i.e. not received more
   than, say 5 minutes, from its claimed timestamp).
 - I can choose any head to start generating from, but given that it's the
   highest difficulty chain that's going to win the next reward (not the 
   highest difficulty block), I will surely pick the most difficult?
 - A rogue miner then issues a block with a fake timestamp; it actually
   generated at (t + T + 5) but claims (t + 5).  Should I start using
   that block as my new head?  Obviously not, because my peers might decide
   that it is a lie and reject it because it was received too late, making my
   work useless.  It is in my interest to pick a head that is honest.

Resolving forks is easy:

 - 50 coins every ten minutes only
 - most difficult chain wins

I'm certainly not saying it's a simple change.  There are certainly areas I 
haven't thought about, and could be game-overs; but I do like the idea of 
there being no target difficulty, and instead the blocks are issued at a fixed 
ten minute rate (or rather the rewards are).


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Fri, Jul 1, 2011 at 12:03 PM, Christian Decker
<decker.christian@gmail.com> wrote:

The multithreaded RPC stuff will need very aggressive testing to make
sure it doesn't expose race conditions elsewhere in the code.

E.g. you don't want to lose change from a send because some txn called
getnewaddress concurrently and there was a bug. So far the
multithreaded RPC patches have pretty much only been run by miners...
who have a different rpc profile than everyone else.

(and the MT RPC that I've been using only multhreaded getwork…)


Gah. No.

The 'hub mode' is not good. We're already low on sockets network wide,
adding a built in DDOS mode flag to bitcoin that makes nodes
aggressively connect to lots of neighbors is a bad idea. People will
ignorantly enable it thinking they are adding resources to the network
when they are really consuming much much more.

I have a big fast node with a higher connection limit and the flood
fixes and I'm currently seeing 596 inbound connections right now. This
suggests the situation is already a lot worse than the rough numbers
using lfnet connection counts suggested.


Miners, concerned with fast block propagation, should manually addnode
each other. We should fix the addnode logic so that it reserve
connection slots for addnoded nodes and tries to keep connecting to
them (or, alternatively, add a peernode flag for that behavior)
currently addnode is oneshot.

There is a lot of room for longer term improvements to the connection
and forwarding logic, and I have a couple interesting ones I'm running
on my nodes, but we don't really have any good way to test and
validate changes, so I'm hesitant to publish them.


-------------------------------------
Just brainstorming here, no idea if this would work:

   - Pick any old block
   - Create a chain fork by creating simpler blocks on top of your chosen
   one
   - The chain will not be accepted by others
   - At some point you might find an incredibly hard block that makes your
   forked chain the hardest one in the network
   - Suddenly all your blocks are valid and you force people to switch to
   your forked chain

If this is possible it would allow you to revoke all transactions and claim
all the mined coins since you forked. My point is that the notion of
hardest chain is not so simple.

The difficulty of invalidating a chain is dramatically reduced with your
time window approach, by not requiring a given difficulty, and relying on
synchronized time windows.

Regards,
Chris

On Wed, Nov 23, 2011 at 2:13 PM, Andy Parkins <andyparkins@gmail.com> wrote:

-------------------------------------
In my opinion, there's not necessary any payload format (json, xml,
multipart). In keeping stuff KISS, everything we need is just an address in
response + potentially some stuff like HTTP redirects (for providing
additional compatibility for proposal of bitcoin URIs with "amount",
"label" and other parts). I don't see reason why we need some extra payload
yet.

slush

On Mon, Dec 19, 2011 at 7:13 PM, Jordan Mack <jordanmack@parhelic.com>wrote:

-------------------------------------
On Wed, Aug 10, 2011 at 12:14:49PM +0200, Matt Corallo wrote:

I do agree about splitting off bitcoincl - it's kinda confusing now how
the client behaves as a rpc daemon or UI when no RPC command-line
parameters are present, and as a command-line client otherwise.

I am less sure UI and RPC should be split (though being able to select
both independently from eachother at compile time would be nice). I
often run the UI and switch to RPC calls to inspect some details.
Not sure how common this usage pattern is, though.


The problem is that bitcoin-qt is built using qmake, and the rest using
makefiles... so it's more than just adding an additional makefile.

That said, it seems bitcoin-qt is mature enough to replace wxbitcoin
to me, and would definitely like to see it in mainline. How streamlined
is the process of building bitcoin-qt on windows and osx? Maybe we can
switch everything to qmake (for now, as long as no maintained autotools 
is present)?

-- 
Pieter



-------------------------------------
BitcoinJS uses OpenSSL to calculate midstate:

https://github.com/bitcoinjs/node-bitcoin-p2p/blob/master/native.cc#L380


On 9/29/2011 1:40 PM, Nils Schneider wrote:



-------------------------------------
There was a discussion about using DHT's for transactions a while back
on the forums:
https://bitcointalk.org/index.php?topic=723.msg7908#msg7908

If you can figure out a scheme that is secure from malicious Sybil
attacks then you're smarter than I am.

And additional protocol messages for lightweight clients is a good
idea, as long as they don't make it a lot easier to pull off a
denial-of-service attacks on a "full" node.

Although I do also wonder if we'll ever run into a problem with full
nodes refusing to answer requests from lightweight nodes (there might
be a tragedy-of-the-commons problem lurking there).

--
--
Gavin Andresen


-------------------------------------
On Aug 24, 2011 10:12 AM, "Gavin Andresen" <gavinandresen@gmail.com> wrote:

If the caveat of a trusted third party is acceptable and, as greg mentioned,
if there was a way to export unsigned transactions and then import/broadcast
after signing this becomes fairly trivial.

Shamir's + 3rd party to combine and sign means no protocol level changes.

Process could work something like this:

Parties agree to endpoint destination address and provide it to third party.
Third party generates key and provides shares to each party in the txn and
the resulting address to both as well.
Third party destroys (preferably, never stores) private key.
Sender sends to address.
Both parties after confirmation of reciept of goods or what have you provide
shares back to third party who uses the privkey to xfer inputs to the
previously agreed upon destination subtracting their fee.

This resembles more traditional escrow setups and relies on the trust of a
third party, which is not ideal, but would be fairly simple to implement
until the other proposals could be better investigated and implemented.
-------------------------------------
"Gavin Andresen" <gavinandresen@gmail.com> wrote:


I agree.  For example, a corporate wallet can require threshold signatures
to disburse.  Or for personal use you can have a couple of additional
keys, one stored on a secure device for confirmation and one offline as
emergency backup if you lose your secure device.

...


For context - I am the author of the latter.


Incompatible at the UI level, but not at the block chain level.  Changing
the block chain rules will be quite an undertaking.  You will have to set
a block number for the rule change a few months in advance and will have
to get agreement from the pools.  I think it is important to increase
trust in the bitcoin ecosystem sooner than that.  The current flat
exchange rate and difficulty may be a signal that people are getting risk
averse.


That is my worry too.  We already have working code for this (pull 319),
and the addresses are not so long as to be unusable.  I hope we can move
forward on the existing code and in parallel move forward on block chain
rule proposals at an agreed upon block number.

--
Bobby Groff




-------------------------------------
vector76 on the Forums posted this interesting variation on a 'Finney attack' :
  https://bitcointalk.org/index.php?topic=36788.msg463391#msg463391

"Let's say I observe the timing of when nodes are broadcasting
transactions and how they are propagating through the network.  By
watching for which nodes are earliest to broadcast transactions from
my target, I manage to establish a direct connection to my target.

I use a similar method of watching block broadcasts to establish
connections to most of the mining pools.

Now I create a transaction making a valid, large deposit into my
target.  I do not broadcast this transaction but I add it to a block
that I am attempting to mine.  I mine solo, just like normal, except
that I have an extra non-broadcasted tx that I am including.

Eventually, I succeed in creating a valid block.  I do not broadcast
it immediately, but instead I wait until someone else mines a block,
and when that happens, I immediately broadcast my block to my target.
If my target sees my block before the other block, they will accept
it, and my transaction will have one confirmation.  The block chain
has forked, and my target (and possibly other nodes, if my target
relays quickly enough) will believe that my block is the correct one,
while other nodes will believe that the other fork is the correct one.

I immediately request a withdrawal, and my target generates a
transaction sending the large amount of coins to an address I control.
 I also double-spend some of the inputs, sending the coins to myself.
The part of the network that did not receive my block first (which
hopefully is most of the miners) will accept this as valid and work to
include it in the next block.

If my block eventually "wins" because enough miners saw my block first
and added onto it first, then I have just made a deposit and
withdrawal, and I lose nothing.

If my block eventually "loses", then the deposit is invalidated.  If
the deposit tx was not one of the inputs to the withdrawal
transaction, then the withdrawal is still valid."

-------------------------------

The lessons are "don't accept 1-confirmation transactions" and  "try
to be well-connected."

But maybe the deeper lesson is "don't trust information you get from
only one peer." Or maybe "watch for peers that are trying to fool
you."


-- 
--
Gavin Andresen


-------------------------------------
On Thu, 2011-07-28 at 01:25 -0400, Alan Grimes wrote:
Yay, yet another person who wants to write their own client from scratch
who will get the net code done, work a bit on wallet code and move on to
something more exciting.  Seriously, at this point it seems everyone and
their mother are writing their own, or planning to write their own,
client.
Bitcoin's code actually can be fairly well segmented into the necessary
pieces (CWallet was the first big chunk, more are coming) and comments
are being added as a part of that effort.
The current code is much, much more trustworthy than anything someone
new will start to code, even if they have 20 lines of comments for each
line of code.  If you want to help the project, please dont write yet
another new client library, just look for an existing one you can help
with, or help with the original client.
-------------------------------------
On Fri, Aug 5, 2011 at 9:03 AM, Andy Parkins <andyparkins@gmail.com> wrote:

I'm sure many people would be interested in patches that solve the
~O(N) peak memory usage with additional connections.


-------------------------------------
Oh ya, forgot this tidbit. Thanks gmaxwell!:

Not mentioned here is that fact that dozens of MTGOX hashed passwords were quietly disclosed on a hash cracking forum on Fri Jun 17, 2011 5:21 am 
(http://forum.insidepro.com/viewtopic.php?t=9124&postdays=0&postorder=asc&start=75&sid=1a9e31567fe815c0eea63c40c39fb707 post by "georgeclooney")

Since the overwhelming majority but not all of the hashes match the mtgox database that was posted on this forum (now deleted) and elsewhere I suspect that this post may have been generated from an earlier dump than was disclosed on the forums and everywhere else after the big event.

This appears to be significantly ahead of the prior claimed breach, and is consistent with the great many other mtgox users claiming that their accounts were robbed prior to the big event on Sunday, which I believe would have been too early to be results of the mtgox database leak according to the official timeline re: auditor compromise.

On Jun 20, 2011, at 11:17 PM, Doug Huff wrote:


-- 
Doug Huff


-------------------------------------
lol, way to miss the point nanotube.

FirstBits *is* useless, but not for the reasons you specified. But simply because the resources it needs rises exponentially as the number of participants in the network grows linearly.

The point is that if FirstBits were built into the implementation, that would allow me to simply send to 1brmlab. The proposal here is not for a website where people can lookup bitcoin addresses, but a shared naming scheme between bitcoin implementations. Here's the story again:

on the wall a picture of their QR code and a bitcoin address. I don't 
own a mobile phone so the QR code is

In our revised history, I simply send 1 BTC to brmlab

BOOM.

Club Mate



----- Original Message -----
From: Daniel F <nanotube@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Tuesday, December 13, 2011 2:32 AM
Subject: Re: [Bitcoin-development] Fwd: [BIP 15] Aliases


ok, imagine if firstbits didn't exist. instead of going to firstbits,
you would have gone to your terminal, opened up brmlabs website, and
copied the address from there?

there may be some arguments for name-> address translation, but i'm
sorry to say, that your example is not one of them. if anything, it
seems to suggest that firstbits is completely useless, since it saves
approximately zero effort.



-------------------------------------
On Wed, 2011-12-14 at 15:07 -0500, Luke-Jr wrote:

I realize I'm responding to an useless nitpick with another useless
nitpick but here goes.

It doesn't have to be a valid URI. As long as the recipient (or the
software he's using) can make it into a valid URI. My web-browser
definitely would open http://david.bitcoin.se/ from that. For bitcoin
clients, https:// should be the guess it tries.

- Joel



-------------------------------------
On Sat, 2011-09-03 at 20:13 -0400, Gavin Andresen wrote:
+ (my fault) Gitian doesnt build properly.



-------------------------------------
Hi Mike,

I've looked but can't find a post like you're talking about.  Can you 
point me to it?

If so then bollocks... I'm looking for something useful to do atm.  
PoolServerJ is in a holding pattern atm as I've stabilisied all the bugs 
I know about and am waiting for several pools to finish testing and move 
into production so I'm twiddling thumbs trying to figure out how to 
spend my time.

On 06/09/11 22:49, Mike Hearn wrote:


-------------------------------------

as long as it's gpg-signed, what's the difference where it is posted?


-------------------------------------
Hi,

This weekend I closed some old github issues that are no longer
reproducible in more recent versions, or needed input from the submitter
but were stalling for months.

I've also closed some issues that deal purely with Wx UI issues like this
one:

https://github.com/bitcoin/bitcoin/issues/425

I think my statement is valid, that we no longer support the old UI? Or
maybe some people want to take up maintenance of the old UI? I don't think
that has very high priority, and should probably not be in the main project.

Some of the older issues are absolutely still relevant, but 150+ open
issues is not something to be proud of, and I wonder how other open source
projects deal with this without too much stepping on people's toes :-)

JS
-------------------------------------
Probabilistic disconnections could make it quite hard to debug protocol
implementations and increases the risk of flaky behaviour in the wild
significantly. I don't see why a simpler solution isn't better.

The most likely failure mode of this is not an attack but the same as
previous breakages - scaling or legitimate version skew that causes problems
as the network evolves.

Agree with Luke that non-standard transactions should not be considered an
attack.

If you stay with the scoring system I'd be tempted to have a flag (defaults
to 100) that sets a minimum threshold for the badness scores and ignores any
below that. Attacks based on sending transactions that aren't syntactically
valid don't seem likely to me, this isn't a good way to DoS somebody because
discarding them is so cheap. If it turns out later there is a problem,
people under attack could flip the flag until a new version is released.

The formula for the DoS score in the case of invalid signatures/merkle roots
seem unnecessarily elaborate. An invalid signature should never occur and
could always result in immediate disconnection.

Treating a block with too many sigops as invalid means legitimate relayers
might be treated as an attacker if/when the constant changes in future. I'd
suggest not treating this as an attacking situation at all.

Why use a mutable field with a const setter?

Unit tests that rely on sleeps like this can be flaky because the OS delay
isn't always precise, not to mention slow/irritating to run. It's better if
tests can override the clock, eg, if GetTime() did something like

   if (nMockTime) { return nMockTime} else { ... }

then unit tests could reliably modify and advance the clock in a
fast/efficient manner.
-------------------------------------
No decentralized solution for non-fixed addresses comes to mind.
If we're going to always rely on servers, we should definitely offer
dynamic addresses.

There was a bitcoin service in the forum to which merchants send
different addresses and the service manages the payments for the
merchant without holding his private keys. The service identified each
shopping cart by a combination of the total amount and the selected
address for that cart. I don't remember the name of the service
though.
It could easily implement aliases (the same alias for various rotating
addresses). Of course, the service provider still knows your income
and you still need to provide new addresses to maintain your privacy.
I say this just in case it inspires someone.


-------------------------------------
On Thu, Jul 7, 2011 at 11:49 AM, Andy Parkins <andyparkins@gmail.com> wrote:

Everyone writing an alternative client goes through this thought
process :-) There's no point in doing it, you cannot prove your
transaction is not a double spend. That requires knowledge (ie, an
index) of all transactions.

You have to treat appearing deep in the chain as ipso-facto proof of
validity. Lightweight/SPV clients simply must have that trust, it
cannot be done any other way. See this article:

http://code.google.com/p/bitcoinj/wiki/SecurityModel

Currently this is pretty safe due to the crazy speeds. In future when
speeds are likely to be lower, it will be less safe and you'd have to
wait longer or use a trusted node.


I think it'd be better to implement the filtering suggestions that
have been made. It doesn't scale to download the entire memory pool -
a better approach is to give the remote node a filter to match against
transactions then have it only relay those. After setting a filter,
transactions pending and matching would be sent in one big inv and you
can then keep the connection open to learn about new transactions
without needing to "drink from the firehose". Filters can be
probabilistic and set on many different nodes to reduce the privacy
implications.


-------------------------------------
On Wed, Nov 23, 2011 at 9:38 AM, Christian Decker
<decker.christian@gmail.com> wrote:

Seems to me that's the real problem with any "hardest block found in X
minutes" scheme.

If I get lucky and find a really extremely hard block then I have an
incentive to keep it secret and build a couple more blocks on top of
it, then announce them all at the same time.

If the rest of the network rejects my longer chain because I didn't
announce the extremely hard block in a timely fashion... then how
could the network ever recover from a real network split?  A network
split/rejoin will look exactly the same.

Bitcoin as-is doesn't have the "I got lucky and found an extremely
hard block" problem because the difficulty TARGET is used to compute
chain difficulty, not the actual hashes found.


---

PS: I proposed a different method for dealing with large hash power
drops for the testnet on the Forums yesterday, and am testing it
today.

-- 
--
Gavin Andresen


-------------------------------------
On Sat, Jul 2, 2011 at 2:50 PM, Luke-Jr <luke@dashjr.org> wrote:


It would change the sequence to

cmake . && make && make install

So a shell script named 'configure' that starts 'cmake .' is the most easy
case :-) Probably it'd also need to pass through some command line args, for
example --prefix.

JS
-------------------------------------
On Monday, September 19, 2011 8:49:08 AM Gavin Andresen wrote:

The problem with the current development model is that bugfixes are done 
alongside improvements, and code changes *always* have the potential to 
introduce new bugs, no matter how careful anyone is. So to stay on top of 
bugfixes right now implies risking new bugs being introduced. What good is 
getting one bug fixed, if it comes with 20 new yet-to-be-discovered bugs?

For example, 0.3.20.2 was the last version if bitcoind before people started 
experiencing random (albeit rare) deadlocks. However, there have been many 
bugfixes since then. Since there is no stable branch, someone who wishes to 
get those bugfixes is forced to either create their own stable branch from 
scratch, or risk getting all the new bugs introduced in the latest version 
(most of which are unknown at this time).

On the other hand, a stable 0.4.x branch can provide people with upgrades 
which they know make only the minimal changes required to fix bugs with a much 
smaller risk of new bugs being introduced (not only are there fewer changes, 
but bugfixes tend to also be less invasive changes). While there are arguably 
still various "must-have" features missing from 0.4, having a stable branch 
also allows people to maintain a stable+<feature I need> branch with greater 
ease too.


-------------------------------------
On Wednesday, August 24, 2011 12:18:54 PM Pieter Wuille wrote:

Also:
- Access to the block height it's part of. While this can be abused,
  transactions accessing it can be given a big red flag in the GUI or
  something. Legitimate uses include "Clearcoin" functionality in the script
  itself.
- Remove the 100 confirmation requirement for spending generated coins. If
  they are respent before 100 confirmations, clients can/should flag the new
  outputs as also "generated" or "recently generated" so recipients are aware
  of the risk. It would be especially handy for pool operators if blocks could
  contain a transaction spending one of the same block's generation in
  addition to other non-generated coins, and specifying the full amount as a
  fee to safely add coins to the generation. Right now, if I were to embed a
  25 BTC fee-only transaction, there is a risk that Deepbit could grab that
  transaction for their own, and fork. By making pool payouts all generated,
  there is no risk to paying invalid blocks instantly (since if the block is
  invalid, so is the payout made in it).


-------------------------------------
I see the Contracts wiki page talking about,

1) Transactions passed around outside the P2P network ...
2) ... transaction ... not broadcast right away

How are transactions created, stored and transmitted?  How will they
be brought back into the P2P network once they are out?

B

-- 
Make a Small Loan, Make a Big Difference - Check out Kiva.org to Learn How!


-------------------------------------
On Mon, Nov 21, 2011 at 03:34:28AM +0100, Pieter Wuille wrote:

To help in testing this: this address corresponds to a compressed
public key:
http://blockexplorer.com/testnet/address/mwUyUCWRp9WqyNgrGAbghs7KjTL8zjFNKN

-- 
Pieter


-------------------------------------
OK, I admit that this is *really* of little importance... 

But could someone with commit rights please update the CDataStream test table in the code. The arguments for the custom stream are just way off (stringstream wins by factor 10-20!). On OS X (g++) I get:

Further, if you get(got) bad stringstream numbers on e.g. windows (dikumware had some issues several years ago) you can improve just by changing the default allocation chunk size. So... speed is not a reason for reimplementing stringstream. (And perhaps this can motivate someone to revert bitcoin to stringstream ;-)

Cheers,

Michael

PS: Could be fun to see the output on other OS'es !

serialize.h (with TESTCDATASTREAM defined, i686-apple-darwin11-llvm-g++-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.1.00)):

CDataStream:
n=1000       0 seconds
n=2000       0 seconds
n=4000       0 seconds
n=8000       0 seconds
n=16000      0 seconds
n=32000      0 seconds
n=64000      1 seconds
n=128000     1 seconds
n=256000     2 seconds
n=512000     4 seconds
n=1024000    8 seconds
n=2048000    17 seconds
n=4096000    40 seconds
stringstream:
n=1000       0 seconds
n=2000       0 seconds
n=4000       0 seconds
n=8000       0 seconds
n=16000      0 seconds
n=32000      0 seconds
n=64000      0 seconds
n=128000     0 seconds
n=256000     0 seconds
n=512000     0 seconds
n=1024000    0 seconds
n=2048000    1 seconds
n=4096000    2 seconds



-------------------------------------
MinorFs sounds like an interesting concept and but wallet encryption
(already being tested and close to release) is a simpler solution for
end-users.

Would MinorFs help securing the wallet on a server, maybe even a
(insecure) VPS?

Can it work without changes to Bitcoin? If not, what is the minimal
amount of changes needed?

Is there any guarantee it will never corrupt the wallet?

What would be the proper way to do backups?

On 02.09.2011 22:32, Rob Meijer wrote:



-------------------------------------
Don't know much about QR codes, but I thought they have a length limitation.
Why jav wants to use not just addresses but firstbits then?

"Allow a field "green_address_list" (short "gal") to specify
acceptable addresses in Firstbit format directly in the QR code and
only use the "green_address_details" mechanism when that starts to get
too long to fit comfortably into the QR code"

https://bitcointalk.org/index.php?topic=32818.msg422789#msg422789


2011/12/17, Luke-Jr <luke@dashjr.org>:


-- 
Jorge Timn


-------------------------------------
I agree with Joel.  I think someone brought this up earlier as well.   Most OP_EVAL transactions won't be complex enough to require more than a few loops.

--Zell

------------------------
"It stopped being just a website a long time ago. For many of us, most of us, Wikipedia has become an indispensable part of our daily lives."
— Jimmy Wales, Founder of Wikipedia 
Help protect it now. Please make a donation today: http://www.wikimediafoundation.org/wiki/Donate



--- On Sat, 12/31/11, Joel Joonatan Kaartinen <joel.kaartinen@gmail.com> wrote:



-------------------------------------

Right, that is the workaround in pull 319.

There is another disadvantage to CHECKMULTISIG - you currently can only
have 1000 of these in a block.  This is because a CHECKMULTISIG is counted
as 20 sigop operations in GetSigOpCount, and you can have a maximum of
20000 sigops in a block (MAX_BLOCK_SIGOPS).  This is in CheckBlock so
won't change anytime soon.

If you want to use HASH160 based addresses, CHECKMULTISIG looks even less
attractive.  The shortest script with CHECKSIG is something like:

0
OVER 2SWAP CHECKSIG SWAP HASH160 {} EQUAL BOOLAND ADD // n times
m GREATERTHANOREQUAL

( thanks to coblee
https://gist.github.com/39158239e36f6af69d6f#gistcomment-47017 )

I think this is actually as short as the shortest you can do with
CHECKMULTISIG.

Another issue that came up during pull 319 discussion is whether to
support more general cases or more specific cases.  For example, should we
optimize for the 1-of-2, 2-of-2 and 2-of-3 cases or should we just have
one script template for all m-of-n? I would propose focusing on a more
general case for the following reasons:

* It is easier to validate one general algorithm than an expanding set of
special-purpose functions.  For example, I think the most people on this
list can validate the coblee script above for all n and m, but faced with
a bunch of special purpose scripts they might miss a bug.

* We don't have to expose the most general cases to the API, but it would
be nice if we didn't have to keep changing IsStandard as people find use
cases for 2-of-4, etc.  With IsStandard remaining narrow, innovation with
new scripts is stifled because most client won't mine or relay
non-standard transactions.

* It would be less work for third-party software to track this
(blockexplorer, android wallet).

--
Bobby Groff





-------------------------------------
Design discussion:  https://gist.github.com/39158239e36f6af69d6f
Pull request:  https://github.com/bitcoin/bitcoin/pull/541

Initial support for multisignature transactions

This adds initial support for three new types of transactions:
(a and b)
(a or b)
(a and b) or c

... where a/b/c are keys. These new transaction types will enable
better wallet security and backup in future versions of bitcoin.

I've taken a conservative approach with this initial pull; the new
transaction types will be relayed and included in blocks, but are
ignored by the wallet code, so will not affect the balance and will
never be considered available to spend. I'm going to start a
discussion on bitcoin-dev to do a bit of a brain-dump on what NOT to
do with multi-signature transactions (there are several potential
attacks that we'll need to be careful to avoid).

I'll be creating a multisig_testing branch in the gavinandresen github
fork that WILL add multisig transactions to the balance, will have a
new RPC call to create multisig transactions, and will be able to
spend the multisig transactions; that will be for testing this PULL
only for now.
=======================

Here's the discussion of potential attacks that occurred to me while I
was working on this:

+ Attacker has an account and a funding address/key ("a") at a
shared-wallet service.  Attacker also has their own address/key ("b").
+ They send 100 bitcoins that can be spent by (a or b).  Note that the
shared-wallet service can't stop the attacker from doing that.

IF the shared-wallet service credits their account (because "a" can
spend the coins), then Bad Things might happen:

+ The shared-wallet service probably assumes that it controls all the
keys in its wallet, and the only time coins in its wallet will be
spent will be when it issues a send* RPC command. But the attacker can
spend using "b" anytime they like.

+ If the shared-wallet service allows importing of keys then the
attacker might be able to get double-credit by importing "b"
(depending on what the 'import private key' code does).

The pull I've submitted doesn't have any of those issues because
multisignature transactions are not credited / added to the wallet.

Going forward, I think the right thing to do is only add
multisignature transactions to the wallet's balance (and make them
available to spend) if the public half of ALL of the keys involved are
known to the wallet.  The private half of the key may not be in the
wallet (maybe it is on another device or maybe it is a deterministic
backup master key protected by a passphrase), but the public key must
be known and in the wallet.


I'd really like to get this into the 0.5 release because it will
enable much better wallet security and backup in some future release
or alternative client (but these transaction types need to be relayed
and mined BEFORE then to make that possible).

-- 
--
Gavin Andresen


-------------------------------------
The mainline client (independently from the GUI) has been referenced to as
"Satoshi" client. I personally like the name as a homage, but I guess it
all comes down to the decision of the maintainers.

Regards,
Chris

On Thu, Nov 3, 2011 at 12:07 AM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
On Saturday, July 02, 2011 3:29:04 AM John Smith wrote:

I don't really care much either way, but cmake doesn't follow the standard 
build procedure (./configure && make && make install), though I imagine 
./configure could be emulated with some script.


-------------------------------------
On Sun, Aug 14, 2011 at 3:05 PM, Venkatesh Srinivas
<me@endeavour.zapto.org> wrote:

applied

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hello Alex,

On Sun, Sep 11, 2011 at 12:20 AM, Alex Waters <ampedal@gmail.com> wrote:



What testing plan do you need?

JS
-------------------------------------
On Wed, Oct 26, 2011 at 4:58 AM, Michael Grønager <gronager@ceptacle.com> wrote:

The additional material _IS_ then part of the private key. It's not
something seperate. Its something you need to know in order to author
the address.  This was fundamentally my argument. Not that you could
hide information, but that information was already hidden.

Right now under conventional uses I can't identify all the
transactions that land in your wallet, because I don't know the keys
it contains. With the proposal it's the same situation.

[snip]

These projects will be able to use the _same_ procedure to extract the
identifying information. Except now instead of
ripemd160(sha256(pubkey)) it will be more like ripemd160(sha256([some
extra bytes generated by the wallet holder]||pubkey)) that you
extract.  If the former is not a problem for these applications, why
is the latter?


-------------------------------------
Thanks for the overview Mike.  I just bailed up Gavin on IRC and between 
that convo and what you've just written I'm starting to picture a plan 
in my head... This sounds right up my alley, I wish I didn't have to go 
to bed right now as I've got a ton of ideas buzzing around I'd like to 
get started on right now.  But I'll be onto it as soon as I've got a 
free moment...

On 07/09/11 00:52, Mike Hearn wrote:
-------------------------------------
I just tagged the git tree:  v0.4.00rc2

Fixes from release candidate 1:

+ Optimize database writes for transactions with lots of inputs
+ Fix a deadlock that could occur when adding addresses from 'addr'
messages and irc
+ Fix a potential problem with duplicate, un-spendable coinbase
transactions if you were generating bitcoins, with a locked wallet,
and ran out of keypool keys.


-- 
--
Gavin Andresen


-------------------------------------
On Sat, Sep 03, 2011 at 08:13:14PM -0400, Gavin Andresen wrote:

I've compiled bitcoind with Gavin's DEBUG_LOCKORDER, and fixed two potential
reported deadlock issues (see https://github.com/sipa/bitcoin/commits/lockfixes).

No deadlock warnings are given any more, but the issue remains. Just starting up
bitcoin with an empty addr.dat seems enough to cause it every few attempts. 
Is there is locked code that waits for an event that never occurs?

-- 
Pieter


-------------------------------------
Sure, of course, as long as it's clearly labelled as just your thoughts, no
issues.

For dispute mediation the way I'd start is playing around with some UI
design stuff and a toy protocol underneath. Once the process is smooth from
the users POV (no seeing binary blobs disguised as text) then it should
become clearer what steps the protocol needs and what order they need to
come in.

Specific feedback on this format - as far as I can tell the format
represents a subset of the regular bitcoin transaction format? Couldn't you
just serialize a Bitcoin CTransaction structure with the txins containing
the output scripts?
-------------------------------------
Three quick examples of duplicated strings. There are many more. Some of
the smaller ones may make sense to have duplicated several times in
english as their translated versions may differ in other languages. But
with these below I don't see the point.

Twice, with a small difference (<b> vs. none):

WARNING: If you encrypt your wallet and lose your passphrase, you will
<b>LOSE ALL OF YOUR BITCOINS</b>! Are you sure you wish to encrypt your
wallet?

WARNING: If you encrypt your wallet and lose your passphrase, you will
LOSE ALL OF YOUR BITCOINS! Are you sure you wish to encrypt your wallet?

Again twice, with a small difference (%s vs %1):

This transaction is over the size limit. You can still send it for a fee
of %1, which goes to the nodes that process your transaction and helps
to support the network. Do you want to pay the fee?

This transaction is over the size limit. You can still send it for a fee
of %s, which goes to the nodes that process your transaction and helps
to support the network. Do you want to pay the fee?

Twice, looks exactly the same:

Generated coins must wait 120 blocks before they can be spent. When you
generated this block, it was broadcast to the network to be added to the
block chain. If it fails to get into the chain, it will change to "not
accepted" and not be spendable. This may occasionally happen if another
node generates a block within a few seconds of yours.

Generated coins must wait 120 blocks before they can be spent. When you
generated this block, it was broadcast to the network to be added to the
block chain. If it fails to get into the chain, it will change to "not
accepted" and not be spendable. This may occasionally happen if another
node generates a block within a few seconds of yours.

Regards,
Geir Harald Hansen

On 24.10.2011 20:10, John Smith wrote:




-------------------------------------
Somebody has been inserting transactions with lots of outputs into the
main bitcoin block chain:
  http://blockexplorer.com/block/0000000000000305f98ffbe1db8445ce847fb9a924551945b465386c828f136f

Their next step will be creating transactions with thousands of inputs
from those transactions. The result will be lots of excessive disk
space usage.

The fix is this patch:
  https://github.com/bitcoin/bitcoin/pull/491

Suggestions on the best way to let merchants, miners, and pools know
about the potential problem?
I hate to take time away from the 0.4 release to re-spin 0.3.24 with
the patch, but we may have to.

-- 
--
Gavin Andresen


-------------------------------------
Hi!

 When my network goes down and I close the Bitcoin, I see the following
message:

---
martinx@floyd:~$ ./bitcoin-0.4.0rc2/bin/32/bitcoin
connect: Network is unreachable


************************
UNKNOWN EXCEPTION
bitcoin in CMyApp::OnUnhandledException()

Segmentation fault
martinx@floyd:~$
---

Thanks,
Thiago

2011/9/22 Martinx - $B%8%'!<%`%:(B <thiagocmartinsc@gmail.com>

-------------------------------------

They can't always judge it, eg if the link between you and that peer
is saturated then you may have connectivity, but it may be very slow
yet appear fast to the node itself.

This really has two parts:

(1) Making it easy to determine latency
(2) Using that data to make better connection decisions

Adding a pong message is fairly trivial and can help solve (1). For
instance we can start building latency histograms of nodes to see how
performant the network is, without risking any issues. Then that data
can be used to inform simulations of what happens if the measurements
are used by the node software. It also lets us experiment with less
critical software like Android clients.


-------------------------------------
On Fri, Jul 1, 2011 at 8:46 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:

The fact that this will -rc before full release softens my concern some.

I did a lot of semi-automated testing of cwallet+crypto (in the
encrypted and non-encrypted states) which I really don't want to redo
for cwallet alone.


-------------------------------------
Am Mo, 24.10.2011, 13:09, schrieb Pieter Wuille:

That would be fine as well. Although I would prefer if one could
query for a specific transaction id, whether it comes from a trusted
source and also from which trusted source, as you might want to
keep track of the amount of unconfirmed funds you are currently
accepting from a specific source (or the Bitcoin daemon could
keep track of that as well, either way is fine).

This sounds a little too involved though, for my level of familiarity
with the Bitcoin source code and C++, to implement myself.

Regards,
Jan


-------------------------------------
On Monday, December 12, 2011 6:37:56 PM Jorge Timn wrote:

This has the same problem as FirstBits, except .bit domains are dirt cheap, 
whereas vanitygen at least slows down grabbing all the common words...


-------------------------------------
On Fri, Aug 5, 2011 at 1:07 PM, Andy Parkins <andyparkins@gmail.com> wrote:


Right, while it doesn't warrant completely changing the transport protocol
to UDP or implementing onion routing,  I'm all for simple timing and order
randomization changes if they can make attacks like this less effective.

JS
-------------------------------------
Bitcoin already has code and a protocol for transactions to IP
addresses. Why not reuse that for dynamic address lookup? Just a few
changes are necessary to enable complete user@server.com handling:
- Extend the protocol so that "reply" messages can be signed by a fixed
  public key
- Extend "checkorder" messages so they can specify an account to
  send BTC to. Or standardize on how to put the account into the
  message field.
- Enable DNS lookups for IP transactions. The DNS-only proposals could
  also be used here to avoid having to use the IP transaction protocol
  sometimes. The public key for signing "reply" messages can be gotten
  from TXT records. This will be safe with DNSSEC and Namecoin. With
  plain DNS Bitcoin could take a SSH-like approach and ask the user to
  verify the public key the first time it is used, remembering it later.

DoS attacks are already handled by the IP transactions code: the same IP
address is always given the same bitcoin address until it pays to that
bitcoin address.


-------------------------------------
Hi,

The attached patch defines MSG_NOSIGNAL to 0 on platforms where it is
unavailable. Previously this definition was only available under
__WXMSW__.

-- vsFrom 8299efe45e090b81c988bcdca58c8e25c0001841 Mon Sep 17 00:00:00 2001
From: Venkatesh Srinivas <me@endeavour.zapto.org>
Date: Fri, 19 Aug 2011 09:41:04 -0400
Subject: [PATCH] Define MSG_NOSIGNAL to 0 on platforms where it is unavailable.

---
 src/util.h |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/src/util.h b/src/util.h
index 1e4ceb2..9d3824f 100644
--- a/src/util.h
+++ b/src/util.h
@@ -89,8 +89,11 @@ T* alignup(T* p)
     return u.ptr;
 }
 
-#ifdef __WXMSW__
+#ifndef MSG_NOSIGNAL
 #define MSG_NOSIGNAL        0
+#endif
+
+#ifdef __WXMSW__
 #define MSG_DONTWAIT        0
 #ifndef UINT64_MAX
 #define UINT64_MAX          _UI64_MAX
-- 
1.7.2.3

-------------------------------------
I may be missing something, but perhaps the simplistic method is the best.  

Start all nodes off with a certain level of trust.  Lets choose an arbitrary number 5.
If a node's trust level is high enough (lets say 10) forward transactions it sends you without checking them.
If a node's trust level is low enough (lets say 0) discard any transactions they send you (i.e. don't forward them on).
For nodes with a trust level between 1 and 9, forward without checking between 1 and 9 out of every 10 transactions.  Check the others, if they are valid, increase the trust level by 1, if they are invalid decrease the trust level by 3.

All of the numbers mentioned here (1-10, 1, 10, 1, 5, and 3) are arbitrary numbers that should be determined by the client or user-preferences instead of the protocol.  This would allow for clients to have varying amounts of initial trust/paranoia about their peers.

By decreasing the amount of trust faster than we increase it, we make it harder for untrustworthy clients to cheat us.  By having a cut off point, we make it so that untrustworthy clients can not DDoS us.  By randomly verifying some transactions in the beginning, we make it harder for a new client from DDoSing us, and we prevent our own trust level from being hurt too much for forwarding on invalid transactions.

The only problem I can personally see with this system is that if Node A trusts Node B with a 10 and Node C connects to Node A, then Node C can send  transactions that are invalid to Node C via Node A without Node C being any the wiser.  This would be stopped fairly quickly as Node B would catch on and stop forwarding transactions, but it would be a problem for new Nodes.

This could be fixed (somewhat) by having a message that says not to trust a particular node.

--Zell Faze



--- On Thu, 12/22/11, Andy Parkins <andyparkins@gmail.com> wrote:



-------------------------------------
Hello,

Another of my crazy ideas:

When a transaction is first broadcast, it should include the hash of the block 
it wants to appear after, let's call it's basis block.  That block can be 
anything the claimer wants; but it allows the miners to add this condition: 
the transactions outputs a new transaction claims must be before the new 
transaction's basis block.

Consider this block chain fork:

 * -- * -- F -- * -- 1 -- 4 -- 5
            \
             * -- 2 -- 3

Let's say in block 2; I transfer coins from address A to Mt.Gox (or any other 
pooled-account online wallet).  In block 1 I transfer credit from address A to 
address B.  In block 3 I transfer credit from Mt.Gox's pool to address B.

The chain at 3 races out first, but eventually the chain at 5 becomes "the 
one".  If Mt.Gox are foolish enough to broadcast my withdrawl in 3; there is 
nothing to stop that same withdrawl making it into 4 (since it comes from a 
pooled fund address).  Therefore Mt.Gox can't allow such a fast turnaround and 
must wait for six confirmations of 2 before allowing use of the funds.  That 
is an inconvenience for all the honest users.

With my proposed change, the Mt.Gox transaction broadcast at 3 would include 
"block 2" as its basis block.  Therefore that transaction could never make it 
into block 4, as no miner will include a transaction based on block 2 in the 
block 4 chain.

Mt.Gox is probably not a good example, as they have problems with fiat to deal 
with too.  However, for other online wallet accounts it would allow faster 
acceptance of received funds, since there is no danger of loss should an 
attacker arrange a reorganisation.

This basis block would be optional (implied by the input transactions if it 
isn't present); and would only need storing for the pending transactions, so 
no incompatible change is needed to the block format.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Wed, Aug 3, 2011 at 2:10 AM,  <bgroff@lavabit.com> wrote:

Correct.


It's not just a matter of mining power, it's also a question of
propagation.  Matt and I tried to perform a non-standard transaction
weeks ago and weren't able to get in mined after many hours. (we
eventually double spent the input with a normal transaction in order
to make it go away, interestingly one point about non-propagating txn
is that they're extra vulnerable to double spending by a standard txn,
as the non-standard one won't preclude the propagation of the standard
one)

on maturity/bugfixes is probably going to delay your full patch, but
the IsStandard part is uncontroversial and could go in quickly.

Based on that I think it would be very useful to split 319 into two
pull requests: one which does the IsStandard change, and one which
adds the full escrow feature set.  This way when the escrow patch does
enter the mainline client it will be meet up with a network which is
happy to handle its transactions.

(and people who are eager to use escrow can use modified clients on
the main network before that point in time)


Ah for some reason I thought your current code did not always produce
the shortest sequence.

If so, I see no reason to block on the other pull.


-------------------------------------
Linux kernel has not solved this problem; developers simply want to
work on interesting stuff, rather than debug, I think.

The best Linus has done so far it making certain periods of time
bugfix-only, refusing to take new feature pushes during the stability
period.  If there are critical bugs, refusing to release the kernel
until a developer fixes the regressions they added.

Linux is large enough, though, that the ecosystem has grown a support
network, where companies pay for support (one big way my employer
stays in business), which includes bug fixes.  So the paid support
orgs, like Red Hat, wind up going a lot of grunt work fixing because
they are the closest contact to actual users in the field encountering
problems with the Wonderful New Features bestowed upon them by
developers.

"drop and run" coding is a term for developers who appear, commit a
new feature, and then disappear without addressing bug reports or
other feedback regarding their contribution.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hi there!

As can been seen from this code block

  // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01
  if (nMinFee < nBaseFee)
      BOOST_FOREACH(const CTxOut& txout, vout)
          if (txout.nValue < CENT)
              nMinFee = nBaseFee;

a fee is required as soon as any output is less than CENT.

I was wondering: would it be possible to loosen this rule to something
like "if _all_ outputs are less than CENT" or maybe "if more than 50% of
all outputs are less than CENT"?

The reason is, that I'm currently working on a project, where I would
like to take a small cut on transactions passing through (probably not
an usual requirement) and a lot of those small cuts would probably bump
into this rule.

Isn't this rule mainly meant to prevent lots of transactions with small
coins? So "all small coins" should work as well as "any small coins" or
am I missing something? (things like creating large transactions should
already be caught by other rules, right?)

Regards!
Jan


-------------------------------------
On Wed, 2011-11-23 at 15:39 +0000, Andy Parkins wrote:

If there's an upper bound on the difficulty a block is accepted to have
(even if it would've passed with significantly higher difficulty), that
could solve this issue. For example, take the median (or average) of the
past 2016 blocks and don't value any new block for more than maybe 4
times as difficult as that. 


Don't be so hasty with that :)

- Joel



-------------------------------------
On Saturday, July 02, 2011 12:50:14 PM John Smith wrote:

And --datadir --mandir --randomobscurecrap CXXFLAGS=-O9, etc
Don't forget --help listing all the useful options... that's the big thing I 
miss with CMake-stuff.


-------------------------------------
Please don't create BIPs that don't have any actual implementation behind
them. Design discussion is fine but the mailing list works for that.

If I were going to implement escrow transactions in BitCoinJ it would not
matter what was written here. I'd just implement the design I thought made
sense. If that design was later adopted by others it can be documented and
agreed upon in a BIP, just like a regular RFC.

For what it's worth I would not attempt to send half-valid escrow
transactions through the p2p network, not even using the overlay networks
the protocol already supports. A correct escrow protocol requires the
seller to challenge the dispute mediator with the public key to be sure
they actually own it, and the simplest way to do that is to leverage the
existing DNS/EV-SSL infrastructure with a "sign this nonce" HTTP request.

BIPs should not be a place for people to come up with armchair designs,
because a design with no corresponding implementation is likely to be full
of problems. Let's revisit this once I can install some software on my
laptop, my server, and a friends server, and do a 3-way mediated
transaction between them.
-------------------------------------
Jeff is absolutely correct, stating that DNS bootstrapping can
potentially be very robust.

Consider, for example, that seeds can be hosted by services like
zerigo, who provide decent management API's, as well as by thousands
of small VPS operated by people all over the world. Moreover, if
namecoin lives up to it's promises than some seeds can be hosted using
it's tlds, and as such we would get around centralised ICANN/registrar
weakness.

The most practical way I see how to improve DNS bootstrapping is
publishing build instructions for a simple DNS server build and a
script which feeds it with node data. Something simple like djbdns plus
a perl script, or similar zerigo API script, would do. Than anyone can
host it. All left to do than is to hardcode a bunch of such DNS seeds
into the client.

Hardcoding seeds is not good enough? Get a convention that anyone
owning a bitcoin.* domain should point seed.bitcoin.* to a decent DNS
seed. Than clients simply scan 100-200 tld's to find working
seed.bitcoin.*

I am not quite sure, though, is if this would enable some attacks by
poisoned seeds.

Vladimir.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



Gregory Maxwell <gmaxwell@gmail.com> wrote:


I can confirm similar results.



It's about time for another checkpoint, I agree.
- --
Douglas Huff
-----BEGIN PGP SIGNATURE-----
Version: APG v1.0.8

iQIVAwUBTg00oEPHkQabDWHPAQhtIg/+KqgpNzu9pInI4w1QMl/PyGSEUrin6pHq
94H9UJRtx6kAPbyBDZ2M/DYTAk5logB0jZoZXg5tkYxY+DoGYC5FLYiLV9nfgIa9
oGEOgdSzaVZseINes0FMNcD5DjEmvvW0nDzJyraD7T11R8r+uATEtcPNN9g0aYSF
WCRWEKZSvf6o9k5sibmDGrWe/Zx9PV5Si59fqo1eglHUGG+9wLjP3Fv904HSQWD/
zJ+bMTNyddOi0vP23S5rQM4V94HG2wjgOVk804a/2qJlibXyJi0cYRQj/JIibOIt
KzXHqYAhJK5JcizUcKu3T8YM22ZE04nIqhxg7h8+5vaZHfHgMYjqGrYeEtqx6GUC
6oXKke2dP8bqdX+JkJ9Zrf5uz8ysPf6Rj+77dA1tYyFZc2CEb5wA0cnW5SSzqMe1
5q7saRda3P0RvTtWmJKLPyXbr7EqETKhr37E/lc7viLgQCroggQ4wVkUAj4rfjDZ
HeZtCfBg3U63oe6WPH1MkzuGPBOjdrSK9RlibFanPU/AL+sTYsf5cs+j8WTHa6WA
ee1k01Nke1Pa7ForvWcUXzzLPVk/ikEgmJrrTKcBNAEh5UKq7BveDX0fSw0kQmPO
XdWjlNfOfcObCVLRcJ7ev8H6fDQOFGxUXH3A98PCVtUx05aVoDVoRvdPAGN0kbTo
Xqa58ov1pQY=
=jKOB
-----END PGP SIGNATURE-----



-------------------------------------
Hey all!

My name is Fred Concklin and I plan on working on Bitcoin development
through my position at Trucoin. I thought I'd take this chance to
introduce myself and go over where I can make contributions.

I'm great with automated builds and testing for GNU/Linux and BSD
platforms and generally plan on structuring the bitcoin project into a
structure compliant with GNU autotools to facilitate testing and bug
reporting.

I'm also interested in work to daemonize bitcoin on boot and furthering
work to bring bitcoin into general coding and implementation paradigms
seen on GNU/Linux platforms.

While I mainly spend my time in high level functional programming
languages these days, I look forward to working on bitcoin and hope
everybody is patient with my occasional cpp implementation ineptitudes.

I'm also interested in spurring discussion on new blockchain
distribution techniques and thoughts on improvements for bitcoin.

I'm excited to begin work on bitcoin.

fpc

-------------------------------------
On Wednesday, September 14, 2011 10:45:36 AM Gavin Andresen wrote:

And those hours of wiggle-room are not enough to cause a problem.
The problem only comes in (AFAIK) when the existing rules are *not* enforced.


As this is against pools/miners' interests, and doesn't seem to solve any real 
problems, I'm going to discourage its adoption if it ever gets done.


-------------------------------------
On Thu, Jul 14, 2011 at 05:19:11AM +0000, John Smith wrote:

I like this idea. Matt and I were considering a similar system for the internal
communication between net/wallet/blockdb/mempool, but weren't really aware of
boost::signal. I looked at it, and really seems to provide everything necessary.


Maybe even per-account?


Does that include more confirmations? I think we'd first need to define what
exactly is relevant information for transactions. It could be defined in
terms of a/some high-level information request functions for transactions, so
GUI/RPC don't inspect the wallet datastructures themselves anymore:
* GetTransactionState(): return state (immature, generated, unconfirmed,
                         rejected, confirmed), and number of confirmations.
                         (possibly using the negative number of confirmations
                         semantics as described here:
               http://forum.bitcoin.org/index.php?topic=5920.msg328468#msg328468.
* GetBroadcasts(): return either -1 (unknown) or some integer denoting how often
                   this tx was broadcast. The "0/offline" state is equal to 
                   unconfirmed + 0 broadcasts
* GetInputs(): return a list of pairs (uint256 txId, int nOffset, int64 nAmount)
* GetOutputsToMe(): return a list of pairs (address addr, string label, fBool isChange,
                int64 nAmount, bool fGenerated, bool fAvailable) describing all
                To-Me outputs
* GetOutputsToOthers(): return a list of pairs (address addr, string label,
                        int64 nAmount)
* GetFee(): get the fee paid

The only things that can change while the transaction is already in the wallet seems
to be GetTransactionState() and GetBroadcasts(), so those would cause a
transactionUpdated event?

Adding/removing private keys from the wallet may change the other outputs, so i suppose
those are also candidates for causing this event.

     - transactionRemoved(int256): transaction removed from wallet (can this
for now, that can't happen, but if something like unspending/rejecting/detection
of conflicting transactions is added, it may.


Ok.


You simply mean the "Transaction requires fee of ..., agree?" message?

Regarding wallet encryption, we could use a

     - string askPassphrase()

maybe?


Ok; those would need to be implemented as globals until a more modular structure
is implemented.

-- 
Pieter



-------------------------------------
OK, give me a shout on IRC. It is a lot of work though, so be prepared. Bring bags of patience :)



________________________________
 From: Luke-Jr <luke@dashjr.org>
To: Amir Taaki <zgenjix@yahoo.com> 
Sent: Wednesday, December 21, 2011 1:07 AM
Subject: Re: [Bitcoin-development] BIP language on normative behavior
 
On Tuesday, December 20, 2011 7:59:00 PM Amir Taaki wrote:

I also contacted the IANA about getting the bitcoin URI spec accepted on their 
index, however never heard back. If you want, please have whoever you 
discussed it with get in touch with me. Either way, please be sure whatever 
they index is compliant with the spec on the wiki as-is (especially not being 
BTC unit specific, as this is clearly non-scalable).

Luke
-------------------------------------


Fixed addresses like that are a temporary thing during Bitcoins maturation
period. They lead to merchants exposing data they probably don't realize
they're exposing, like their income, which is basically unacceptable for
any payment system.

There's no point trying to optimize a case where:

1) You are in the minority (no phone?)
2) The "perfect experience" leaks private data in such a way that would be
deemed a gross security breach by any serious payment processor.

OK, some thoughts on the general proposal, from the POV of what it'd take
for a large deployment, like for every Gmail or every Facebook user. In
terms of ease of implementation it is ordered HTTPS/HTTP then DNS trailing
by a large margin. Big sites, even small sites, typically have high-speed
load balancing and demuxing already implemented for HTTP[S] and it's
usually easy to add new endpoints. The same is *not* true of DNS, and
whilst coding up a custom DNS server is possible it's definitely a worse
fit.

FirstBits seems out of the question for the same privacy reasons as given
above. No banking system worth its salt would let everyone look up other
peoples income.

The simplest approach would be to request a full public key with an HTTPS
request like

   foo@domain ->
https://domain/_bitcoin/getnewkey?user=foo&label=Payment%20from%20Bob

If you then want to turn the resulting public key into an address before
creating a transaction you can obviously do that.

BTW the BIP is pretty hard to read. Your spec for the HTTPS proposal is a
big pile of source code. I think it's the same as above, but it's hard to
tell without more effort.
-------------------------------------
On Thursday, August 04, 2011 6:56:42 AM John Smith wrote:

Well, that certainly doesn't sound like a security vulnerability at all.
It's by design that everyone knows about every transaction.


-------------------------------------
On Wed, Aug 10, 2011 at 9:29 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:

I'm already on it, leveraging bitcoinj to do the work. I've added async
capabilities to bitcoinj so that I can peer with everything that will let me
with the goal of publishing quality peer lists via the DNS. Once I can build
some metrics off the network its a matter of creating the visualizations.

I just started on this project last week. Happy to work with others on what
a healty network looks like as well as best ways to communicate status.

also need advise on how to not be an impolite peer.

-rick
-------------------------------------
On Thursday, September 15, 2011 8:56:24 AM kjj wrote:

No. There is no such thing as "non-standard transactions" really; it is simply 
"transactions outside of the bounds that I as a user/miner will relay/accept". 
It is perfectly legitimate for other users/miners to relay/accept transactions 
more liberally. By penalising for transactions falling outside of your 
*personal policies*, you would end up banning many legitimate nodes.


-------------------------------------
On Tue, 2011-09-27 at 20:28 +0200, david@bitcoin.se wrote:
Most developers treat the forums as write-only or just ignore them all
together, they are way too full of junk to bother reading.
Translation updates are pretty much just blindly pulled unless someone
opposes. 
No one is responsible for translations in Bitcoin, though it would be
nice to have people agree to keep their translations up-to-date when
they submit new ones...
Anyone can make a pull request, people who can push to the bitcoin repo
(ie can pull a pull request) are Gavin, tcatm, sipa, jgarzik, and
alexwaters.

Matt



-------------------------------------

https://groups.google.com/forum/?pli=1#!topic/bitcoinj/LSlZdUWcCdk



Patches to BitCoinJ are always welcome :-)

If you'd rather do your own thing, you could experiment with writing a proxy
that sits in front of bitcoind and multiplexes connections. Gavin is
concerned about socket exhaustion as users move to lightweight clients.
Multiplexing proxies are a battle-tested technique for reducing the strain
of this type of thing. BitCoinJ uses thread-per-connection so wouldn't do a
good job of that right now, but allowing it to use a mix of async io and
multi-threading would be a nice improvement. It'd need some changes to
bitcoind as well for a really good effort, to allow for IPs to be forwarded.
I'm happy to discuss it more with you over on the bitcoinj list if wanted.
-------------------------------------
RE: buying me and Gregory a shared beer:


But that transaction won't show up in my bitcoin wallet as bitcoins I can spend.

And even if my wallet DID show me "transactions that involve your keys
but that you can't spend," all I would know is there are N bitcoins
that I can only spend if I can somehow figure out that Gregory has
public key XYZ.

How would I know that unless you told me?

I think the right long-term solution is moving away from bitcoin
addresses as 'pay-to entity' and create an infrastructure where we're
paying people or organizations. But in the short term, I think there
are lots of benefits to creating a new type of bitcoin address built
on top of OP_EVAL that will be very easy for all of our existing
infrastructure to support.

-- 
--
Gavin Andresen


-------------------------------------
On Thu, Jul 14, 2011 at 10:50 PM, Luke-Jr <luke@dashjr.org> wrote:

On Sat, Jul 16, 2011 at 6:38 PM, Arthur Britto <ahbritto@gmail.com> wrote:

On many (most?) modern Unix file systems writing zeros just once is
not sufficient because the data won't be written in place, but
multiple writes aren't any better.

Moving the keypool addresses aside so they won't be used sounds like a
good idea.

The lamest thing is that there is no way for wallet to be
born-encrypted. So the only way to prevent a leak is to build the
wallet initially on a ramdisk or the like, then move it over after
encrypting it.

At least luke-jr's (2) would make the key leak on a new wallet
inconsequential— since all keys in it are keypool keys at that point.
So I really think it ought to be done.


-------------------------------------
If there haven't been lots of upgrades in a few days, I think it's
time to use the alert function again.


-------------------------------------
On Fri, 2011-09-09 at 10:02 -0400, Gavin Andresen wrote:
I'm too lazy to make nice tars so here is the raw gitian output (I plan
on working out gitian-downloader stuff sometime in the next couple
days).
Also, setup exe still not deterministic so theres that...

Anyway:
http://dl.dropbox.com/u/29653426/bitcoin-ubuntu-v0.4.00rc2.zip
http://dl.dropbox.com/u/29653426/bitcoin-win32-v0.4.00rc2.zip

SHA1s:
fd886d79bf48ba0d90f2f99fdd19d96946662bf5  bitcoin-ubuntu-v0.4.00rc2.zip
703712859ecdce423020116ebf65d087b179997d  bitcoin-win32-v0.4.00rc2.zip

Matt
-------------------------------------

this is an excellent "painting the bikeshed" question, so i cannot
resist participation :)

imo, anyone who has any business looking at the beps (which would
generally be technically-minded people), will be smart enough to
google for "bitcoin bep003" to find what he's looking for. so i don't
see an issue, whatever acronym we end up using.


-------------------------------------
OK, I'm ignoring your sarcastic style, I just wanted to support the URL
idea, which is KISS attitude, in the oposite of everything else proposed
here. I'm really affraid of over-engineering the aliases, which will make
it hard to implement in clients. Somebody noticed account implementation in
standard client - yes, it's good example of fail.

I still don't see any serious issue with the URL proposals. And sipa's idea
of posting back the transaction ID is also interesting, prividing yet
another flexibility in implementation and possible usage.

Btw, Rick, feel free to provide me some relevant RFCs which are solving
similar problems like BIP 15. And no, it's not sarcasm, I really want to
learn something new. Until now I just feel we're reinventing wheel or
raping some stuff which we should not touch at all (DNS).

slush

On Fri, Dec 16, 2011 at 4:52 PM, Rick Wesson
<rick@support-intelligence.com>wrote:

-------------------------------------
I haven't been much a part of these brainstorming discussions, and so I'm
really looking at this from a bird's eye view, without any bias towards any
particular idea.

I do see what appears to be relevant concerns, brought up just before new,
powerful functionality is injected into 50%+ of the nodes on the network.
 I cannot tell from my position if there is/has been consistent concern for
OP_EVAL proposal, or if it's mostly a transient response to hearing about
recursion in the scripting engine, etc (like myself, originally).  I
haven't debated this topic much, so I'm not in a position to personally
comment on any proposals.  (Though, this all feels very similar to the
problem of hash-table collisions in HTTP
POST<http://www.securityweek.com/hash-table-collision-attacks-could-trigger-ddos-massive-scale>
).

However, I would like to remind everyone that we/you are messing with a
$20+ million dollar *thing*.  There's more than just a piece of software at
stake -- whatever goes in needs to be as hard as diamond.  If we open up a
hole that allows someone to satisfy arbitrary scripts, or create one-packet
DoS/crash attacks, that could be devastating for Bitcoin.  Roconner is
persuasive enough to make *me* think that not all corners of this
functional space has been explored properly.  And while my opinion doesn't
matter, I'm concerned that others may feel too invested in the current
design path to want to "go backwards."  Again, I don't know one way or
another, I just want to warn against pride getting priority over security.


At the very least, you should consider consequences and recovery path of
such unanticipated problems.  If the things that could go wrong are
devastating, let's lean towards a more conservative solution (like
sandboxing the sub-scripting engine).   Remember, the network is working
just fine *without *OP_EVAL, and while OP_EVAL provides some really nice
benefits, I don't think the benefits over regular multi-sig are worth the
consequences of making a mistake in this multi-million dollar beast.

Okay, back to your regularly-scheduled debating...
-Alan

On Thu, Dec 29, 2011 at 2:08 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:

-------------------------------------
I agree with Mike Hearn and Christian Decker-- paying to
'somebody@foo.com' should become, behind the scenes, a HTTPS query to
https://foo.com/something. If you just want to (say) donate to
eff.org, then paying to '@eff.org' aught to work nicely.

And if namecoin ever takes off you'll pay to 'somebody@foo.bit'.

It seems to me that if it was DNS-based, the address should be
something like 'somebody.bitcoin.foo.com'. But I think it is unlikely
people will setup and run a custom DNS server just to support bitcoin
payments.

-- 
--
Gavin Andresen


-------------------------------------
Could we combine this proposal and the HTTPS proposal?

The DNSSEC TXT record could give instructions on how to query an HTTPS server to get the address.  Then we get the dynamism of HTTPS without having a rigid URL scheme for querying the server along with the advantages of DNSSEC.


--- On Wed, 12/14/11, Rick Wesson <rick@support-intelligence.com> wrote:



-------------------------------------
On Mon, Jul 11, 2011 at 9:33 AM, Mike Hearn <mike@plan99.net> wrote:



+1

More code documentation would be helpful, and so would making the interfaces
more understandable/readable, and getting rid of the manual locking
(especially in client code!), but I don't see how that would warrant a
complete rewrite.

Some refactoring would be much safer than trying to reproduce every nook and
cranny in a rewrite.

re:4) I also don't see why boost would be a 'nonstandard dependency'. From
what I understand, a large part of the new C++0x standard is derived from
boost. Also C++ compilers are getting faster and more smart all the time, so
I absolutely don't see "build speed" as a goal.

re:6) I've already submitted a few pull requests that replace hardcoded
magic values with constants. Moving the constants to a config file is not
needed IMO because the end-user doesn't need to change them.

JS
-------------------------------------
On Mon, Oct 24, 2011 at 8:55 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:


Are there current users of gettransaction for whom the performance penalty
would be problematic?  If so, perhaps gettransaction could take an optional
second argument includeinputaddresses which defaults to false.

-- 
Michael
-------------------------------------
On 2011 December 16 Friday, Rick Wesson wrote:

Could you point me at an example?


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
"Gavin Andresen" <gavinandresen@gmail.com> wrote:



Here are some additional use cases:

* Long term lock funds, requiring signatures from 2 officers of a company
to disburse (2 of n for n between 3 and 20)

* Short term lock funds, with 2-factor auth to disburse and an additional
2 of n backup in case one of the factors is lost (2-of-2 OR 2-of-n)

* "Escrow" with the the two parties having to agree or one of two backup
observers helping in case of disagreement (2-of-2 OR 2-of-3 OR 2-of-3)

* An options contract where the outcome is triggered by a key being
broadcast: (Ks AND K1) OR (Kr AND K2) - s gets control of funds if K1 is
broadcast, r gets control if K2 is broadcast.






-------------------------------------
On 06/16/11 20:18, Luke-Jr wrote:
Jeff's scratch off branch modified to use email (as unique salt) and
password would eliminate the need for a static wallet.dat for 99% of the
userbase.  This seems like a much better solution than encryption. 
(Although obviously it's still vulnerable to key loggers).


-------------------------------------

On Jun 15, 2011, at 7:46 AM, Christian Decker wrote:



I propose "Reference client." Seeing as that's what it is, the original reference implementation.

-- 
Douglas Huff


-------------------------------------
I like the user@server.com model. The protocol should be done entirely
in DNS, though, not using HTTP connections to the server. Then the
protocol can easily be used with Namecoin or other DNS
replacements/enhancements later. Crypto to prevent MITM attacks can be
an optional part of the protocol.

Almost all users will be unable to set up *any* always-on Internet
service to answer queries, so I'm not too concerned about how easy it is
to set up the server software.

I agree that FirstBits is bad for this. Unlike DNS, "registrations" last
forever because private keys can't be transferred safely. All short
names will be taken quickly. It will also be very expensive for clients
to query this themselves.

The CA model is broken and it should never be used by Bitcoin.


-------------------------------------

Or maybe report them as 'suspicious.'  Changing the meaning of
'confirmations' is likely to break code (e.g. code like block =
current_blockchain[blockcount-tx.confirmations] ... would give the
wrong block).

A floating-point 0.0-1.0 'confidence' measure might be a good idea to
go along with the integer confirmations. I can think of all sorts of
ways of gauging the reliability of transactions or blocks (did it come
from a trusted peer-- assuming we eventually have trusted peers.  Does
it have a lot of confirmations?  Are there no active block chain
forks?  Have we been getting new blocks at the rate we expect?  etc
etc etc)

We could start with an as simple-as-possible "confidence == 0 if
confirmations < 2, otherwise confidence = function(#confirmations)"
and improve it from there.

-- 
--
Gavin Andresen


-------------------------------------
Starting from bitcoinj, I have plenty of ways to publish DNS. Why sort them
by version? Ordering from highest to lowest?

how about publishing addresses under version.example.com if you version has
a perfrence?

-rick


On Wed, Aug 3, 2011 at 7:10 AM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------

The term "contract" is sort of misleading, but there isn't a better
word for it. Satoshi called them contracts so that's what I call them
too.

http://en.bitcoin.it/wiki/Contracts

The point is to allow for lower trust in certain types of
transactions. For instance, consider Kickstarter. They allow people to
club together to fund the creation of new things, typically indie
movies and games. The problem is you need this trusted middleman to
collect peoples pledges and aggregate them. That adds fees, etc. With
contracts it can be done entirely with software, all the artist/game
programmer would need is to run some software on their website.


;)

Lock time or if every sequence number is UINT_MAX.


-------------------------------------
Why does anyone care what an address looks like?

If the user is seeing an address, that's a usability fail right there. It's
common today because AFAIK nobody finished off the  URL handling support in
the main client for browser integration. It'd be a much better use of time
to finish off that integration and make it easy for people to create links
containing a bitcoin: URL (like with copy/paste of text/html content).
-------------------------------------
Hi Gavin / Alan,

Agree that we would also need to consider these "half" transaction valid. At least for the time being up to the lock_time, and one could have an extra constrain - that the lock_time should be within e.g. 30minutes that would avoid the will-never-be-completed cases.

My main concern when it comes to introducing other protocols is that they might never be standard (I think a great number of clients will emerge - and this would be a thing to compete on). If it is part of the p2p network it will be a seamless standard and easy for everyone to use, even across different clients. But I share your concern on the 

I can, however, also understand your worries, and some other constraints should be introduced to ensure that not even short time spamming is possible... 

/M

On 09/11/2011, at 20:13, Gavin Andresen wrote:




-------------------------------------
Hi Mike,

I expect I'll be submitting patches for bitcoinj sometime in the future 
but I'm not really across it yet to the point where I'd be confident 
submitting patches right now...

This proxy sound like a good match for what I've been up to lately 
though so long as it wouldn't involve direct changes to bitcoind on my 
part.  My c/c++ skills are non-existent.

However I have been building a pool protocol using protobufs and netty 
for non-blocking IO and I'd imagine the kind of multiplexing proxy 
you're talking about could be easily implemented using netty.

I'm not really understanding the use case though.  I believe most 
bitcoind's have a default max connections of 8.  Is the goal to increase 
this without fundamentally altering the bitcoind concurrency model?  Or 
is it to provide capactity for a more hub/client oriented network?  If 
the latter then presumably this is functionality that should ideally be 
native to the client in the long term in the form of NIO?

On 06/09/11 23:31, Mike Hearn wrote:
-------------------------------------
No, a bug was found where it no longer opened ("Error: unable to load
wallet.dat") when the ~/.bitcoin folder was empty/not present.
-------------------------------------
On Thursday 04 August 2011 19:39:56 Matt Corallo wrote:


"Slightly" is an understatement.  It add more network traffic for every 
double spend attempt.  Which don't happen very often.

Also, I'm not proposing a new message, heaven forbid that we add a new 
message type, I'm proposing that we do this:

 enum
 {
     MSG_TX = 1,
     MSG_BLOCK,
+    MSG_DOUBLESPEND,
 };

Also, people don't "have" to know about it.  And it's not "people" it's an 
addition to the _one_ official client.  _and_ it's backward compatible 
because if they don't know about it, nothing changes... the TX gets dropped 
just as it is now.


They do care because the network as a whole is what makes the eventual 
decision about which is the block-chain-to-rule-them-all.  Chain forks, and 
eventual reorgs are also far less disruptive when each leg of a double spend 
isn't on each potential chain.  "Half the network" includes half of the 
miners.  It's perfectly possible for half the miners to be working on one 
leg, half on the other.  That means it's 50/50 which leg eventually gets 
confirmed.


Well that's true enough; but how on earth you're going to identify an IP 
address of a particular vending machine that isn't accepting incoming 
connections is beyond me.  If it is a target it's pretty close to invisible.


What?  It's easier to trigger massive adoption and organisation of an 
inherently disorgainsed network of miners than it is to write a few lines of 
code?  If that's true, then the bitcoin source is even more impenetrable 
than I imagine.


It's not about prevention, they are already prevented.  It's about 
detection.  Quickly.


How is this second transaction going to end up anywhere but on a few 
isolated nodes if it isn't propagated?  The only way _both_ can be in a pool 
is if they are both received.  If they aren't both forwarded then it won't 
be in most pools.  If it isn't in most pools then which how is the relevant 
user going to get notified?


If it's still an experiment why is there such huge objection to pretty much 
every change anyone proposes?  Bitcoin is one of the most conservative 
projects I've ever seen, even for the most passive of changes.  I can 
understand wanting to prevent potential financial loss, but it's not like 
I'm suggesting we start broadcasting private keys on the network.


When you're using it as an argument for why a suggestion is unnecessary 
that's not how it sounds.

Anyway; it's fine.  You don't think it's a good idea; and I suspect none of 
the other official client developers will either, they don't like protocol 
changes.  So be it; it was only a suggestion and I'm a nobody around here.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
These are now formally announced:

https://bitcointalk.org/index.php?topic=43626.0
-------------------------------------
In CNode::SendMessages there is a trickle algorithm. Judging from the comments it is supposed to:

* at each update round a new (random) trickle node is chosen, with 120 nodes and an average round time of 100ms (the sleep) we will have moved through roughly all nodes every 12-15 seconds.
* when a node is the trickle node it will get to send all its pending addresses to its corresponding peer.
* when a node is not trickle node (the rest of the nodes) we send transaction-invs, however, only 1/4 of them - the rest is pushed to wait for the next round and would eventually get sent.

However, the way the 1/4 of the invs are chosen is by: 
	(inv.getHash() ^ hashSalt) & 3 == 0

As hashSalt is a constant (static, generated on start up) and as the hash of an inv is constant for the inv too, the other 3/4 will never get sent and hence it does not make sense to carry them around from round to round:
	if (fTrickleWait) vInvWait.push_back(inv); 
and:
	pto->vInventoryToSend = vInvWait;

The hashSalt will be different for each node in the peer-to-peer network and hence as long as we have much more than 4 nodes all tx'es will be sent around.

Ironically, this (wrong?) implementation divides the inv forwarding hash space into 4, along the same lines as we discussed last week for DHTs...

I suggest to either keep the algorithm as is, but remove the redundant vInvWait stuff, or to change the algorithm to e.g. push the tx'es into a multimap (invHash^hashSalt, invHash) and choose the first 25% in each round. 

The last alternative is that I have misunderstood the code... - if so please correct me ;)

Happy New Year!

Michael



-------------------------------------
Hey,

I'd like to simplify the internal reference miner and remove all
dependencies on cryptopp (it's the only place we use cryptopp instead of
OpenSSL).

Unfortunately, cryptopp is also used to calculate getwork "midstate".
This field is redundant and the miner could easily calculate it from the
blockheader so I'd like to remove it.

Any thoughts? Where should such a change should be announced so all
miners can be upgraded?


-------------------------------------
Hey,

Can we lock the version numbers to be the protocol version (which changes rarely) and instead use the sub_version_num field + revision number for individual builds?

Satoshi 0.4
BitcoinJava 120311
bitcoin-js 6

Like so. Otherwise we will have version bumping insanity :)
-------------------------------------
On Wed, Aug 24, 2011 at 1:57 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Strongly agreed...

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wednesday, December 14, 2011 6:02:25 PM Rick Wesson wrote:

Don't confuse BTC (Bitcoin unit) with BC (Bitcoin in general / protocol)...
The hard part of using DNS will be sticking to the standard good practice of 
using a new address for every transaction.


-------------------------------------
On Fri, Dec 30, 2011 at 5:42 AM,  <roconnor@theorem.ca> wrote:

If you look at the archives of the concatenative programming mailing
list [1] you'll see lots of examples of people creating stack
languages with minimal operations that exploit similar functionality
to reduce the required built in operations. The discussion on the list
is mostly about stack based languages where programs can be pushed on
the stack and executed (eg. Joy [2]/Factor/Some Forths).

I don't think the scripting engine in bitcoin has the ability to
concatenate, append or otherwise manipulate scripts on the stack to be
eval'd though does it?

[1] http://tech.groups.yahoo.com/group/concatenative
[2] http://tunes.org/~iepos/joy.html

Chris.
-- 
http://www.bluishcoder.co.nz


-------------------------------------
On Wed, Aug 24, 2011 at 3:05 PM, Christian Decker
<decker.christian@gmail.com> wrote:

This works fine for ECC.  But it requires that the composite key
signer has simultaneous access to all the key-parts, so it doesn't
solve the "my PC has malware" problem.


-------------------------------------
Criticism accepted, although I'd appreciate it if you supply some reasons
about why it's such a bad idea :-)
The idea was never really popular and before starting work on a real
implementation I wanted to test the water, and should it turn out it's
complete non-sense I'm happy to accept that.

I don't want to have a DHT for the DHTs sake, I was more interested in
reducing the number of messages that need to be sent around the network,
since network load is going to be a major problem if we ever grow beyond a
certain point.

Just wanting to brainstorm.

Regards,
Chris
On Sat, Dec 17, 2011 at 8:28 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------

On Jul 4, 2011, at 1:23 PM, Gavin Andresen wrote:

I'd go a step further and say that, since import/export is planned to get merged at about the same time, intentionally breaking unsafe/badly designed backup mechanisms is actually desirable.

-- 
Douglas Huff


-------------------------------------
I think it is a very important feature to be able to extract transaction to/from you only from your private keys. In the standard transactions this is easily accomplished - in the case you only want to find the addr to tx mapping:

   vector<pair<opcodetype, vector<unsigned char> > > vSolution;
   if (!Solver(scriptPubKey, vSolution))
       return 0;

   BOOST_FOREACH(PAIRTYPE(opcodetype, vector<unsigned char>)& item, vSolution)
   {
       vector<unsigned char> vchPubKey;
       if (item.first == OP_PUBKEY)
           // encode the pubkey into a hash160
           return Hash160(item.second);
       else if (item.first == OP_PUBKEYHASH)
           return uint160(item.second);                
   }

This possibility is used today in:
* blockexplorer
* bitcoin-js
* my own tiered implementation for thin clients

I agree that you can of course always construct payment schemes to hide payments (hashes from classic novels, sending the private key off line etc), but I consider those either exotic or on purpose hidden, and hence they are not really a problem, nor an argument that this feature does not really exist today.

So, if we introduce a standard (multikey) payment that hides the address (or makes it overly complicated to extract it) it will be a major problem for the projects that I listed above. 

I will post a more detailed technical comment reflecting directly on the BIPs, but the wiki is currently down and I need to re-read the BIPs first.

Cheers,

Michael


On 25/10/2011, at 18:47, Alan Reiner wrote:





-------------------------------------
On Thu, 2011-07-28 at 08:45 +1000, Gavin Andresen wrote:

Well, the bounty thing can't be automated, so, wouldn't publishing the
work you've done up to then by, for example, mailing this list, pretty
much guarantee someone else couldn't claim they fixed it all by
themselves anymore?

It could, however, end up with some quarrels about how much of the
bounty to give and to whom. Those are not nice things to have.

- Joel




-------------------------------------
What do you know, it worked. Finished.

Once again Norway finishes ahead of Sweden. :P

By the way, I had to translate some of the exact same strings 2-3 times.
That's something you may want to improve on.

On 22.10.2011 15:28, Nils Schneider wrote:




-------------------------------------
On Thu, Dec 29, 2011, at 01:55 AM, roconnor@theorem.ca wrote:

Even if OP_EVAL allowed infinite depth, you'd still need to explicitly
specify all operations performed, since there is no way of looping.

I think that something like OP_EVAL will eventually be used to improve
Script in a backward-compatible way (enable the disabled math ops, fix
bugs, etc.), so the mechanism might as well be used now. The only
advantage I see with OP_CODEHASH is that script ops won't need to be in
Script "strings".


-------------------------------------
I'd appreciate review/feedback on this:

https://github.com/bitcoin/bitcoin/pull/492

This change skips ECDSA signature verification for transactions during
the initial block-chain download, which makes downloading the block
chain much faster.

"Initial block chain download" is all blocks up to 120 blocks before
the last blockchain lock-in point.

Reasoning for why this is safe:

If an attacker tries to feed a client bad transactions during the
initial block-chain download (transactions with invalid signatures),
then they change the merkle tree, and at the first blockchain lock-in
the bad chain will be rejected.

Transactions are still checked for orphan blocks that come in during
initial block-chain-download (ConnectInputs will be called with
fBlock=FALSE) and for mined blocks (ConnectInputs called with
fMiner=TRUE).

-- 
--
Gavin Andresen


-------------------------------------
These branches are ready for merging to mainline.

Branches can be viewed at:
    http://luke.dashjr.org/programs/bitcoin/w/bitcoind/luke-jr.git/heads

git pull git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git <branchname>

=

minfee_modes: minor internal API change as a step toward allowing
              user-customizable fee schedules

=

qmake_system_crypto++: allow building bitcoin-qt against system crypto++

    This is worthless if the crypto++ dependency is removed.

=

sharedlibs: build bitcoind against shared libraries on 'unix'

    Not sure why it's been static for so long, but most systems only have
    shared libs.

=

signal_blk_notify: -blknotifypidfile option to send SIGUSR1 to a PID when
                   there's a new best block

    Used by basically every pool now, it just sends SIGUSR1 to a poolserver.

=

bugfix_qt_uri_amount_parser: fix URI amount parser to accept exponents and
                             hexadecimals

    Please don't bother arguing over bugfix_qt_uri_amount_parser. It'll just
    be a waste of time. Neither the pro- nor anti- sides have budged over
    multiple arguments already. I can't force you guys to merge it, but I can
    at least make it easy if you decide to tolerate it. Just keep in mind that
    it doesn't hurt the BTC-only URIs at all, and if nobody ends up using it
    for other units, it can always be removed later.
        Best  case scenario: people use it and bitcoin-qt works correctly
        Worst case scenario: people don't use it, and it can be removed

=

base58_liberal_parsing: accept typos in base58 data

    The same best/worst case scenario logic as the URI parser applies
    to base58_liberal_parsing too, so long as typos aren't advertised as
    legitimate addresses.



-------------------------------------
I wish that was the case. It would have made my life a lot easier in the 
past. A lot of the MIME libraries out there are extremely buggy. MIME is 
just difficult to work with, and support is still weak.

Undefined content length + text based boundaries = pain in the ass.

It is in the e-mail module because that's all MIME was originally 
intended for. It's now grown beyond that now, but you will find the MIME 
functions still live in the e-mail libraries. When dealing with raw MIME 
encoded data, e-mail is still the most common case.


On 12/19/2011 11:16 AM, Luke-Jr wrote:


-------------------------------------
L.S.

Some bitcoin "security vulnerabilities" have been discussed by Dan Kaminsky
at BH 2011, there is one article about this dated yesterday:

http://searchsecurity.techtarget.com/news/2240039221/Black-Hat-2011-Dan-Kaminsky-reveals-network-security-research-topics

The article is very unspecific though. They talk about a tool called
"blitcoin" that "unmasks" both sides of a bitcoin transaction. A google
search also turned up nothing, except some misspellings.

Does anyone have more information?

JS
-------------------------------------
Luke-Jr wrote:
It is certainly true that standardness is an artificial construct that 
only has meaning to this particular implementation of the software, but 
no meaning in the context of the protocol or the system as a whole.

On the other hand, the vast, vast majority of all transactions follow a 
particular pattern.  If someone gives you one that doesn't match the 
standard pattern, you might be a little suspicious, but it is no big 
deal.  But, if they emit dozens or hundreds, it is hardly unreasonable 
to disconnect them until you figure out what's going on.


-------------------------------------
@Steve re "Who knows, it might be the only way we'll ever hear from Satoshi
again."

That brings up a good point... Does anyone aside from Satoshi actually have
the ability to send such an alert? Should we at the very least change the
alert system to give such privileges to current devs and ensure that that if
the missing Mr. Satoshi has had his key compromised we don't see an
authoritative-looking alert come up from a malicious source?
-------------------------------------
On Wed, Aug 10, 2011 at 6:38 PM, Andy Parkins <andyparkins@gmail.com> wrote:

The above has been discussed on the forums.  The community seems to
consider that option one of last resort, because the consequences of
-not- upgrading immediately become "I cannot access my money."  The
community also seems rather hard-wired against breaking changes like
that, because it implies that we lowly dev peons are daring to mess
with the Blessed Satoshi Design that has received extensive study, and
100% communal agreement.

If the community changes its mind, and there are strong calls to make
a breaking change, we can certainly do that.  Bitcoin is not only open
source but very much democratic -- people vote by choosing which
client software to use.



Historically speaking, the protocol has had minor tweaks, if you check
the patch history.  Adding new protocol commands is pretty easy, for
example.  Removing commands tends to be high cost for low benefit
("protocol removes a harmless redundancy"), if you're messing with the
initial negotiation sequence.  IMO verack is not redundant, anyway.

But the answer is "what do the users want" not "no"  At the end of the
day we're here to adequately reflect the needs of our userbase at all.
 And so far, the userbase seems highly conservative when it comes to
incompatible changes.  Correct me if I'm wrong...



It's negative to weight costs vs. benefits?  That is what I expect any
good engineer to do.

In any case, our -users- are not clamoring for breaking changes of the
type you describe above, as far as I can see.  Just the opposite.  So
if you want to deploy a breaking change, the burden is on you to
convince the bitcoin users and miners that it's a good idea.

If the bitcoin dev team is not accurately reflecting the desire of its
users, then that should be corrected, and we want to hear feedback.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Tue, Jul 12, 2011 at 12:13 AM, Alan Grimes <agrimes@speakeasy.net> wrote:

This is about the last thing we should do, and it's one of the worst
coding practices of many C++ projects (and unfortunately carried over
to Java by force).  See Knuth and his work on literate programming.
Putting logically similar code -together- is often more impactful and
meaningful than splitting up files into dozens (hundreds or thousands,
in large projects) of tiny, 20-line files.

A project attains zen in the -balance-.  Bitcoin was not well served
by "everything in main.cpp" approach -- but neither is it well served
by splitting wallet / transaction / etc. logic across a great many
files.  We should not have to ask ourselves, Is This Code In
WalletFactory.cpp, WalletTx.cpp, WalletStore.cpp, WalletKey.cpp,
WalletCrypt.cpp, or in s/$F.cpp/$F.h/ ?

Strict, unthinking rules do not buy anything, and can cost us much.

Plus, no matter how you slice it, bitcoin is Hard To Learn and there's
no getting around that.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
2011/9/22 Martinx - $B%8%'!<%`%:(B <thiagocmartinsc@gmail.com>


Can I ask your rationale for this?

address for each new contact that sends them bitcoins (either for every
transaction, or they reuse the address for this person).  To make sure that
the address is labeled, they create it themselves and then give out the
generated address.

They are utterly spooked by suddenly appearing unlabeled addresses, of which
they are unsure whether they are used, and which can never be removed.

I'm fine with adding it back as an option but please leave it disabled by
default...

JS
-------------------------------------
On Mon, Sep 26, 2011 at 3:42 PM, Nils Schneider <nils@nilsschneider.net> wrote:

I think one of the pools was already working on something like that?
I'm pretty sure it can be removed, and I'm pretty sure somebody has
already field-tested that guess.
-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wednesday, September 14, 2011 5:51 PM, "Gregory Maxwell" <gmaxwell@gmail.com> wrote:

Backward-compatibility is valuable. I believe version 0.1 will still
more or less work on the current network. This is a real selling point
for Bitcoin: the code is solid enough that even 2-year-old clients are
still working.


-------------------------------------
I think IBANs are not such a good idea. Note that as someone who has spent the last year of my life dealing with hundreds of bank transactions a day and interacting with the banking system (both on a technical, systematic and personnel level), the entire system is a gigantic mess.

The banks are in fact looking to us for answers. That's why we (Bitcoin Consultancy) were invited to the SWIFT conference to join their panel on bank 2.0.

I don't even mind the maxim "take everything the banks have done and do the complete opposite" :)

I invite anyone who is skeptical to read the ECB's specification on SEPA payments. It really is an example of a system made to work alongside legacy systems that rely on inefficient people. The interchange fees are dependent on a totally arbitrary test of merchant indifference and various antitrust regulations.

These systems are usually built not by engineers or hackers, but by finance people. IBAN has no place in bitcoin IMO.

I don't mean to sound too critical, but I'm skeptical of its usefulness. Especially when we already have bitcoin addresses with their own checksums- what value do IBANs add? Nothing except negatives.



________________________________
 From: slush <slush@centrum.cz>
To: Khalahan <khal@dot-bit.org> 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Friday, December 16, 2011 7:54 PM
Subject: Re: [Bitcoin-development] [BIP 15] Aliases
 

Khalahan, honestly, using namecoin for aliases is (for me) clean example of over-engineering. I mean - it will definitely work if implemented properly. I played with a namecoin a bit (as my pool was the first 'big' pool supporting merged mining), but I think there's really long way to provide such alias system in namecoin and *cleanly integrate it with bitcoin*. Don't forget that people who want to do lookup need to maintain also namecoin blockchain with their bitcoin client. It goes against my instinct of keeping stuff easy.

For example, yesterday I implemented HTTPS lookup for addresses into my fork of Electrum client. I did it in 15 minutes, it works as expected, it does the job and the implementation is really transparent, becuase implementation is 20 lines of code. There's no magic transformation, no forced "?handle=" parameters or whatever. And I don't care if somebody provide URL https://some.strange.domain/name-of-my-dog?myhandle=5678iop&anything_else=True

And everybody can do the same in their clients, in their merchant solutions, websites or whatever. Everybody can do HTTPS lookup. But try to explain DNS, Namecoin, IIBAN, email aliases to other programmers...


Those IIBAN - well, why not. At least I see the potential in PR. So far I understand it as some teoretic concept which is not supported by anything else right now. Give it few years until it matures and then add IIBAN alias to Bitcoin client too.

Maybe I'm repeating myself already, but the way to go is to make aliases as easy as possible, so everybody can implement it in their own solution and thus practially remove the need of using standard bitcoin addresses for normal users. Using some superior technology, which is hard to implement or even understand won't solve the situation, because it will ends up with some reference implementation in standard client only and nobody else will use it.

slush


On Fri, Dec 16, 2011 at 6:23 PM, Khalahan <khal@dot-bit.org> wrote:

 
    things to .bit url would not be the optimal way of using namecoin.
------------------------------------------------------------------------------
Learn Windows Azure Live! Tuesday, Dec 13, 2011
Microsoft is holding a special Learn Windows Azure training event for 
developers. It will provide a great way to learn Windows Azure and what it 
provides. You can attend the event by watching it streamed LIVE online. 
Learn more at http://p.sf.net/sfu/ms-windowsazure
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
Please at least get Coinbaser merged for 0.5. It has had a lot of testing on 
Eligius for months, a landslide of support for the new JSON-RPC method (as 
requested), and I have even gone to the effort to document it. As I will no 
longer be using bitcoind for Eligius soon, I have little incentive to 
maintain/rebase coinbaser across a 0.6 development period.


-------------------------------------
On Mon, Oct 3, 2011 at 1:32 AM, Luke-Jr <luke@dashjr.org> wrote:

(4) is a nice idea.

I was hoping to avoid (3) simply because for any one of these upgrades
hopefully 95% of the network is neutral wrt the change because they
won't mine either form of the transactions.

The active statement has the benefit that it constitutes a proof: You
know with specific confidence (based on the window size) how likely a
fork of length X will be if a newly invalid transaction is announced
at the time of the activation.


-------------------------------------
On Mon, Jun 13, 2011 at 7:48 AM, Christian Decker
<decker.christian@gmail.com> wrote:

No advantage over DNS (you're talking about IRC)


No advantage over DNS (you're talking about IRC)


False.  A proper DNS seed actively samples the bitcoin network for live nodes.


Irrelevant -- it's still a bunch of additional code.  We "already use"
DNS lookups as well, so I could apply similar logic to DNS seeding.


This is an invalid assumption, based on an overly simplistic sampling.
 DNS seeds are perfectly capable of returning new and useful peers on
each query.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
BIPs are either "standards track" (affects everyone, represents consensus),
"informational" (ie basically just summarizing the authors viewpoints on
things) or "process".

My point is you can't have a credible standards track BIP until something
has been implemented end to end. I don't think it's a good plan to design
these things in isolation. You'll end up with bizarre user experiences
because of technical decisions taken months earlier that are now hard to
reverse. A working end to end implementation gives you the confidence to
say, yes, this is how it should work, because here's the demo and you can
see it works very well and the code is clean.

If your BIP is informational then no problems, but I don't think there's
much point in informational BIPs to be honest - it's easier to just write
an email or forum post summarizing your views on things. If you find it a
useful framework to write your thoughts in that's OK, but don't expect
implementors to follow what's written there just because it's a BIP. It
carries no more weight than any other document would.
-------------------------------------
If you wonder where the bitcoin-0.5.0rc2-linux.tar.gz went...

I removed it because it is not sane (we need to teach the Qt build to
statically link dependencies).

Once the Mac and Linux deployment issues are fixed, expect a release
candidate 3...

-- 
--
Gavin Andresen


-------------------------------------
Hi folks,

I've been working on a new private key export format that includes
simple password-protection.  Details of the scheme are posted at:

https://bitcointalk.org/index.php?topic=36195.0

It is intended as an interchange format, not specifically integrated
with wallet encryption, and simple enough to be produced by the
vanitygen program.  Importing to the official bitcoin client using a
method like the import/export patch would require the user to provide
the password of the private key, in addition to the wallet password if
the wallet is encrypted.

Comments on the format are welcomed!

As the proposed format is base-58, I would like to make a request to use
one of the data classes as proposed by Pieter Wuille about a month ago:

http://sourceforge.net/mailarchive/forum.php?thread_name=20110708092506.GA6641%40ulyssis.org&forum_name=bitcoin-development

If this doesn't fit with the general bitcoin development agenda, that's
OK too, but I would like to explore some possibility for a protected
export format for private keys.

Thanks,
-Sam Revitch


-------------------------------------
Hello Pieter,

Other opinions? Someone actually interested in writing a cmake configuration

I'm willing to do it, but the priority is not that high.

I'm currently sticking with qmake, as apart from boost library name
auto-detection, I had no problems with it and it works well enough for a
relatively small project such as bitcoin.

JS
-------------------------------------
I think what Jeff has said is ideal for a stable 1.0 or 1.1 release of
a kernal. I also think it's absolutely the direction we should be
heading in, but not this afternoon. The desire to keep a 0.4.x stable
branch is a symptom of a bigger QA problem, one that I am attempting
to address in general.

Gavin has reminded me to test, test, test. I implore anyone who clicks
the pull button to not only test their code, but write down how they
tested it. The issue tracker is somewhat out of control, and my
opinion is that a stable branch is not going to fix it.

This stage of development can be agitating, as you implement code in
the wild - it is outpaced or broken easily. The sooner we can get a
robust QA process to hammer out bugs, and process pulls - the closer
we are to a stable 1.0 release.

Please contact me if you would like to help contribute to the bug
hammering - I promise that we can find ways to make it
interesting/challenging. (working on a zapper too!)


-------------------------------------
On Fri, 2011-08-05 at 14:03 +0100, Andy Parkins wrote:
Mike and me were talking about outgoing connection count, not incoming,
which is another thing entirely.
However, to your point: having 1000 Bitcoin connection is still almost
no traffic, the only timt you really hit much traffic is when you get a
peer with a client who doesn't have the full chain as they will start
downloading the chain maxing your bandwidth.  My bandwidth of Bitcoin is
something like avg 3GB/month for 125 connections which is nothing.
However it has very brief spikes of my entire outgoing bandwidth.
Thus, neither bandwidth nor connection count are really good metrics for
choosing your number of incoming slots.

Matt
-------------------------------------
Block sizes have started to get quite large once again. Whilst testing
chain download today I was disconnected due to going over the 10mb
flood control limit. Infuriatingly, I can't reproduce this reliably.
But at 500 blocks an average of 20kb per block will cause this. As we
can see from the block explorer, the average is probably quite close
to that.

The flood control seems like a pretty serious scalability limitation.
I can see a few solutions. One is to raise the limit again. Another is
to raise the limit and simultaneously lower the batch size. 500 blocks
in one message means very large messages no matter how big the flood
control limit is. Going down to 100 or even 50 would hurt chain
download speed quite a bit in high latency environments, but chain
download is already a serious bottleneck.

Thoughts?


-------------------------------------
While using DHT for storage of the block chain is an intriguing concept, 
I do not see how it is feasible. As Gavin noted, DHT is a system that is 
difficult to impossible to guarantee against data loss or manipulation.

Even if we found a way to store the block chain in DHT, how would 
transactions be verified? As Gavin noted, you could ask the network, but 
cannot necessarily trust the peers you are connected to. Verification of 
the full block chain allows the client to trust no one.

I also do not see how DHT would solve the problem of scalability in 
regards to broadcast messages, although I am definitely interested in 
the concept.


-------------------------------------
On 7/17/11, Jeff Garzik <jgarzik@exmulti.com> wrote:

At the risk of making myself very unpopular, perhaps it's the
development project that should move to a new URL?

Rob


-------------------------------------
I believe I'm missing something here. I was under the interpretation 
that alias resolution was going the KISS route, of basically a single 
HTTP request and response. How do you see binary data fitting into this?

I'm not going to pretend that I know all the details of the difficulties 
that were encountered with JSON-RPC. But in the argument of developer 
accessibility, it still serves a purpose. If JSON-RPC support is 
removed, you will immediately lose a large pool of high level language 
developers. I would hope that support would not be dropped, even if it 
only remains as a secondary protocol with limited capability. Most high 
level developers are only going to use it for basic functions anyhow.



On 12/19/2011 10:15 AM, Luke-Jr wrote:



-------------------------------------
Ah, right, I think stackexchange is pretty good for that. I committed.

JS

On Mon, Jul 18, 2011 at 8:08 PM, Chris Acheson <chris_acheson@lavabit.com>wrote:

-------------------------------------
On Wednesday, July 13, 2011 9:04:09 AM Andy Parkins wrote:

This isn't an arbitrary constant, it's the result of a calculation...


-------------------------------------
sipa made a nice specification for version numbers a while back, that seemed 
great at the time. However, there are concerns that it has overlooked a very 
important factor: usability in base58 encoding. The version currently chosen 
for script-based addresses (2) makes this excessively complicated for end 
users-- these addresses, once encoded, may begin with ANY of the following 
characters: 2opqrstuvwxyz

Taking this into account, as well as sipa's original goals, I have come up 
with the following proposal:
* Bits 128/64 define network class
** 0 = main network
** 64,128 = reserved
** 192 = test network
* Bits 32/16 define network
** 0 = Bitcoin
** 16,32 = reserved
** 48 = OTHER (next octet)
* Bits 8/4/2 define data class
** 0 = Public key hash
** 2 = Public key (raw)
** 4 = Script hash
** 6 = reserved
** 8 = Private key (raw)
** 10 = Signature
** 12 = reserved
** 14 = OTHER (next octet)
* Bit 1 is freely chosen (for aesthetic assignment)

Unlike sipa's proposal, however, I have (intentionally) neglected to consider 
the versions currently in use other than the widespread Bitcoin addresses. 
That means this reassigns the versions used by Namecoin and testnets, and 
probably messes with the (unmerged) key export format and signature formats.

It "wastes" 2 bits (64 and 1) to accomplish aesthetic norms. Bit 64 *could* be 
assigned in the future if we ever have a "crunch". By using the high bit (128) 
to designate test networks, all testnet addresses will now begin with '2'. 
Bitcoin script-hash (aka OP_EVAL) addresses are assigned version 5 (using the 
aesthetic +1), which means they always begin with '3'. Signatures are on 
version 10 and/or 11, beginning with '5'.

We get two first-class "networks" besides Bitcoin, addresses starting with '7' 
and 'E' (pubkey), and '9' and 'F' (script). I propose these should be assigned 
sparingly, only when a network has significant adoption-- the only one I would 
even *consider* might fit the requirement today is Namecoin. I would also 
suggest making merged mining support a requirement except for networks that 
have a proven-better proof-of-work (ie, NOT scrypt). Other networks can use 
the "other" value (thus beginning with 'L' and 'N') and a second octet (which 
can be divided up later).

Thoughts?

Luke


-------------------------------------
On Fri, Dec 16, 2011 at 1:52 PM, Khalahan <khal@dot-bit.org> wrote:

The same goes for http(s) one would not be able to use
http://google.com/user unless google offers the services.

ALSO look at DANE for getting around the certificate requirement for https


DNS TXT are not the only way forward, also registry/registrars can facilitate.


This most likely relies on a paid, valid certificate (that expires),
no self signed certs. I admit that running a secured https server with
a valid CA signed  cet is as simple/hard as running a DNSSEC authority
zone.

using a x.509 certificate to secure a bitcoin transaction removes some
of the anonymity of the transaction by allowing the lookup to identify
the certification, ca, crl etc thus connecting a transaction/bitcoin
address to the cert and to its issuing authority. No matter the
frequency of the destination bitcoin address changing.

IMNSHO, leveraging CAs to secure http to provide a lookup translation
to a bitcoin address will only erode anonymity. While DNS is connected
to whois there are provision for hiding behind a proxy where to the
best of my knowledge there are no such provisions offered by CA's
issuing x.509 certificates.

Should self signed cers be "allowed" or encouraged only decreases
security. Clearly DANE would be the only way to mitigate this
situation but then you are back to relying on DNSSEC to bind the x.509
cert.

wash, rinse,  ...

-rick



-------------------------------------
I've worked on open source projects for over 10 years now. This
dynamic always exists but I've never seen it seriously kill a project.

Thoughts:

 - People who start out with features often stick around and become
core contributors.
 - Unit tests are critical.

Now there's a basic skeleton for unit tests, the bug debt can start to
be paid down by insisting that anyone who touches a piece of code
introduces tests, whether it be for new features or refactorings.
Insist patches won't be accepted without some new tests. In an
untested codebase, adding or improving tests often reveals other bugs
that then get fixed at the same time.

People usually don't want to write tests if there's nothing there
already. So I'd suggest seeding the test suite with a small number of
simple tests for each part (wallet, net, db, etc). Once there are a
few tests already it's easier to get people to add more. It's tempting
to say, well, the wallet or re-org handling or whatever is the most
critical so we'll write lots of tests for that first and do the rest
later, but that's not as conducive to getting people to help.

Most complex projects need some unit testing infrastructure to assist.
For instance, the ability to use mock network connections or minimal
difficulty chains. So if you build up that infrastructure and plant
those seeds, it'll be easier for other people to flesh it out.

Final thought - big test suites take a long time to grow, especially
in codebases developed without them. A good start is a manually
written test plan, that just walks you through the apps features.
Insisting that a patch be signed off as passing the test plan is a
good way to avoid gigantic breakages like the wallet encryption bug
from cold start, at the cost of slowing down development (nobody likes
doing manual test work over and over).

I don't always follow my own advice on this and usually end up
regretting it ....


-------------------------------------
Hey Eric,

Two comments.

1.
The ability to query for transactions belonging to pubkeys or bitcoin addresses is supported today by several implementations:
* blockexplorer.com
* bitcoin-js
* my own libBTC (will more on this soon)

To query for transactions you need to use json-rpc and not the bitcoin protocol, however. But still the purpose is the same: to be able to build thin clients that can rely on a server for storing the blockchain and keeping connected on the p2p network.

The reason for not having these queries part of the standard protocol (I think) are as they breaks anonymity, and that you would actually encourage people to participate in the p2p.

2. The second part you mention, to some how move the storage of the blockchain into a DHT based storage would be quite nice. The benefit of this is that it could be a way to integrate the smaller clients into the network without breaking the anonymity. But it should be thought out quite carefully. Further, if each client only store a fraction of the blockchain we should work out what fraction that need to be in order to ensure a similar service level. I would be happy to work with you on this.

Cheers,

Michael

On 17/12/2011, at 08:41, Eric Lombrozo wrote:





-------------------------------------
Hey,

Names aren't too important and people were in favour of BIPs. I've moved them from BEPs to BIPs (Bitcoin Improvement Proposals).



----- Original Message -----
From: Daniel F <nanotube@gmail.com>
To: Gavin Andresen <gavinandresen@gmail.com>
Cc: bitcoin-development@lists.sourceforge.net
Sent: Friday, September 23, 2011 9:45 PM
Subject: Re: [Bitcoin-development] Bitcoin Enhancement Proposals (BEPS)


this is an excellent "painting the bikeshed" question, so i cannot
resist participation :)

imo, anyone who has any business looking at the beps (which would
generally be technically-minded people), will be smart enough to
google for "bitcoin bep003" to find what he's looking for. so i don't
see an issue, whatever acronym we end up using.

------------------------------------------------------------------------------
All of the data generated in your IT infrastructure is seriously valuable.
Why? It contains a definitive record of application performance, security
threats, fraudulent activity, and more. Splunk takes this data and makes
sense of it. IT sense. And common sense.
http://p.sf.net/sfu/splunk-d2dcopy2
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
I think it would be a lot more than that. According to the Scalability 
page (https://en.bitcoin.it/wiki/Scalability) if Bitcoin took over all 
credit card transactions, that would be about 1.14GB per block. I 
believe that is 58.5PB per year. (6*24*365*1.14/1024) This would also 
mean the distribution of 2MB of block data per second, which doesn't 
include broadcast overhead.

On 12/21/2011 12:50 AM, Michael Grnager wrote:


-------------------------------------
Hi John!

 Thank you for your answer...

 I have "two kinds" of address, the "static address", which I created myself
for any personal reason, and the "dinamic address", which is the automatic
generated address when I receive some Bitcoin amount, I label each one (the
automatic created by the software) with something like "DINAMIC-1",
"DINAMIC-2" and so on...

 I use my "dinamic address" in a "random" way, following the moon phase...
lol

 My point is: I like to keep track of all my Bitcoin Address, they are all
my...

 Please, leave this feature alive, as a option, disabled by default.

 I don't know why people fear about their own address... It is all under
"Receiving" tab! There is nothing to fear about it.

 ---

 BTW, I think this option should have some explanations at the "Options
screen", for example:

 For increasing your anonymity, enable the "Dinamic Bitcoin Address" option
and make sure to always use one new and different address for each
transaction. And do not link each address with your person!

 (X) Dynamic Bitcoin Address (a new Bitcoin Address will be created
automatically for you, after each new received Bitcoin amount)

 ---

 Thank you so much!

Best,
Thiago

2011/9/22 John Smith <witchspace81@gmail.com>

-------------------------------------
On Saturday, October 08, 2011 7:12:31 PM Luke-Jr wrote:

FWIW, Gavin's IRC response more or less amounts to being unwilling to merge 
this even though it was ready, tested, and even fulfilled his original request 
for community support for the new JSON-RPC call, all long before he announced 
the feature freeze on 0.5... hopefully it'll get merged to 0.6 git before it 
needs a rebase. :/


-------------------------------------
I hate to get specific about potential attacks on a public mailing
list, but I think the debate over what to do with non-standard
transactions means we need to.

I agree with Gregory; if there are NO rules about what transactions
peers can send at you, then an attacker can trivially get around other
the DoS rules.

I also agree we need to think hard about what will happen when new
'standard' transaction types are deployed.

There are two significant DoS attacks I can imagine using transactions
that will never be included in blocks.  The "will never be included in
blocks" bit is important, because if an attacker can make you do
significant work at no cost to themselves then they win. And if the
transactions will never be included in blocks the attacker can include
lots of transaction fees that will never be spent.

1) Exhaust memory by filling up the transaction memory pool. I think
another patch needs to be written to deal with that (keep the size of
the transaction pool reasonable by evicting low-priority
transactions).

2) Waste CPU time validating transactions   They can make you use an
arbitrary amount of CPU time just by flooding you with a stream of
valid-but-won't-ever-get-into-a-block transactions.

The code already refuses to relay non-standard transactions, and
doesn't check their signatures or add them to the memory pool, so I
think no DoS check is needed for them (and would be harmful when we do
start supporting new standard transactions).

It also drops transactions with "too few fees" before checking
signatures or doing other CPU-intensive work, so no I think no DoS
check is needed there, either (and again, would be harmful when
transaction fee rules change).

I'm ignoring bandwidth DoS attacks-- we already have the
-maxreceivebuffer option to deal with those.


PS: I'll add Gregory's comment:

"There should be nothing I can give a node that it will
forward on that will make that node's peers drop it. (and this needs
to remain true while forwarding rules evolve)"

... as a comment in the code so hopefully we don't forget it.

-- 
--
Gavin Andresen


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

My only concern is: How well have the fixes in pull 358 been tested? Wasn't there an issue with the "" account found just last night?

Matt Corallo <bitcoin-list@bluematt.me> wrote:


- --
Douglas Huff
-----BEGIN PGP SIGNATURE-----
Version: APG v1.0.8

iQIVAwUBTg5uzkPHkQabDWHPAQhEDRAAikf9NX06CSjHOKRdErIEgixHgrcUJk85
GuUxmTIm305WNdxswVDwXhPAqi9PBr5jPYgowp4/UoiYprNHN/s9pPwqNyMI3Urn
SH7rXEA0yYuUU2b2VINY3cxHropu0cGH/EjXOXd+hDf6Dlf/lCsohz3BTcjUho4B
1esBTvhZngmEXaYSs5Hxd7CdbsJ8TVeib8aVGQN3GYc1H4I/MDFNpIsCVB0lAay2
93nczwFvkB/0KyU8vzua8atygdyGNTPWr0BOKvuJO39audokbZmpEREjLiqlIfxj
3MfcUZcOZ9or4Mq8Gq0ZLydpktKSKeZWpbpdzVEk/KQjz+zZhVZ+0jDj4FWIumcS
sd7AdPpQAVVb5uG4ZnALI9V1gmfdXB+yxo7nKdHPCSOTaYwcbHu2+FI7PVlVlh/4
IgcRtZT2p4xoNeuDU+QBinuCDsCPq14f0zPhIo7ZCzs/ruV3Y9BtBS7Ez8FnXIRp
yI06/AX9Bmw2DWBS5Jbu3u32osK1JWBdO9Hh1yVb+O1f9pqDPn7KYroqs4yAPZfx
iz6OaQWtG5Zm+UjoLQiVhPA2cU2Zm42LywtbW3sxm+pmwEx91MeTFCioqOdkz9RI
4NxkaWOlAcXlpr/WX5QoYVcio9GR9AnIeO6h6p4ov0PPI2WqgobrYQbtjdnqxZXi
Q12+wZuYiDo=
=STlK
-----END PGP SIGNATURE-----



-------------------------------------
On Fri, Sep 23, 2011 at 07:21:58PM -0400, Luke-Jr wrote:

I don't want to send a mail to you or chat with you when I'm buying something
in your webshop. Or do you mean my client does that automatically? Why not
through an HTTP connection like the one I'm already using anyway to view
the static address on your website?


They still require you to give me your public key root, and me to give
you the ephemeral private key I generated, optionally together with what
I'm paying you for. That's bidirectional communication to me. Agreed, your
scheme requires a few steps less, but I believe mine is far more flexible
and user-friendly.

-- 
Pieter



-------------------------------------
hey,

so sipa/gmaxwell proposed on irc that maybe upnp is not working anymore but there isnt any way to test.

well i made an alternate chain, and ran the daemon on my vps.

sometimes it accepts connections, sometimes not. It's all very patchy.

anyway just putting this out there



-------------------------------------
I've been arguing with Luke-JR on IRC about the interpenetration of
BIP_0014—  Gavin's recent commit uses the same version string for the
GUI interface and the daemon mode.

Luke believes this is a _violation_ of BIP_0014 and an error in
judgement on Gavin's part, and a failure to conform to the community
adopted standard. I believe Luke is mistaken: that BIP_0014 actually
don't have mandatory requirements for what you put in the version
field and even if it did, that they are in fact the same software and
should have the same name.

I don't think an agreement is likely on the second point, but the
first point highlights some ambiguity in the interpretation of BIP
language. E.g. What is permitted vs encouraged vs required.

There is well established standard language for this purpose:

https://www.ietf.org/rfc/rfc2119.txt

I strongly recommend that all BIPs be written using the RFC2119
keywords where appropriate.


-------------------------------------
These branches are NOT ready for merging to mainline, but need peer review.

Branches can be viewed at:
    http://luke.dashjr.org/programs/bitcoin/w/bitcoind/luke-jr.git/heads

git pull git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git <branchname>

=

my_free_txn: accept the user's own transactions regardless of fees or
             standardness; put credits-to-user toward covering fees required

    Common-sense, really.

=

accept_nonstdtxn: adds a -acceptnonstdtxn option to allow miners to easily
                  accept "non-standard" transactions

    We probably want to amend this with a block for OP_NOP*?

=

free_relay: relay transactions regardless of fees

=

optimize_cache_rpcauth: cache RPC username and password

    Part of JoelKatz's diffN patches for a while, seems fairly well-tested on
    (other) pools

=

optimize_conn_adjtime: cache AdjustedTime around a for loop

    Another part of JoelKatz's diff4 patch.

=

optimize_ToHex: faster binary-to-hexadecimal-string function

=

optimize_DecodeBase64: faster base64 decoding

=

optimize_remove_CheckWork_delay: remove 2 second delay from CheckWork

    I don't know why this is here, but apparently most pools work fine without
    it? (from JoelKatz)

=

optimize_FastGetWork: optimizations for the common case of getwork

    Yet another JoelKatz patch. His patch has it bundled tightly with the
    ToHex branch, so once one is merged, the other will need rebasing.

=

optimize_http_status: use C instead of C++ for HTTP status reply strings

=

rpcclient_conn_close: "Connection: close" header in client mode

=

threaded_rpc: use a new thread for each JSON-RPC connection, with mutexes
              preventing actual methods from being executed concurrently
              (except for parts of getwork)

    Tested on Eligius from day 1, under older versions. A few months ago, the
    code was merged with some of JoelKatz's patch, making it stable with SSL
    support.

=

rpc_keepalive: support for HTTP 1.1 keep-alive

    Depends on threaded_rpc.


-------------------------------------
On Mon, Jul 4, 2011 at 2:23 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:
[snip]

Rewriting the old one before erasing it and replacing it with a
placeholder might increase the chances that the old unencrypted keying
material was not left on disk.


-------------------------------------

That seems like the right way forward.

I just wrote a unit test and stepped through the CHECKMULTISIG code to
see exactly what the bug is, and the offending line is:
   797	                    int isig = ++i;
   798	                    i += nSigsCount;

It should be just   int isig = i;

The result is CHECKMULTISIG expects one extra item on the stack, so
the workaround would be a standard transaction type of the form:

scriptSig: OP_0 sig1...m
scriptPubKey: m pubkey1...n  n OP_CHECKMULTISIG


-- 
--
Gavin Andresen


-------------------------------------
On Sep 15, 2011 11:20 AM, "Gavin Andresen" <gavinandresen@gmail.com> wrote:

I disagree with this comment. The way this is currently implemented is a mem
exhaustion dos in itself waiting to happen and does nothing to prevent
network flooding.
-------------------------------------
Sounds like Dan wrote a tool which attempts to connect inputs/outputs
and make a map of a person on the network, or at least thats my blind
guess.  Something people have been saying was easily possible for some
time, but for some reason people insist on refusing their precious
Bitcoin isnt anonymous.

Matt

On Thu, 2011-08-04 at 10:56 +0000, John Smith wrote:
-------------------------------------
On Wed, Aug 10, 2011 at 4:49 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:


As the project is still in "experimental" phase I suppose people can expect
changes like this? And the change is pretty much trivial, and it makes sense
for a future direction (UI<->Wallet in separate processes for security
concerns).

To be honest I feel a bit like every change that I (and I've also heard this
from others) propose is shot down, no matter how well formulated.  This is
actively discouraging developers from joining this project.

Of course it makes sense to be a careful, but the project is not on life
support is it? Satoshi did a great job making the program, but his work was
not perfect, and it makes sense to look ahead a bit.

I think it would be better to switch to two branches, like most other open
source projects I've worked with:

0.3.x -> small, compatible changes, bugfixes, like now
0.4.x -> trunk, more impactful changes, refactorings, eventual major release

Both will obviously be fully compatible on the P2P-level.



I could do the Gitian stuff but not the Mac instructions, as I don't have a
Mac...

JS
-------------------------------------
I'm sorry that I misunderstood the protocol being separate from the
client in regard to 'BEPS'. It definitely makes more sense that way.

As far as naming; I vote BER pronounced Beer.


On Mon, Sep 19, 2011 at 12:57 PM, Gavin Andresen
<gavinandresen@gmail.com> wrote:


-------------------------------------
Perhaps even add a way for anyone add to the bounty attached to a bug on
the bug tracker? Also, a listing page for bugs with their bounties might
be nice too.

- Joel

On Wed, 2011-07-27 at 06:40 +0000, John Smith wrote:





-------------------------------------
Some bugs I found in my spec so far:
- Bitcoin public keys begin with '2' (same as testnet data)
- For the first first-class "aux" network, signatures and private keys will
  start with the same character.
- More "collisions" are possible if the "reserved" values were ever assigned.

To address these slightly better, here's a revised proposal:
* Bits 128/64 define network class
** 0 = main network
** 64,128 = reserved
** 192 = test network
* Bits 32/16 define network
** 0 = Bitcoin
** 16,32 = reserved
** 48 = OTHER (next octet)
* Bits 8/4/2 define data class
** 0 = Public key hash
** 2 = reserved
** 4 = Script hash
** 6 = Public key (raw)
** 8 = Signature
** 10 = reserved
** 12 = Private key (raw)
** 14 = OTHER (next octet)
* Bit 1 is freely chosen (for aesthetic assignment)

Note that under this scheme, both script hashes and raw public keys begin with 
'3'; I consider this a non-issue since neither are supported by current-
generation clients, and both pubkey-hash and script-hash are quite capable of 
the same functionality as a raw public key. Also, the raw public key will 
presumably be noticably longer.

For reference, a table of version number to first-base58-char mappings:
+........   0 => 1
-.......1   1 => QRSTUVWXYZabcdefghijkmno
-......1.   2 => 2opqrstuvwxyz
+......11   3 => 2
-.....1..   4 => 23
+.....1.1   5 => 3
+.....11.   6 => 3
-.....111   7 => 34
+....1...   8 => 4
-....1..1   9 => 45
+....1.1.  10 => 5
+....1.11  11 => 5
-....11..  12 => 56
+....11.1  13 => 6
-....111.  14 => 67
+....1111  15 => 7
+...1....  16 => 7
-...1...1  17 => 78
+...1..1.  18 => 8
-...1..11  19 => 89
+...1.1..  20 => 9
+...1.1.1  21 => 9
-...1.11.  22 => 9A
+...1.111  23 => A
-...11...  24 => AB
+...11..1  25 => B
+...11.1.  26 => B
-...11.11  27 => BC
+...111..  28 => C
-...111.1  29 => CD
+...1111.  30 => D
+...11111  31 => D
-..1.....  32 => DE
+..1....1  33 => E
-..1...1.  34 => EF
+..1...11  35 => F
+..1..1..  36 => F
-..1..1.1  37 => FG
+..1..11.  38 => G
-..1..111  39 => GH
+..1.1...  40 => H
+..1.1..1  41 => H
-..1.1.1.  42 => HJ
+..1.1.11  43 => J
-..1.11..  44 => JK
+..1.11.1  45 => K
+..1.111.  46 => K
-..1.1111  47 => KL
+..11....  48 => L
-..11...1  49 => LM
+..11..1.  50 => M
+..11..11  51 => M
-..11.1..  52 => MN
+..11.1.1  53 => N
-..11.11.  54 => NP
+..11.111  55 => P
+..111...  56 => P
-..111..1  57 => PQ
+..111.1.  58 => Q
-..111.11  59 => QR
+..1111..  60 => R
+..1111.1  61 => R
-..11111.  62 => RS
+..111111  63 => S
-.1......  64 => ST
+.1.....1  65 => T
+.1....1.  66 => T
-.1....11  67 => TU
+.1...1..  68 => U
-.1...1.1  69 => UV
+.1...11.  70 => V
+.1...111  71 => V
-.1..1...  72 => VW
+.1..1..1  73 => W
-.1..1.1.  74 => WX
+.1..1.11  75 => X
+.1..11..  76 => X
-.1..11.1  77 => XY
+.1..111.  78 => Y
-.1..1111  79 => YZ
+.1.1....  80 => Z
+.1.1...1  81 => Z
-.1.1..1.  82 => Za
+.1.1..11  83 => a
-.1.1.1..  84 => ab
+.1.1.1.1  85 => b
-.1.1.11.  86 => bc
+.1.1.111  87 => c
+.1.11...  88 => c
-.1.11..1  89 => cd
+.1.11.1.  90 => d
-.1.11.11  91 => de
+.1.111..  92 => e
+.1.111.1  93 => e
-.1.1111.  94 => ef
+.1.11111  95 => f
-.11.....  96 => fg
+.11....1  97 => g
+.11...1.  98 => g
-.11...11  99 => gh
+.11..1.. 100 => h
-.11..1.1 101 => hi
+.11..11. 102 => i
+.11..111 103 => i
-.11.1... 104 => ij
+.11.1..1 105 => j
-.11.1.1. 106 => jk
+.11.1.11 107 => k
+.11.11.. 108 => k
-.11.11.1 109 => km
+.11.111. 110 => m
-.11.1111 111 => mn
+.111.... 112 => n
+.111...1 113 => n
-.111..1. 114 => no
+.111..11 115 => o
-.111.1.. 116 => op
+.111.1.1 117 => p
+.111.11. 118 => p
-.111.111 119 => pq
+.1111... 120 => q
-.1111..1 121 => qr
+.1111.1. 122 => r
+.1111.11 123 => r
-.11111.. 124 => rs
+.11111.1 125 => s
-.111111. 126 => st
+.1111111 127 => t
+1....... 128 => t
-1......1 129 => tu
+1.....1. 130 => u
-1.....11 131 => uv
+1....1.. 132 => v
+1....1.1 133 => v
-1....11. 134 => vw
+1....111 135 => w
-1...1... 136 => wx
+1...1..1 137 => x
+1...1.1. 138 => x
-1...1.11 139 => xy
+1...11.. 140 => y
-1...11.1 141 => yz
+1...111. 142 => z
+1...1111 143 => z
-1..1.... 144 => 2z
+1..1...1 145 => 2
+1..1..1. 146 => 2
+1..1..11 147 => 2
+1..1.1.. 148 => 2
+1..1.1.1 149 => 2
+1..1.11. 150 => 2
+1..1.111 151 => 2
+1..11... 152 => 2
+1..11..1 153 => 2
+1..11.1. 154 => 2
+1..11.11 155 => 2
+1..111.. 156 => 2
+1..111.1 157 => 2
+1..1111. 158 => 2
+1..11111 159 => 2
+1.1..... 160 => 2
+1.1....1 161 => 2
+1.1...1. 162 => 2
+1.1...11 163 => 2
+1.1..1.. 164 => 2
+1.1..1.1 165 => 2
+1.1..11. 166 => 2
+1.1..111 167 => 2
+1.1.1... 168 => 2
+1.1.1..1 169 => 2
+1.1.1.1. 170 => 2
+1.1.1.11 171 => 2
+1.1.11.. 172 => 2
+1.1.11.1 173 => 2
+1.1.111. 174 => 2
+1.1.1111 175 => 2
+1.11.... 176 => 2
+1.11...1 177 => 2
+1.11..1. 178 => 2
+1.11..11 179 => 2
+1.11.1.. 180 => 2
+1.11.1.1 181 => 2
+1.11.11. 182 => 2
+1.11.111 183 => 2
+1.111... 184 => 2
+1.111..1 185 => 2
+1.111.1. 186 => 2
+1.111.11 187 => 2
+1.1111.. 188 => 2
+1.1111.1 189 => 2
+1.11111. 190 => 2
+1.111111 191 => 2
+11...... 192 => 2
+11.....1 193 => 2
+11....1. 194 => 2
+11....11 195 => 2
+11...1.. 196 => 2
+11...1.1 197 => 2
+11...11. 198 => 2
+11...111 199 => 2
+11..1... 200 => 2
+11..1..1 201 => 2
+11..1.1. 202 => 2
+11..1.11 203 => 2
+11..11.. 204 => 2
+11..11.1 205 => 2
+11..111. 206 => 2
+11..1111 207 => 2
+11.1.... 208 => 2
+11.1...1 209 => 2
+11.1..1. 210 => 2
+11.1..11 211 => 2
+11.1.1.. 212 => 2
+11.1.1.1 213 => 2
+11.1.11. 214 => 2
+11.1.111 215 => 2
+11.11... 216 => 2
+11.11..1 217 => 2
+11.11.1. 218 => 2
+11.11.11 219 => 2
+11.111.. 220 => 2
+11.111.1 221 => 2
+11.1111. 222 => 2
+11.11111 223 => 2
+111..... 224 => 2
+111....1 225 => 2
+111...1. 226 => 2
+111...11 227 => 2
+111..1.. 228 => 2
+111..1.1 229 => 2
+111..11. 230 => 2
+111..111 231 => 2
+111.1... 232 => 2
+111.1..1 233 => 2
+111.1.1. 234 => 2
+111.1.11 235 => 2
+111.11.. 236 => 2
+111.11.1 237 => 2
+111.111. 238 => 2
+111.1111 239 => 2
+1111.... 240 => 2
+1111...1 241 => 2
+1111..1. 242 => 2
+1111..11 243 => 2
+1111.1.. 244 => 2
+1111.1.1 245 => 2
+1111.11. 246 => 2
+1111.111 247 => 2
+11111... 248 => 2
+11111..1 249 => 2
+11111.1. 250 => 2
+11111.11 251 => 2
+111111.. 252 => 2
+111111.1 253 => 2
+1111111. 254 => 2
+11111111 255 => 2



-------------------------------------
Hey Pieter,


We could use the XOR hack for now and remove it the next time we reset 
testnet. But I do think the 111 is baggage we want to get rid of. Using 
the lsb as a simple flag is much cleaner.

Cheers,

Stefan


On 7/7/2011 1:15 PM, Pieter Wuille wrote:



-------------------------------------
On Thu, Jul 7, 2011 at 11:42 AM, Mike Hearn <mike@plan99.net> wrote:
[snip]


It _could_ be done another way, with a protocol change:
http://forum.bitcoin.org/index.php?topic=21995.0


-------------------------------------
It is SO tempting to start over from scratch, isn't it?

We'll just tell everybody to stop using bitcoin so much for six months
or so while we implement a much better client.  It will be exactly
like the bitcoin we have now, except with a much nicer internal
architecture and much cleaner code-base, and we're pretty sure we can
get it done in six months if everything goes exactly as planned.

I think incremental improvement of the "devil we know" is the right
thing to do right now, although I'm going to spend more time thinking
about how to make sure different bitcoin implementations work well
together (I've started working on network-protocol-level testing).

Regarding Michael's specific suggestions:  the
lots-of-threads-and-mutexes architecture of the client bothers me
because it is too easy to change code and create a deadlock that is
very hard to debug and fix. Switching to asynchronous IO might be the
right thing to do.  Then again, it might be easier to modify the
CRITICAL_SECTION code to detect and report deadlocks (anybody have
experience doing that?).

-- 
--
Gavin Andresen


-------------------------------------
On Sat, Dec 17, 2011, at 05:27 PM, Jordan Mack wrote:

A headers-only client is much better than trusting anyone, since an
attacker needs >50% of the network's computational power to trick
such clients.

For everyone to keep being a full node, hardware costs would need to
constantly go down enough for all nodes to be able to handle enough
transactions to meet demand. If hardware doesn't become cheap enough
quickly enough, either some people would be unable to handle being full
nodes, or the max block size wouldn't rise enough to meet demand and
transaction fees would become noncompetitive.


-------------------------------------
If you are going to support this use case, you should also notify the user
on wallet changes that results in invalidated backup. For example whenever
the key pool gets extended.

-----Original Message-----
From: Gavin Andresen [mailto:gavinandresen@gmail.com] 
Sent: 17 November 2011 14:28
To: Bitcoin Dev
Subject: [Bitcoin-development] There will be a release candidate 6...

I got email from a tester who gave this feedback:


I agree that is likely to happen and, when it does, will be disastrous.
So I'll be reworking the wallet encrypt/rewrite code today and creating a
release candidate 6.

My previous attempt (encrypt, invalidating keypool, then unlock and write a
new keypool) resulted in unencrypted private keys in the new wallet.

I think this will work, I'll implement and test today.

Invalidate all the old keypool keys in the old wallet.Write new keypool keys
to the old wallet.Encrypt all the keys in the old wallet.Rewrite the old
wallet to create a new wallet.Shutdown/restart.
IF ANYBODY IS WILLING TO HELP:

There is still a mysterious problem with bdb throwing an exception when
dbenv.close(0) is called during shutdown. If you can compile a -g version of
bdb and then step through DbEnv::close in a debugger and tell me why it is
throwing an exception that would be extremely helpful.
--
--
Gavin Andresen

----------------------------------------------------------------------------
--
All the data continuously generated in your IT infrastructure contains a
definitive record of customers, application performance, security threats,
fraudulent activity, and more. Splunk takes this data and makes sense of it.
IT sense. And common sense.
http://p.sf.net/sfu/splunk-novd2d
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
-DFOURWAYSSE2 is an obsolete flag; lets remove it.

-- vsFrom 136f8fbd449b7584b61451ac396ca921d5e731c2 Mon Sep 17 00:00:00 2001
From: Venkatesh Srinivas <me@endeavour.zapto.org>
Date: Sun, 14 Aug 2011 15:02:31 -0400
Subject: [PATCH] Remove -DFOURWAYSSE2 flag from UNIX makefile.

---
 src/makefile.unix |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/makefile.unix b/src/makefile.unix
index ba9d0ca..4c92797 100644
--- a/src/makefile.unix
+++ b/src/makefile.unix
@@ -10,7 +10,7 @@ WXLIBS=$(shell wx-config --libs)
 
 USE_UPNP:=0
 
-DEFS=-DNOPCH -DFOURWAYSSE2 -DUSE_SSL
+DEFS=-DNOPCH -DUSE_SSL
 
 # for boost 1.37, add -mt to the boost libraries
 LIBS= \
-- 
1.7.2.3

-------------------------------------
Despite this being quick, I really want to get 0.3.24 out and rolling so
that we have us much lead time on 0.4 as possible so that any solution
to this problem that is better in 0.3.24 can be in as many hands as
possible, and so that the network issues can be resolved.

All that needs to happen for that is to agree on either
https://github.com/bitcoin/bitcoin/pull/378 or
https://github.com/bitcoin/bitcoin/pull/381 thus, I would ask that we
get acks on those and then continue this discussion.  Frankly, I prefer
378 as it is simpler and means that you dont have to keep track of what
features you have or have not used in a wallet, but instead just write
and let the keys take care of themselves.  However, I'm game for either,
I just want to get 0.3.24 out the door ASAP (ie preferably rc2 tomorrow
and release by the end of the week).

Matt

On Mon, 2011-07-04 at 22:39 +0200, Matt Corallo wrote:
-------------------------------------
Am Mo, 24.10.2011, 16:55, schrieb Gavin Andresen:

I now created a patch based on this idea. To avoid slowing down
listtransactions or gettransaction, I put it in a separate RPC
call 'getorigins'. This is the patch:

https://github.com/javgh/bitcoin/compare/bfa4600a93...getorigins

Any obvious mistakes I made there?

Regards!
Jan


-------------------------------------
In light of recent events in the "bitcoin community" I have decided that private disclosure of issues is doing nothing but making them more prevalent.

In light of this decision I would like to report multiple CSRF vulnerabilities in http://clearcoin.appspot.com .

This set of CSRFs are particularly nasty since this is hosted on appspot and uses google account auth. So long as you stay logged into your google account you are vulnerable to this CSRF.

Things tested:
  Changing refund address.
  Releasing funds.

POC code (open this in any browser even from a local file):
==========
<html><head><title>test</title></head>
  <body>
  <form id="refund_address_form" action="https://clearcoin.appspot.com/set_refund_address" method="POST"> 
      <label for="refund_address">Your bitcoin address:</label> 
      <input type="text" name="refund_address" id="refund_address" size="60" value="PUT ANY ADDRESS HERE"
             class="text ui-widget-content ui-corner-all" autofocus required placeholder="refund bitcoin address"/> (required)
  </form> 
  </body>
</html>
==========

Javascript auto submittal, hiding in an iframe, and other obfuscation methods are left as an exercise to the list.

This site is run and maintained by Gavin Anderson, aka, the lead bitcoin maintainer.

You should know better Gavin.

-- 
Douglas Huff


-------------------------------------


Fair enough I'll take it to the bitcoinj list.  I wanted to post here in 
case I got any nibbles from c developers about option 2.  If anyone 
want's the follow this discussion on the other list it's here:
https://groups.google.com/forum/#!topic/bitcoinj/kqiBq9VxL-k




-------------------------------------

I was in brmlab and wanted to pay 1 BTC for a Club Mate. They had on the wall a picture of their QR code and a bitcoin address. I don't own a mobile phone so the QR code is 
useless. Then I remembered FirstBits, went to my terminal and typed 
1brmlab. I got their bitcoin address from the website and copied that, 
then opened my terminal and pasted that in to send 1 BTC.

And 
these proposals for Namecoin, would make bitcoin implementations 
dependent on unproven technology. HTTPS/DNSSEC have been around a long 
time and are responsible for many mission critical systems. There's a 
lot of momentum behind those projects. Namecoin by contrast, could die 
tomorrow. And it isn't a big deal that they're centralised. This is a 
convenience for end users and does not affect the core system much.

tl;dr: usability



-------------------------------------
On Mon, Sep 19, 2011 at 11:00 AM, Luke-Jr <luke@dashjr.org> wrote:

Bug fixes also introduce bugs. Considering the fairly small number of new
features added, I'd take a bet that most of the more recently introduced
bugs were the result of fixes not features.


-------------------------------------
On Wed, Jun 22, 2011 at 9:24 AM, Mike Hearn <mike@plan99.net> wrote:

I think it is time to start experimenting with MULTISIG transactions on testnet.

Mike:  Did Satoshi ever tell you what he was thinking for the best way
to implement MULTISIG transactions?
I'm wondering if hard-coding new standard script templates in
script.cpp Solver():

 vTemplates.push_back(CScript() << OP_1 << OP_PUBKEY << OP_PUBKEY <<
OP_2 << OP_CHECKMULTISIGVERIFY);
 vTemplates.push_back(CScript() << OP_2 << OP_PUBKEY << OP_PUBKEY <<
OP_2 << OP_CHECKMULTISIGVERIFY);
 vTemplates.push_back(CScript() << OP_1 << OP_PUBKEY << OP_PUBKEY <<
OP_PUBKEY << OP_3 << OP_CHECKMULTISIGVERIFY);
 vTemplates.push_back(CScript() << OP_2 << OP_PUBKEY << OP_PUBKEY <<
OP_PUBKEY << OP_3 << OP_CHECKMULTISIGVERIFY);
 vTemplates.push_back(CScript() << OP_3 << OP_PUBKEY << OP_PUBKEY <<
OP_PUBKEY << OP_3 << OP_CHECKMULTISIGVERIFY);

... would be the right approach to support 1/2 of 2 and 1/2/3 of 3
signatures.  It'd be nice if there were generic
OP_N << OP_PUBKEY_N << OP_N  ... template matching opcodes, but there aren't.

I'm also wondering if it makes sense to just support 2-of-2 (for
validate-on-multiple-devices) and 2-of-3 (for escrow) for now.

I think all of these could use a new type of bitcoin payment address;
it might make sense for THAT to be generic, maybe containing:
 version byte
 m
 n
 hash of xor of all n public keys
 checksum

I'm most interested in the 2-of-2 case; I think merchants and
exchanges need bitcoin deposit/payment addresses that they can make
secure by requiring a 2-step signature process for spending those
funds.

-- 
--
Gavin Andresen
http://clearcoin.com/


-------------------------------------
It would appear that we are all explaining why we agree...so, can we get
ACKs on UPnP by default on bitcoin and disabled by default on bitcoind
from everyone (specifically Gavin), as well as ACKs in general on 0.3.24
coming out with the originally listed things?
-------------------------------------

Sure. Or just "a key". It wouldn't have to be an actual key used in
the block chain.


It won't break the IsStandard checks, if that's what you mean. You can
put any data you like into a scriptSig. In practice only data is
useful, there's no purpose in having an actual script there (or at
least, I wasn't able to find one yet).


You could easily change the bitcoin code to detect such transactions -
just look for scriptSigs that have 3 items instead of two, where the
3rd item is the right size to be a signature.


Heh, if that's a reference to my feedback, I definitely wouldn't
describe such a feature as "evil", that's rather strong :-)


-------------------------------------
On Thu, 2011-08-04 at 23:36 +0200, Mike Hearn wrote:
I stand with satoshi here.  No need to add more stuff to the network
protocol, a well-connected node can easily monitor the miners(/network)
for double-spends and alert whoever may need to know that the
transaction should not be accepted.  True, not everyone has the
resources to try to implement this, however the number of people who
have the resources to implement a Bitcoin storefront and not implement
this (vs those who will/do use a payment processor who handles such
things), I would think, are fairly small.
Additionally, keep in mind that many storefronts don't need to care if a
transaction confirms in 10 seconds or 1 hour.  Only digital goods and
physical purchases could benefit from such speed increases.

On Fri, 2011-08-05 at 00:10 +0200, Stefan Thomas wrote:
Since nobody else has mentioned it: There is another (more pragmatic?) 

This is exactly what I've been suggesting this whole time.
-------------------------------------
Hi Gavin,

Did a quick compile and run (bitcoind, Ubuntu 10.04.3 LTS)

Findings - compile (I do not use the UPNP feature):
in the makefile.unix I have to change the:
USE_UPNP:=0
to 
USE_UPNP:=
i.e. it is defined if it is "0" ! 

running: no apparent issues (I have never managed to trigger the deadlocks.?.)

Nice job, but a quick cleanup of interfaces and classes (one file pr class, all interfaces defined in headers) would really be nice... Would be happy to do it myself, as it would greatly enhance the flexibility of the code and be a first step towards a more library/interface like split.

Cheers,

Michael


On 04/09/2011, at 02:13, Gavin Andresen wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------

The "satoshi" bitcoin client already supports use over TOR with the proxy
option - I think this was something Satoshi made regular use of.
-------------------------------------
On 2011 December 22 Thursday, Michael Grnager wrote:


Why should they have to?  Joining the network as a node is very low cost to 
the other nodes.  You can't force any node not to be lazy, since their option 
is to disconnect themselves.  As to maliciousness, that is defended against 
because when a node negative announces a transaction, that transaction is 
going to be checked (note that there is still no implicit trust) -- if a node 
is incorrectly negative-announcing then it can justifiably be kicked.


Me too.  It's important though to distinguish between "you must be verifying" 
and "if you do verify, you must be honest about it".  No node should be forced 
to do any work it doesn't want to; but they should be forced to be truthful 
about the work they choose to do.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Actually,  I'm not sure if your solution works,  because it relies on
broadcasting a tx to the network that isn't valid.   I believe that the
first tx in your proposal will be rejected and thus you'll need to exchange
the tx's offline.

However,  third-parties could pretty easily and conveniently host a service
for this kind of exchange.

--Sent from my overpriced smartphone
On Nov 9, 2011 9:43 AM, "Alan Reiner" <etotheipi@gmail.com> wrote:

-------------------------------------
On Tue, Sep 6, 2011 at 8:32 PM, Alex Waters <ampedal@gmail.com> wrote:

May we assume you're working with / building upon the existing gitian
build stuff?

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I am so sorry about this email, just find it.

2011/11/17 Martinx - $B%8%'!<%`%:(B <thiagocmartinsc@gmail.com>

-------------------------------------
On Monday, October 10, 2011 5:22:28 AM Mike Hearn wrote:

Writing some custom software designed to more efficiently create work.
To clarify, bitcoind will still serve the purpose of peering with external 
nodes and picking out valid transactions to be accepted into blocks; it just 
won't be involved in the primary operations of the pool.


-------------------------------------
On Wednesday, December 21, 2011 5:12:07 AM Mike Hearn wrote:

Not sure what you mean. Maybe `git log --no-merges` ?


-------------------------------------
Thanks for writing this. It's great to see somebody run with the contracts
protocol.

Your proposed protocol is simpler than the one I suggested, so I updated the
Contracts wiki page to use it. However your implementation, as pointed out
by Gavin, is too complicated. See my proposal on the wiki here:

  https://en.bitcoin.it/wiki/Contracts

I think you can just use an output script of

  2 <K1> <K2> <K3> 3 CHECKMULTISIGVERIFY



On Thu, Jun 16, 2011 at 6:53 AM, <bgroff@lavabit.com> wrote:

-------------------------------------
Namecoin is a peer-to-peer generic name/value datastore system.
Don't forget it's not limited to .bit usage ! So, directly mapping
things to .bit url would not be the optimal way of using namecoin.

Namecoin is *specificaly designed to map things to names* in a fully
decentralized way. So, it's the perfect starting point to map names to
other things (a public bitcoin address, an url, etc)
You won't have all the advantages of namecoin when using other systems
like DNS and HTTP(S) as the first entry point.

What is namecoin ?

* proven technology :
- do not mix the namecoin technology and the dot-bit namespace with .bit
domains (dot-bit domains needs dot-bit compatible dns servers or proxies
+ namecoin and have a small visibility due to the nature of
top-to-bottom domain name system controlled by ICANN, namecoin needs
only namecoin to store data !)
- as proven and secure as bitcoin
- merged mining provides a secure network

* decentralized :
- a lot of nodes, and you can have your own node
- everybody can register his own name, by itself with the namecoin
software (bitcoin could even allow registration directly from it,
easily) or by using a name provider
- everybody can become a name provider (register for your friends and
resell names).

* no single point of failure :
- DNS and HTTPS have several limitations (Man in the Middle attacks, no
reliable authority of certifications, domain seizure, ...)

* designed for that :
- namecoin uses a system of namespaces to separate each usages :
http://dot-bit.org/Main_Page#Namespaces.
For example, the "personal namespace" draft
(http://dot-bit.org/Personal_Namespace) could be extended to support
mapping to a bitcoin address, or a dedicated namespace can be used if
prefered (the "bitcoin/" or "alias/" or "map/" prefixes for example).

* easily connectable to bitcoin
- they both use RPC and json to exchange informations, so connecting one
to the other is really easy
- bitcoin could even allow registration of names by sending an RPC
request to namecoin

* extensible and not limited :
- you are not forced to store a bitcoin address directly in namecoin,
you can also store an url or a domain name
- allows additional security : add a certificate fingerprint combined
with an https url (so, using DNS or HTTP(S) is not a major problem
anymore if the first point of entry is really secure and configurable
[and you use and self-signed certificate])
- really easy to update
- simple for simple cases
- possibility to use a nick, an email address or a domain as name
- other methods to get bitcoins addresses can be added later, protocol
is extensible


Examples of possible registered names in namecoin with the "personal
namespace" (with the "p/" prefix) :

* An individual person with well known public addresses :
"p/*khal*":
{
    "email": "khal@dot-bit.org",
    "bitcoin": "1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T",
    "namecoin": "N1KHAL5C1CRzy58NdJwp1tbLze3XrkFxx9"
}

* Another individual person with well known public addresses :
"p/*khal@dot-bit.org*":
{
    "bitcoin": "1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T",
    "namecoin": "N1KHAL5C1CRzy58NdJwp1tbLze3XrkFxx9"
}

* A merchant accepting payments in bitcoin, namecoin, paypal or
othercoin (to show you how the whole namespace could be used) :
"p/*mymerchant.com*":
{
    "bitcoin": {
        "url": "https://payto.mymerchant.com/bitcoin/",
        "fpr": "54FFA829023FC4DEF26B9339E07F7A743DF9F926"
        "cert": "https://payto.mymerchant.com/certificate.pem",
    },
    "namecoin": {
        "url": "https://payto.mymerchant.com/namecoin/",
        "fpr": "54FFA829023FC4DEF26B9339E07F7A743DF9F926"
    },
    "paypal": "xxxxxx@yyyyyyyyy.zzz",
    "othercoin": "oxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
}

* A merchant with a public address, an url to generate custom addresses
and a domain name (not sure if this case is really usefull, maybe as
fallback)
"p/*mymerchant2*":
{
    "bitcoin": {
        "url": "https://payto.mymerchant.com/bitcoin/",
        "fpr": "54FFA829023FC4DEF26B9339E07F7A743DF9F926",
        "dns": "_bitcoin.payto.mymerchant.com",
        "address": "1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T",
    }
}


* How to use it in bitcoin ?

Several possibilities of address syntax :
- khal, khal@dot-bit.org, mymerchant.com, mymerchant2 : no syntax limit
- mymerchant2@bitcoin : will conflict with names already containing a @
- mymerchant2@namecoin : same
- namecoin:mymerchant2 : strange syntax, confusing with the "uri scheme"
- namecoin://mymerchant2 : same
- other ?


Here is how things would be processed when people put an address to pay
to in the bitcoin client :

* address : khal
-> RPC to namecoin for "p/khal"
-> json processing for "p/khal->bitcoin"
-> result : 1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T

* address : khal@dot-bit.org
-> RPC to namecoin for "p/khal@dot-bit.org"
-> json processing for "p/khal@dot-bit.org->bitcoin"
-> result : 1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T

* address : mymerchant.com
-> RPC to namecoin for "p/mymerchant.com"
-> json processing for "p/mymerchant.com->bitcoin"
-> json processing for "p/mymerchant.com->bitcoin->url" and
"p/mymerchant.com->bitcoin->fpr"
-> https request to "https://payto.mymerchant.com/bitcoin/"
-> result : 1xyxyxyxyxyxyxyxyxyxyxyxyxyxy

* address : mymerchant2
-> RPC to namecoin for "p/mymerchant2"
-> json processing for "p/mymerchant2->bitcoin"
-> json processing for "p/mymerchant2->bitcoin->url" and
"p/mymerchant2->bitcoin->fpr"
-> https request to "https://payto.mymerchant.com/bitcoin/"
-> result : error (website unavailable, page not found, timeout, etc)
-> json processing for "p/mymerchant2->bitcoin->dns"
-> dns request for "_bitcoin.payto.mymerchant.com"
-> result : 1xyxyxyxyxyxyxyxyxyxyxyxyxyxy


Le 15/12/2011 20:59, theymos a crit :


-- 
Best Regards,
Khalahan
http://dot-bit.org/

-------------------------------------
Check it out,


http://forum.bitcoin.org/index.php?topic=30646.0

Best to post questions on the forum. I don't often check this email.
-------------------------------------
On Thu, Sep 08, 2011 at 09:09:12AM -0700, David Perry wrote:

Yes, Satoshi transferred the key to Gavin when he "left". I agree we should
keep it, btw. There have been suggestions before on this list to use the
alert system to ask people to upgrade to recent versions of the client (eg.
the disconnect issue 0.3.20-0.3.23 had). I feel there may come a moment when
we really need to use it for that purpose.

-- 
Pieter


-------------------------------------
2011/11/23, Andy Parkins <andyparkins@gmail.com>:

Well, I meant "the probability of  your block being the hardest".
What a miner can do is hash the block (cheating the timestamp) for 2
more minutes than the rest of the people and then send it to the other
nodes. Nodes cannot possibly know when did you hashed the block only
by looking at their clock when they receive it, because there's also
network latency.


1) This is part of the satoshi client but not the protocol. A miner
can rewrite this part of the code and there won't be anything in the
chain that contradicts the protocol.

2) I haven't read the code but I'm pretty sure that's not a perfect
decentralized clock.

I will be more specific. Where's the network clock in the chain (in
the protocol)?

-- 
Jorge Timn


-------------------------------------
What if we specify "bitcoin" to make it easier for software (maybe the
browser, a plugin for the browser, the bitcoin client analyzing the
clipboard...) to easily detect that you expect a bitcoin address when
going to url?
If puted in the bitcoin client, the "bitcoin://" is optional (? and
can also be replaced by http ?) since from the context you already
expect an address or an url that will give you the address.

In the browser:

bitcoin://address
bitcoin://rest_of_url

In the bitcoin client:

address
rest_of_url
bitcoin://address
bitcoin://rest_of_url
http://rest_of_url  ??

Maybe in the bitcoin client you can put any site and the client
downloads the web to look for occurrences of "bitcoin://" (? or just
valid addresses ?) in it. It caches and shows them to you to decide
what to do with each one.
I have used other programs (jdownloader) that read the clipboard
looking for patterns in links and is very convenient.

Maybe then parameters for the client can be added to this.

bitcoin://address?amount=10.53
bitcoin://rest_of_url?amount=10.53&green_address=r
bitcoin://rest_of_url?amount=10.53&green_address=r&green_address_list=address1,address2,address3

Whatever the community have planned for bitcoin URIs.


-------------------------------------
Hi all,

I posted this question on the forums but got no answers.

I'd like to make some improvements to the Swedish translation of the
client. I understand the technical side of making a pull request etc.,
but will my request be accepted? There aren't many people in the
project who can judge if the Swedish translation is good or not, so
will it simply be accepted if noone opposes it?

Previous Swedish translations seem to have been commited by codler, is
this person "responsible" for the Swedish translation? Related to
this, is there anywhere I can see a list of people who have
permissions to make a pull?

David


-------------------------------------
Agreed, I find measured dialog much more valuable. I also agree that
standards take time and are messy, though choosing a standard allows
additional participation and can drive interopability. One does not
need to accept IBANN but we should participate in the dialog in its
development. internet-drafts don't make it through the process
unchanged. IBANN is a starting point not the end of the discussion.

-rick

On Fri, Dec 16, 2011 at 11:06 AM, Gavin Andresen
<gavinandresen@gmail.com> wrote:


-------------------------------------
On Wed, Aug 10, 2011 at 2:43 PM, Luke-Jr <luke@dashjr.org> wrote:

In kernel land there exists "linux-next"  Stephen Rothwell maintains a
tree that is linux -tip, plus a list of trees & branches to pull from
various individual developers.  For example, linux-next pulls my SATA
tree from libata-dev.git branch NEXT.

Each developer is expected to publish changes they feel are ready for
upstream.  Developers are expected to "play nicely" and coordinate
amongst themselves when two trees include conflicting changes.
Trivial merge conflicts are handled by Stephen Rothwell, who does
merging, build testing and such of the final set-of-N-trees result.
More difficult merge conflicts are coordinated by the developers
themselves, who work together to create a temporary "merge tree" that
is then pulled by the linux-next maintainer.

linux-next is the always moving, regenerated daily target where
developers stage [in their opinion] upstream-ready changes.

Thus Linus's linux.git development process really looks like the
following, when linux-next is included in the picture:

1. Version X-1 is released, on day 0.
2. Merge window for version X opens, on day 0.
3. Linus pulls all changes that have seen testing in linux-next, over
the -rc window (step #6, below)
4. Merge window closes, on day 7.
5. Version X-rc1 is released, on day 7.
6. Only bug fixes are accepted now (hopefully seen at least 24 hours
of testing in linux-next, unless urgency demands otherwise).  All new
development is done in developer trees and branches, and is
automatically published nightly in linux-next.
7. Version X is released, on day 90.

Thus "upstream" stays almost constantly stable, except for the short
1-week merge window period, and linux-next comprises the rolling
"development version" where new changes are staged.

Note the subtle but important distinction between this and maintaining
a strict 'bugfix' and 'development' branch system like John Smith
described.  The underlying linux-next dependent trees may be rebased
at any time, and so linux-next is constantly regenerated, rather than
being a cumulative history of choatic development.  Major changes can
and will be staged, de-staged, and re-staged during development, and
maintaining a strict "official development branch" methodology is less
flexible.

Here is an example linux-next report.  Stephen sends one, daily, with
each linux-next tree generated:
http://marc.info/?l=linux-next&m=131295044704945&w=2

As it applies to bitcoin, this "bitcoin-next" approach may simply be
layered on top of the current methodology.  All it requires is a
volunteer who maintains this tree-of-trees, and wha-la:  bitcoin has a
development branch.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
(taking this a bit out of order)

On Thu, Oct 27, 2011 at 3:32 AM, Michael Grønager <gronager@ceptacle.com> wrote:
[snip]

script is part of the cryptographic key.

[snip]

Which you must.

I can see no functional difference than if you said of the current
system "except if you also have knowledge of the final 32 bits of the
ECC private key".

I don't see any reason to expect clients to identify funds without
knowing the information required— it's impossible. I mean, sure, you
_could_ bruteforce the final 32 bits of your private key— or you could
attempt to try the cartesian product of every key you have with every
key seen in the block chain for finding an op_eval script. But thats
unworkable, unnecessary, equally bad for all client types, and not
being suggested.  Under either system a coin is not yours unless you
know all of the right bits— knowing some is not good enough.

Could you suggest how else we could gain the advantages of op_eval
without it?   How can I secure my wallet under whatever scheme I like—
create a trust that requires multiparty signoff— and securely have
senders pay into it without expecting them all to handle some rare and
complicated procedure for sending to me? (Or a burdensome address
which serializes a script and a large amount of data into hundreds of
characters, and which still may be unable to represent the rules I
wish to have govern my account— and which the sender might mutate—
e.g. twiddling the threshold counts— and cause me great
problems/confusion)

[snip]
[snip]

On the basis of the discussion here I now oppose checkmultisig as a
standard transaction type. (Sorry, I'm not trying to be a jerk if it
came off that way, I'm not opposing it simply because you support it:)

The advantage I saw of having it was faster deployment for the
explicit escrow cases that don't need to encode the payment rules in
an address (as is needed for wallet security and trusts)... but it
seems to me that there is a serious misunderstanding that there is a
bijection between hash160s and public keys, and one between ECC
private keys and spendable transactions, and that this bijection is
desirable or even essential to bitcoin.

I'm concerned that this misunderstanding will moot the flexibility of
the script system because every script that doesn't look like a direct
mapping of hash160->pubkey->payee will be regarded as _broken_— not
just useless to one app or another which could have simply chosen not
to generate those addresses— but actually incompatible with bitcoin,
as is basically being argued here— or, keeping in mind that people can
freely mine non-standard transactions, could this result in tools
which are rendered insecure by unexpected transaction types— Will a
system that thinks HASH160 = IDENTITY recognize that a script which
also requires an additional secret key on the stack is unspendable?

Keeping checkmultisig alone as a standard transaction, when it's
functionally a redundant subset of OP_EVAL  (and inferior because it
reduces the txn you can place in a block) could only further that
misunderstanding. :-/


-------------------------------------
On Thu, Jun 16, 2011 at 12:32 PM, Gavin Andresen
<gavinandresen@gmail.com> wrote:

Agreed, though security professionals (and luke-jr) are already
pointing out the wallet crypto mainly eliminates a bit of bad PR,
rather than being a major crime deterrent.

zooko on IRC had a pretty good suggestion:  introduce a built-in
facility for air-gapped wallets (multiple wallets), so that loss of
your everyday transactional wallet does not mean loss of everything.

You can do this manually, but we need something for all the people who
(a) don't know crypto, and (b) simply download and run the client
without thinking much about security.



Three points, on testing:

T1) autotools has a minimal testing framework built into it.  "make
check" builds, and then runs tests.  Each test is a program or script,
that returns 0 on success and 1 on failure.  "make distcheck" builds,
runs tests, and then creates the distribution tarball if the tests
succeed.

T2) I wouldn't narrow the focus to "unit tests", as stress tests and
other comprehensive, automated tests are quite useful as well

but most importantly...

T3) Don't hold v0.4 release for this.  As we say in kernel-land, we
have a test lab called "the internet"  Test suites have clear software
engineering value, but they largely "guard the past" -- making sure
you don't repeat past mistakes, rather than being a good indicator of
possible upcoming problems.  The best testing is always in the field.
That always finds more problems than unit testing ever does.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Tuesday, December 20, 2011 8:46:41 PM Luke-Jr wrote:

And here's yet another update, this time with a total of 21 branches merged. 
Anyone want to make binaries to get these branches some wider testing?

Accepted for 0.6:
* 81807c3 (pull 719) Coinbaser
* 6ea6db3 (pull 683) Context menu updates for TransactionView and...
* a6ef83e (pull 629) QR Code generation via libqrencode
* e0673bd (pull 582) Bitcoin-Qt signmessage GUI

Ready for acceptance?
* 4783528 (pull 454) Add -keepnode which attempts to -addnode and keep a...
* 5a11d0f (pull 570) Specify fees explicitly via JSON-RPC
* 2cddc71 (pull 649) Compressed pubkeys
* 73a8ca6 (pull 593) Full URL Support in bitcoin-qt
* 27a2460 (pull 721) 'getmininginfo' method
* e57ccf4 (pull 686) Testnet difficulty calculation changes, to take effect...
* 5b4a18d (pull 720) Use standard C99 (and Qt) types for 64-bit integers

Needs review:
* c7ee97d (pull 421) added option -forceresendtx
* cff2c28 (pull 714) Execute a command when best block changes...
* 3ca784f (pull 691) Temporarily disable "minimize to tray" in the startup...
* 59842f5 (pull 568) Multithreaded JSON-RPC with HTTP 1.1 Keep-Alive support
* d08e8fd (pull 565) FastGetWork optimization
* 0dc52ac (pull 715) Bugfix: comply with BIP 0014 ...
* f88dddc (pull 559) -acceptnonstdtxn option to skip "non-standard...
* 95d3e7e (pull 552) Typo-tolerant (optimized) Base58 parser
* 45beffe (pull 553) Parse URIs with non-BTC amounts
* 74439a5 (pull 562) Optimized binary-to-hex converter (ToHex)

Cannot be merged cleanly (at least not into next-test at this point):
*         (pull 430) joelkatz optimizations
*         (pull 452) JSON-RPC API versioning
*         (pull 457) IPv6 JSON-RPC
*         (pull 427) IPv6

Not yet written:
*                    Treat generation (almost) like normal receive
*                    JSON-RPC with integer amounts


-------------------------------------
As you noticed, we replaced most of the icons with license issues in
Bitcoin-Qt... but I intentionally did NOT replace the ones you created, 
assuming you would be willing to relicense them under the MIT (or similar) 
license. Could you commit a license change for these icons, ideally before 
0.5.0 final, please?

Luke


-------------------------------------
To those who think there are too many vanity versions of bitcoin, all I 
have to say is this:


atg@tortoise ~/source/bitcoin/src $ make -f makefile.unix
g++ -c -O2 -Wno-invalid-offsetof -Wformat -g -D__WXDEBUG__ -DNOPCH 
-DFOURWAYSSE2 -DUSE_SSL -DUSE_UPNP=0 
-I/usr/lib64/wx/include/gtk2-unicode-2.9 -I/usr/include/wx-2.9 
-DwxDEBUG_LEVEL=2 -D_FILE_OFFSET_BITS=64 -DWXUSINGDLL -D__WXGTK__ 
-pthread -DGUI -o obj/util.o util.cpp
In file included from util.cpp:4:0:
headers.h:43:20: fatal error: db_cxx.h: No such file or directory
compilation terminated.
make: *** [obj/util.o] Error 1
atg@tortoise ~/source/bitcoin/src $


'nuff said.


-- 
E T F
N H E
D E D

Powers are not rights.



-------------------------------------
First, thanks very much to Russell for looking more closely at both
BIP 12 and the patch than anybody else-- he's found two bugs and two
things the BIP isn't clear enough on (so far).

And I've got to say, I'm very sympathetic to the "OP_EVAL starts down
the code-as-data path, and There Be Dragons" argument.

But:

I don't think the proposed alternative would be, in practice, any
better.  I see two main disadvantages over OP_EVAL:

  about 20-bytes larger

  it means going back to where we were two months ago, writing more
code, reviewing it, finding bugs in it, backporting it so miners
running old software can support it, etc.

... and some other minor disadvantages:

  'standard' scripts will need to be slightly different in the
scriptSig and the scriptPubKey
   (e.g. <signature> CHECKSIG  becomes  <signature> CHECKSIGVERIFY
with OP_CODEHASH)

  OP_EVALs are not executed, and so the code associated with them does
not have to be part of the transaction, if they are in the
non-executed branch of an OP_IF. That could be good for privacy, and
could be good for reducing block-chain size.

----------------------

In discussions in IRC yesterday, we talked a little about possible
changes to the OP_EVAL BIP to make it less subject to abuse. In
particular, the big can of worms is allowing arithmetic or bit
operations on the serialized script that will be EVAL'ed:
  <serialized script> <other_data> OP_ADD OP_EVAL  <-- Look! Dragons!

If <serialized script> is more than 4 bytes, that is actually illegal
right now (all of the arithmetic operations are limited to operating
on numbers that are 4 bytes of less, and I believe we could prove that
no series of operations will ever produce a value more than 5 bytes
big given the current limitations).

Which leads me to suggest that BIP 12 be amended to state that:
  OP_EVAL shall cause script validation to fail if the top item on the
stack is less than 8 bytes long.

I'm tempted to propose a rule:
  OP_EVAL shall fail if the top item on the stack is the result of any
calculation

... but I don't think the extra code it would take to implement that
(keep track of which items on the stack were the results of
OP_ADD/etc) is worth it.


On the "you can't tell how many CHECKSIG operations will be performed
before executing the script" issue:

That is already true, because the parameters to CHECKMULTISIG that
determine how many signatures it checks might be computed.

Finally, I would echo theymos' observation that I think we'll
eventually do something very much like OP_EVAL in the future-- maybe
to support (in a backwards-compatible way) a
quantum-computing-resistant signature algorithm or SHA3. When that is
done, I think it might make sense to do a bottom-up redesign of Script
based on what we've learned.

-- 
--
Gavin Andresen


-------------------------------------
Khalahan, honestly, using namecoin for aliases is (for me) clean example of
over-engineering. I mean - it will definitely work if implemented properly.
I played with a namecoin a bit (as my pool was the first 'big' pool
supporting merged mining), but I think there's really long way to provide
such alias system in namecoin and *cleanly integrate it with bitcoin*.
Don't forget that people who want to do lookup need to maintain also
namecoin blockchain with their bitcoin client. It goes against my instinct
of keeping stuff easy.

For example, yesterday I implemented HTTPS lookup for addresses into my
fork of Electrum client. I did it in 15 minutes, it works as expected, it
does the job and the implementation is really transparent, becuase
implementation is 20 lines of code. There's no magic transformation, no
forced "?handle=" parameters or whatever. And I don't care if somebody
provide URL
https://some.strange.domain/name-of-my-dog?myhandle=5678iop&anything_else=True

And everybody can do the same in their clients, in their merchant
solutions, websites or whatever. Everybody can do HTTPS lookup. But try to
explain DNS, Namecoin, IIBAN, email aliases to other programmers...

Those IIBAN - well, why not. At least I see the potential in PR. So far I
understand it as some teoretic concept which is not supported by anything
else right now. Give it few years until it matures and then add IIBAN alias
to Bitcoin client too.

Maybe I'm repeating myself already, but the way to go is to make aliases as
easy as possible, so everybody can implement it in their own solution and
thus practially remove the need of using standard bitcoin addresses for
normal users. Using some superior technology, which is hard to implement or
even understand won't solve the situation, because it will ends up with
some reference implementation in standard client only and nobody else will
use it.

slush

On Fri, Dec 16, 2011 at 6:23 PM, Khalahan <khal@dot-bit.org> wrote:

-------------------------------------
On Monday, December 12, 2011 9:37:06 PM Amir Taaki wrote:

And then Joe Address Squatter gets 1 BTC. BOOM.


-------------------------------------
On Mon, Jun 13, 2011 at 4:55 AM, Christian Decker
<decker.christian@gmail.com> wrote:

It seems to offer few benefits over DNS seeding, while potentially
potentially creating a vulnerable hot spot in the DHT.  Sybil attacks
on DHTs are well documented.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sat, 2011-12-17 at 12:14 +0100, Jorge Timón wrote:
Under no circumstances should the use of firstbits ever be supported.
It doesn't scale, not even close, especially as we (hopefully) move
towards SPV clients.  Also, it provides incentives for people to spam
the chain to get a firstbits address.  Never should that be supported.

Matt



-------------------------------------
Quick status update on 0.4; I probably won't have time to tackle these
properly before Tuesday:

+ sipa found what looks like a deadlock between the addr-handling and
IRC-join-handling code.
+ UukGoblin reports a deadlock problem on a bitcoind handling getwork requests.

If you want to get more familiar with the bitcoin code and you have a
lot of patience, tracking down deadlocks a great way to do it.

+ ArtForz found a performance bug with transactions that have
thousands of inputs and outputs on the solidcoin test network.
 (not as big an issue for bitcoin due to fees being based on
transaction size, but still worrying)

-- 
--
Gavin Andresen


-------------------------------------
Luke-Jr wrote:
A few non-standard transactions are probably legitimate.  A whole bunch 
of them are probably not.  I would think that assigning a point or two 
of badness to a peer sending one is pretty reasonable, with the 
understanding that we would need to adjust that as the network evolves.


-------------------------------------
I adapted the Python PEP 0001 to Bitcoin (its license is public domain):

https://en.bitcoin.it/wiki/Bitcoin_Enhancement_Proposals

https://en.bitcoin.it/wiki/BEP_0001

BEP 0001 is open to additional authors and revisions.

Ideally these should go in a github.com/bitcoin/beps/ repo.

Lets have a standardisation track for changes to the protocol.



-------------------------------------
On Wednesday 10 August 2011 22:35:01 Jeff Garzik wrote:

wrote:

I wasn't actually giving a full explanation of how these things could be 
done, I was providing a list of "negatively received ideas"; imagine my 
surprise that they have been negatively received by you.

However... The version number field combined with the massive complexity of:

 if( blockNumber > 500000 )
   new_process();
 else
   old_process();

Would sort all of your "compatibility" objections out, and would give nodes 
time to upgrade.


If only there were some way of sending different things to different nodes, 
based on some sort of version number field.


  if( Version < VERSION_INTRODUCED )
    sendVerack();

My point is that you are a clever guy; you are perfectly capable of coming 
up with these answers, but you don't want to.  Nor does any other bitcoin 
developer.  The protocol is perfect and there is no way of changing it.


Eh?  The transaction list is available on bitcoincharts.  If my node had 
been connected it would have received that list anyway when each one was 
broadcast.  What possible privacy loss could there be by making it possible 
to request it be repeated?

Again though: the detail isn't the point.  It's another half-hearted 
objection.


No; I mean being able to ask for just the block without the header.  The 
reason being that a thin client might request blocks on demand... it's 
already got the header and doesn't need it again.

The response: "it's only 80 bytes, blah, blah".  80*150000*N is a non-
trivial amount of traffic.


Only for the version message.  But it would be trivial to do both types of 
checksum on the version message, and if either is true to accept the version 
message.  After which the version is known and a much simpler checksum could 
be used for subsequent messages.  Eventually the network would be upgraded 
enough that the old way can be dropped.

Besides... hasn't TCP already got checksumming?  Let's just stop checking 
the checksum.  Or better still, stop calculating it and sending it.  Double 
SHA-256 on every single message on every single node to create four checksum 
bytes is an enormous waste of CPU.


If only there were a version field in the transaction and block structures.

Again; casual rejection.


See above.


No, "consensus" doesn't.  I was simply listing all the ideas that got 
rejected out of hand.  The reason "consensus" doesn't think this one is 
necessary is because "we can already detect double spends by being widely 
connected"; ignoring the fact that a light or intermittently connected 
client would not be widely connected.  But that's okay because "eventually 
payment processors will appear".  Yep, my idea for fixing bitcoin is stupid 
because eventually someone else will mitigate it.


It was a few weeks ago; and it was an email from me about getblocks 
enhancements.  It was patronisingly laughed off as being something that all 
you newbie "alternative client" writers go through.

The use case is an on-demand thin client that wants to find the block that 
contains a particular transaction ID without downloading and indexing every 
single block in the chain.  Additionally, _I_ plan to separate the block 
chain and wallet executables, so much so that the wallet executable doesn't 
necessarily need a local blockchain node and relies on a partially trusted 
remote -- it still wants to be able to do spot checks on that remote, and 
confirm whatever it's told.  I would like to be able to do that using only 
commands that are in the official protocol; but I'm rapidly coming to accept 
that nothing I ask for will ever go in because there is no "use case".


As with every project.

However, the protocol is being treated as if it is some kind of holy scroll, 
and must not be touched.  Bitcoin's ideas are revolutionary, its 
implementation is not.  If we started again today, it would be done 
differently.  Shouldn't we be trying to move the current protocol toward 
_that_ "done differently" as much as possible while bitcoin is still 
relatively small?  Rhetorical again... I know the answer, it's "no".

What exactly do the developers mean when they keep talking about bitcoin as 
"experimental"?  It seems to me they mean "incredibly conservative, with no 
changes for the rest of time".


Nothing I've suggested was to "stop the current system".  I'm not even 
asking for developers to prioritise my ideas.  I would just like mine, or 
anyone's ideas to not be instantly rejected out of hand.  I mean for 
goodness sake, even "splitting into multiple executables" has been stomped 
on in this very thread.  If something as trivial as that is "impossible" 
what chance is there that I would ever get "Change the 64-bit timestamp 
field to be microseconds since the epoch instead of seconds" in?


There is a popular idea that some other cryptocurrency will come along and 
displace bitcoin.  It's not going to happen.  Networking effects mean that 
there is no reason for people to change.  I can just see the queue around 
the block now for bitcoin.2; identical in function to bitcoin except it 
"doesn't use ECDSA and the it uses protocol buffers on the wire, and uses 
more memory".  Wow; there's a set of unique selling points.  I'll get signs 
made.

Let's be practical: technical-only improvements _have_ to be to bitcoin.1. 
Bitcoin's financial features are already complete or in progress; and it is 
financial features that would make people migrate to a competitor.  Nobody 
is going to move to bitcoin.v2 because the source code has better comments.


I disagree about how set in stone these things are; but yeah; I've accepted 
that I'm on a loser.  My list was to demonstrate how negative the community 
is; and you have confirmed that for me admirably.  Bear that in mind the 
next time you're discussing the lack of manpower for bug fixes.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
PKI would avoid the need for the trust aggregator to be consulted for 
each transaction. Obviously checking for revocation would be essential. 
The CA cert can state what kind of guarantee is available.

Simon


On 10/24/2011 09:25 AM, Mike Hearn wrote:


-------------------------------------
Guys,

 The bidcoin-qt for Linux does not have the Bitcoin icon at the Desktop
Pager (Ubuntu Oneiric 11.10).

 This is a cosmetic change.

Best,
Thiago

2011/11/17 Martinx - $B%8%'!<%`%:(B <thiagocmartinsc@gmail.com>

-------------------------------------
On Mon, Dec 12, 2011 at 9:37 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

well, it's easy to miss the point when the example you use doesn't
make the point you think you're making. :D
but ok, yes, it would be nice to send directly to something like
1brmlab from the client. i suppose figuring out how to make sure that
1brmlab actually does send to whom you think it sends, is left to the
details of implementation, but that's a separate question.


-------------------------------------
On Mon, 2011-08-29 at 16:10 -0400, Gavin Andresen wrote:
Hopefully working on something that would help do this now.
Also my build update pull would be much appreciated.
NICE



-------------------------------------
Cmake is just as bad as autotools, just with a different syntax and more "buzz" behind it right this second. I don't see any advantage to it over autotools unless you're not familiar with either and even then I wouldn't really call it an advantage. It's just different.

It also requires a dependency that isn't installed by default anywhere, as already mentioned, and is less known outside of some obscure qt/kde circles and so finding people who are familiar with it and are willing to maintain it is more difficult. 

Autotools is the devil you know.

You'll probably throw out that mysql and compiz have switched to it, but really, those projects aren't something that should be emulated by anyone. Ever.

On Jul 2, 2011, at 11:50 AM, John Smith wrote:


-- 
Douglas Huff




-------------------------------------
On Thu, Aug 18, 2011 at 12:16 PM, Gavin Andresen
<gavinandresen@gmail.com> wrote:


At the same time, if this causes people to wait less than the 6 blocks
that the software currently waits for before leaving unconfirmed
status then that would be sad.

Simply waiting a number of blocks is an excellent metric and provides
robustness against almost all attack patterns in a way that various
one-off-heuristics can not as it equates to _real difficulty_ (and
real expense (hashing computation, loss of income on the orphaned
blocks)) in a way that can't be faked.

A few weeks back when there was some rumor going around that mybitcoin
lost coin based on some kind of one confirmation attack I described on
IRC a similar attack pattern which had a useful improvement:

* The attacker runs many widely distributed sybil nodes (e.g. using
botnet drones as simple tcp proxies to appear at many addresses). He
takes advantage of the fact the bitcoin won't connect to /16s that
have already connected to it to further isolate nodes.

* By creating normal looking probe transactions which his own nodes
won't forward he detects network partitions which he is able to
create. He searches for a cut which causes there to be at least two
partitions which contain significant mining power.

* He creates two accounts at MoronBank. He doesn't even bother
identifying MoronBank's node. MoronBank will be in one partition or
another. He makes deposits in both partitions, and conflicting
transactions in the opposite partitions, while carefully filtering out
these transactions from crossing the boundary.

(Notably, the network doesn't appear partitioned to everyone else now
because he's still forwarding blocks and transactions unrelated to his
attack— it only becomes visible once some of his evil transactions are
mined)

* After the funds show up in MoronBank he withdraws and drops the partitioning.

Only if he has difficulty getting MoronBank into the smaller partition
does he need to bother locating it and attacking it directly.

The bad thing about this attack is that it doesn't require the
attacker to have any hash power at all: he captures miners as
unwilling (or willing but plausibly deniable) participants. The lost
income from orphaned blocks is externalized to the victimized miners
(and since most pools don't pay orphaned blocks out of pocket a pool
operator would be inclined to help out).

The good thing about it is that it's killed dead by nodes adding in a
few manually configured peerings, they don't even really need to be
trusted: You just need to trust that they don't all go to a single
bad-guy conspiracy. At a minimum all major miners should be fully
meshed.

Unfortunately, We don't currently have software for this as addnode
doesn't worry about keeping the links up... and the major pools also
don't seem to be interested in participating.


-------------------------------------
On Thu, Aug 25, 2011 at 4:10 PM, Pieter Wuille
<pieter.wuille@cs.kuleuven.be> wrote:

So 187 bytes in base-58? I think pretty darn good for a destination
with 6 keys and complicated rules. I like that a lot.


-------------------------------------
On Monday, November 21, 2011 8:06:27 PM Gavin Andresen wrote:

Not prioritizing some unannounced "release schedule" over getting bugs fixed 
before making the release is another part of the answer, at least.


-------------------------------------
On Wed, Oct 5, 2011 at 8:31 AM, Michael Grønager <gronager@ceptacle.com> wrote:

They don't need 7 blocks to maturity and respendability. The software
will attempt to use older inputs when available but if not it will use
what it has.  It's also prone to respending its own outputs quickly
because it reasonably trusts that it won't doublespend its own
transactions.

And, yes, if there is a deep split then its possible that inputs might
have been spent differently in the new split. But it's not especially
likely. Retransmitting one of your own txn's parents if its dropped
but not yet impossible sounds prudent to me.


-------------------------------------
On Thu, 2011-08-04 at 20:42 +0100, Andy Parkins wrote:
Exactly, why add more network traffic for something that you can get
better without doing that?
Again though, adding more crap to the protocols is something we want to
avoid, especially if it offers no gain.
Nope, the network decides nothing, only the miners decide.
Then your whole attack scenario is broken and it becomes a 50/50 (or
more likely less) guess.
No, its easier for people who care to make sure they are peered with
well-connected nodes than for us to change the network protocol.
Yep, which is what my suggestion does.
If it only ends up on a few isolated nodes, then you dont care as the
ones that you dont know about will never be confirmed.  If it ends up on
a node you peer with, you will be able to fetch both transactions and
then you know about the double spend.  Hence why you have to have
well-connected peers.
No one is against making changes if they offer clear incentive.  This
one doesnt.  Additionally, whether its an experiment or not, people have
money stored in it and a mistake could mean the loss of tens of
thousands or hundreds of thousands of dollars.  Lastly, no one is (yet)
paid to work on Bitcoin, sorry the developers dont spend enough time
merging for your liking.
I think having the ability to detect double-spends rapidly is something
that is needed, my point is that you already can with relatively little
effort, no point adding more stuff to make it no easier.

Matt
-------------------------------------
I would like to propose adding timers to the pulls / issues:

https://github.com/bitcoin/bitcoin/pull/523

"From time to time a pull request will become outdated. If this occurs, and
the pull is no longer automatically mergeable; it will be closed after 15
days. This can be avoided by rebasing the commit. Pull requests closed in this
manner will have their corresponding issue labeled stagnant.

Non-bug issues with no commits will be closed after 15 days from their
last activity.
Issues closed in this manner will be labeled stale.

Requests to reopen closed pull requests and/or issues can be submitted to
QA@BitcoinTesting.org. "

This will help cut down on the abandoned / stagnant pulls and issues.
It will also focus attention on priority items, and phase out unwanted changes.

Sidenote: QA@BitcoinTesting.org is working, unlike QA@Bitcoin.org

-Alex


-------------------------------------
...

You're right, it doesn't make sense.  The use case I would like to work is:

I setup an escrow that requires m of n signatures to release funds,
securely getting public keys from the other n-1 parties.

Now we all need to fund the escrow. Or maybe other people can fund the
escrow (it just takes m of n of us to decide when/how/where to spend
the funds).

It would be spiffy to publish a new type of bitcoin address that is an
"m of n address", that anybody could pay into, but would require m of
n signatures to spend.  Publishing a really really long address with
all n public keys would work.

It would be great if the "higher level protocol" for pay-to-escrow was
just get a bitcoin address via https (or other secure mechanism), like
we do now for pay-to-single-party.  Where the person you're paying has
their own mechanisms for generating or fetching/authenticating the
public keys, and knows which bitcoin addresses they've published.

All of which makes me wonder if the straightforward "n PUBKEYS m
CHECKMULTISIG" transaction type is the right thing to do.
Following the pattern of our standard DUP HASH160 etc. transaction
type, maybe 2 of 2 and 2 of three should be:

2DUP ADD HASH160 ...hash(pubkey1+2)... EQUALVERIFY 2 2 ROLL CHECKMULTISIGVERIFY
3DUP ADD  ADD HASH160 ...hash(pubkey1+2+3)... EQUALVERIFY 2 3 ROLL
CHECKMULTISIGVERIFY

Spending those transactions would mean putting the m signatures and
the n public keys in the TxIn, but sending funds you'd only need the
hash of the sum of the public keys.

-- 
--
Gavin Andresen
http://clearcoin.com/


-------------------------------------
A while back I had proposed a similar idea to the DHT, although my main
goal was to reduce the need for broadcasts.

My idea was to structure the network in a hypercube and use prefixes to
address different parts of the network, and use those prefixes also to find
the location where an item (transaction, block, ...) should be stored. Each
vertex in the hypercube is a small, highly connected, cluster of nodes. The
storage would be distributed, messages are routed on behalf of others,
which makes finding the origin of the query hard to find (think Tor), each
node would have to store only O(log(p)) items, with p being the prefix
length, maximum number of hops is equal to the dimension of the hypercube
O(log(n)).

Newly created transaction will be sent directly to the location they'll be
stored and miners retrieve new transactions at regular intervals. It might
increase delays to the confirmations, but it reduces the number of
broadcasts and storage requirements on nodes greatly.

Regards,
Chris


On Sat, Dec 17, 2011 at 2:13 PM, Michael Grnager <gronager@ceptacle.com>wrote:

-------------------------------------
FirstBits looks nice at glance, but is bound to create a gold-rush to grab 
every nice-looking FirstBits address.

HTTPS is only as secure as the (centralized) CAs, thus not really any better 
than TXT records.

I don't think an address of some form is avoidable.


-------------------------------------
On 2011 November 23 Wednesday, Christian Decker wrote:

The above is a problem in either system (mine or current).  If I can make a 
"hardest chain", then I have indeed reverted all the existing transactions. 

Look at CBlock::AddToBlockIndex(), 

    if (pindexNew->bnChainWork > bnBestChainWork)
        if (!SetBestChain(txdb, pindexNew))
            return false;

If the received block has higher total chain work than the current best chain 
work; then the new block becomes the head of the best chain.  The chain work 
being calculated like this (I've abbreviated for the email):

  pindexNew->bnChainWork = pprev->bnChainWork + pindexNew->GetBlockWork()

I'm not entirely convinced that this method of totalling chain work is the 
best (it's a sum of exponentials I think); but that's a different issue.


I don't see that it is reduced; it is the same.  Hashes are hashes.  A given 
difficulty isn't required, but a higher difficulty beats a lower difficulty.  
So whatever the hashing power of the network at that moment, it's used.  That 
makes the chain more secure, not less.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
0.4 RELEASE

Bitcoin version 0.4 release candidate 2 looks stable; I've been
running a slightly-modified version of it on the Faucet website with
no issues for a couple of days now, and am not aware of any
show-stopper issues.

I built and uploaded OSX binaries to github:
  https://github.com/bitcoin/bitcoin/downloads

Windows and Linux binaries will appear as soon as our "gitian-capable"
builders get a minute to create them (Jeff and Matt have been busy
with real life or their day jobs).

I'd like to switch from distributing binaries on SourceForge to
distributing them on GitHub, since GitHub supports https downloads.


NEXT RELEASE

If you have patches waiting to be pulled, now would be a good time to
rebase them; I expect minimal-to-no changes between release candidate
2 and the final 0.4 release.

And, if you haven't already, write up a little test plan and/or add
some unit tests.

The big planned feature for next release is switching from wxWidgets
to qt for the GUI client.

ON THE RADAR

I'm going to start separate discussions about a few need-deep-thinking issues:

1) There is a bug/design flaw in bitcoin's difficulty adjustment
algorithm. More generally, there have been nagging issues surrounding
how bitcoin handles time that I think need to be addressed.

2) I'm going to submit pull requests for an implementation of the
"don't talk to misbehaving peers" idea. That should proactively
prevent a whole swath of potential denial-of-service attacks, but if I
got it wrong it could be very bad for the network.

3) I'd really like to come to consensus on one or more
'multi-signature' standard transactions to enable much better wallet
backup and security.

Lets talk about those three issues in separate threads.

-- 
--
Gavin Andresen


-------------------------------------
There is a lot of complaining about this alert system, but I really don't
see the problem.

As others have already said, it's just a message. Even if someone managed to
compromise the private key, the most they could do is spam graffiti messages
or try phishing. There are much worse things that could happen to the
network (in which case an alert system could come in very handy). It's just
not worth worrying about.

JS

On Thu, Sep 8, 2011 at 4:20 PM, Pieter Wuille <pieter.wuille@gmail.com>wrote:

-------------------------------------
On Tue, Oct 25, 2011 at 10:49 AM, Gregory Maxwell <gmaxwell@gmail.com>wrote:

(1) As I understand it, OP_EVAL is being proposed as an *optional* tool for
multi-signature transactions.  It sounds like to me, that you can still use
the regular OP_CHECKMULTISIG if you are concerned about these things.  If
you're dealing with too many parties with questionable reliability that they
will notify you of transacitons that include you, I don't see anything wrong
with declaring that you'd only prefer dealing with OP_CMS transactions and
not OP_EVAL (besides some grumbling from them that their way is "better").
Either way, they're screwing themselves, too, if they want to include you on
transactions and don't notify you as such (kind of defeats the purpose of
multi-sig txs).

(2) I think it's unnecessary to discuss cases where you somehow lose your
mappings but not your private keys.  In order for OP_EVAL scripts to work,
the subscripts/mappings are *just as important* as your regular private
keys.  They should be kept in your wallet forever just like your private
keys--and thus you lose none of them or all of them.  The only real
difference is that they aren't sensitive like your private keys, so they
don't have to be encrypted.

(3) There should most definitely be a button on the main client that allows
you to "Add OP_EVAL script" or something along those lines (maybe something
with a less obscure name).  We need to make it as easy as possible for
someone to add such a script/mapping to their wallet.  Although, this
invites a breach of one of my core rules of user interfaces:  if the
functionality is dependent on the user performing some regular maintenance
task, you better be prepared for all users to fail at doing it.  Even
diligent users are going to forget/mess-up sometimes.  If failure at
performing this task results in breaking the client or losing money, we
should avoid promoting that usage paradigm.
-------------------------------------

Not with this PULL-- I think wallet security and backup is a critical
feature, so that is what this is for.


groffer pointed out that might cause problems when transaction volume
ramps up, because each CHECKMULTISIG counts as 20 sigops, and there is
a limit to the number of sigops you can put into a block. And since it
isn't needed for wallet security and backup I dropped it.

Accepting this does not preclude adding more 'standard' transaction
types in the future.

-- 
--
Gavin Andresen


-------------------------------------

Great. I really hope these get pulled ASAP, having the tests all over the
place in different forks is really confusing :(

JS
-------------------------------------
Hi All,

Along with the multisig/op_eval BIPs (11/12) I am considering how the actual client functionality could be.

Some of you might already have the solution for this - if not I would like to propose the following...

Lets consider the 2 of 3 multisig - and lets say I now have some coins hence only redeemable using 2 key signatures. So when I want to spend them I would do:

1. from client1 I issue a transaction containing one of the signatures, with a locktime e.g. 10 minutes from now and a sequence of 0. This transaction is now posted to the p2p network.

2. client2 discovers the transaction and that it will affect its wallet. It hence modifies the transaction to includes also the second signature, changes the sequence to 0xFFFFFFFF=final and the lock_time to 0 and retransmits the transaction.

3. The transaction is now valid and final and will be approved by the miners.

However, for this setup to be possible, we need to reenable the replacement of transaction in the client....

Anyone working on this now ?

Alternatively, the transactions would need to be sent between clients using another protocol...

Cheers,

Michael




-------------------------------------
On Friday, August 12, 2011 12:35:27 PM Gavin Andresen wrote:

Updated variable name in branch...


Perhaps the vanity use would need to be introduced only after the community 
has accepted these as alternative legitimate representations. Even without 
that, I think gracefully handling the typos would be sensible.


-------------------------------------
On Tuesday, June 28, 2011 2:35:59 AM Mike Hearn wrote:

MtGox's code is just as related as BitcoinJ or any other Bitcoin software, 
IMO.


-------------------------------------
On Thu, Aug 25, 2011 at 3:39 AM, Michael Grønager <gronager@ceptacle.com> wrote:
the customer to bypass the clerk and have 3 key addresses, or could we
just leave it to the/a client to implement the multisign transaction
after the money has been received - as a transfer to a safe? This
would greatly simplify the problem and cover the vast majority of use
cases. Not covered in this is huge single transfers where the intruder
of a single key system finds it profitable to reveal their intrusion
by grabbing the entire wallet.

Obviously these things don't need to be hard coupled, since they're
useful independently.   But I don't agree with the premise that being
able to pay directly into an escrow using an address isn't essential
at least as an eventual feature.

The bank analogy falls down because in our threat model people are
replacing the bank teller with a convincing facsimile (malware turning
your computer against you).  Funds can be stolen in a microsecond, so
any exposure isn't good.

Again, I'm not arguing to delay anything— just pointing out that the
ability to have usable addresses (they can be long) that encode a
couple escrow destination.

Perhaps just an address type that can encode any payment script?  User
provides the inputs, sets the outputs plus and additional outputs, and
signs. Client refuses to pay to an address if the resulting
transaction fails IsStandard.

On Thu, Aug 25, 2011 at 1:18 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

3-of-3 in particular seems somewhat important to me (group trust
accounts).  I'd really rather not drop use cases unless we're not
confident that they can't be tested sufficiently simply because it'll
just mean another cycle of testing later someday to test them and,
honestly, a more uphill argument as the usecases get narrower and
narrower.

I'll spend some cycles testing whatever cases make it in.


-------------------------------------
If we chose the simple URI proposal namecoin can still be integrated
to map the IP of the server by those who want to.
Does it removes the necessity of the certificates?
If so, we should let people decide between HTTP, HTTPS, namecoin or
whatever they trust.

Shouldn't we be also discussing the valid format of the answered
message? I mean fields like "amount", "concept" and such.


-------------------------------------
On Fri, Sep 30, 2011 at 1:21 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

I think 2 of 3 is a _far_ more useful example than (a or b),  it is
the prototype for a normal escrow transaction., and still only results
in three address and at most two signatures like the (A and B) or C
case.

You can also replicate the functionality of (a or b) in a hashish and
inefficient sort of way with two of three by simply using a public
known key as one of the roles.


-------------------------------------
On Thu, Dec 29, 2011 at 01:55:03AM -0500, roconnor@theorem.ca wrote:

If we're again brainstorming about alternatives for OP_EVAL, I'll do my own.

It is called OP_CHECKEDEVAL, and is specified as follows:
* It looks at the two elements most recently (in code position) pushed by a literal,
  and not yet consumed by another OP_CHECKEDEVAL. These are S (the serialized script),
  and H (its hash). This implies it defines its own literal-only stack, where all
  literals push to, and only OP_CHECKEDEVAL pops from. This special stack has the
  advantage of allowing static analysis - one does not need to execute any operations
  to find out which data will end up on it. Note that "skipped" code (inside the
  ignored part of an IF-THEN-ELSE) can still push to the literal stack.
* For the "outer script", it does not have any effect at all, except for:
  * 2 elements popped from the literal-only stack
  * potentially causing failure
  It does not touch the main stack, alt stack or any other part of the execution state
  not listed above.
* Failure is caused when either of these conditions hold:
  * No two elements remain on the literal-only stack
  * The Hash(S) != H
  * The inner script execution caused failure
* For the execution of the inner script:
  * It is executed in a completely new and independent execution environnement
  * It executes the deserialized S
  * It inherits the main stack and alt stack (without the serialized script and the hash
    themselves) from the outer execution.

This requires OP_CHECKEDEVAL to immediately follow the push of script and hash,
so the code in the pair < <script> OP_CHECKEDEVAL > can be parsed and interpreted as code, 
allowing static analysis.

As OP_CHECKEDEVAL has absolutely no effects except for potentially causing failure, it
is very similar to the OP_NOPx it would replace, and guarantees that interpreting
OP_CHECKEDEVAL as OP_NOPx can never cause the script to become invalid if it wasn't
already.

A basic pay-to-script-hash scriptPubKey is very short:
  
  <scriptHash> OP_CHECKEDEVAL

And it is redeemed using:

  <script inputs> <script>

Furthermore, the implementation is very similar to what was already done for
OP_EVAL. Modifications:
* EvalScriptInner needs less by-ref arguments, as it cannot modify the parent's state.
* A literal-only stack needs to be maintained.


I believe this combines all advantages:
* Easy spend-to-script-hash (shorter than OP_EVAL)
* Backward compatible (guaranteed by construction, instead of separately enforced like with OP_EVAL)
* Statically analyzable (though it requires deserializing the script data).
* Possibility to introduce a new language inside (not done in this proposal)

Only disadvantages:
* Slightly less flexible than OP_EVAL, as it disallows dynamic interation with serialized scripts.
* Static code analyzers need to deserialize script data.

Credits: gmaxwell for the idea of a literal-only stack

-- 
Pieter


-------------------------------------
Hi Brian,

Had a similar issue the other day with my cmake btc buildsystem - I just changed the name to -mt, I think that is th way to go.

Cheers,

Michael

On 05/10/2011, at 01:40, Brian McQueen wrote:





-------------------------------------

What are the use cases for this?

arbitrary scripts in a user-facing address. The software has to be
able to present some kind of reasonable user interface given an
address, it has to explain what is going to happen to the users money
and so on. From this perspective, doing pattern matching against some
encoded script template is annoying and inefficient. It'd be better to
just define another type of URI for each kind of transaction you wish
to support. This is doubly true because often to do the more
interesting contracts, you need out of band protocols, so the
"address" would probably specify some information that's not in the
final output script, like a rendezvous point.


-------------------------------------
I'm not sure I get your point. If someone tells you "hey, check out
the web page at xkcd.com", is that your response or do you just open
up your web browser and type "xkcd.com"?

D.H.


-------------------------------------
On Wednesday 10 August 2011 19:41:51 Gavin Andresen wrote:

(Rant follows; stop reading now)

That paragraph reveals a gross misunderstanding of how open source works.  

People get itches and they want to scratch them.  They aren't paid, so they 
don't necessarilly want to turn up and be told which part they _should_ be 
working on.  The choice is not "bug fix that Gavin wants" or "new feature 
that New Developer wants", it is "New Feature" or nothing.

Of course, nothing forces existing developers to accept these new features; 
but the incredibly negative attitude on display when any new feature is 
suggested is not the way to grow a community.  The correct way is a 
mentoring attitude -- offering opinions on how a new developer can get their 
idea in rather than telling them why it will never happen.


Again: that's not your call.  People will work on what interests them.  I've 
suggested a couple of features both here and on the forum and been shot down 
in varying degrees every time.  Fine, but don't expect that I'm thinking 
"well I'll become an unpaid bug fixing grunt instead".

I don't expect to be appointed head developer because I suggest an idea.  I 
don't even expect anyone else to implement my idea for me.  But why should I 
spend time on my own idea when the feedback is "no", "no", "we've already 
thought of that", "not needed", "go away", "why not fix some bugs instead"?

I'm amazed that John Smith is as polite and persistent as he is looking at 
the amount of effort he's put in putting a pretty face on the train crash 
that existed before hand and seems to get no benefit of the doubt for his 
work.


That pressure might be relieved if the community were able to grow a bit, 
and people felt they had a personal investment.  That means loosening the 
reigns a bit; and perhaps a development branch would be the way to do that 
while not compromising code quality.

I suggest a look at the way git itself is developed; it has the following 
branches:

 - master: the latest release + newly accepted features
 - maint: the latest release + bug fixes only
 - next: new features planned for inclusion, actively being worked on.
   Often created by merging "topic" branches from individual developers
   working on their current itch
 - pu: crazy stuff; not planned for inclusion, but acting as a staging
   area for people to show what they're working on



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
Fair enough.  I'm not expecting anyone to just suddenly adopt BIP 0010 
just because I published it to the wiki.  I put it there to get feedback 
on what it might be missing, and maybe we can converge on a good 
preliminary solution.  Then update it as we start playing with it and 
find more features/fixes to add to it.

Right now, I have actually implemented BIP 0010 in my own client 
software (which is still a few weeks from even having an alpha version, 
but nontheless I'm actually implementing it). I'm going to use TxDPs in 
offline-wallet transactions, which is a nearly identical process (it's 
just a 1-of-1 transaction).  As such, I will be interested to test with 
some other client developers, whether they can easily use the TxDPs I 
produce.

I assume it doesn't bother you if I leave it the way it is, with the 
acknowledgment that I know no one is adopting it yet (except for 
myself).  It's informational, until we get a couple different clients, 
or at least test setup to play with it.

-Alan




On 11/12/2011 12:16 PM, Mike Hearn wrote:



-------------------------------------
On Thu, Aug 11, 2011 at 1:45 PM, Joel Joonatan Kaartinen <
joel.kaartinen@gmail.com> wrote:

I personally would welcome alternative clients as a vulnerability in the
main client right now has the potential to kill the entire network.

Changes to the protocol are hard, mainly because hashes of packets are used
to identify transactions and blocks, and even the target hash is a hash of a
packet.
As for your proposal to eliminate some parts of the protocol, I have to
agree (the magic bytes seem an ugly hack by satoshi as I discussed with
Mike, and the double SHA256 hashes as checksums are incredibly wasteful, and
seem to have been chosen simply because a double hashing was already
implemented).

Changes should be implemented with backward compatibility in mind, even if
it restricts the freedom of what can be changed.

Having a Wiki or a single Wikipage to list proposed changes, with all pro
and cons, maybe pointing back to the original discussion would be nice. But
don't forget that situations change, and features that have been shot down
way back might become reachable/desirable at a later time, so please don't
just use it as a method to shoot down ideas, but as a way to bring people up
to speed and, if necessary, continue the discussion where it left.

- cdecker
-------------------------------------
Yes, those trackers would be hard coded, just like the IRC servers and
channels are hardcoded right now.

The advantages over IRC and DNS Seeds are:
 - sporadic HTTP requests to a tracker, as opposed to keeping an IRC
connection open at all times
 - no virus/botnet like behaviour (automatically join IRC channel with
cryptic name), ISPs tend to bother network admins (like myself) with alerts
when they see this...
 - adapts faster than DNS Seeds which require configuration changes on seed
should the nodes become unreachable
 - we already use HTTP to determine our external IP, so it would be a
consolidation of transports
 - more peers than DNS Seeds (better load balancing)

As for Vladimirs proposal, seems like an extreme measure, that is not really
practical. Also it leads to network partitions since nodes will prefer their
own /8 and /16 networks. IPv6 will also soon be a problem for this method.

On Mon, Jun 13, 2011 at 12:54 PM, Vladimir Marchenko <
vladimir@marchenko.co.uk> wrote:

-------------------------------------
On Mon, Aug 22, 2011 at 10:26 PM, Fred Concklin <fconcklin@trucoin.com>wrote:



Some work has already been done for autotools (not yet merged into main
repo). You might want to start there.

https://github.com/bitcoin/bitcoin/pull/180

- Jay
-------------------------------------
+1 on git. not necessarily as replacement, but at least as backup.
could possibly use markdown and github pages, which automagically
pushes git commits out to the website (uses markdown syntax, iirc)

On Thu, Oct 27, 2011 at 11:22 AM, Nils Schneider <nils@nilsschneider.net> wrote:


-------------------------------------
BTW...

 I'm running Ubuntu 11.04 32 bits...

 When I just close the bitcoin with the network still online, I see almost
the same message:

---
martinx@floyd:~$ *./bitcoin-0.4.0rc2/bin/32/bitcoin*


************************
UNKNOWN EXCEPTION
bitcoin in CMyApp::OnUnhandledException()

Segmentation fault
martinx@floyd:~$ *lsb_release -ra*
No LSB modules are available.
Distributor ID: Ubuntu
Description: Ubuntu 11.04
Release: 11.04
Codename: natty
---

Thanks!
Thiago

2011/9/22 Martinx - $B%8%'!<%`%:(B <thiagocmartinsc@gmail.com>

-------------------------------------
Thanks for this summary Luke.

Git does not produce very helpful summaries when every commit is a merge.
Is there a way to fix that? You have to guess what a change does based on
the name of the topic branch currently.
-------------------------------------
Just for reference: https://github.com/bitcoin/bitcoin/pull/63
The issue resulted in my most useless pull request fixing two variables :-)

I second the use of sub_version_num as a Client and Version identifier.

Regards,
Chris

On Wed, Nov 2, 2011 at 11:33 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
It is analog to getting assigned a random part (based on IP) of the hashspace and then only verify transactions within this fraction.

But, there is in fact a subtle difference: If anyone can choose to verify at random, you will see lazy implementations where random means none, and as it is random you cannot, from the outside, judge if a node is taking part in the validation work or if it just benefitting from others announcements. In the hash space part, you can monitor peers and see if they did not tell you about a failed validation and then disconnect from them as they are either malicious or lazy.

Besides from that, I like a setup where we scream about failed verifications, but keep a low profile on things that actually verifies...

/M


On 22/12/2011, at 11:12, Andy Parkins wrote:





-------------------------------------
On Wed, 2011-07-27 at 09:07 -0700, Rick Wesson wrote:
Gavin leads the effort just fine (when he's not on vacation or in
Australia...) but I do agree with paying him, though I'm not sure how
much time he has to spend on development over PR and other
project-building efforts.

-------------------------------------
All,

I fully agree with Mike Hearn on this. Like email addresses, bank numbers,
phone numbers, IPv4/v6 addresses and such the bitcoin address is just an
opaque identifier for machines to be able to send each other messages.

Base58 was chosen not for human readability but to make it easy to
copy/paste.

Of course, sometimes for security reasons you may want to check the
addresses manually, but it is not the prime usage scenario. Although fun as
a nerd pasttime, I don't think we should encourage "addresses with meaning"
to normal users.

Indeed better to focus on alternative ways that don't involve typing or
even seeing the addresses.

Copy/paste of HTML content is currently not possible. You *can* already
drag&drop the bitcoin: link to the client. Bluematt has a pull request to
automatically handle bitcoin: URLs when clicked in the browser.

Wladimir

On Tue, Dec 13, 2011 at 11:38 AM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
Just so we're clear, what is the need for HTTP at all?

A query for a string and an answer can all be handled via DNS.

On Thu, Dec 15, 2011 at 4:57 PM, Zell Faze <zellfaze@yahoo.com> wrote:

-------------------------------------
On Thursday 07 July 2011 17:44:48 Mike Hearn wrote:

There is no way for a client to know in advance whether any broadcast 
transaction contains a send to an address in its wallet.  So every incoming 
transaction has to be examined.

Then, there is no way to know if while you were offline any of the 
transactions in the blocks you missed contained transactions for an address 
in your wallet.

Also, a feature I am interested in supporting is a split wallet -- where the 
private key is held elsewhere.  I'd still want to be able to report the 
current balance in a particular address though.  That address can be added 
at any time.

Also, I would like to make some blockexplorer-like facilities available to 
lightweight clients.


We're only talking about one verifying one (or minimal numbers of) blocks; 
"efficient" isn't really going to matter much in that context.  Also, if 
we're talking about a situation where we don't necessarily trust the remote, 
we've got to verify the whole block, not just the one transaction we're 
interested in, since we told the remote which one we were interested in when 
we requested it.


Is the filter going to be filter-by-address then?  I misunderstood in that 
case, I thought you were talking about filter-by-hash, which obviously tells 
you nothing about the contents of the transaction.


That's good to know.  I'm trying to be circumspect in what my client does; I 
want to be 100% compatible, which means if I need a new feature, it's got to 
be in the official client first.

I accept that this is all big talk, and there are plenty of people who start 
new clients and then give up; which might still happen to me.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Fri, Aug 5, 2011 at 12:58 PM, Christian Decker <
decker.christian@gmail.com> wrote:


Yes. Optionally layering Bitcoin over Tor/I2P is a much better option than
trying to replicate an onion network in Bitcoin itself. For one,  traffic
analysis is much more difficult if your onion routing network contains
multiple kinds of traffic. Also it would complicate the core algorithm and
waste developer time. Doing anonymity *right* is very hard. So let's leave
it to the Tor/I2P people that know what they're doing.



Except the part about making the client/network more resistant against DDoS.

JS
-------------------------------------
A few thoughts:

Should the DoS protection auto-disable if the node has less than a 
minimum number of connections? The idea being that if our node seems to 
be kicking /everybody /off the roster maybe there is something wrong 
with the protections.

It would be nice if the node sent a message to the banned peer with a 
code indicating the reason for the ban, specifically the offense that 
put Bitcoin over the edge. Logging the reason is probably fine for most 
cases, but I wanted to put the idea out there, because it might make 
debugging easier if there are some weird bans happening in the wild and 
we can't figure out why.

Should sending lots of messages that don't pass the protocol-level 
checksum test be a bannable offense? Or generally sending garbage data? 
The attacks I'm thinking of are cross-protocol attacks. So as rough 
example: The attacker puts an iframe on a website with a url like 
http://victim.com:8333 so lots of people's browsers connect to it. Maybe 
he could even use something like [magic-bytes]tx\0[...][valid orphan 
transaction] in the URL, so the browser would send GET /[magic-bytes] 
etc. and the Bitcoin node would interpret it.

kjj wrote:


Strongly disagree. What is a non-standard transaction today may /be /a 
standard transaction tomorrow.


On 9/15/2011 2:25 PM, Gavin Andresen wrote:

-------------------------------------
On Wed, 2011-08-03 at 12:04 +0200, Mike Hearn wrote:



Its actually much, much less.  You forgot to grep for filtered, which
are also worthless and you didn't make an actual connection to the node,
meaning there is no way to tell if the node has its connection slots
full (a node which has the maximum connection count will ack a syn, but
will drop the connection after the first message, so nmap thinks the
port is open).
I just tested and I show 0 accepting from bitseed.xf2.org and 0 from
bitcoin.bitcoin.co.uk.  dnsseed.bluematt.me rotates every 2 minutes to
the most recently checked so it tends to be pretty good if you get it
right after a rotate, if you wait to long, those slots fill up quick.
Point him to https://github.com/TheBlueMatt/dnsseed it could use a bit
of cleanup, but it works.
If a different DNS Server were used to could pull directly from the
database in a more dynamic way it would probably work better too (it was
originally set up on MySQL and PowerDNS, but that is quite a resource
hog compared to SQLite and BIND, but the original backend is still there
and could work if you have a beefy enough server).

Matt
-------------------------------------
On Tue, Jul 12, 2011 at 5:47 PM, Michael Offel <michael.offel@web.de> wrote:

Objectively, your believes have only the weight of the electrons they are
printed on, so long as you're talking and not coding.

I don't mean that as an insult— I'm sure many people value your ideas
but when you disagree with someone who is actually coding you'll
eventually lose every time.  Talk is cheap.

(And I'm guilty of this too— but aware of my lacking commits I'm
certainly not going to expect anyone to listen to _coding style_ advice.
 I try to keep my comments to crap I can measure and speculate about.)

[snip]

Certainly no modern SCM has major issues with merge conflicts due to
shared files.

Bitcoin is a _tiny_ piece of software... on the order of 20kloc. It's a
a scale where someone competent can read it in a day and have a basic
overall understanding of it in a few.

This fact makes the aesthetics talk seem like pointless shed-painting
especially coming from people who are yet doing substantial work.

The proposal about reimplementing parts as libraries and the switching
to them after validating them is a fine one.  I suggest you do it.
Having multiple work on such projects would not be wasted effort,
as we'd all learn from the competition in designs/APIs/and targets for
comparative testing.

The interesting logic, however, is not net.cpp... because nothing too
awful happens if peers get confused and drop their connections here
and there. The critical logic is the blockchain validation logic. Which
must make absolutely identical decisions on all nodes and which has a
lot of corner cases which are difficult to test and might expose
behavioral differences.

There is also a lot of neat functionality in the scripts which is
currently disabled because of a lack of confidence about the
security of that code.

So not only are new, clean, secondary implementations of this logic
needed, but good automatic testing shims which can find
inconsistencies between implementations.

(Testing rigs are often an excellent area of work for people new to
a project.)


-------------------------------------
I'm in favor of dropping the wxWidgets GUI and replacing it with a Qt
GUI. I think supporting more than one GUI for the reference client is
a bad idea.

Qt is LGPL, so license for that is not an issue.
John, you willing to release your code under the bitcoin MIT license?

Everybody else:  anybody object to replacing "the devil we know"
(wxWidgets) with Qt?

-- 
--
Gavin Andresen


-------------------------------------
There's a bigger problem here honestly. The p2p network is just starved for
connectable slots.

You can start up a bitcoind, on a host with sufficient connectivity, with
-maxconnections=512 and they will fill in <15 minutes.

As to why sort by version: <=3.23 has problems serving the blocks from the
last 2 months. It can take days to weeks to get the whole chain if you're
connecting to those nodes.

-- 
Douglas Huff
On Aug 3, 2011 9:18 AM, "Rick Wesson" <rick@support-intelligence.com> wrote:
them
has
DNS
wouldn't
rick@support-intelligence.com
inherently
addresses
custom
the
------------------------------------------------------------------------------
-------------------------------------
Am Mo, 24.10.2011, 16:55, schrieb Gavin Andresen:
assume that it is of the structure <sig> <pubKey> and calculate the
Bitcoin address from <pubKey>.
validate if given <sig> <pubKey> as input:  a simple OP_NOP would work
(do nothing, then check the top value on the stack and validate if it is
not zero-- and <pubKey> is not zero).

Aw, I see. So back to the drawing board for me.

How about this: I make sure that <sig> is a proper signature from a green
address key, by bringing my own scriptPubKey of just OP_CHECKSIG, complete
the script to be <sig> <pubKey> OP_CHECKSIG, and run it and afterwards
check the address by looking at <pubKey>? Would that be safe? (Even if it
is a hackish solution that only works for certain type of transactions):

scriptSig.  You'd have to hack your bitcoin client, but you could
generate a transaction that had <greensig> <sig> <pubKey>  ... as the
input instead of <sig> <pubKey>.

Interesting suggestion! So if I understand correctly, <greensig> would be
the signature generated from signing the transaction with the key of a
green address? Which would allow the rest of the transaction to be
completely 'normal' and not require it to use specific inputs as such?
Sounds good - I guess I never thought in this direction, as I always
assumed doing anything 'non-standard' with the scripting language would
create a number of knock-on problems. But you are saying, that this would
still be considered standard? I guess I have to study this part of the
source code more.

Well, I guess I'm torn a little bit between two options:

1) Get something working reasonable fast to detect current green address
style transactions. It's fine if it is a little bit of a hack, as long as
it's safe, since I don't expect it to be merged with mainline anyway at
this point.

2) Rethink how green transactions are created and verified and try to put
something 'proper' together which has a chance of being merged at some
point.

For the moment I was going more with 1) because I got the impression, that
green transactions are too controversial at this point to get them
included in mainline. Criticism ranging from 'unnecessary, as
0-confirmation transactions are fairly safe today' to 'encourages too much
centralization and therefore evil'. So how to people on this list feel
about green transactions? Would people be interested in helping me with
2)?

Regards,
Jan




-------------------------------------
Is this the ArtForz solidcoin 'attack'?

On 07/09/11 01:21, Gavin Andresen wrote:


-------------------------------------
Hello,

One problem with Bitcoin is that if large numbers of miners suddenly switch 
off, the network takes a long time to adapt (since the adaption time is a 
function of blocks generated, and the block generation rate has changed).  The 
same problem exists in the other direction, but an increased generation rate 
for a little while doesn't really do any harm.

I had this idea as a way of completely normalising the block generation rate, 
regardless of network power.  I hesitate to offer it, as I get shouted down a 
lot, but what the hell...

Let's imagine that the whole network shares a clock (which it does already).  
Let's abandon the idea of a target difficulty.  Instead, every node just 
generates the most difficulty block it can.  Simultaneously, every node is 
listening for "the most difficult block generated before time T"; with T being 
picked to be the block generation rate (10 minutes).

Every node is therefore generating blocks and comparing not against some 
moving average determined target, but rather against the most difficult 
recently received block.  If the generated block is harder than the received 
block, then it gets broadcast.

Clearly, early on in the block, the traffic would be high, but that could be 
limited with a bit of intelligence -- there's no point broadcasting your best 
blocks in minute 0 of the current block... you know everyone will beat it, as 
it was so easy.  So the rule would be broadcasts only start at T/2 plus a 
little randomisation.  There wouldn't be that many because someone will have 
generated a pretty good block by chance in the first half, and that will 
quickly stop anybody else from bothering to broadcast their easier block.  
There is no advantage to broadcasting a lesser block, so there is no incentive 
to cheat.

As always: the most difficult chain wins; and blocks with out-of-bounds times 
are rejected regardless of difficulty.  Everyone therefore has an incentive to 
base their next block on the block with highest difficulty from the previous 
period.

The block period is now guaranteed to be 10 minutes (or in fact, whatever 
period you like, there is no danger at all in changing it to 2 minutes); and 
there is no change of block generation rate with network power.  Changes in 
network power merely adjust the average difficulty of the best block per 
period.  The cost is higher network traffic, because there are block 
broadcasts that don't necessarily make it to the end.  However, there's no 
need to broadcast the full block, only the header.  If that block turns out to 
be the winner, then the other nodes will request the full block at the end of 
the period, and will check it's valid.  If it's not then the next highest on 
the list will be requested.  So again, 

I recognise that this is a pretty large change to make; and so don't really 
expect it to happen.  Perhaps one day though... when all the wishlist items go 
into one huge protocol overhaul.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Sorry for shooting this approach down, but I'm against it. User-agent
strings are an extremely bad idea as it would lead developers to start
making communication choices depending on the client type. User-Agents in
HTTP are only useful if the clients (browsers) do not adhere to a well
defined behavior. I see the version string more as a kind of vanity point
(xyz peers are using my network code) and it would be bad to base choices
on it.
For protocol choices we already have a good mechanism in place (nServices)
to negotiate capabilities.

I for one vote for keeping it as simple as possible, just a simple string,
without any further meaning.

On Sat, Nov 5, 2011 at 4:39 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
understand that not *everyone* wants or will adhere to that best
practice and in my NSHO it isn't.

-rick

2011/12/14 Luke-Jr <luke@dashjr.org>:


-------------------------------------
Right!  I'm back from the CIA, and trying to ignore all the reporters
who want to talk with me.

I want to do a quick brain dump on what I think the short-term
development priorities are.  Here's my list:

1) Scaling-up issues, like disconnections when downloading the block chain.

2) Wallet security.

3) Unit testing framework.  There was a PULL that had the start of
boost unit tests; I think that is a critical need, along with a good
suite of test cases.

Those are the big issues for me.  Anything that slows those down I'm
going to ignore (example: love the idea of escrow transactions, but I
do NOT want to add nifty new features when we're having trouble
keeping the features we're using now working properly).

Does everybody agree those are the critical priorities? (try not to
let this thread wander into a discussion of HOW to do stuff, just WHAT
the priorities aught to be)


-- 
--
Gavin Andresen
http://clearcoin.com/


-------------------------------------
On Wed, Sep 14, 2011 at 4:28 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:


Could we bundle this and potential future blockchain-splitting changes
- to implement them in a major release (down the road)? Or save them
for when they are very necessary?

TL;DR shelf it until needed, have it written just in case.

-Alex


-------------------------------------
Those indeed seems weird... I'll take a look at it.

JS

On Mon, Oct 24, 2011 at 8:55 PM, Geir Harald Hansen
<operator@bitminter.com>wrote:

-------------------------------------
On Thu, Jul 07, 2011 at 01:15:57PM +0200, Pieter Wuille wrote:

I realize my mail may have been a bit unclear. This is about the version bytes
used in addresses and other base58-encoded data structures. I'd like to see some
convention adopted before everyone starts defining their own.

The proposal in the previous mail could be summarized by the following functions
(for non-alternate chains). It is compatible with all currently-used version bytes
that i know of (testnet, realnet, addresses, private keys, namecoin, multicoin):

enum dataclass_t 
{
    address = 0,
    privkey = 4,
    masterkey = 6,
    extended = 7
}

int EncodeVersionByte(dataclass_t class, int nVersion, bool fTestNet)
{
    return (class << 5 + nVersion << 1) ^ fTestNet*111;
}

void DecodeVersionByte(int nByte, dataclass_t& class, int& nVersion, bool& fTestNet)
{
    fTestNet = false;
    if (nByte & 1)
    {
        fTestNet = true;
        nByte ^= 111;
    }
    class = (nByte & 224) >> 5;
    nVersion = (nByte & 14) >> 1;
}

-- 
Pieter



-------------------------------------
This was already discussed on the forums, but clear use cases would be helpful.

I originally thought this feature seemed like a no-brainer, but
randomly emailing money to people out of the blue is not a very common
operation. You almost always have contact with them first, if only to
say "hey, I'm going to send you some money", but more commonly to
figure out how much you're going to pay and what for.

Once you have communication, providing an address in-band isn't very
hard, and it has the advantage of always working. Doing anything with
DNS or magic HTTPS endpoints means that 90% of the time, your feature
*will not work* (eg it won't work for any gmail/yahoo/hotmail account)
and users will rapidly learn not to bother trying as they have no way
of knowing if any given address will work or not.

It's not smart UI design to provide users with a feature that will
normally never work, and for which they can't even guess at whether it
will.

What would be better to see is a standardized (probably HTTPS based)
protocol in which a Bitcoin URI could contain a domain name, and then
your client would challenge the domain to sign a nonce with the key
corresponding to the address (or raw pubkey). This means in your
client the payment can be rendered and recorded as a payment to
"foobar.com", which is much more helpful. That protocol could then be
extended to support "user@foobar.com" type challenges so when a
bitcoin: link is provided, the server is challenged to prove ownership
by that user of that public key. It means the details are hidden and
when the feature is present, the UI gets silently better, but there's
never any demand on any users to do anything different. The "copy
Bitcoin address" button in the UI can provide the clipboard with both
text/plain and text/html content so the right one is picked depending
on context.


-------------------------------------
Since you guys probably won't notice otherwise...
Got some 0.5 binaries here:
https://bitcointalk.org/index.php?topic=47586.msg573675#msg573675


-------------------------------------
scriptPubKeys that use OP_EVAL contain a hash of a script. If I
understand correctly, that means to detect a transaction in a block
that is relevant to your wallet, that means you need to pre-calculate
every possible hash that might appear.

For the case of a single payment, that's not a problem. It means for
each key you now have to check for:

 - raw key
 - key hash
 - hash of script that contains key hash
 - hash of script that contains raw key

which isn't so bad.

What is the complexity like when multi-signing comes into the picture?
I *think* it's not an issue for the use cases currently envisioned,
but being unable to "see into" a script could complicate things later.

Specifically: for a wallet protection service, you have to make sure
the WPS keys are matched 1:1 with your own private keys. You must
never mix them up otherwise you have to check the block chain for the
cross-product. Deterministic wallets are one way to achieve that
without compromising privacy.

For escrow contracts, using OP_EVAL means you cannot detect them
unless the sender has told you the pubkey they are going to use,
because otherwise you can't recreate the hashed script. Escrow
protocols require some out of band communication anyway in order to
set up the escrow key, so this isn't inherently a problem.

Are there any use cases where you will want to recognize transactions
to you, where you can't predict the full script contents?


-------------------------------------
On Thursday 04 August 2011 18:45:17 Matt Corallo wrote:

It's hardly complex.  It's exactly as it is now, with exactly the messages 
there are now, but with an extra type added to the inventory list.  A 
transaction _already_ propagates using inv messages with MSG_TX, is it 
really so "complex" to add MSG_DOUBLESPEND to the enum?  What's more it's 
backward compatible because clients that don't understand MSG_DOUBLESPEND 
will ignore the inv ending up exactly where we are now.


Vending machine, newspaper salesman, ice creams, a beer.  The list of small 
vendors is endless.  I picked Ferrari's out of the air.


I think you've missed the point.  Double spend transactions that enters the 
network at two reasonably evenly connected points are each only seen by half 
the network, since the first one locks out the second from propagation.


There is no "target" node.  There is only a vending machine listening for 
transactions.  It's unlikely that vending machines will even have incoming 
connections enabled.  They certainly won't be keeping a full copy of the 
block chain or be mining.


It is a little bit.  Your job is _first_ to figure out which are yours; 
then, as you say, to see which are going to be confirmed.  Well: once you've 
seen a transaction on the net you know it's going to be confirmed... unless 
a matching double spend transaction was accepted by the next miner to 
generate a block.


It hasn't happened, and yet it seems to be that this non-existant thing is 
your solution to the problem.


Well that's what happens now.  But that doesn't help the poor sap who's just 
handed over some goods.  I want it so that small businesses can use the 
client to give them practical answers instead of this "0/unconfirmed" stuff 
which requires understanding of the system.


I'm not really trying to prevent double spends -- bitcoin _already_ prevents 
double spends.  Also: the only difference between your suggestion (don't 
drop) and my suggestion (don't drop but mark with MSG_DOUBLESPEND) is a 
single number in the inv.  I really don't get the objection.


"In the future" is all well and good.  What if there is no future because 
bitcoin is still too difficult for average joe to use?



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Saturday, July 16, 2011 3:59:07 PM Stéphane Gimenez wrote:

It is also very broken, which is why I took the time to come up with something 
workable when I needed it ;)


"move" is positive amount, but doesn't change the actual value in the wallet.


-------------------------------------
On Sat, Dec 17, 2011 at 8:37 AM, Christian Decker
<decker.christian@gmail.com> wrote:

I strongly advise people who are not me to use this sort of scheme, so
that I may enjoy the benefits of robbing you blind.


.... But really, saying "some sort of DHT" without basically
presenting a working implementation that demonstrates the feasibility
of solving the very difficulty attack resistance problems these
schemes have basically triggers my time-wasting-idiot filter.  (Or
likewise, presenting a fixed network structure that would have a nice
small and easily identifiable min-cut...)

I don't doubt I'm completely alone in this,  though perhaps I'm more
of a jerk about it.   Even if your actual proposal might have some
merit you should be aware that every fool who has operated a
bittorrent client has heard of "DHT" and, although they may not even
understand what a hash table is, many have no reservation going around
suggesting them for _every_ distributed systems problem. Want to scale
matrix multiples? DHT! Want to validate bitcoin blocks? DHT! Network
syncup slow (because It's bound on validation related local IO)? DHT!
I suggest people solve the real problems first, then worry what name
to give the solutions. ;)

To address gavin's tragedy of the commons concern, one useful feature
would being able to mutually authenticate a peer... then full nodes
could pick and choose which lite nodes they're willing to do (a lot
of) hard work for. This would also be valuable because some modes of
lite operation require non-zero trust of the full node being queried.


-------------------------------------
On Thu, 2011-12-22 at 11:52 +0000, Andy Parkins wrote:

a node that is not doing any checking themselves can not reliably
forward failed verifications without getting the blame for doing faulty
work. Those nodes would then have the incentive not to relay the failed
verifications. This ends up making it important to know which nodes will
be checking transactions or not so you don't isolate yourself from other
nodes that are also checking transactions.

- Joel



-------------------------------------
On Sat, Dec 17, 2011 at 4:52 PM, Luke-Jr <luke@dashjr.org> wrote:

Would introduce yet another address type that services will have to cope with.

No currently deployed sofware knows how to spend it.

No currently deployed software knows how to receive it.

All pay-to-pubkey schemes (point compressed or otherwise) shift
storage to TXN _output_ scripts which are the least prunable place, so
for nodes which are pruning any pay to pubkey scheme will result in
more storage than pay to address.

Ignoring pruning, pay-to-address + key recovery is quite a bit smaller
than pay-to-compressed pubkey.

The downsides to op-eval2+recovery were the lack of software, but
we're in an equal boat with this.

Excitement over key recovery fell was diminished when it was pointed
out that it only saves space in input scripts which wasn't so
important because they're quickly prunable.  If you accept that
pruning will someday be common on many nodes then you should prefer
pay to address (since its smallest in that case).  If you assume they
won't be, you should prefer pay to address plus key recovery (since
its the smallest without pruning).

Pay to non-compressed pubkey is smaller than
pay-to-address-without-recovery assuming you don't prune, and its more
deployable because nodes can already recieve it.  It's larger if you
do prune, and it's larger than recovery either way.  Pay-to-compressed
has all the disadvantages, it still larger than recovery and doesn't
have the advantage of already deployed software.

Sorry to be curt— I'm a little irritated that discussion on recovery
in OP_EVAL was dropped because "input script size doesn't matter
because of pruning" and now people are talking about adding another
address type which creates seriously bloated transactions where there
is pruning, because its slightly smaller in the no-pruning case (and
again, still not as small for key recovery).


-------------------------------------
On Thu, Aug 25, 2011 at 3:39 AM, Michael Grnager <gronager@ceptacle.com> wrote:

Nope.

I should have been more clear in my initial email and in the
proposal-- I am not proposing anything more than just agreeing on the
very lowest-level infrastructure, so there is a solid foundation upon
which we can build a couple of key very-high-priority features.

I wanted to talk about it now so there is rough consensus on what to
put on the road map, and to get as many smart brains looking at the
proposal and making it as good as possible.  Current proposal is at:
  https://gist.github.com/39158239e36f6af69d6f

I have two issues with it:

1) groffer reports that there's a bug in CHECKMULTISIG (pops too many
arguments off the stack), so perhaps we should avoid using it at all.
Fixing the bug would change its behavior, and is not an option because
that would cause a blockchain split. We absolutely need unit tests and
better documentation for how CHECKMULTISIG behaves (perhaps it is
working as intended, and Satoshi just messed up the description of
what it does in the comment).

2) How often will the 1-of-3 and 3-of-3 cases be used? I included them
just for completeness, but perhaps they should be dropped for now so
there is less code to write and test.  I just don't imagine there are
many cases where you have exactly three parties and 1-of-3 or 3-of-3
are required to spend.


-- 
--
Gavin Andresen


-------------------------------------
I don't really get what you want to achieve with this. The protocol will be
slow down evolution (hopefully) soon, while the clients will continue
releasing at a similar rhythm. It took long enough to decouple the protocol
version from being bumped each client release, now doing the inverse
coupling makes no sense.

Regards,
Chris
On Wed, Nov 2, 2011 at 10:23 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
On Wed, Aug 24, 2011 at 1:07 PM, Rick Wesson
<rick@support-intelligence.com> wrote:

Can you provide a reference to this 'demand' a post by Luke isn't
enough to support the claim of demand.

We're not at maximum size right now (thankfully).

We don't know what the network dynamics would look like at that
traffic level. So how could we competently say what the right metrics
would be to get the right behavior there?  Thats what I meant by too
early.


-------------------------------------
Am I the only one to think putting pools at a disadvantage is actually
desirable?
Back when pools started to appear we all had huge reservations about putting
so much control into the hands of a few pool operators, but nowadays it
seems that having pool operators control a vast majority of the
computational power is desired.
I do like pools (I use them myself), but we should put the security of the
protocol in first place and then only think about individual players.
Always remember that the problems pool operators encounter are likely also
the ones of a potential attacker that tries to accumulate 50%+ of the
network power :-)

Regards,
Chris
On Wed, Sep 14, 2011 at 5:43 PM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
On Mon, Sep 19, 2011 at 8:20 PM, Alex Waters <ampedal@gmail.com> wrote:


We need to avoid a user/contributor experience of:  "my pull request
was abruptly closed with no warning"

Contributors might not track the state of the tree on a day-to-day
basis.  Thus, following the example of bugzilla.redhat.com and many
other "tracker" applications, outdated issues first initiate an
automated warning email -- usually by adding a comment to the bug
report -- that describes the policy, why the policy (closing outdated
reports) exists, and how to avoid automated report closure.

In our case, this means a "we will close pull req, unless you update
this commit in 15 days" comment should be added to the pull req.  The
comment should describe in broad terms, with links, how to rebase a
commit, what standard expectations are, etc.

Closing with no warning should be avoided.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Jan,

On Thu, Jun 23, 2011 at 9:51 PM, <jan@uos.de> wrote:


I think the easiest way to speed this up would be to scan the wallet every
time a block comes in or something else changes in the block chain (or, if
you prefer, some pre-set interval of N minutes). Then go over the entire
wallet and the accumulate balances for all accounts. This could be done in
amortized linear time using a hash_map.

1) This reduces the time the API takes to return the balance for an account
to a predictable, very short time. Just the time to look up the balance in
the hash table (and return 0 on miss). The number crunching happens in the
network thread, not while you're waiting on the API.

2) Less bug-prone than "incremental caching" as you propose, and doesn't
require determining which accounts are influenced by a new block

3) Block chain reorgs are no problem.

JS
-------------------------------------

Are you sure you want to require qmake for the daemon build?

I agree having a unified build system would be nice, but qmake doesn't add
anything for non-qt software. Better to stick with a makefile.

If the goal is 'making it easier for the user' maybe it'd be best to make a
bash script that wraps both, that builds the daemon if possible, and the UI
if possible, and converts command line flags.

JS
-------------------------------------
I'm looking for review of this pull request:
  https://github.com/bitcoin/bitcoin/pull/517

The big idea: if a peer is sending you obviously wrong information,
punish it by maybe dropping your connection to it, and ban it's IP
address so it cannot immediately re-connect.

The probability of dropping the connection, and the length of the ban,
depend on how how potentially wasteful/damaging the peer is behaving.
So sending an extra 'version' message is a minor transgression that is
usually tolerated, sending a more-than MAX_BLOCK_SIZE block is a major
transgression that gets the peer disconnected immediately.

Detailed how-it-works, using "I got a version message I wasn't
expecting" as the specific example:

Getting an unexpected version message from a peer increases that
peer's 'misbehaving' score by 10, and (assuming that is the peer's
first bad behavior) gives it a 10% chance of being disconnected.  If
it is disconnected, then that peer's IP address is banned from
connecting for a couple of hours.  If it is not disconnected, then
nothing happens unless the peer misbehaves again; if it does, then its
chances of being disconnected go up, and the length of time it will be
banned increases.

Misbehavior/ban information is stored only in memory, and information
about misbehaving peers is never broadcast. Also, peers that are
disconnected/banned are just dropped, there is no warning or reason
sent.

I think this will eliminate a lot of potential denial-of-service
attacks, and could be a good framework for responding to other
potential attacks. "We" should still look through the code and limit
the potential size of any data structures that an attacker might
target (transaction pool, orphan block pool); the DoSprevention
changes are meant to make it harder for an attacker to stay connected
long enough to pull off an attack.

The danger is that I got something wrong; what if an attacker can
leverage the DoSprevention code to split or shatter the network?
Here's my thinking on that, please help check my work:

+ I'm relying on TCP to prevent IP address spoofing (otherwise an
attacker could force you to disconnect from your peers by pretending
to be them and sending you a bad block).

+ Peers are only penalized for sending messages that won't, and
shouldn't, get relayed. So an attacker shouldn't be able to poison the
network with a bad message that is propogated and then causes
everybody to disconnect from everybody else.

+ I specifically do not punish peers for relaying what look like
double-spend transactions. If I did, then an attacker could try to
segment the network into two pieces by broadcasting a series of
double-spends from two halves of the network, and waiting until the
nodes "in the middle" disconnected/banned across the 'seam'.

So: please let me know if or how I'm being an idiot.

-- 
--
Gavin Andresen


-------------------------------------
I still think HTTPS should be used, at the minimum. Using HTTPS is 
standard to every website out there that deals with financials, even if 
it is not a perfect system. Why should Bitcoin adopt a more lax policy 
than everyone else?

I thought that JSON support was fairly common these days. I personally 
prefer XML in most cases, but since JSON is already used with the RPC, 
it seemed like a natural fit here. Binary data can be base64 encoded, 
although I'm not sure why you would need to send back binary in an alias 
response.

What exactly do you mean by "custom output script"?


On 12/19/2011 8:30 AM, Luke-Jr wrote:


-------------------------------------
On Tuesday, September 27, 2011 11:44:43 PM Jeff Garzik wrote:

I'm aware of that.


Ok. That's not usually how versions work, though. Gavin also recently stated 
that the next version after 0.4.0 was to be 0.5, which is why the commit was a 
surprise. I'm just trying to clarify what version number to use for stable, 
and getting apparently mixed answers.


Yep.


-------------------------------------
Maybe I wasn't clear enough in the document, but this is the intent with the HTTPS proposal.

genjix@foo.org

Contacts https://foo.org/bitcoin-alias/?handle=genjix and the system responds with a bitcoin address. Whether the system gives you a new address from a pool of addresses, or contacts the merchant behind the scenes is implementation defined.

I'll clarify it later. This is the relevant line:

string strRequestUrl = strDomain + "/bitcoin-alias/?handle=" + pszEncodedNick;

Between HTTPS service and server service, I lean slightly towards HTTPS (automatic encrypted connection, CAs + all benefits of DNS). But still interested in arguments in favour of a server service (daemon answering queries).


----- Original Message -----
From: Gavin Andresen <gavinandresen@gmail.com>
To: Jorge Timn <timon.elviejo@gmail.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Tuesday, December 13, 2011 1:06 PM
Subject: Re: [Bitcoin-development] Fwd: [BIP 15] Aliases

I agree with Mike Hearn and Christian Decker-- paying to
'somebody@foo.com' should become, behind the scenes, a HTTPS query to
https://foo.com/something. If you just want to (say) donate to
eff.org, then paying to '@eff.org' aught to work nicely.

And if namecoin ever takes off you'll pay to 'somebody@foo.bit'.

It seems to me that if it was DNS-based, the address should be
something like 'somebody.bitcoin.foo.com'. But I think it is unlikely
people will setup and run a custom DNS server just to support bitcoin
payments.

-- 
--
Gavin Andresen

------------------------------------------------------------------------------
Systems Optimization Self Assessment
Improve efficiency and utilization of IT resources. Drive out cost and 
improve service delivery. Take 5 minutes to use this Systems Optimization 
Self Assessment. http://www.accelacomm.com/jaw/sdnl/114/51450054/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
Amir started the "get more formal about changes to bitcoin" ball
rolling by creating BIP 0001, starting from the Python "PEP" /
BitTorrent "BEP" processes:
  https://en.bitcoin.it/w/index.php?title=BIP_0001

The idea is to use BIPs for changes that may or will affect every
bitcoin implementation (not to use them for proposed changes to one
particular implementation).

I'd like to propose some minor changes to the process:

 I propose that BIPs be wiki pages, with a social convention that the
Author gets final word if any editing wars break out.

 If he's willing, I propose that Amir take the role of BIP editor.

 I think bitcoin is still too small to have a specialized
"bitcoin-ideas" mailing list; I propose that new potential BIPs be
discussed either here or on the bitcoin-dev mailing list.

What do y'all think?

-- 
--
Gavin Andresen


-------------------------------------

Yes - by the burdensome address ;) - which I am not sure I consider that much of a trouble, for practical uses... Anyway, it could just be added to the URI scheme and then it would still only be a click away.


So far we had by the standard transactions a nice bijection, I do however, share your concern for other and more rich scripting... And here we need to make some choices! 
Do we want to keep this notion of transactions between addresses or do we want to start unfold the richness of the scripting - I am not sure we actually gain that much from OP_EVAL and the extra scripting. And what bothers me is that you then cannot define a set of data (be that key, scripts or whatever) from which you can obtain all possible txes send to you. If I e.g. looses this argument and want to donate a beer to each of you and Gavin, that I want you to drink together. I would make a "both of two" btc-addresses script transaction using OP_EVAL. And post it.
You would then not be able to know that you actually got a beer unless I told you so in a mail.

This means that we move from a setup where transactions needs not only to be asked for but also they need to be announced by the sender. I don't like this... 

Further, if you make a uint160 from a OP_EVAL script and post this as a bitcoin address - the user should then know that this was a special address - otherwise he would be sending money nowhere. I agree that this could be encoded into the bitcoin address using e.g. a 2... instead of a 3..., but as you mention yourself this is only the start of the OP_EVAL uses and hence you would need a whole series of strange numbering to define what script a specific address was referring to. 

At least it challenges my esthetics...

Cheers,

M

-------------------------------------
On Sat, September 3, 2011 09:04, John Smith wrote:

I think its best. The old version I wrote in Perl using some rather rarely
used perl modules from cpan that don't have packages in either opensuse
nor ubuntu. I've moved most of my other new development projects to Python
or C++ for a long time, so Python has become much more natural for me to
work in, while migrating all perl module usage to a packaging compatible
set would also be a pretty large task.
learned from the existing MinorFs and do a rewrite in Python, making sure
all python modules used are available in both OpenSuse and ubuntu.


MinorFs IS basically a set of user space file-systems on top of current
UNIX/ACL permissions. Without further changes with application granularity
and without delegation of sub-trees, the two are basically equivalent.

The plans I currently have will allow a migration path from such a model
to one with a finer granularity level where sub systems delegate sub trees
to eachother in a pass by reference way.






-------------------------------------
On Mon, Sep 19, 2011 at 8:49 AM, Gavin Andresen <gavinandresen@gmail.com> wrote:

I think the primary concern that they are attempting to address there
is providing a stable base bitcoind for miners, banks, and webservices
to apply their patches on top of.

Right now, if they want to keep up with development they are stuck
forward porting against often disruptive changes as just about
everyone running something of importance needs some patch or another
so you have people who are clearly in the know like Luke and tcatm
trailing development on some of their systems by many months.

This isn't healthy for the network.

I'm not convinced a bugfixes only branch will help much: Even bug fixes
will disrupt local fixes, and testing and supervising your upgrade usually
takes more effort than the forward porting.

I'd rather see more effort put into mainlining the changes people are
carrying sooner and restructuring code to better accommodate patches
which aren't suitable for mainline.  This will also encourage people
to make the fixes they're running publicly available, rather than
just keeping them private for competitive advantage.


-------------------------------------
On Thu, Aug 4, 2011 at 6:10 PM, Stefan Thomas <moon@justmoon.de> wrote:

Except for the fact that such a party is a DOS attack on the network
which is already short on functioning listeners.  I don't have much
doubt that people doing the "connect to everyone" are already causing
harm. There are some nodes in .ru/.ua which aggressively connect to me
(instant reconnects if I hang up on them) which have never passed me a
transaction in all my available logs.

Alerts scale better— both can have a place in the ecosystem, they're
actually complementary: Alerts are vulnerable to filtering by sibyl
attackers but they have deeper network penetration and where filtering
doesn't prevent them you don't need a connection to hear them.


-------------------------------------
On Mon, Dec 12, 2011 at 02:21:09PM -0800, Amir Taaki wrote:

Interesting discussion so far, with many nice ideas.

I'll try to give my opinion and comment on some in batch here.

First of all, I'm a big proponent of moving away from using base58 strings
as addresses. They are not flexible and not human-friendly. I did an own
proposal to improve the situation some time ago, see

  https://gist.github.com/1237788

There was little reaction, and maybe the reason is we shouldn't try to solve/fix
everything at once.

a) IP transactions-like system with DNS resolution

Not only does this give you nice identifiers, but it also moves the
responsibility of getting the transaction accepted by the network from the
sender to the receiver - the one who actually cares about getting his
money.

The authentication problem that was present in the original IP transactions
system can either be mitigated by trusting the existing SSL public-key
intrastructure (which not everyone may like) or (as Satoshi suggested) adding
bitcoin address-based authentication on top (separate from the address used in
the transaction itself). So you get an identifier like <url>$<btcaddress>, and
the communication to <url> would be authenticated using <btcaddress>. This
is obviously not useful as human-typable alias, but is no problem for
clickable URLs on websites that want to provide the additional security.

I'm not sure about using the bitcoin p2p protocol here - i think there are
easier (or at least more widely deployed) protocols like HTTP. So maybe ...

b) HTTPS Web Service

we can just use an HTTPS web service, that provides the bitcoin address to
be used in the transaction to a client that queries a URL. This immediately
makes the identifier double as a clickable URL, and a merchant could add
metadata to the URL to make the transaction easily trackable.

As for the possibility for spoofing: relying on DNSSEC is currently
difficult i believe (though i'm not entirely up-to-date about its
deployment). Again, alternatives are the SSL PKI, or bitcoin address-based
authentication (basically doing SSL but using bitcoin pubkeys to
authenticate)

c) user@hostname-like identifiers

These look very good, and conveniently match the e-mail system's identifiers.
However, I believe they are only useful for one purpose: user-to-user
payments. For anything somewhat more business-y you probably want to use
a clickable URL, and hide all address information entirely from the user.
Still, for user-to-user payments they are nice.

I'm not convinced about the hardcoding of the "https://" and
"/bitcoin-alias/?handle=" parts, though. These seem very arbitrarily
chosen to me, but if you consider an HTTPS-based variant of a bitcoin
ip-transactions-like system, the proposed "account" parameter to
checkorder would probably become a CGI parameter anyway...

d) DNS TXT lookups

I'm not entirely against this, but only allowing a fixed bitcoin address
to be returned would far too strongly encourage the use of fixed
addresses in transactions. If anything, it should be an identifier
for one of the other proposals (which do allow interaction, or at least
creation of a fresh bitcoin address) that is returned. 



To conclude: my suggestion would be to use URLs as address identifiers,
optionally suffixed with a bitcoin address for authentication.
This means my "address" would be either "sipa.be/pw.btc" or
"sipa.be/pw.btc$14TYdpodQQDKVgvUUcpaMzjJwhQ4KYsipa" (where "https://")
is an implicit default. Initiating a payment to either of these would
result in a GET of https://sipa.be/pw.btc. When a transaction is
constructed, it is POSTed back to that URL.

If we can agree on reasonable hardcoded mapping, pw@sipa.be could just
be a shorthand for either of these (though vulnerable to proofing...).

-- 
Pieter



-------------------------------------
I've made a couple recent posts that were intended for the Protocol
extensions thread but have been put in new threads. What part of the
email message is used to identify the thread to which it belongs? I
would have thought the subject, but apparently it isn't.


-------------------------------------
Would it be possible to port some of the existing translations?

Well, the strings in the core can be reused one-on-one as the _ function is
mapped to the Qt translation function.

And some of the UI texts probably can be reused as well, at least for a
rough approximation.

The files will have to be converted, as Qt uses an XML-based format whereas
Wx uses a line-based one. Also, Qt translations have a "context"
(file/object) defined whereas in Wx the "msgid" is only the English text.
Nah, nothing that a bit of Python hacking can't solve.

Though IMHO its not a huge deal if qt is merged without all the

Exactly... if there is some time between Qt being merged and Wx being phased
out, translations can be added. The Qt translation tool (Qt Linguist) is
user friendly enough to be used by anyone.


Sounds fine with me,

JS
-------------------------------------

Does this mean dispute mediation (2-of-3) will not be supported? I thought
the plan was also to allow CHECKMULTISIG for smallish numbers of keys.
-------------------------------------
There is one issue holding up a 0.5.0/0.4.1 final release:  I've seen
a couple of bug reports of crashes on startup when re-encrypting
previously encrypted wallets on Linux64 systems.

I've tried to reproduce on Ubuntu 10.10 server and "it worked for me"
-- so I need help figuring out what is going on (is it only bitcoin-qt
that is crashing? Is Ubuntu OK but other linux variations broken?
etc)

-- 
--
Gavin Andresen


-------------------------------------
Brian,

Yea, I vaguely remember going through all this when I first tried building it.  If I recall you can statically link libz into crypto when you compile crypto.  Or something like that.  Maybe the default MacPorts crypto install does not do this.

Eric

-- 
Eric Mockensturm, Ph.D.
Associate Professor
Department of Mechanical & Nuclear Engineering
The Pennsylvania State University
157C Hammond Building
University Park, PA  16802
Email:  emm10@psu.edu
Phone/Fax:  (814) 863-0736/7222


On Oct 6, 2011, at 6:18 PM, Brian McQueen wrote:


-------------------------------------
On Wed, Aug 10, 2011 at 5:13 PM, Andy Parkins <andyparkins@gmail.com> wrote:

Breaking backwards compatibility means breaking people's access to
their own money.

If you remove an "unnecessary" step that existing nodes expect, then
the cost of disrupting monetary access seems higher than the value of
that breaking change.



My own 'supernode' proposal also includes using the nServices bits.
There's nothing fundamentally incompatible or wrong about that.


Compatibility issues?


I could see value in querying a bitcoind node over JSON-RPC for
pending transactions... and by extension, supporting that as an RPC on
various miners' pool servers.  Having a local dump of pending TX's
would be useful.

As an optional bitcoin P2P protocol command, available to anyone,
seems to negatively impact privacy.


Consensus has already approved this one, AFAIK.


Do you mean headers without bodies?  Gavin wants to work on
headers-only, from what I've read, but others are welcome to
contribute patches.


Compatibility issues?


Compatibility issues?


Compatibility issues?


Does consensus want this?


Link to elaboration of use case and need?



Well, one unfortunate current aspect of bitcoin is...  there seem to
be problems aplenty right now :)

However demotivating it may be, keeping the current system running
must take priority over new features.

I also heartily encourage others to do something I always want to do,
but for lack of time:  work on the design for bitcoin v2 ("theme: any
breaking change is acceptable, it is a new block chain")  There you
may improve the protocol, get rid of the patent-cloudy ECDSA, use
google's protocol buffers for encoding, make the proof-of-work
algorithm memory-intensive, and other excellent, thoughtful
breaking-change suggestions that have been made.

Securing the integrity of money means that a lot of implementation
decisions have been cemented into stone, however much we may
personally dislike them.  Backwards compatibility is paramount.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------


Thanks for your support. This is a noble ideal and will ensure bitcoin's eventual success by serving as a neutral platform for discussions.

One step I've taken in this direction is to setup a process for proposing changes to the bitcoin protocol. See my other email to this list and this url:

 https://en.bitcoin.it/wiki/Bitcoin_Enhancement_Proposals

The first proposal BEP 0001 is copied from Python's PEP 0001 and is a good starting point. I've marked it as a draft since it's only a non-working proposal. After that with mutual consent and discussion, we can move it to active status and start to think about setting up an arbitration committee.

We should in general favour long discussion over voting. The Wikipedia model for resolving issues through hammering out details is superior to debian with a cycling board of voting members.

The bittorrent page looks like a good future ideal to model ourselves off of and the EP pages too:

 http://bittorrent.org/beps/bep_0000.html

BEP 0001 needs review and comments. As you can see, bittorrent did the exact same thing here (copying the PEP process) with success:

 http://bittorrent.org/beps/bep_0001.html

genjix / Amir Taaki



-------------------------------------
Oups - I was reading the code wrongly - going through AddSupportingTransactions carefully again...

The vtxPrev contains a list of the supporting confirmations up to 3 confirmations back. So it is only of relevance (and only gets filled) if you accept coins that are less than 3 confirmations old. In this case you would like to resend the depending transactions to the network in case of chain splits.

This makes much more sense, but also, it is only of relevance when you accept newly earned coins. And it will only be of relevance for half an hour or so.

Cheers,

Michael



On 05/10/2011, at 14:50, Gregory Maxwell wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------
On Jul 10, 2011, at 5:37 PM, Michael Offel wrote:


I've actually offered (on irc) to fix the latter a few times and been told that a pull removing implementations from the headers would not be merged so have not wasted the effort. (Because it's a rather large one.) Not only does this cause long build times it makes adding new code in the logically "right" places nearly impossible due to the build deps.

I agree with pretty much the entirety of your post and think all of it needs to be discussed further and addressed.

-- 
Douglas Huff


-------------------------------------
On Fri, Jun 17, 2011 at 06:42:30AM +0000, John Smith wrote:

I'm in favor of merging autotools now, unless there are still known issues with
it, such as mingw32 compatibility?

If the Qt port is functionally complete and stable, I'd vote to have it merged as
well under these conditions:
* the changes to the 'core' are minimal/trivial
* marked as 'experimental', and not enabled by default

The only disadvantage of another GUI is that the (necessary) cleanup of RPC/GUI
code will now need makes changes in 3 places instead of 2, but as I understand
it, there are much more people willing to work on Qt code than on wx code?

-- 
Pieter


-------------------------------------
0.3.24 RC3 tar uploaded to http://dl.dropbox.com/u/29653426/Bitcoin%
200.3.24%20RC3.tar.bz2

I still disagree that 0.3.24 shouldn't handle incompatible wallets
cleanly, but I digress.

SHA1:
af85f46201bfffaf38fe4d64f3aa357ac03b51e1 Bitcoin 0.3.24 RC3.tar.bz2

Notes:
gitian-win32.yml is broken (my fault) just remove the lines
  cp WSPiApi.h $HOME/build
  #
and you should be on the same one as me.

Build gitian signed and email signed as always,
Matt
-------------------------------------
On Monday, December 19, 2011 2:56:09 AM Jorge Timn wrote:

I'd prefer we stick to simple standards.
HTTP alone should really be fine to build on...

JSON in particular has very poor language support, and cannot reasonably 
represent binary data (such as a custom output script). The HTTP 
specification, however, allows binary data in multipart content just fine.


-------------------------------------
I can't speak for Namecoin. As for the HTTPS requirement, I'm on the 
fence. Without it, the resolution is open to a man in the middle attack. 
Perhaps HTTPS should be required, and if HTTP is used, a large warning 
message is displayed.

As for the answered message format, is JSON the assumed structure that 
would be used?


On 12/18/2011 1:05 PM, Jorge Timn wrote:


-------------------------------------
On Wed, 2011-08-03 at 10:48 -0400, Gregory Maxwell wrote:
They were redone in .24 to the point that they should not cause any such
issues in the future.
Agreed.



-------------------------------------
Sure.

On Tue, Jun 28, 2011 at 2:49 AM, solar <laszlo.hanyecz@heliacal.net> wrote:


-------------------------------------
On Thursday, June 30, 2011 11:23:56 PM Jeff Garzik wrote:

There seems to be a new version at:
	http://davids.webmaster.com/~davids/bitcoin-4diff.txt
I haven't compared them yet.

For the "3diff" version, I extracted and made proper git branches for each 
logical part:
  hub_mode
  threaded_rpc
  \-- rpc_keepalive (depends on threaded_rpc, or a single connection would
                     keep the JSON-RPC interface locked up)
  signal_blk_notify (generic version of -pollpidfile, with a bugfix)
  bugfix_CreateThread_leak
  getwork_dedupe (original branch for my bugfix)

In addition, I also consider these branches valid candidates for merging:
  coinbaser (popens a given command and reads coinbase outputs from stdout)
  gitignore (ignore some common misc files)
  minfee_modes (internal function changes to allow specifying different fees
                for relay, send, or accept-in-block)
  \-- eligius_relay (relay lower fees only Eligius will accept)
      \-- eligius_sendfee (send lower fees only Eligius will accept)
  txinfo (adds entries to getinfo for transactions accepted for relaying,
          transactions accepted for the current block-in-progress, and current
          block-in-progress size)
  bitcoinuri (compliant support for all bitcoin: URIs)

All available from git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git


-------------------------------------
On Thu, Aug 11, 2011 at 12:19:45PM +0000, John Smith wrote:

I think there are a lot of misunderstandings here. Given your clarification
that you simply wanted to remove the RPC client from the gui/daemon executable,
I'm all for it. If I reread the answers, there is only "mild against" and a "no"
that was based on a partial misunderstanding.

Somehow it seems that many discussions in which some negative remarks were made
just die out, and the person originally suggesting it takes this as a "shot
down". Maybe (and that includes myself) we should be more outspoken about ideas
we do like.

As for the rest of this thread: i think some dev branch (either something
linux-next like, or a separate official branch, or something else) is indeed
very needed. The main tree should definitely be dealt with in a conservative
way, but it's hard to make progress if you know that every patch that does
some internal changes will need many rebasings and maintainance before it's
actually merged and finally tested by some larger user base.

Considering the issue of backward incompatible changes to the protocol: there is
no denying that there are some serious deficiencies now (double sha256 checksums,
the handling of the data being signed) and redundant things (magic bytes, verack).

Yes, it is true that we could change these in the future with a (nBlocks >= X)
test, but that would still mean you carry around both the old and the new code
until at least block height X. Additionally, if you get another (better) idea
that supercedes it somewhere between now and block X, you're still forced to
first switch to the intermediate one, as some clients may not have upgraded...

This is not to say this isn't an option we should consider, but for now, it just
doesn't seem worth the hassle to me. There may come a day where we absolutely
need a change to the protocol, and when we do, maybe it is time to fix all these
"known and agreed upon defficiencies". It's definitely useful to discuss these,
and in the context of "for when we do an incompatible change", no "breaks backward
compatibility!" argument is valid. I'm in favor of wiki page where these are listed,
together with pro and cons.

-- 
Pieter


-------------------------------------
I'm getting an intermittent crashes on bitcoin-qt.exe when doing RPC 
commands. I seem to be able to get it to occur most frequently when I 
send a bunch of RPC commands in rapid succession. I have never 
encountered it with "getbalance", but I have with some other commands. 
Sending a single letter as the command seems to trigger the crash most 
often.

I was unable to generate the crash using 0.4.1.

I was unable to find an issue logged for this, although I wonder if it 
is related to https://github.com/bitcoin/bitcoin/issues/639

Can anyone make suggestion on any other debug information I can gather 
before submitting an issue?



Windows 7 x64
Bitcoin 0.5 rc5

Faulting application name: bitcoin-qt.exe, version: 0.0.0.0, time stamp: 
0x4d44aa00
Faulting module name: bitcoin-qt.exe, version: 0.0.0.0, time stamp: 
0x4d44aa00
Exception code: 0x40000015
Fault offset: 0x00e4b7fa
Faulting process id: 0xf80
Faulting application start time: 0x01cca56065158dac
Faulting application path: 
C:\Users\jmack\Desktop\bitcoin-0.5.0rc5-win32\bitcoin-qt.exe
Faulting module path: 
C:\Users\jmack\Desktop\bitcoin-0.5.0rc5-win32\bitcoin-qt.exe
Report Id: 050b54aa-1155-11e1-86c0-f46d0496aff0



On 11/16/2011 8:34 AM, Gavin Andresen wrote:
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.1/test/
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/test/



-------------------------------------
On Sunday, December 18, 2011 4:05:11 PM Jorge Timn wrote:

How are you going to authenticate the host? Certificates from CAs are how 
HTTPS does it. HTTP is vulnerable. If the URI contains an address (eg, 
bitcoin://remotehost/base58key), the remote host could sign its (self-signed) 
SSL key with the ECDSA key to prove authenticity. DNSSEC/namecoin presumably 
has some way to do this as well.


At some point, a proper protocol to negotiate payment is needed for anything 
like this.


-------------------------------------
Could we just get the forum link removed entirely?  The current Google
search link does very little to disassociate the forum from the Bitcoin
project.  There's no need to have a forum link anyway, as there's
already a link to the wiki, which links to the forum, and can be edited
to link to other unofficial forums as well.

I just came across a thread by someone offering to sell a bitcoin mining
virus:

<http://forum.bitcoin.org/index.php?topic=21524.0>

I know there'd been complaints about illegal activity, but this is a
whole new level of bad PR compared to people just offering to sell
drugs.  Especially when there are responses like:

"Excuse me while I put this on every computer at my school."

"This would be so awesome if I could install it at every computer in my
college lab. So many bitcoins for me."

It doesn't just look like some one-off cybercriminal spam, it looks like
forum members in general support this kind of thing.

-------------------------------------
I'm offering patches for DNS lookup, which seems good enough to locate
the irc server but not good enough for the folks that use copy/paste.

from a usability standpoint, the clipboard isn't a UI element in flow
design. Its also subject to MITM attacks for the most popular OSes.

Finally, think beyond you and your friends to how you can buy coffee
at starbucks easier and faster than with a starbucks card. Thats how
you make successful apps and protocols.

Has anyone offered to write the mythical
https-address-resolver-easy-button for bitcoind?

-rick


On Sat, Jul 30, 2011 at 4:34 AM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
On 2011 July 07 Thursday, Mike Hearn wrote:

Ah; you mistake me.  I'm not interested in double spend prevention, in this 
case I'd be willing to trust the full node to return whatever block it thinks 
contains that transaction, and that it has already done double spend 
prevention.

What I want to be able to do though is calculate a balance for an aribtrary 
address.  Not every address; just the particular ones that the client is 
interested in.  It's complete overkill to require the whole block chain just 
to calculate the balance of a few addresses.


Not entirely.  If I ask for "the block that contains transaction with hash 
12345678abcd..." then when I get that full block, I can verify the merkle tree 
myself.  I do have to trust that the peer hasn't been adding double spends in, 
but not that the transaction is actually in the chain.


I'm sorry, I've only started watching this list in the last few days.  I'm not 
familiar with the filter suggestions.

I'm not entirely sure I see how a filter helps.  If I've been offline for ten 
minutes then I need all the transactions pending in the last ten minutes.  No 
amount of filtering makes that list any smaller.


That would be fine.  My reason for suggesting using getblocks was that it 
didn't introduce a new command.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Thu, 2011-09-08 at 09:09 -0700, David Perry wrote:
Gavin does
Meh, why make the key-holder send out two alerts for old clients and new
clients.  I also highly doubt satoshi would let his key get compromised.
That said, keep in mind they are literally just messages, they make no
functional difference.



-------------------------------------
Michael, thanks for taking time to read the proposal.  Responses are 
inline, below.
The txout scripts are not just handy, they /need/ to be included in the 
txin scripts for signing.  By putting them there already, the parser 
only has to blank out the others txins, add the hashcode, and pass it to 
the ECDSA code for signing (if you're not familar with OP_CHECKSIG, see 
my diagram here <https://bitcointalk.org/index.php?topic=29416.0>).  I 
think this feature is *critical* to adoption, as it works for the most 
lightweight clients that might not even contain blockheaders -- 
everything you need to understand and sign the the transaction is 
included (except for the txin values).

For that reason, this doubles as a convenient way to do offline 
wallets/signing:  you don't have to keep transporting 700 MB of 
blockchain to the offline computer just so it can sign your transactions.
I see the benefit of JSON for dynamic information with lots of optional 
fields.  But this information is fairly static -- if there's extra 
information developers need for this process, it can be added.  I don't 
see a lot of variation in the amount/types of data to be included here.

The core benefit follows PGP messages:  compact, easy-to-identify, 
blocks of text, that can be included inline in an email as easily as it 
can be supplied as a file/attachment, and only requires code that's 
already available in a BTC developer toolbox.  I can even remove the 
numsigs counter, as it's easy enough to search for the END-TXDP line.  
Think about a non-developer opening a file and trying to identify it:  
JSON looks like code, this looks like... "----BEGIN-TXDP---"  (now that 
I think about it, "BEGIN-TRANSACTION-9fj3fsQ" might be better...)
If we start talking about in-blockchain techniques, I agree with you.  
But If that idea is discarded, *all* out-of-band solutions are going to 
require encoding this exact information somehow.  I think offering this 
solution before developers start asking the question of how to do it is 
exactly what's needed.

-Alan

-------------------------------------
On Sat, Jul 02, 2011 at 07:29:04AM +0000, John Smith wrote:

I have no preference for any particular project build system. If a system
* is easy enough to set up (included in standard repositories, eg.)
* allows building of the bitcoin codebase on several linux distro's
* does cross-compilation to windows
* supports osx
* is easy to maintain
* it is not too hard to adapt other GUI's to use it (bitcoin-qt,
  maybe others as well, i hear about a cocoabitcoin?)
* gets implemented and tested to support all of the above
.. i have no problem with choosing that system for future versions.

-- 
Pieter



-------------------------------------
On Wednesday, August 10, 2011 1:45:42 PM John Smith wrote:

It seems there's room for some kind of "experimental" branch as well, 
including features that might not make it into any stable release (due to lack 
of use/interest or whatever).


-------------------------------------
On Wed, Dec 21, 2011 at 11:45 AM, Luke-Jr <luke@dashjr.org> wrote:

This is not "accepted" as discussed yesterday on IRC.  You need to
find buy-in from some other miners to make sure this is what "they"
want, rather than just what "you" want.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On 2011 November 23 Wednesday, Gavin Andresen wrote:


Good points.  I don't think I have a response to that one.

I saw the "I got lucky" result as a benefit, as it made it harder to fork the 
chain.  We got an advantage from the luck.

I'll have to abandon this suggestion.  It's not going to work.

Thanks for the feedback everyone.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------


A URI identifies a resource and is in effect an alias itself.
Identifying a resource is different from interacting with it. So,
while <resource-type>://<resource-type-specific-alias> will work
sufficiently for the identification, it does not explain the
interaction.

Interaction is a requirement, since there seems to be a widely felt
need to preserve anonymity through the use of temporary addresses.
Generating a temporary address requires some actual processing to
achieve, since the issuing of the new address cannot be done without
interacting with the entity hosting the wallet (unless I'm missing
something?).


This is not the case. Please read my earlier response to Gavin and the
IIBAN specification itself to clarify.  That would be a total breach
of privacy since the entity would have access to financial information
on all transactions using the IIBAN identifiers... prior to
transactions being executed.

It *is* true that under the current IIBAN proposal there would be one
entity (IANA) in charge of issuing namespace portions ('institution
codes' - probably best to rename these...), however:
 - The policy is strict and something similar to 'give one out to
anyone except existing financial instutions with the pre-existing
capacity to issue IBAN'.
 - IANA have a pretty reasonable track record
 - This suggestion, like the entire proposal, is open for discussion
and modification.  If you can think of a more efficient and fair way
of assigning namespace prefixes to random entities on the internet
that doesn't require someone *without* an established track record of
doing this for the internet community to take up IANA's place, then
I'd be happy to hear it. Whilst a bitcoin-like 'community consensus'
system is conceivably possible to deploy in its place, I don't think
it's necessary.

Regards,
Walter Stanish
Payward, Inc.


-------------------------------------

The issue is, what if I'm not trying to DoS you, but something went wrong?


Only clear to the node owner. Not the sender, who may in a better
position to debug.

It's pretty common for protocols to return useful errors even in DoS
conditions. Eg, http servers will often return 503 Service Unavailable
in overload conditions. Google actually sends a redirect telling you
why you got blocked.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1



On 08/03/2011 07:38 AM, Matt Corallo wrote:

Someone I know who runs a moderately large website told me that some ISPs cache DNS for as long as a week without regard to TTL.
If your DNS seeds are not pointing to your own dedicated boxen then you might want to do a lookup on a random cookie as a subdomain.

Caleb

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)

iQIcBAEBAgAGBQJOOT64AAoJECYAmptlsgnWNNYP/3pk/61AOaTo8577XF2E3RWU
hqPclOYMveBZveo7Hz0k/Vf3TMf5p7CFGtFllApVmmR5ck4hXwow+tXwaYvBuf9b
4QwDlNtBelZ+7DqOdDTxRjaRzBo7PlsuiEp+6B3+oggfjKWnkWlIighfM/6LOtMO
kv+MsC9xulqCrX96FrQBERVknkvza8NWfVblAFCM0uxECC5Hd52W1Okx1cDqUsIj
MAp6T6IDwy1u0WtYIZBbD3KR802tqTpx/gzElo2AAz4ZR8P9yATBbAjmd9vZDscB
SRF5yg+BIAzTQzz84c0cno8Q6hFyieRLTu9x0AWUqAZPTL3OgYV7hyl9WXMzcQGY
LgnG9hP5N9qn2S+rYJuNJwvTJhzaLgUwOdRgyisI8v86R5vEjOpAAPVStAgCtvw2
6BJJvit3iZ74fK37kPb4iEljd11ibb8rOoiZzKSuS6LMJXkCplQQ06Uhy9MFd/Wn
UZbSwbXqizJmQUPnHfCvvJc9fmoPFbj4SpYagxXFbUXtQsuB84h1e/jKAf5cvRed
n0fLfKBZJuAfK1B/lV8+R6+oJj6F2OSGdCpdGzMlrxKX3JPcDJGK56/JmFzaqXyA
ScaYja4yps83l80zt7H9Fadl642tNWXsdETniyDt2ADnqr1u/nWr9m+aT7oskbZA
SfO+U22w9JC0CW8u5fAa
=7WNK
-----END PGP SIGNATURE-----



-------------------------------------
On Tue, 2011-07-12 at 22:47 +0100, Michael Offel wrote:
I had been planning on, and putting off starting work on, a central hub
infrastructure to Bitcoin until fairly recently.  Its a central hub
where net/main/wallet/etc can subscribe to get notified of new
blocks/txes/etc, push new blocks/txes/etc and can get information about
blocks/txes/etc.  I started work fairly recently, but hopefully it will
be functional sometime in the not-too-distant future.
As I said earlier, the Bitcoin code base really isn't all that messy,
its only its lack of clear lines between classes that makes it seem that
way.  It does some things inefficiently, however its general algorithms
are quite good the way they stand.  (though net could probably stand a
ground-up rewrite of the backend).  If you want to rewrite for a more
optimized handling of p2p connections/etc, it would be apprecitated and
(assuming its done well) certainly merged.
I can't speak for satoshi here, but I would agree with his decision on
the grounds that BDB offers a good mix.  Compared to a sql-driven
library, it offers a much lighter-weight footprint.  Compared to rolling
our own, its much, much simpler to use the existing code that people
have spent years writing/optimizing/fixing/etc.  It also provides good
Database transactioning which Bitcoin does depend on on some (rare,
though hopefully less so as time goes on) circumstances.
Interesting might have been the wrong word.  Let me rephrase that too
"of hot topic if you ask several people who incessantly create new
chains for no reason other than to create new chains".
Neither the original client nor any other client or patch currently
implements work-sharing, I don't think you understood my statement here.
I was referring to http://forum.bitcoin.org/?topic=7219.0

Those parameters are available, though I don't think they show up in
--help output.  If someone had the time to go back and document the
parameters not in --help, it would be much appreciated ;)
That is yet another debated issue.  The transaction (relay) fees are
there for a reason much more than just for the hell of it.  If
transaction (relay) fees were easily changeable, they would serve no
purpose as they would all be set to 0.  Transaction fee handling needs a
rethinking and recoding, but offering each user the option to just relay
every transaction off the wire is not an option.

That was not at all the point of that comment.  Trying to fix bugs on an
old codebase while rewriting a new one is worthless and just creating
way more effort than is necessary.

Matt

-------------------------------------

Good idea! This could be integrated with the QR-code generation (
https://github.com/bitcoin/bitcoin/pull/629) which adds "create a payment
link" functionality (but currently only "exports" this link as a QR code).

Wladimir
-------------------------------------
I wrote this pre-draft:


https://en.bitcoin.it/wiki/BIP_0015

It's merely a starter for discussions.

Aliases are a way to lookup bitcoin addresses so I can type genjix@genjix.net instead of 1jkddsjdskjwnk2j3kj232kjdkj



-------------------------------------
Wouldn't it work to restrict the number of executions of OP_EVAL allowed
per transaction? That way it wouldn't allow for unlimited looping. If
there's too many OP_EVAL executions during the transaction evaluation,
just consider the transaction illegal. 3 would be enough for the
purposes people have been planning for here I think.

- Joel

On Thu, 2011-12-29 at 11:42 -0500, roconnor@theorem.ca wrote:




-------------------------------------
On Wed, 24 Aug 2011 11:12 -0400, "Gavin Andresen" <gavinandresen@gmail.com> wrote:

Yes. The feature will be very good.


Please do enable any transactions that seem to be a possible solution.
Even if this client doesn't ever implement any of them, alternative
clients can try them.


I agree that something should be done with what we have now. It *will*
take months to properly figure out how to add chain-forking features for
this. If we want to consider all of the unrelated feature proposals, it
might take years of discussion...

However, as I said in the forum thread, I think it would be better for
people using this protection to receive at a normal address and then
create new transactions at their end. Then no one has to handle huge
addresses, and the sender will never have to pay abnormal fees or deal
with incompatibilities. There will be a short period of time when the
recipient's money is unprotected, but I think this is worth it. A better
scheme can be made later after chain-forking features are figured out.


-------------------------------------

On Jul 1, 2011, at 11:35 AM, jan@uos.de wrote:


I don't think this should be a vote at all. Given Greg/Matt's numbers it is a necessity to ensure network stability over the next 90 days.

Also: the default will only apply to pre-built binaries, which bitcoind isn't one of, so for people running bitcoind this default doesn't matter at all. Just continue building without UPNP support as you're already doing.

-- 
Douglas Huff


-------------------------------------
On Tuesday, December 20, 2011 3:49:16 PM Gavin Andresen wrote:

I've rebuilt my 'next' and 'next-test' branches...
    git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git

Accepted for 0.6:
* 81807c3 Merge branch 'coinbaser' into next
* 6ea6db3 Merge remote branch 'laanwj/ui_copy_amount' into next
* a6ef83e Merge 'QR Code generation via libqrencode' into next
* e0673bd Merge branch 'signmessage_gui' into next

Ready for acceptance?
* 4783528 Merge remote branch 'matt/keepnode' into next-test
* 5a11d0f Merge branch 'force_send' into next-test
* 2cddc71 Merge remote branch 'sipa/comprpubkey' into next-test
* 73a8ca6 Merge remote branch 'matt/uri' into next-test
* 9314427 Merge remote branch 'gavin/testnetdifficulty' into next-test
* 1360e43 Merge branch 'stdint' into next-test

Needs review:
* 6ee82ff Merge branch 'forceresendtx' into next-test
* 8a82ba6 Merge branch 'blknotify' into next-test
* 674f1a6 Merge 'Temporarily disable "minimize to tray" in the startup phase
          if the "-min" option is specified' into next-test
* 5afd4de Merge branch 'bugfix_client_name' into next-test

Cannot be merged cleanly (at least not into next-test at this point):
* Pull 556 txinfo
* Pull 568 JSON-RPC multithreading + rpc_keepalive
* Pull 457 IPv6 JSON-RPC
* Pull 427 IPv6
* Pull 565 optimize_FastGetWork
* Pull 430 joelkatz optimizations
* Pull 562 optimize_ToHex
* Pull 452 JSON-RPC API versioning

Not yet written:
* Treat generation (almost) like normal receive
* JSON-RPC with integer amounts


-------------------------------------
On Thu, 2011-08-11 at 06:47 +0100, Andy Parkins wrote:

And you're only shooting his actions down without indicating clearly
what you think ought to be done instead. What do you want him to say
instead?


No way that will happen. A fork is going to happen sooner rather than
later if this continues. It'd be great if it could be done within this
project and named bitcoin-dev or bitcoin-next or similar.

If this is not done, I wouldn't be surprised with the network splitting
into 2 camps with different protocols but still working on the same
blockchain.


There's no way to get the majority to vote with their feet to move to an
incompatible client. Not immediately anyway. It can happen gradually
though.

As in: 1) alternative client is published that is compatible but
extended. 2) this client gets the majority share of users/miners 3) they
see this and decide to break compatibility. 4) original bitcoin client
is now incompatible/history.


What is happening here is that most suggestions you point at have been
discussed about before and so the "early adopter" developers remember
that a decision about that was made already. However, the problem here
lies with the fact that it's difficult to find the previous
conversations.

If there was a section in the wiki for recording past suggestions, there
would be no need to say 'no'. You could instead say "We have discussed
this before, please read..." and give them a link to the page with the
relevant discussion. Of course, this would require actively forwarding
people to the wiki for discussions and having them there. I think this
would be a good idea.

That would leave this list for discussing and coordinating the
implementation of the changes that have been agreed on.

For things that have already been discussed, you could try to find the
previous discussion and add it there. But I expect for some things, new
discussion needs to be had to get it on the wiki.

- Joel



-------------------------------------
On Wed, Dec 21, 2011 at 12:14 PM, Luke-Jr <luke@dashjr.org> wrote:

Quoting IRC yesterday,
<gavinandresen> jgarzik:  I defer to your judgement on coinbaser, I don't care.


Then post data backing up that vague statement.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
dns resolution is far simpler to implement than properly checking the https certificate chain

Matt Corallo <bitcoin-list@bluematt.me> wrote:

-------------------------------------
On Sunday, December 18, 2011 6:58:37 PM slush wrote:

The point of the extended URI is to allow the server to negotiate payment 
details (payment/order information, fees, new privacy address, etc) rather 
than merely sending a simple payment to a single fixed address.

I am not convinced *aliases* are practical, without CA trust. An organization 
that wants to trust a CA with all their funds can leave off the address 
portion, to provide more human-friendly URIs.


-------------------------------------
On Mon, Sep 26, 2011 at 3:17 PM, Luke-Jr <luke@dashjr.org> wrote:

Huh?

So in the future lets suppose we schedule a change to the acceptable
block rules that allows more SigOps in a block, or allows generation
transaction to be spent before 100 confirmations. At that same time,
the DoS rules will be changed.

You cannot "legitimately" relay those blocks without a scheduled
block-chain-split.  If a block-chain-split IS scheduled and the rules
change, then denying service to nodes running old, obsolete versions
of bitcoin is the right thing to do-- it is better to "fail hard" and
find it difficult or impossible to connect to the network rather than
continue with an obsolete client and a non-majority block chain.

(and the third DoS in AcceptBlock(): prev block not found  is a
"should be impossible" case, because AcceptBlock is only called when
extending the best-block chain).

-- 
--
Gavin Andresen


-------------------------------------
OK, sipa pulled his wallet code movement + wallet class stuff.

Wallet import/export and crypto will need a rebase.  Other code will
too, but those are the big ticket items that we want to merge in the
short term.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

Definitely want _some_ path to HTTP/1.1 persistent connections, either
this or async I/O, https://github.com/bitcoin/bitcoin/pull/214

Based on field usage, it sounds like the above, threaded rpc, is more
stable.  So my only question remaining, for which I've not yet
reviewed the code, is:  what is the behaviour under assault from lots
of new incoming TCP connections?  One very common problem with
threaded TCP servers is blindly creating new threads without any
filtering or checking of incoming connections, thereby quickly
reaching thread limits, possibly causing other parts of the program to
fail.

Any amount of RPC request volume, miner or not, sent to the present
implementation winds up using a lot of socket resources due to the
constant disconnect/reconnect demanded of the current HTTP/1.0 code.
This patch addresses that key issue, providing positive impact for all
production bitcoin sites using RPC.

Miners are hitting these problems now, and Gavin's right that mainnet
miners are a small portion of the total population, but our RPC server
implementation really is bloody awful at present.  Reliable,
production TCP servers use either threads or async I/O, or a
combination of both (thread pool + async I/O == win).  Deploying
HTTP/1.1 persistent connections will make a positive impact at any
site heavily using RPC.



Did I leave something out, when merging

     commit 67ed7d9d4929d8fe1c5f976c184c72dff02d83b7
     Author: JoelKatz <DavidJoelSchwartz@GMail.com>
     Date:   Mon Jul 25 15:06:45 2011 -0700

?



I think we need this, but have not yet reviewed/thought about it.


Sounds nice to have.

     Jeff


P.S.  I'm moving my home computer lab setup to a new house.  Internet
will be spotty until August 11, and you won't see much of me at all on
#bitcoin-dev.


-------------------------------------
On Fri, Dec 16, 2011 at 12:35 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

[snip]


I believe that any URI scheme will still leverage DNS and inherit any
base issues you would have with TXT records. I suggest looking at DANE
and reviewing their work on hardening certificate (x.509)
infrastructure as your HTTPS scheme will inherit the issues we
currently experience with CAs getting p0wned.

Hardening the protocols and usability are related. Please look at some
of the work done in the IETF which has a long history in addressing
many of the issues you are considering. Review some of the elegance in
the bitcoin protocols. The proposals in this thread are neither clear
nor elegant. If you can't reach nearly the same level of
sophistication then I suggest you rethink your scheme.

-rick


-------------------------------------
On Wed, Jul 27, 2011 at 2:42 PM, Joel Joonatan Kaartinen <joel.kaartine

Although, if GitHub can't support the feature, it could be an argument

Well if signing up with github is such a big problem we could make a list of
bounties on our own site with a trivial web application, and link from there
to github issues (if neccesary) for a description. It really doesn't matter
how it's implemented. I think it is useless to discuss technical details or
GitHub TOS right now, let's discuss the merit of ideas...

JS
-------------------------------------
First: everybody please try to focus on the issues/ideas, and try to
avoid this becoming a flame war.

Second: I think Walter Stanish made several good points that may have
been missed in all the long posts and discussion, the main one being:

The banking industry has been dealing with many of these issues for
years; I think we should not dismiss their experience.

I think there is also a huge public relations benefit to using a
standard like IIBAN instead of inventing our own. Having a Bitcoin
Payment Routing Address (or whatever it ends up being called) that
looks like the number issues by big financial institutions will give
people the warm fuzzies.

I don't really care what happens behind the scenes, as long as it is
as secure as an HTTPS connection (RE: CA pwnage:  there's no such
thing as perfect security, and until a more secure solution comes
along HTTPS is the best we've got).

And I'll reiterate that there doesn't have to be just one solution.

My only concern is that IIBAN is Yet Another Fledgling Standard, and
those little details that remain to be worked out could take years to
actually work out.

-- 
--
Gavin Andresen


-------------------------------------
Hello everyone,

here is an idea i've bean writing up: https://gist.github.com/1237788

I hope it can start some discussion about moving away from static bitcoin addresses
as descriptions for transactions. I suppose it's a candidate for a BIP/BEPS/BFC/...,
but as things don't seem to have been decided completely about those, I put it in a
Gist.

Please, comment.

-- 
Pieter


-------------------------------------

We track DNS disobeyers at Google, as we use it for load balancing (along
with many other large sites).

I'd be kind of surprised if any large/professional ISP disobeyed the TTL
that badly, because it would cause frequent problems reaching popular sites
like anything hosted on Google or Akamai. But randomizing the DNS request
isn't a bad idea.
-------------------------------------
On Thu, Jun 30, 2011 at 8:07 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:

*Flood fix

I think this is important, slow bringups are problematic and I think
the flood disconnects have been contributing to network partitioning
(you'll disconnect nodes that have the full blockchain but keep ones
that don't), adding to the partitioning problems cause elsewhere.

I've been running it for a couple hours on a large public node which
was seeing frequent flood disconnects, and it seems to be working
fine. No more flood disconnects.

Syncing a local node to it (no a not terribly fast core) now takes
34.5 minutes (I new bringup on the same system a few days ago hadn't
synced in over an hour).

Increasing the nLimit in sipa's code from 500 to 5000 reduced the
syncup time for me by about 1.5 minutes, almost all of the speedup
being in the early blocks.  Since it has the 5MB limit now I don't see
much reason for a large per block limit.

*Dnsseed

I've been using this for a while, we need more dnsseed roots but I see
no reason not to turn it on now.

*UPNP

Lfnet now reports 32843.  Presumably there are more bitcoin users than
that, because not all use IRC. 32843*8 = 262744 listening sockets.
Meaning, assuming a nice equal distribution we need 2189 listening
nodes to support the network— but the real distribution will be
somewhat uneven due to bad luck and the /16 limit.

Matt has estimated that there are around 4000 stable listening nodes.

Linear extrapolation from the two day lfnet growth leave us running
out of sockets in a little more than a month. While it won't all break
if it runs out, since we don't strictly need 8 connections, it's still
not good.

I think getting more listening nodes is a somewhat urgent matter as a result.


I'd also like suggest updating the checkpoint in 0.3.24. Difficulty
has increased almost 17x since the highest one currently in there. A
rather large number of parties could mine pretty nice forks at 1/16th
the current difficulty for nodes that they've sibyled.


-------------------------------------
Small correction - if the node is the trickle node it gets all invs, not just the special quarter.  This means that everything get distributed everywhere every 12-15seconds, but a special quarter of the hash space is treated earlier, so there is a meaning for vInvWait, but there is still a mismatch between comments and code.

Cheers,

M


On 29/12/2011, at 23:05, Michael Grnager wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------
Mike,

I think I can contribute to your DNS seeding project. Could you help define
long-lived peers?

-rick


On Wed, Aug 3, 2011 at 3:04 AM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
Its a negative example -- in that the IETF does not specify anything
in the PATH part of the URI. The scheme, sure, but not in the path,
there are many types of URI schemes ( start with RFC 2396 )

There is significant upside to having your own scheme and having apps
understand how to integrate with it. Frankly, having just one client
(I understand there are more) is an artifact that hinders acceptance
and participation. If you want to go the route of https then
specifying a scheme is your path forward

I still believe that it is experience that is leading this thread down
the rat-hole of CGI and HTTP requests. The stuff isn't magic, it is
just what you are used to. Review the bitcoin protocol, there is an
elegance there -- not found  in the https schemes proposed thus far.
CGI isn't a protocol, nor does it address usability/identity issues.

Providing a mapping from user@authority.tld addresses usability and
identity. I'd like to see an elegant transformation, specifically I
take to task anyone that advocates
https://authority/foo/user?tx=1zhd789632uilos as elegant.

-rick


On Fri, Dec 16, 2011 at 9:10 AM, Andy Parkins <andyparkins@gmail.com> wrote:


-------------------------------------
I don't think Amir wants to put it into the protocol, but I still
don't like much the proposal if it has to rely on servers.
As an aside, even if firstbits it's not useful enough for the human
memory, it is still useful for QR-codes like in the case of green
addresses's POS instant payments.

Would it be too strange to use namecoin?
Some devices may need to rely on block exploring servers, but it is
the easiest decentralized solution that comes to mind.


2011/12/13, Zell Faze <zellfaze@yahoo.com>:


-- 
Jorge Timn


-------------------------------------
On Thu, 2011-08-04 at 18:18 -0400, Gregory Maxwell wrote:

I've been thinking about going through my logs to see how many nodes I
am connected to that are clearly bad (like those), but I suppose you
beat me to it.  Should such connections not be dropped over time as they
are clearly not functioning nodes?
-------------------------------------
(copying part of a conversation from IRC)

IMO, wallet crypto and wallet import/export are the two "must have"
features for v0.4.  wallet crypto rationale is obvious.  sipa's wallet
import/export might need a rebase, but it seems important for further
wallet security, such as printing out and storing a private key in a
bank's safety deposit box.

autotools and other stuff can wait, if they hold up the release of
wallet crypto.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
The whole point of having headers built at a constant size and 
generation rate is to minimize the amount of data needed to "understand" 
of the blockchain while simultaneously maximizing integrity/security in 
the presence of untrusted nodes.  Barring the 50%-attack, you only need 
a couple honest nodes out of 50 to stay safe (as long as you're waiting 
for your 6 confirmations).   In fact, I would argue that a full node 
(Satoshi client), has the same level of security as a headers-only 
client... because they both base *all* their verification decisions on 
computations that end with comparing hashes to the longest-chain headers.

In the case that an attacker figures out how to isolate your node 
entirely and start feeing you poisoned blocks, then you are vulnerable 
with any kind of node, full or lightweight.  I don't see where the 
reduced security is.

The only issue I see is that a truly light-weight, headers-only node 
will be having to download an entire block to get one transaction it 
needs.  This would be significantly alleviated if nodes can start 
requesting merkle-trees directly, even without merkle-branch-pruning.   
If a node can ask for a tx and the tx-hash-list of the block that 
incorporated that tx,  he can easily verify his tx against his 
no-need-to-trust-anyone headers, and doesn't have to download MBs for 
every one.

As for blockchain pruning... I think it's absolutely critical to find a 
way to do this, /for all nodes/.  I am swayed by Dan Kaminsky's 
scalability warnings, and my instinct tells me that leaving full 
verification to a select few deep-pockets nodes in the future opens up 
all sorts of centralization/power-corporation issues that is contrary to 
the Bitcoin concept.  It is in everyone's best interest to make it as 
easy as possible for /anyone/ to act as a full node (if possible).  As 
such, I believe that the current system of minimizing TxOut size is the 
right one.  TxIns take up 0 bytes space in the long-run when taking into 
account any blockchain pruning/snapshot idea (except for nLocktime/seq 
transactions where the TxIn might have to be saved).

-Alan





On 12/18/2011 12:09 PM, theymos wrote:

-------------------------------------
On Jul 2, 2011, at 12:31 PM, John Smith wrote:

This would be true if gmake didn't build/run basically everywhere; but, it does.


Don't get me wrong, I'm not defending autotools' design or implementation. It is; however, more ubiquitous and understood by a much wider audience.


I would say that's actually a mark against cmake. If you need a gui to select build options because your cli doesn't have proper help output something is wrong.

If you're willing to setup and maintain a cmake build environment I wouldn't say it should be rejected outright. Speculating about it without an implementation to compare seems like a waste of time.

Especially when jaromil already has a mostly-functional autotools setup. It needs tweaking still and some changes to catch up and rebase, but it works. He also already did the tedious work to rearrange the source tree to make adding any auto-configuration tool for the build environment easy to drop in place. (Which is already merged.)

-- 
Douglas Huff


-------------------------------------
2011/12/15, Walter Stanish <walter@stani.sh>:

I thought the interaction was just the server answering with an
address (maybe also amount and other details). But we don't have to
define how the server will get that address.
Some possibilities:

-A static address: less anonymity, but some people may not care. Say a
donation address.
-The servers stores the recipient private keys and generates a new one
for each payment.
-The server stores a set of addresses provided by the recipient and it
manages what address it gives in each request (like in the web service
I told you I can't find).


IANA reserves some namespace for bitcoin. All right.
The problem comes later.
"
* Systems such as [BITCOIN] have quirks that require slightly
      delayed settlement due to the nature of their decentralized,
      consensus-based approach to fiscal transfer.  Users requiring
      instant settlement MAY thus see benefit in the use of a
      centralized proxy system or organization as an instantaneous
      financial settlement provider (the 'institution').
"
As I understand it (probably I'm wrong, because I haven't read the
whole IIBAN draft) there would be a "bitcoin institution" that would
map bitcoin addresses to the bitcoin subspace of the IIBAN.

"    * IANA MAY delegate management of portions of the IIBAN name space
      through such institutions."

If we can find a deterministic method to map the subspace the all
possible bitcoin addresses, everything's fine again. But if that's not
possible, we would need a central institution to manage the mapping
and that would be a step back in decentralization.
I can't find the answer of Gavin's question "How is the mapping done?"
in your post. I'll re-read it though.


-------------------------------------
Yup, +1 for Git.

On Thu, Oct 27, 2011 at 6:15 PM, Daniel F <nanotube@gmail.com> wrote:

-------------------------------------
As it's unlikely to be an automated system anyway, I do not see why
people claiming the bounties would need to agree with the GitHub TOS.
Besides which, I suspect most people contributing to bitcoin already
have agreed to it.

Although, if GitHub can't support the feature, it could be an argument
for setting up a bug tracker unrelated to GitHub.

- Joel

On Wed, 2011-07-27 at 10:28 -0400, Luke-Jr wrote:




-------------------------------------
Damn, german is already contributed :-)
Well I can still do the italian one and check german then.

On Sat, Oct 8, 2011 at 11:13 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:

-------------------------------------
Probably patches for this bug would also be high priority:

   http://forum.bitcoin.org/index.php?topic=19168.0

It should be an easy fix.
-------------------------------------
This thread is getting off-topic so I changed the subject.


OK. A better way is tx filtering, as discussed here:

   http://bitcointalk.org/?topic=7972.0

The reason is you want to only get the transactions+merkle branches
relevant to you, otherwise cost is still O(system activity) not O(your
activity) as blocks get bigger, even if you don't download every
block.


Yes, but it's more complex than that.

Some contract protocols require one party in a set to be able to
re-issue transactions without interacting with the other parties. The
reason is that each input can come from a different person. If the
sequence number was a property of the transaction, updating it would
either require all participants to re-sign the transaction, or for the
signatures to not cover the sequence number at all.

With seqnums on the inputs, I can create a newer version of the
transaction by just resigning my input with a higher sequence number.
This is defined by IsNewerThan(). Note that my options here are
limited - I can't create an arbitrarily different version of the
transaction without invalidating all the other input signatures. If I
own all the inputs, no problem. If some are owned by others, what I
can change is defined by the SIGHASH flags. To replace this tx in the
memory pool requires others to re-sign their input with a higher
sequence number than mine - so we establish a kind of chain. Nobody
can rewind the transaction to an earlier point, but anyone can update
it within the parameters established by the SIGHASH flags on the
others signatures.

These features all combine together to allow for particular types of
contracts that take place on the negotiating table of the networks
memory pool. For instance, if you are taking part and then decide you
don't wish to continue, you can set the output that's in the same
position as your input to reassign all the money you put in back to
you, sign the input with SIGHASH_SINGLE and broadcast with nSequence
set to UINT_MAX. Now the transaction is still valid but is a no-op
from your perspective. Note that once you've done this, you've bowed
out of the negotiation completely because you can't replace the
transaction anymore.

You can't change anything about the inputs beyond scripts this way.
The transaction still has to connect to the same outputs as before,
and thus import the same amount of value.


-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Why off on Linux? If anything Linux has, historically, had the most testing of the miniupnpc library. So it's the most stable of the three.

Gregory Maxwell <gmaxwell@gmail.com> wrote:


- --
Douglas Huff
-----BEGIN PGP SIGNATURE-----
Version: APG v1.0.8

iQIVAwUBTg3AXUPHkQabDWHPAQgI8RAAm4Csyc4jqLvJSpopwNKg20273Hk2dhpR
s0RHerh1TgFDLDeByhzZLX/GC5SzGpPRDllDDlKcXl+E7iS7xtsuB+KbNdjYERmn
eVm67PQnXZ0PaDUnUxywyl55dcM8WAhwAYZKxvY2IzJ5y6oV7aPSDt7+qtXGL5Tx
EWjtQU06EaLhQkamelEc0KhHWqA72S/1VIgITvW4KVOf8SKyfTkxADdvRJ2iEznZ
bemdm81nbNFuYjGng9pEzqs9CVkWthANFa8GhxV9yFiqhpT7rCZKktkmqazxw6le
zog0v0MDfd55eWH59dHd9FbdiU757VMZtjTew3EoKrvIOwj1XQ50aSwaxO2CeTfW
qfW/xrxo+6VJx2kpLC833rvek4nx/7a0YVSvtypp9R1td9wAPi14IT+wOZ6C6ofs
Cg1VtETit4cS4xeHNx5boMayBvqpS1tmYgrTdi0QjmlWa75RDLIIteWcS7Q6NP0r
G2BRm3sqTGo/7Vzhmqn3BWNe5lq21NCW9kMs8nzhntnalF13BdIN4ZMimmSmLb5O
PUzg9OUZ5qfW3rsbYgYXXritzcNSftva+H/sCLIIoFOJO16wpiQXoHjTSY0TwwIT
XrVAcP2sRQjfT5QzPfwHDBRcYDgpfGJs5+jXtPc1maac7AxRjZ0op7gXFb/3L/W4
mQFXl6I9hhg=
=qsYM
-----END PGP SIGNATURE-----



-------------------------------------



----- Forwarded Message -----
From: Amir Taaki <zgenjix@yahoo.com>
To: John Smith <witchspace81@gmail.com>
Sent: Thursday, July 28, 2011 2:01 AM
Subject: Re: [Bitcoin-development] Seeking advice: Encouraging bug-fixing over new features


I already tried the bounties route- made a forum thread offering $4000 worth of bounties and it got very few responses before dropping off the page.


Also, http://forum.bitcoin.org/?topic=4761.0 and http://forum.bitcoin.org/?topic=4543.0

In the end I came to the conclusion that the only was is to bring in projects and pay people to work fulltime on Bitcoin under an organisation.



________________________________
From: John Smith <witchspace81@gmail.com>
To: Joel Joonatan Kaartinen <joel.kaartinen@gmail.com>
Cc: Bitcoin Dev <bitcoin-development@lists.sourceforge.net>
Sent: Wednesday, July 27, 2011 4:20 PM
Subject: Re: [Bitcoin-development] Seeking advice: Encouraging bug-fixing over new features


On Wed, Jul 27, 2011 at 11:14 AM, Joel Joonatan Kaartinen <joel.kaartinen@gmail.com> wrote:

Perhaps even add a way for anyone add to the bounty attached to a bug on

Good idea. I'm not sure if the github bug tracker supports extension attributes, but it'd be a great place to add it. Also, people can let know that they're already working on a feature using a comment, to prevent double work.

The biggest problem will be organizational, in getting the BTC together for bounties; only a high profile member such as Gavin will have enough trust to ask for support. Or maybe there's something left in the faucet? :-)

Unrelated: what also might help is publishing a roadmap. Plan a few "bug fix only" releases before scheduling addition of new features. It's also helpful for people that wonder that direction the project is going in...

JS 


------------------------------------------------------------------------------
Got Input?  Slashdot Needs You.
Take our quick survey online. Come on, we don't ask for help often.
Plus, you'll get a chance to win $100 to spend on ThinkGeek.
http://p.sf.net/sfu/slashdot-survey
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
On Friday, June 17, 2011 2:42:30 AM John Smith wrote:

Before this gets merged, I'd like to check: does it work ok if Qt is built 
without glib support?


-------------------------------------
This should make it compatible with Namecoin addresses...

Here's a revised proposal:
* Bits 128/64 define network class
** 0 = main network
** 64,128 = reserved
** 192 = test network
* Bits 32/16 define network
** 0 = Bitcoin
** 16 = reserved
** 32 = OTHER (next octet)
** 48 = Namecoin

The rest is left up to the network to decide; for Bitcoin, it is:
* Bits 8/4/2 define data class
** 0 = Public key hash
** 2 = reserved
** 4 = Script hash
** 6 = Public key (raw)
** 8 = Signature
** 10 = reserved
** 12 = Private key (raw)
** 14 = OTHER (next octet)
* Bit 1 is freely chosen (for aesthetic assignment)


-------------------------------------
On Wednesday, November 02, 2011 6:55:27 PM Amir Taaki wrote:

My point is that the "Satoshi client" was the wxWidgets client, which was 
retired by 0.5.


-------------------------------------
On Sun, Dec 18, 2011 at 01:15:26PM +0100, Jorge Timn wrote:

Yes. The reason is that currently a send-to-address puts the address in the
output script, while redeeming requires the full pubkey plus the signature
to be placed in the input script. Overall, this requires more space than a
send-to-pubkey, where the output contains the pubkey, and the input the
signature.

There are several possible improvements however, and they may not all have
been explained in this thread. To summarize:
* compressed public keys (33 byte pubkeys instead of 65 bytes)
* compact signatures (66 bytes instead of 72, including hash type byte)
* pubkey recovery (allows the public key to be derived from a compact signature)

The first is very easy to implement (see pull #649). Compact signatures 
and pubkey recovery require a change to the scripting language (though are
already implemented, as they are used for message signing).

These result in several combinations that could be proposed:
1) send-to-pubkeys-hash
   - currently the default addres type
2) send-to-recovered-pubkeys-hash-with-compact-signature-inside-op_eval
   - extend the scripting language inside OP_EVAL, as described in
     https://gist.github.com/1262449
   - use compact signatures
   - use key recovery, and never put a pubkey in the blockchain data
3) send-to-pubkey
   - traditional transaction type
4) send-to-compressed-pubkey
   - what Luke proposes as new address type
5) send-to-compressed-pubkeys-hash
   - what pull #649 would bring

Gregory Maxwell made a small table to compare these options:

  http://people.xiph.org/~greg/addr.compare.html

If you don't consider pruning, everything is better than send-to-pubkeys-hash
as we have now. Both using pubkeys instead of hashes, using compressed pubkeys
instead of full ones improve the situation independently, and using key
recovery is even better.

If you do consider pruning, the advantages are smaller, but it is far from
clear to me how pruning will be implemented in the future (as a pruning
node cannot function as a NODE_NETWORK service anymore).

-- 
Pieter


-------------------------------------
On Wednesday, August 24, 2011 11:12:10 AM Gavin Andresen wrote:

If a block chain split is to occur, it makes sense to try to fix as many 
problems as possible:
- Replace hard limits (like 1 MB maximum block size) with something that can
  dynamically adapt with the times. Maybe based on difficulty so it can't be
  gamed?
- Adjust difficulty every block, without limits, based on a N-block sliding
  window. I think this would solve the issue when the hashrate drops
  overnight, but maybe also add a block time limit, or perhaps include the
  "current block" in the difficulty calculation?
- 21 million really isn't enough if Bitcoin ever takes off, even with
  100,000,000 units per BTC. Replacing the "Satoshi" 64-bit integers with
  "Satoshi" variable-size fractions (ie, infinite numerator + denominator)
  would create infinite possibilities of future divison, allowing people to
  not only do nBTC and pBTC, but also exact 1/3 of any quantity. Transaction
  size would go up based on the number of primes involved in an amount, which 
  would encourage discarding annoying primes in transaction fees.
- Standardize everything on network (big) endian.

I'm sure others can think of other chain-splitting fixes that wouldn't be too 
much work to fix.


-------------------------------------
On Fri, Dec 16, 2011 at 08:03:28AM -0800, Rick Wesson wrote:

That's why you use URI + bitcoin address pairs, and use SSL communication
authenticated using the respective bitcoin pubkey. They may spoof your DNS
server, they can't fake having the requested corresponding private key.

Obviously, this moves the problem to getting the URL + address securely
to the client that wants to interact with it, but that is inevitable if
you're not going to rely on a pre-trusted certificate authority and PKI.

Also, the client software can cache the address corresponding to a particular
server or URL, making it similar to an ssh client that caches host keys and
warns when they change.

-- 
Pieter


-------------------------------------
Can we use a git repo or something more redundant for BIPs? They're
rather important and the wiki has been unreliable before.

On 27.10.2011 17:15, Amir Taaki wrote:



-------------------------------------
This sounds cool, I started implementing the other half of this a couple
days ago.  My broad idea of a source cleanup (that sipa largely wrote)
is to have a central notification interface which wallet(s)/net/block
store/etc all communicate with, and then an interface, like the one
proposed here, which GUI/RPC/etc use to communicate with wallet/net.
This should allow for very clean separation of pieces and large-scale
rewrites of one or another part (or drop-in replacements) without
touching anything but the parts that are being redone.  This should also
allow for cool programs (like pushpoold/a block notification server/etc)
to use Bitcoin as a library fairly efficiently.

Matt

On Thu, 2011-07-14 at 05:19 +0000, John Smith wrote:
-------------------------------------
https://github.com/bitcoin/bitcoin/pull/506 has been closed pending
additional commits or a change in consensus.
-------------------------------------
On Wed, 2011-08-31 at 14:20 +0000, John Smith wrote:
Would it be possible to port some of the existing translations?
Something is better than nothing so some text that is close to the wx
version can just be copied.
Though IMHO its not a huge deal if qt is merged without all the
translations as IMHO it should be merged soon and then not the default
release GUI until its in tree for a bit (like one release) and some
translations can be built up.
IMHO it should be merged right after 0.4 is pushed.
-------------------------------------
Hello,
 
I would like to start a discussion about code quality to catch some opinions and create an codebase cleanup plan.
 
Let me just start with some points I've seen while reading and stepping throw bitcoin:
 
 
1. nearly no code documentation
 
All I found was the original paper and some partial wiki pages and the overall coding style does not help much here. I would love to see some class hierarchy, method descriptions and thoughts in the code. Instead one can find comments like this...
 
 
This comment is just waste of valuable disk space and time for anyone who reads it. While I can guess what the CScript class does I would more like to understand the thoughts behind the decision to implement some crypto macros in a compile time interpreter and why Berkeley db 4 is used at all.
 
 
2. isolation of modules
 
It would be a lot easier to understand parts of the code if they would use well defined interfaces to communicate. Bitcoin makes use of global variables, public member variables in classes and global external functions what makes understanding the code a lot harder. To give an example here, the irc module has no interface at use it or to use. It gets some kind of magic thread started and pushes received addresses directly to some global function in net.cpp. The code is full of concepts like this. A well defined interface would be an bitcoin unrelated IRC module interface and some kind of translation class between the IRC and peer2peer network interface.
 
 
3. poor use of threads
 
Bitcoin starts a new thread for every little module it has and as soon as there is some serious work to do, it locks some kind of global mutex. While this eliminates nearly every performance advantage, it introduces a high difficulty in writing bug free code. Not only that one has to know which mutex to lock when, there is no documentation about that, one may also accidently add dead locks. This kind of bug is very hard to find, it may run well for a million of tests and crash or just hang on the next one. And my experience tells me that it will not be an developer nor an little user when it occurs. The fist user who hit's the bug will be mt gox doing an emergency transfer. ;) My suggestion is to remove all threads and critical sections and build a sequential easy to follow model. Some modules like the cpu miner may still require to spawn threads, but he should do this internally and hide any synchronization.
 
 
4. long build times
 
It takes longer to build Bitcoin than building some of the million lines of code projects I'm working on. The reasons I did see so far is the use of boost, lack of module isolation and implementations in header files. While the rest is just bad coding style the use of boost is arguable. As far as I can see it is mainly used for threading and FOREACH. I already put threading on the table, but using pthread or making an platform dependent startthread and mutex would be much more lightweight and nobody needs FOREACH. Boost is also an heavy non standard dependency that is an unnecessary barrier for new developers.
 
 
5. style guide
 
There is a style guide but it does not include anything about readability.
I'm talking about one file per class, no methods and single code line longer than a screen page. It should be natural to write code like this and I dislike having a lot of rules but the code shows that there is a need for such thing.
 
 
6. hardcoded values
 
There are tons of hardcoded values for the official and the testnet block chain. It would be a great step to move all chain related settings to a chain description file. This would allow custom chains and clean up the code.
 
 
All this is just the tip of the iceberg. Bitcoin is a widely used application and users are transferring millions of dollars. The current code quality is very prone to bug's. To be clear I'm not saying there are a lot of bugs nor do I blame someone for the code quality. It is still a beta version and it was necessary to bring out a working version to attract more developers. And it is hard to analyze the code or just see a bug during development. One can be happy to understand what a method does, but this gives not the confidence to see and report obvious bugs.
 
Let me also say that I'm not pointing to someone to do all this. I'm willing to spend a lot of time on this promising project but this kind of cleanup is simply too large for one person who is new to the code.
My overall suggestion is to begin a complete rewrite, inspired by the old code rather than moving a lot of "known to be somehow functional" around.
The official Bitcoin client should be some kind of an reference project for other clients and must therefore be extra clean and well documented.
 
Hopefully I did not hurt someone's feelings.
 
Michael
 
 

___________________________________________________________
Schon gehört? WEB.DE hat einen genialen Phishing-Filter in die
Toolbar eingebaut! http://produkte.web.de/go/toolbar


-------------------------------------
Merged wallet crypto.  Test (and review) away...

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I imagine a lot of the things on the contracts page will be implemented by
specialized software that interacts with the Bitcoin network directly.
Transactions would then be moved around, for example, by having clients do
HTTP POSTs of protocol buffers to servers that are listening and know how to
interpret the received messages.
-------------------------------------
On Wed, Aug 10, 2011 at 12:29 PM, Gavin Andresen
<gavinandresen@gmail.com> wrote:

Seems like this would be a useful companion website + project.
bitcoin/networkmon.git could be a central point for contributors to
add various monitors and tests.

Getting on-going network health information is critical to bitcoin's
success.  We need to know if incoming nodes are getting DDoS'd...


Agree


IMO the only thing lacking is docs.  There is no real admin guide
describing how to prepare bitcoind installations for encryption;
doc/README does not mention RPC encryptwallet at all, nor does it
describe the various states your wallet may be in, when before and
after encryptwallet has been run.  The information is very general,
and not adequate for a competent admin to be able to evaluate.  It
does not describe encryption method or other security parameters.  It
does not describe the specific technical relationship between the
master key and other keys.



I have never seen an open source project with a successful Bug Czar,
unless that is an actively compensated position.


I think Q/A will naturally grow out of some sort of dedicated support
organization, rather than have a dev fiat requirement.  Testing like
that is always desireable in the "I'd love it, if it were this way"
vein, but not always realistic at all for open source projects.
Especially with open source, time has shown that the best testing
comes from the field, and we have the biggest test lab in the world:
the Internet.  So IMO focus less on roadblocks to publishing software,
and more on widely distributed test software.

For new features, simple "it works" test at a minimum seems
reasonable, most of the time.  But in open source the testing and such
tends to happen in the periphery, by organizations and individuals
with the incentive to focus on those issues.

In my recent emails describing linux-next and a proposed
"bitcoin-next", one attribute of linux-next is that it is run through
automated tests on a daily basis, right after the merge is complete.
It forms a useful layer on top of the primary linux project & tree.


Although I do agree, remember that it is the nature of open source
that you always have less control than you'd like :)

If the Iron Fist of Developer Justice squeezes too tightly, people
will simply route around the bottleneck with their own trees and
software releases.  genjix is already pushing for his libbitcoin
branch, for example.


Nice to have, but I think it's just a short term fix.  Long term, it
will be SPV clients vs. full nodes, and bringing up a full node will
be so costly that you'll just mirror the block database directly out
of band, then boot the node at 99%+ block height.


Yes.  I was hoping to get that for 0.4.


Not a big deal to me, I never use GUI :)


Has anyone actually come up with a good idea to code?

This is a widely acknowledged problem, sure, but where are the good
solutions, even on paper?


Parting shot:  there is a reason Linus specifically says there is no
roadmap for the kernel.  That's because it is always driven by the
community, and like a free market, the collective motivations and
goals of the group.

Projecting into the future, _and then attempting to stick to that
roadmap_, will end in much frustration.

Open source contributions are far more organic and unpredictable.
Roadmaps work better in fiat organizations where developers do what
they're paid/told to do :)

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Be careful though, if you relay everything, it suddenly *does* have DDoS
potential...

JS


On Thu, Sep 8, 2011 at 5:15 PM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
On BitDroid I stopped updating the protocol version at 31700 and set the
string to be both Version and Client, just like BitcoinJ :-)

On Sat, Nov 5, 2011 at 3:32 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
On 2011 November 23 Wednesday, Jorge Timn wrote:


True enough; but then the same is true for everyone else.  If the window is 2 
minutes after the stated time, then everyone _can_ wait until the end of that 
window.  However, they risk their block being rejected by their peers, and 
their efforts are wasted.  In fact, it can be guaranteed by making the accept 
window zero.  There is then no reason to carry on computing after the reward 
window closes, since you know your peers will reject it.


Well yes.  What does that matter?  It's only a way of calculating an average 
time.  The node can use any clock it wants, as long as the block time is 
verified by the peers.


It definitely isn't.  NTP is mentioned in the source as an alternative.


It's nothing to do with the protocol; it's an individual miner choosing 
whether to accept or reject a block based on the timestamp it claims, and the 
current time as the miner sees it.  For the sake of compatibility, the clients 
currently choose to use a community clock as "current", as established from 
the time they receive from peers in the "version" message (it actually holds 
offsets between them, which is pretty bad, as a long-connected client will 
drift).  They don't have to, but if miners aren't using time that approximates 
what their peers are using, under my system, their blocks would be rejected: 
so an incentive to use that "community clock" exists.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
The Bitcoin QT worked excellently the first time on my Mac.  I was so
surprised to do a pull and compile and bang the new wallet popped up
and was running.  Its much easier than getting it all going from
makefile and CLI.

 However I no longer see the tests subdirectory.  How are the unit
tests handled within this QT framework?

B
-- 
Make a Small Loan, Make a Big Difference - Check out Kiva.org to Learn How!


-------------------------------------

Agreed.


I don't think 0.3.24 "needs" either of those pulls.  Fixing
downgrade-to-0.3.24 is low on the priority list, because
downgrade-to-something-before-0.3.24 is just about as likely, and that
has to do something mostly reasonable.

I just pulled https://github.com/bitcoin/bitcoin/pull/379 "Do not use
comma as thousands separator", and pulled a block-chain lock-in at
block 13444.  Those were the only issues I think really need to be in
0.3.24.

-- 
--
Gavin Andresen


-------------------------------------
...

I like this part.


-------------------------------------

But what is that for? You said it's for a lightweight client to do
that when it receives a transaction, to verify that all the
dependencies are in blocks recursively. But why?


Well, it's more efficient to just verify the merkle branch. But yes.


Why do you need all of them? You just care about the ones sending
coins to you, surely?


IMHO it's fine to introduce new commands. They'll just be ignored by
old clients in any event.


-------------------------------------
On Monday, December 19, 2011 5:29:34 PM Gregory Maxwell wrote:

To clarify, I believe LYING about the client is a violation. Specifically, 
Gavin's commit intentionally reports "bitcoin-qt" for bitcoind. A common name 
for the codebase is compliant, and I don't see anything that says a version 
*must* be reported at all, let alone for a specific component, so it *could* 
comply by leaving that part off. But if there is a common part, it certainly 
isn't Bitcoin-Qt.

https://github.com/bitcoin/bitcoin/pull/715 contains a fix that should fulfil 
everyone's desires (Gavin wants security by obscurity by making bitcoind and 
Bitcoin-Qt indistinguishable; this is the default with pull #715).


-------------------------------------
Gavin,

 I try to reproduce the error by doing this (Ubuntu 11.10 64bits):

 rm -rf ~/bitcoin # CAUTION
 ./bitcoin-0.4.0-linux/bin/64/bitcoin

 * Encrypt my wallet
 * Close Bitcoin 0.4.0

 Next open Bitcoin 0.5.0rc7:
 ./bitcoin-0.5.0rc7-linux/bin/64/bitcoin-qt

 * Automatic wallet upgrade (I guess) working... No crashs...

Best,
Thiago

On 19 November 2011 14:20, Gavin Andresen <gavinandresen@gmail.com> wrote:

-------------------------------------
On Fri, 2011-08-05 at 01:52 -0400, Jeff Garzik wrote:

Could every node do the resends? Alternatively, could we implement a TOR
like tunneling system just for the first leg of the transactions
(overkill?). Then again, maybe just a TOR gateway if that's desired.


This is a nice idea but sounds rather unreliable.


There's already an implementation of this, called UTP. If we do decide
that using UDP is worthwhile, this library is probably better than
implementing something ourselves.

- Joel




-------------------------------------
Gavin, Jeff, et al:

A group of developers would be interested in maintaining 0.4 into the future 
as a stable branch (ie, bugfixes only). Would you be willing to plan on making 
the next mainline version after 0.4, being called 0.5, so we can release 
0.4.1, 0.4.2, etc? If we prepare the git repository + tags, would you guys be 
willing to make the actual release builds + source, and/or post such on the 
websites you administrate?

Luke and various others in #bitcoin-stable


-------------------------------------
Perhaps a bit off-topic for this list, maybe there should be a
software/services announcements list? Anyway ...

I'm happy to announce version 0.3 of the leading Java implementation of the
Bitcoin protocol. BitCoinJ is a widely used library that forms the
foundation of projects as diverse as the Android Bitcoin
Wallet<https://market.android.com/details?id=de.schildbach.wallet&hl=en>,
the p2p network status graphs <http://bitcoinstatus.rowit.co.uk/>,
MultiBit<http://multibit.org/>
, PoolServerJ <http://poolserverj.org/> and more.

You can get it either from our Maven
repository<http://code.google.com/p/bitcoinj/wiki/UsingMaven>or the
downloads
section <http://code.google.com/p/bitcoinj/downloads/list> of the website.

New in this release:

   - Many bugfixes, robustness and test suite improvements.
   - Major optimizations to reduce parsing overhead, most protocol messages
   are now parsed on demand.
   - A new PeerGroup API that handles the management of multiple peer
   connections.
   - Switched to using Maven for the build process, removed the bundled
   Bouncy Castle as a result. You can now depend on BitCoinJ using Maven if
   you don't need any special patches.
   - A bunch of new APIs to make writing Bitcoin apps easier.

This release would not have been possible without the major contributions
from:

*Steve Coughlan*, who contributed many parsing improvements and
optimizations
*Miron Cuperman*, who did significant work on the PeerGroup API
*Andreas Schildbach*, developer of the Android wallet, who as always
reported many bugs and useful suggestions for improvement
*Gary Rowe and Jonny Hegheim*, who set up the continuous build and Maven
infrastructure

What's next? The next release will focus on "more of the same", that is,
fixing bugs and filling out missing features so projects using the library
don't feel any need to patch their local copy of the library. By popular
request we'll be switching from Subversion to git. We'll also introduce a
stable wallet format that isn't dependent on Java serialization, and
timestamp key creation to resolve some issues with clients that ship block
chain copies. And finally of course, whatever is contributed by the
community.

thanks
/mike

-- 
Google Switzerland GmbH
-------------------------------------

I don't think there are huge objections to every change. You've only
really argued about this with Matt ;)

The vending machine/detecting double spends issue was discussed by
Satoshi in July 2010:

   https://bitcointalk.org/index.php?topic=423.msg3819#msg3819

He mentioned payment processors that could "alert the transaction is bad".

Gregorys idea looks sound to me. It'd be useful, though, to have a NAK
message for transactions anyway (not propagated). It's possible to get
yourself into a situation today where you connect to nodes that refuse
to relay your transaction for some reason (perhaps your peers are
using old fee rules, or you are) but you think the transaction was
relayed. The user is left wondering why the spend didn't confirm.

If nodes sent a message saying "I refuse to process this tx because
<reason>" it'd make debugging and testing easier as well.


-------------------------------------
Andy sounded very convincing when talking in favor of URLs. What's
wrong with his proposal?

2011/12/15, Walter Stanish <walter@stani.sh>:

Why don't just...

bitcoin://url.without.explicitly.specifying.provider
bitcoin://alias@provider
bitcoin://IIBAN@authorizedBitcoinInstitution ??

By the way, I don't like the fact that a single authorized institution
needs to map the IIBANs to bitcoin addresses.


-------------------------------------
This is expected to happen from time to time of course as it's inherently
racy, but there are a *lot* of bad nodes appearing in the DNS seeds.

$ nmap -oG /tmp/x -p 8333 `dig +short bitseed.bitcoin.org.uk
dnsseed.bluematt.me bitseed.xf2.org`
...
Nmap done: 48 IP addresses (25 hosts up) scanned in 9.80 seconds

$ grep -c 'closed' /tmp/x
6

So of 48 IPs returned only 19 are actually usable. This is slowing down peer
bringup for the Android apps, which don't currently save the addresses of
last-used peers (yes, I know we should fix this).

I was talking to a friend a few days ago about Bitcoin, he seemed
interested. I'm hoping he might take on DNS seeding as a project. A custom
DNS server that watches the network to find long-lived peers that run the
latest version would be helpful for resolving this kind of thing.
-------------------------------------
Bitcoin v0.3.24 is now available for download at
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.24/

This is another bug fix release.  We had hoped to have wallet
encryption ready for release, but more urgent fixes for existing
clients were needed -- most notably block download problems were
getting severe.  Wallet encryption is ready for testing at
https://github.com/bitcoin/bitcoin/pull/352 for the git-savvy, and
-hopefully- will follow shortly in the next release, v0.4.

Notable fixes in v0.3.24, and the main reasons for this release:

F1) Block downloads were failing or taking unreasonable amounts of
time to complete, because the increased size of the block chain was
bumping up against some earlier buffer-size DoS limits.
F2) Fix crash caused by loss/lack of network connection.

Notable changes in v0.3.24:

C1) DNS seeding enabled by default.
C2) UPNP enabled by default in the GUI client.  The percentage of
bitcoin clients that accept incoming connections is quite small, and
that is a problem.  This should help.  bitcoind, and unofficial
builds, are unchanged (though we encourage use of "-upnp" to help the
network!)
C3) Initial unit testing framework.  Bitcoin sorely needs automated
tests, and this is a beginning.  Contributions welcome.
C4) Internal wallet code cleanup.  While invisible to an end user,
this change provides the basis for v0.4's wallet encryption.

Full changelog ("git shortlog v0.3.23.."):

Dawid Spiechowicz (1):
      added polish translation

Doug Huff (1):
      Add OSX App bundle and correct build instructions to reflect reality.

Eric Hosmer (3):
      Updated Visual C++ makefile.
      Further updated Visual C++ makefile.
      Add keystore.h to makefile.vs's header list.

Gavin Andresen (3):
      Boost unit-testing framework.     make -f makefile.{unix,osx,mingw} test_b
      Block-chain lock-in at 134444
      Do not use comma as thousands separator     Using the comma as thousands s

Giel van Schijndel (2):
      rpc server: send '403 Forbidden' to rejected clients
      rpc: don't send 403 when using SSL to prevent DoS

Han Lin Yap (3):
      Double check translation and improved a translation string
      Update swedish translation
      Consistent Bitcoin example address

James Burkle (1):
      Edited init.cpp to include a check that -datadir exists

Jeff Garzik (6):
      FormatFullVersion: build fix related to recent translation improvement
      doc/release-process.txt: minor updates
      CWalletTx::GetAmounts(): pass NULL for CKeyStore*, rather than false     t
      Enable DNS seeding by default.
      Bump version to 0.3.24.
      Bump OSX version to 0.3.24 (missed in previous commit)

Joerie de Gram (1):
      Fix connection failure debug output

Jordan Lewis (8):
      Only include irc.h when needed
      Only include db.h when we have to.
      Only included rpc.h when necessary
      Only include net.h when we have to
      Only include init.h when we have to
      Only include strlcpy.h when we have to
      Remove some globally unused headers from headers.h
      Only include certain boost headers if necessary.

Matt Corallo (8):
      Update translations and remove obsolete translations.
      Add new DNSSeed dnsseed.bluematt.me.
      Only use dnsseeds and static seeds when not on testnet.
      Make UPnP default on Bitcoin but not on Bitcoind.
      Give more detailed error messages for connection failure.
      Added a couple minor things to match newer build process.
      Revert "Make UPnP default on Bitcoin but not on Bitcoind."
      Enable UPnP by default on bitcoin, but not on bitcoind (on gitian)

Pieter Wuille (6):
      move wallet code to separate file
      CWallet class
      Bugfixes walletclass
      Fix segfault when creating new wallet
      Limit response to getblocks to half of output buffer size
      Fix synchronization of default key

Shane Wegner (1):
      Fix missing includes needed for Boost 1.46.

Stphane Gimenez (1):
      Fix AddressBook syncrhonization between a CWallet and CWalletDB

Wladimir J. van der Laan (1):
      add GetTotalBlocksEstimate() function, move magic number to constant

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

4909c17a1cc025c6f6c88d036f0b487c51c510f6  bitcoin-0.3.24-linux.tar.gz
58531249230f769fdc755822b41e0f18ba59512c  bitcoin-0.3.24-src.tar.gz
d4b5425eff673551a326d5326b92a06359dc1a3d  bitcoin-0.3.24-win32-setup.exe
520aed70ee28a0a91ed49dd983639cb1fab2a93c  bitcoin-0.3.24-win32.zip
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIVAwUBThd13todwg8tvwyoAQKnVhAAnQzWKk5HrY5eMIprWwtsFZL0VOxAV2nV
Kn8NISmYk7PtfhzRm2sf0YYr369e7NtKAzdVNTRl+9m4RwQ6HhvzrChWG3OXxueA
AYg2JkS3oXbU2p4zOQT0/0ILp7iiHGhXCrEyd3bU5KkWOJhUnV0lS3ZzsELf8sab
I5MYQsrpZ9HZUI13e1ak/E0cub2gvxl+4D5Eg7EkNP71APR1MXGGzcfF7vlDYf4/
j1JTtkrBVZU6yFi8fNUxMQ/8G/0vyWLOOoCxaSvl5u5kssbI4rklhTA+BaqE1apx
xZN9Re0KjQ8cZiLQnVG9RhJsPhWe5tJRGqnKmaKF0gDELihFw9JLBDQkeSlhkhGx
wYtOfMClTDbd2qj5+dmvIrJPmDYHpGvmEO6xPsiv0qaNMZ1X/yMd9pp7nyCYosWB
u/vcPF0i4I27SDgRZ1TCPSgJgDQ4gEwKgzO69HywJw4KSkJq5MdecJDGRqTaYaf2
QI757pBXzFF3qORECSt5QIOjV1+bUc+1pB6450OfrZ+fTMMyWGF8t9t+TMAOwqoR
E0AMx2V+g+w6AXtpar4vsh0erexissREf6g1tW5ogy21Cv91MbIGZA9lUKNeU0Np
OgYSTNd5DvlbF7VpRZemSIz9gGWayqEi0G1oBQDo6DFcjeCS0okrIWPep4o1uoYz
xhxoauT2XEM=
=hgmn
-----END PGP SIGNATURE-----

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
For some reason my mail client is being thick and not responding
on-list, sorry about that...

On Tue, 2011-07-26 at 08:34 -0700, Rick Wesson wrote:
If you are using a self-signed cert to do any kind of important data
transfer you are just being stupid.  Here I am assuming your computer
isnt actually compromised, but only the network is, which I think is a
fairly good assumption.
No, DNSSEC is very well done, this thread is specifically about the
security implications of using DNSSEC for Bitcoin address communication.
IMO it is not a good idea, as for it to be secure against a coffee-shop
network MITMer you have to implement a full resolver with root trust
anchors and knowledge of root servers in Bitcoin, which does not seem
like a good idea.
I totally agree, however I don't think DNS-based resolving is a good
idea here.  HTTPS does have several advantages over a DNSSEC-based
solution without any significant drawbacks that I can see.

Matt
-------------------------------------
There really is no reason to add the extra network complexity for this.

First of all (as you point out) no one buying a Ferrari will refuse to
wait an hour for the payment to confirm.  If someone is attempting to
pull a similar trick on, say, a vending machine however it might make
sense.  But that changes the equation.  In order for these two scammers
to pull it off, some effort is required in terms of communicating the
time to send the coins and the nodes of the targets (vending machines or
whatever) must be figured out.  So now its less of "make it impossible"
and more of "make it really hard to the point that it is no where near
worth the effort".

Lets simplify the scenario a bit so that one scammer can pull it off.
Send one copy of your transaction to the target node and another to
large mining operations so that the payment transaction is considered
invalid to miners and a transaction which pays you is confirmed.

If you are the vending machine, your goal is not to figure out any
transactions which are yours, but to figure out which transactions which
are yours are going to be confirmed.  So, you peer with the largest
miners (a "Bitcoin backbone" or large miners and merchants has been
suggested over and over again and really hasn't happened) and modify
your client to, instead of dropping transactions which are
double-spends, keep both in memory pool and consider them both invalid
until one of them confirms.

This will work with 1, 2, or n scammers, doesn't require any additional
network messages, and offers just as good, if not better security over a
double spend message.

Additionally, in the future, when(/if) Bitcoin payment processors exist,
most merchants will rely on those, which can handle such double-spend
checks and tell a merchant a transaction is confirmed in ten seconds for
small transactions, an hour for large ones, or anywhere in between.
Such payment processors could also mine or have contracts with large
miners which allows them to influence the transactions which are to be
confirmed, allowing for even quicker confirmations and the offering of
insurance against unconfirmed transactions being invalidated.

Matt

On Thu, 2011-08-04 at 14:23 +0100, Andy Parkins wrote:
-------------------------------------
I added -mt and it compiles, but here is a surprise.  I had to add
libz.a to the makefile.osx.  Sounds odd!  Its coming from the crypto
libs.

On Wed, Oct 5, 2011 at 11:50 AM, Douglas Huff <dhuff@jrbobdobbs.org> wrote:



-- 
Make a Small Loan, Make a Big Difference - Check out Kiva.org to Learn How!


-------------------------------------
On Fri, Jul 1, 2011 at 4:00 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

No objections...  I could get out 0.3.24-rc1 post-sleep, presuming
this plan (or something like it) receives Holy Alpaca Pee.
-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Good idea.


How about BRC?

 Bitcoin Request for Comments?

Otherwise I like the sound of BERs, but it doesn't matter too much the name.



----- Original Message -----
From: Gavin Andresen <gavinandresen@gmail.com>
To: bitcoin-development@lists.sourceforge.net
Cc: 
Sent: Monday, September 19, 2011 6:57 PM
Subject: Re: [Bitcoin-development] Bitcoin Enhancement Proposals (BEPS)

New 'standard' transaction forms would be perfect candidates for BEPS.

I think we aught to have a formal proposal to separate the protocol
version from the client version, too.

--

Does anybody besides me think maybe we should name them something
other than "BEP" ?

I'm worried we'll regret it in two years when a google for "BEP003"
takes you to the BitTorrent EPs instead of the BitCoin EPs.

Maybe "BIP" == Bitcoin Improvement Proposal
or "PEB" == Proposal to Enhance Bitcoin
or "BER" == Bitcoin Enhancement Request

I think I like "BIP" (PEB sounds like a diet soda, and I don't know
if BER should be pronounced "bear" or "beer").

I generally don't care about names, but it seems like a little
planning now might save some confusion later. And I don't want the
BitTorrent folks to get pissed off at us for 'stealing' their acronym,
either.


-- 
--
Gavin Andresen

------------------------------------------------------------------------------
BlackBerry&reg; DevCon Americas, Oct. 18-20, San Francisco, CA
Learn about the latest advances in developing for the 
BlackBerry&reg; mobile platform with sessions, labs & more.
See new tools and technologies. Register for BlackBerry&reg; DevCon today!
http://p.sf.net/sfu/rim-devcon-copy1 
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-------------------------------------
On Fri, Sep 23, 2011 at 12:38:48PM -0500, kjj wrote:

Well, I agree, this scheme is not (primarily) intended to be a solution
for people who want to accept anonymous donations; static addresses
work very well for that application (unless you want unlinkability
between different payments).

Let me try to explain what I do want to accomplish.

What current addresses are, is a reference to a public key. The way they
are used is as a template for a transaction. If you do not need complex
transactions, this suffices indeed, given that all other negotiation about
the payment occurs out-of-band already (e.g., a webshop interface that
after clicking 'pay' gives you a freshly generated bitcoin address and
stores it so it can track your payment).

What I want to do is to standardize part of that out-of-band communication
inside a protocol. The first observation is that if you want a freshly
negotiated key each time, some form of bidirectional communication is 
necessary anyway, and a static txout template does not suffice anymore.
If you're doing bidirectional communication, you are no longer limited
by the space constraints of something by-human-copy-pastable, and you can
just negotiate the txout directly, which transparently adds support for
anything that is possible through bitcoin scripts.

So far, the creation of transactions is "solved". However, by asking nodes
not to broadcast their transaction, but instead just send it back (we're
communicating with some other party already anyway, and this other party
is the one who cares about the tx being accepted), the receiver can track
it as well. Furthermore, by passing tags along, identification of
transactions becomes a lot easier. As a  extra advantage, this makes the
requirements for a client easier as well (it doesn't need to be a p2p
node).

The third step is adding signatures to authenticate the whole process.
They are necessary to make sure the client is communicating with who he
thinks he is, but by using them for the submission of the transaction as
well, it gives the client a proof of payment acceptance too.

Summarized: addresses are a limited method for defining payments, and as
soon as you move to a protocol instead of a static template, a lot of
possibilities open up.

-- 
Pieter


-------------------------------------
On Monday, September 26, 2011 4:47:06 PM Gavin Andresen wrote:

The first one I was referring to is a *transaction* with "non-standard" sig op 
count, which is AFAIK allowed in blocks, just not accepted by the mainline 
rules. In the second case, that transaction is not tied to a specific block. 
Maybe the person spending it sees it matured beyond 100 confirmations, and you 
only see 99. An attacker could use these things to get nodes to ban each 
other.


-------------------------------------
This is maybe the best idea. I added it:
https://en.bitcoin.it/wiki/BIP_0015#IP_Transactions

Things I like about this:
- IP transactions are useful, but have a security flaw. This mitigates their security problems.
- The code for IP transactions is already in Satoshi client. If other clients want to add IP transactions, then it can be done with minimal fuss/bloat.
I feel that for any protocol extension, less is more. The less code 
needed, the better the extension. Not always but generally we want to 
avoid bitcoin protocol bloat which *will* happen far in the future. The 
only way to mitigate how spaghettified the standard will be in the 
future, is by careful cautious planning now.

- We can have a proxy node running 24/7 for us, serving our public keys in lieu of us.



________________________________
 From: theymos <theymos@mm.st>
To: bitcoin-development@lists.sourceforge.net 
Sent: Thursday, December 15, 2011 7:59 PM
Subject: Re: [Bitcoin-development] [BIP 15] Aliases
 
Bitcoin already has code and a protocol for transactions to IP
addresses. Why not reuse that for dynamic address lookup? Just a few
changes are necessary to enable complete user@server.com handling:
- Extend the protocol so that "reply" messages can be signed by a fixed
 public key
- Extend "checkorder" messages so they can specify an account to
 send BTC to. Or standardize on how to put the account into the
 message field.
- Enable DNS lookups for IP transactions. The DNS-only proposals could
 also be used here to avoid having to use the IP transaction protocol
 sometimes. The public key for signing "reply" messages can be gotten
 from TXT records. This will be safe with DNSSEC and Namecoin. With
 plain DNS Bitcoin could take a SSH-like approach and ask the user to
 verify the public key the first time it is used, remembering it later.

DoS attacks are already handled by the IP transactions code: the same IP
address is always given the same bitcoin address until it pays to that
bitcoin address.

------------------------------------------------------------------------------
10 Tips for Better Server Consolidation
Server virtualization is being driven by many needs. 
But none more important than the need to reduce IT complexity 
while improving strategic productivity. Learn More! 
http://www.accelacomm.com/jaw/sdnl/114/51507609/
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
On Mon, Sep 5, 2011 at 8:04 AM, Mike Hearn <mike@plan99.net> wrote:
[snip]

I'd rather see effort spent on the root issues, e.g. having nodes
gauge their own suitability (working inbound port, reasonably current
block chain, etc) before becoming advertised listeners.

Or more importantly— figuring some way of setting up network
simulations which could be used to actually _validate_ proposed
changes in this area.

I, or many other people, could spout endlessly about attractive
sounding network enhancements (e.g. move-to-front peer prioritization,
tweaks to peer selection, etc.) but it's all just arm waving without a
way to measure it, and the real network is far too slow to upgrade
(and important) to test things in situ while testnet is far too small
and unlike the real network for useful testing.


-------------------------------------
Hi,

You may have a look at the following proposal. It associates
generations txouts with the appropriate addresses and accounts.
(See my previous mail)

https://github.com/sgimenez/bitcoin/commit/a8e6510042f2f7f951414c7da124668b30da4acd


Either this, or maybe webservices should be told to forget about
categories and to rely only on the sign of the amounts. Maybe a "type"
field with values "credit"/"debit" could help them? This way, more
categories could be added later (escrow transactions, or other scripts
that might be standardized).

An official API guide (not just a technical reference) would be very
valuable here.

Last, I agree that {list,get}receivedby* should include generated
amounts, because there is currently no way to do this for
generations. (This issue is not addressed by my patch yet)

Best,
Stéphane


-------------------------------------
Matt,

I started from the premise that I can't remember a bitcoin address but
I can/do remember email addresses which, as an identity are easy
labels for humans to remember. The IPv4 address is the metaphor I
consider. As someone who actually worked on parts of DNSSEC I do
believe in it -- and that it offers reasonable security for
transactions.

Remember MITM attacks on DNS for a transaction are for the sender
against the merchant, and it is only the wallet ID that would be
available. These identifiers are something people use "like" an
identity in that they are frequently shared in public spaces.

Also, a DNS mapping does not prevent or deny anyone from leveraging
HTTP(S) for simular mapping. My point is that DNS is designed for name
to thing mapping and its done a decent job. What I like about the DNS
is that it is frequently leveraged as a proxy for identity and http
URIs are not. Where https://wesson.us/ricks-bitcoin-address doesn't
feel like and identity (to me) and rick.wesson.us does.

My point is about usability and user experience. Bitcoin if used in
the DNS might make DNSSEC more popular which IMHO is a good thing.

-rick


On Mon, Jul 25, 2011 at 6:35 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:


-------------------------------------
There has been some discussion on the new Bitcoin
StackExchange<http://bitcoin.stackexchange.com>site lately about the
alert protocol. A few have suggested that it might
carry the potential for abuse (spam/DoS) and others have argued that it's
merely deprecated. In any case, enough have voiced concerns that I've forked
bitcoin/bitcoin, removed the snippet of code from main.cpp that makes the
questionable call and submitted a pull
request<https://github.com/bitcoin/bitcoin/pull/506>.
On that pull request it was noted by Gavin Andresen that it merited
discussion here and some kind of consensus should be reached before acting
on that pull request. It was also mentioned that he thought the feature was
still more useful than dangerous and that he would argue against.

So I pose the question to you fine fellows: Is the alert system valuable, an
unnecessary risk or merely a snippet of deprecated code? Should it be
removed?

Sources:
http://bitcoin.stackexchange.com/questions/583/what-is-the-alert-system-in-the-bitcoin-protocol-how-does-it-work/590
http://bitcoin.stackexchange.com/questions/636/is-the-alert-system-still-in-the-main-clients-code-will-it-be-removed/711
-------------------------------------
I've just joined the list with the goals of producing a patch to
sendtoaddress in rpc.cpp to support DNS lookups so that one could publish a
TXT record in the DNS with their wallet address to facilitate sending of
coin.

I'm proposing something like the code below, which works but needs
additional error handling.

also working on a internet-draft to describe how to put bitcoin addresses in
the DNS which I hope to post the first draft of this week.

I'd appreciate comments on issues around annomity, community push back and
any other issues you might have with leveraging the DNS for bitcoin
transactions.

thanks,

-rick


Value sendtoaddress(const Array& params, bool fHelp)
{
   if (fHelp || params.size() < 2 || params.size() > 4)
       throw runtime_error(
           "sendtoaddress <bitcoinaddress> <amount> [comment]
[comment-to]\n"
           "<amount> is a real and is rounded to the nearest 0.00000001");

/**
; <<>> DiG 9.7.3 <<>> _btc.rick.wesson.us txt
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 43754
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;_btc.rick.wesson.us.           IN      TXT

;; ANSWER SECTION:
_btc.rick.wesson.us.    300     IN      TXT     "BTC=1;
1GCVXLfF1TcpnnDLJRHk845NZhuJWQTnUD"

;; Query time: 143 msec
**/


   string strAddress = params[0].get_str();
   string dname="_btc.";
   if(strAddress.find("@")){
      unsigned char answer[255];
      int len=0;
      dname.append(strAddress);
      dname.replace(dname.find("@"), 1, ".");

      if((len = res_query(dname.c_str(), C_IN, T_TXT, answer, PACKETSZ)) <
0) {
        string dnsAnswer=(char*)answer;
        int i=dnsAnswer.find("BTC=1;");
        if( i < 0) throw runtime_error( dname + " is not associated with a
bitcoin address");
        i += 6;
        i = dnsAnswer.find("1", 6) ; // address start with a one (1)
        dnsAnswer.erase(0,i);
        strAddress=dnsAnswer;
      }

   }
   // Amount
   int64 nAmount = AmountFromValue(params[1]);
...
-------------------------------------
If I remember the details correctly you could combine (lagrange
interpolation) the results of m smaller encryptions/signatures without ever
sharing the secret key share itself. No idea if that is possible with ecdsa
at all, but it sure would solve quite a few problems, as it would allow
several independent servers to share a secret key, sign transactions with
it, but no m-1 compromised machines would endanger the whole balance.
I will definitely look into it when I'm back from holidays.

Cheers,
Cdecker
On Aug 24, 2011 9:29 PM, "Gregory Maxwell" <gmaxwell@gmail.com> wrote:
works
if
-------------------------------------
On Fri, Jul 1, 2011 at 5:35 PM, <jan@uos.de> wrote:



If bitcoin listened on IPv6 that might help for alot of people. Windows 7
users get a teredo IPv6 address (unless they disable it) when behind NAT on
IPv4. Take any win7 box and put it on a typical NAT /DSL setup this is what
happens. I think this might actually work for more users than have UPNP
support on their DSL gateways. teredo IPs aren't that stable though (they
change frequently) and they might tend to flood the address cache with stale
addresses.

Rob
-------------------------------------
@Matt
I didn't thought about firstbits scalability, but the "registering
crap" and squatting arguments don't apply to green addresses because
no one wants fancy or easy to memorize names there. Is just a way to
make the bitcoin addresses shorter in the green addresses protocol to
be able to have various of them in the same QR-code.

@Amir
I see, the point is to be able to type the alias directly into the client.

I like the DNS proposal. This would allow for both well known working
centralized technology and namecoin (not proven, but decentralized)
options to be used.


2011/12/13, theymos <theymos@mm.st>:


-- 
Jorge Timn


-------------------------------------
On Wed, Aug 10, 2011 at 11:36, John Smith <witchspace81@gmail.com> wrote:

Back on topic:

I initially misunderstood your proposal. Let me reformulate, and
suggest some names:
* bitcoin-gui (or bitcoin-qt): always starts GUI, optionally starts
RPC server, no RPC client
* bitcoin-server: always starts RPC server, no RPC client, no GUI
* bitcoin-client: always runs RPC client, no RPC server, no GUI

Additionally, we could offer a script or symlinked executable with
names "bitcoin" and
"bitcoind" that detect whether RPC commands are present on the command line, and
based on this invoke either bitcoin-server/bitcoin-gui or
bitcoin-client (for backward
compatibility).

-- 
Pieter


-------------------------------------

As Alan said, that won't work-- it will not be relayed across the
network because it isn't a valid transaction until it has enough
signatures.


Formats and protocols for gathering signatures are in the TODO
category-- Alan's BIP 10 is the next piece of the puzzle, maybe a
standardized http/https RESTful API, or HTTP/JSON, or protocol buffers
and raw sockets, or... something... solution (or solutions) built on
top of that makes sense.

I don't think partially-signed transactions belong on the main Bitcoin
P2P network, mostly because I don't see any way of preventing somebody
from endlessly spamming bogus, will-never-be-completed partial
transactions just to be annoying.

-- 
--
Gavin Andresen


-------------------------------------
On Thu, Aug 25, 2011 at 02:31:49PM -0400, Gregory Maxwell wrote:

On the github pull request I posted a general scheme that can convert arbitrary
expressions over signature-checks (given in RPL notation) to bitcoin scripts.
Maybe we can define an address type that encodes an expression in RPL form (which
should be more compact and more easily parseable)?

That basically just means the usual bitcoin scripts, with two extra pseudo-
instructions: one that represents an address check, one that represents an
pubkey check.

For example (same example as on the pull req), the expression
a1 OR (a2 AND a3) OR COUNT(a4,a5,a6)>1 (with a1-a6 given addresses)
can be given in RPL form as

  ADDR<a1> ADDR<a2> ADDR<a3> BOOLAND BOOLOR ADDR<a4> ADDR<a5>
  ADD ADDR<a6> ADD 1 GREATERTHAN BOOLOR

Which is 13 bytes + 6*20 bytes, instead of the 54 bytes + 6*20 bytes for the
real bitcoin output script.


-- 
Pieter


-------------------------------------

Would the multi-signature proposal be a good test case for BEP-0002?

https://gist.github.com/dba89537d352d591eb36

I can reformat it and email here.

Gavin has a competing one:  https://gist.github.com/39158239e36f6af69d6f

and I have a pull request matching a previous version of my proposal.

--
Bobby Groff





-------------------------------------
On Thu, 2011-08-18 at 10:00 -0400, Gavin Andresen wrote:

This particular attack seems quite dependant on the target not using the
deposit Tx as input. I believe this whole class of attacks become
ineffective if each account has it's own separate wallet.

Also, receiving a block with a transaction that hasn't been broadcast to
the network is in itself quite suspect. Are there cases where that
happens legitimately? Perhaps in such a case, don't treat the block it
came in as a confirmation at all. Instead, start counting from the next
one.

- Joel



-------------------------------------
On Jul 1, 2011, at 12:50 PM, Matt Corallo wrote:


It's not on OS X so I assumed it wasn't anywhere else. My bad.

-- 
Douglas Huff


-------------------------------------
I am working on the following to create a stable build environment for
testers:

- Build bitcoin 4.0 source in Windows 7
- Create a package of the build dependencies, and upload to SF
- Write up instructions for the build process

x Build bitcoin 4.0 source in Ubuntu 11
- Create a package of the build dependencies, and upload to SF
- Write up instructions for the build process

I am also compiling a list of commits that need to be tested in both
environments. If you can think of any priority commits that need testing,
and/or have a test case for them - please link the pull request in a
response to https://github.com/alexwaters/bitcoin/issues/2

This is not a requirement for pull requests, but will help process the
important/easy ones a lot faster. I would love to discuss other ways of
prioritizing pull requests, but this seems like it can get the job done for
the time-being.

-Alex Waters
-------------------------------------

As I said, that is a "can't never happen but we'll wear a
belt-and-suspenders just in case" case.

AcceptBlock() is called from two places in the code:

ProcessBlock, if the block is not an orphan:
    // If don't already have its previous block, shunt it off to
holding area until we get it
    if (!mapBlockIndex.count(pblock->hashPrevBlock))
    {
....  orphan processing stuff...
      return true;
    }

    // Store to disk
    if (!pblock->AcceptBlock())
        return error("ProcessBlock() : AcceptBlock FAILED");

The mapBlockIndex.find(hashPrevBlock) in AcceptBlock can't fail.

The second place is recursively, in AcceptBlock(), processing orphans
that link to the block being accepted, and mapBlockIndex.find() would
find the used-to-be-an-orphan-block-that-is-now-being-accepted.

So: it is a case that should be impossible to trigger. However, in
case there is some subtle bug or edge case I'm not considering it seem
to me keeping the check is appropriate, and, because it will be a
subtle bug or edge case, it seems to me keeping the DoS penalty is
also appropriate, because attackers look for subtle bugs and edge
cases that can be exploited.


-- 
--
Gavin Andresen


-------------------------------------
On Thu, Sep 1, 2011 at 2:13 AM, Luke-Jr <luke@dashjr.org> wrote:


You can put assignments on the commandline; for example,

qmake "CONFIG+=test" test.pro

Like in plain make, these variables can be used for conditionally
enabling/disabling libraries or other options in the .pro file.

http://doc.qt.nokia.com/latest/qmake-manual.html

(reminds me that I still need to add the USE_UPNP option)

Note that qmake is a pretty simple tool, optimized for conveniently building
Qt applications in a cross-platform way; it in no way compares to
cmake/autotools or another "full" build system. But it's enough for building
bitcoin-qt on the supported target architectures so that's good enough for
me... For "bitcoind" and "bitcoin-wx" you probably want to keep around the
makefile.

JS
-------------------------------------
On Aug 24, 2011 3:29 PM, "Gregory Maxwell" <gmaxwell@gmail.com> wrote:
works
if

I don't think anything simple enough to actually be used by people in
general does. Same concept as what I proposed earlier before nanotube gave
me the context for Gavin's intent on irc.

Now that I'm understanding the use case I really think the best way to go
about this initially is like you said earlier.

Provide methods to export/import unsigned txns, provide methods to run the
GUI in a way that can track your own addresses with only pubkeys available
to the client, provide methods to sign and import/export/broadcast signed
txns.

With these tools offline wallets become feasible. Combined with wallet
crypto I think this is really the best that can be done to protect users
from themselves in a way that isn't too complicated for them to actually
use.
-------------------------------------
Hey Chris,


This type of intermediate routing makes Tor slow 
<https://svn.torproject.org/svn/projects/roadmaps/2009-03-11-performance.pdf>. 
Bitcoin does not and imho should not make anonymity guarantees. Many 
users do not need them.

Let those who want anonymity connect through Tor, Freenet, etc. It's 
easy to add anonymity via an extra layer, but it is impossible to add 
performance on top of a slow system.

That's really the only thing I wanted to point out - if you do DHTs, 
focus on performance, not anonymity. :)

Cheers,

Stefan

On 12/17/2011 2:37 PM, Christian Decker wrote:

-------------------------------------
I'm getting really, really annoyed by the forums.

Can we please please remove the link to them from bitcoin.org, and replace
it with a forum that has but one goal: help users of bitcoin (and merchants,
and developers)?

No speculation about economic or political futures, no philosophical pissing
contests, no "I trust/distrust this/that exchange/company" FUD, no repeated
discussion of things already answered in the FAQ, etc.

There is a place for all of those, but not in the official forums of an open
source project. IMO, if we link an official forum from bitcoin.org at all,
it should be a neutral place for helping people adopt the technology (a bit
like the Ubuntu forums, for example).

Just my two bitcents...

JS
-------------------------------------
On 2011 August 05 Friday, Matt Corallo wrote:

I'm arguing that "number of connection slots" isn't the best metric; so that 
wouldn't matter.  Just keep accepting incoming connections (with some sanity 
limit of course) until you've allocated your bandwidth, not your number of 
connections.

If I connect to a thousand nodes and never send anything, I'm not using up 
very much of their resources.  If _they_ want to use up resources by relaying, 
then that is their choice, but again they can do that based on bandwidth 
calculations rather than connection counts.  If I am sending, then that adds 
to their bandwidth and gets included in whatever limit they've chosen.

For example: the client could simply maintain an average bandwidth over all 
connections.  If that average is less than threshold0, then make new outgoing 
connections.  If that average exceeds threshold1, then stop accepting incoming 
connections.  If it exceeds threshold2, start dropping established incoming 
connections.  If it exceeds theshold3, start dropping established outgoing 
connections.

The actual rules don't matter so much; I'm just saying bandwidth is a better 
metric than connection count.  If you limit by connection count, then you'll 
just end up filled with non-relaying listeners, since they (in the future) 
will be the most commonplace.  You'll have no incoming relays, and therefore 
nothing to forward, so your bandwidth will be zero, but your connection count 
at maximum -- you've locked yourself out.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
I think we should move forwards, not sideways-- git tip + whatever we
need to fix bugs in current tip is my preference.

RE: upnp:  I say pull Matt's patch (bitcoin=upnp, bitcoind=!upnp).

-- 
--
Gavin Andresen


-------------------------------------


I think this would solve one of the other issues I raised about the green
address idea .... you can have some kind of trust aggregator sign the
transactions. Merchants like MtGox that send would create a transaction,
export it, upload it to the trusted authority which can just check IP
address or something to verify it's really coming from MtGox, then sign it
and broadcast it.
-------------------------------------
1) Native Long Polling Support
Not sure about this one, it would be useful, but preferably done once
Bitcoin is cleaned up anyway. A probable good way would be a central
notification interface which net, wallets, etc all connect to, including
things like a pool server. Thus I'm not sure about merging something
like this now.

2) A fix from Luke Dash Jr.
His branch is at
https://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin/commits/getwork_dedupe and I would say it would be good to merge. gmaxwell indicated that hes been running this for a while and it is stable.

3) Hub Mode
Why? We dont have enough nodes listening to begin with, this generates a
ton of net usage on other listening nodes, which is not good. If you
open up your ports, you will get just as many, if not more connections
very easily.

4) RPC Turbocharge
Yep, this is something that is needed, there is also the other asio pull
request on github, not sure how/if these compare.

5) Resource Leak Fix
Looks good to me.

Matt

On Fri, 2011-07-01 at 18:03 +0200, Christian Decker wrote:


-------------------------------------


Interesting that you bring up the effort factor.

The notion that every individual will want to run their own DNS or
HTTP based alias system to dispense transaction-specific bitcoin
addresses seems - on this basis - alone a little far fetched. Such a
system would provide very little added value at significant hassle to
the small subset of users who could be bothered setting up such a
scheme. Also, remember that most people in the world don't even know
what DNS is, nor do they have the capacity or motivation to set up a
program on a web server for what amounts to minor ongoing time savings
and some vanity thrills.

To my mind, it is far more likely that third party hosted services
(such as providers of hosted wallet, conventional currency holding and
exchange services) will provide aliasing resolution, and that these
alias resolution services will operate on an alias@provider mechanism
(for example, IIBAN and its 'institution' codes @ ).

In addition, during the 'pre-transaction exchange' that the alias
resolution process essentially represents, additional value could be
added by these types of service providers by providing functionality
presently excluded from Bitcoin but relevant to real world financial
systems. For example this 'pre-transaction exchange' process might
include, in addition to alias resolution, transaction metadata
exchange (transaction description, invoice/order number, taxation
information, schedules of fees and charges, pre-arranged currency
exchange rates if filling an payment for an amount quoted in another
(eg: conventional) currency, shipping terms, transaction reversal
(cancellation) terms, escrow terms, etc.)

Regards,
Walter Stanish
Payward Inc.


-------------------------------------
On Sunday 18 Dec 2011 01:27:10 Jordan Mack wrote:


I'm working on (slowly) making a client able to download-on-demand.  That is 
to say that the block chain headers would be downloaded and maintained, but 
the block bodies would be downloaded as needed for full verification.  It's 
certainly not possible with the current protocol; but it's certainly a 
conceivable application.  I suppose it slots between headers-only and full 
client conceptually.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
I first thought it was a problem in my UI, after syncing to the latest git
version. But the following screenshot says enough:

http://img24.imageshack.us/img24/7363/screencpf.png

The address are also missing in the detailed transaction view. It appears
that the problem is in script.cpp:

        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)
        {
            uint160 hash160;
            if (item.first == OP_PUBKEY)
                addressRet.SetPubKey(item.second);
            else if (item.first == OP_PUBKEYHASH)
                addressRet.SetHash160((uint160)item.second);
            if (keystore == NULL || keystore->HaveKey(addressRet))
                return true;
        }

It will only return "true" on keys that are in the keystore (your own
private keys...). After commenting out the "if (keystore == NULL ..." line,
the display is fixed.

But that simple solution might have impact somewhere else.

JS
-------------------------------------


I agree with Amir completely on both these points.

With something as critical as financial transactions, no exceptions can 
be made. The reported client and version should be ignored completely. 
If a client does not comply with the protocol, they must be rejected 
outright.

It is not in the best interest, or ability, to attempt to micromanage 
how developers choose to use the information given. Recommendations and 
guidelines can be made, but how they choose to implement is ultimately 
their decision. In my opinion, clear and concise definition of the 
protocol, and strict adherence in the mainline client, are the best 
options available.

The protocol version should be indicated so that it can properly be 
handled. Neither the name of the client, or it's version, need to be 
reported in this. Protocol validation should ignore this completely.

I do not believe that leaving out the client name and version entirely 
is the best option though. As silly as it may seem to some, vanity and 
recognition are very strong motivators. We want to encourage more 
supporters to the scene, not scare them away. The additional data 
provided by this could also be used for calculating various statistics. 
It sounds like BitcoinJ and BitDroid have already found ways of adding 
it in anyway. I believe it is in the best interest of the developers to 
formalize how this information will be included, and use it to their 
advantage.

TL;DR: Adhere strictly to the protocol, and reject clients that do not. 
Add a user agent string of some kind, but keep it separate from the 
protocol version.



-------------------------------------
It is a lot easier to set up an HTTP server to dynamically respond with addresses than a DNS record.  It is considered a good practice to use a different address for every payment.

------------------------
"It stopped being just a website a long time ago. For many of us, most of us, Wikipedia has become an indispensable part of our daily lives."
— Jimmy Wales, Founder of Wikipedia 
Help protect it now. Please make a donation today: http://www.wikimediafoundation.org/wiki/Donate


--- On Wed, 12/14/11, Kyle Henderson <k@old.school.nz> wrote:

From: Kyle Henderson <k@old.school.nz>
Subject: Re: [Bitcoin-development] Fwd: [BIP 15] Aliases
To: "Zell Faze" <zellfaze@yahoo.com>
Cc: "Luke-Jr" <luke@dashjr.org>, "Rick Wesson" <rick@support-intelligence.com>, bitcoin-development@lists.sourceforge.net
Date: Wednesday, December 14, 2011, 11:56 PM

Just so we're clear, what is the need for HTTP at all?

A query for a string and an answer can all be handled via DNS.

On Thu, Dec 15, 2011 at 4:57 PM, Zell Faze <zellfaze@yahoo.com> wrote:

Could we combine this proposal and the HTTPS proposal?



The DNSSEC TXT record could give instructions on how to query an HTTPS server to get the address.  Then we get the dynamism of HTTPS without having a rigid URL scheme for querying the server along with the advantages of DNSSEC.





-------------------------------------
http://tinyurl.com/3gpvrhm

git fetch git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git \
 base58_liberal_parsing && git merge FETCH_HEAD

This simple modification allows base58 inputs to use zero and uppercase 'O' in 
place of lowercase 'O', as well as lowercase 'L', bar/pipe, and exclamation 
point in place of one. This allows more tolerance when inputting addresses or 
other data by manual typing, and gives a bit more variety to vanity addresses.


-------------------------------------
On Thu, 2011-07-28 at 08:45 +1000, Gavin Andresen wrote:

I do think it would motivate some people to fix a bug or two, though I
would say it wouldn't encourage long-term contributors, just a bunch of
hacked together patches which "fix" a bug.

I know jgarzik hates the idea of branching for releases, but quite a few
projects do that, and it seems to work fairly well.  I would support the
idea of starting with 0.4 and branching for bugfixes to an 0.4 branch,
then adding new features to a head branch to be eventually called 0.5.
Awesome.

-------------------------------------
On Thu, Aug 18, 2011 at 12:47 PM, theymos <theymos@mm.st> wrote:

Not that helpful. In that attack pattern the attacker can release the
block and the conflicting transaction at the same time (to different
nodes, of course). They can also inject the conflicting transaction
into many places in the network at once.


-------------------------------------
Reposting from the forums:
  https://bitcointalk.org/index.php?topic=47586

I just tagged the git tree "v0.5.0rc1". If you are able, please
compile and help test.

See the INSTALL file at the top of the source tree for instructions on
compiling. Binary releases for at least unix and mac should be
available in the next day or two (there is a show-stopper bug on
Windows, and we could use help from people familiar with
cross-compiling using mingw to update the Windows build process).

Major bugs you should be aware of:

Wallet does not relock on Win32

Major changes from version 0.4:

Switched from wxWidgets for the GUI to Qt, using Wladimir J. van der
Laan's bitcoin-qt. Why? We didn't have any wxWidgets programmers
contributing fixes or improvements.

New JSON-RPC commands:

getmemorypool : alternative to 'getwork' that provides everything
needed to construct a block with a custom generation transaction.
listsinceblock : Get all transactions in blocks since block [blockid]
signmessage/verifymessage : sign/verify a message with a wallet
public/private keypair

Deprecated JSON-RPC features:
'midstate' data item from getwork requests

Deprecated JSON-RPC commands that have been REMOVED:
setlabel
getlabel
getaddressesbylabel
getamountreceived
getallreceived
getreceivedbylabel
listreceivedbylabel

Run: git shortlog --no-merges v0.4.0..
... to get a complete list of changes, and thanks to everybody who is
contributing!


-- 
--
Gavin Andresen


-------------------------------------
On Monday, December 12, 2011 3:56:01 PM Pieter Wuille wrote:

Or both: use this proposal for 20-byte base58 for now, and overhaul it in the 
future (maybe when the block chain forks?).


Looks good here.


These are 32-byte, so have no reason IMO to follow the 20-byte proposal.
Since a lot of services are already using version 128 ('5') for bitcoin 
private keys, and 128 is "reserved" in the 20-byte proposal, I think it's fair 
to leave it alone (for now).


-------------------------------------
Due to the flood control limits becoming an issue again, it would appear
we need a 0.3.24 release.  The idea is to have sipa's flood limit fix
(https://github.com/sipa/bitcoin/commit/df94ed7ac0ed7bb3a96cf434ca3c64c4b475e37e), dnsseed on by default, and maybe UPnP enabled by default as well.

I just got a DNSSeed up with reliable hosting which dynamically fills
its hostname with random nodes known to be up and accepting connections
(and on port 8333 and on version 0.3.19 or higher) (dnsseed.bluematt.me)
and I hope others follow suit with
https://github.com/TheBlueMatt/dnsseed (its poorly done but works just
fine).  This was added to master in 44d16327. Since its no longer a
static list, I think its time to enable dnsseed by default (I have one
or two connections by the time the GUI opens when I use -dnsseed
-noirc).

Also, I think UPnP by default would be a good idea as it could increase
the percent of nodes which accept incoming connection (and other P2P
applications which depend on the ability to accept incoming connections
have it on by default as well, such as Skype).  Jgarzik has also
suggested this, and I really dont see much of a reason not to.

Also,
https://github.com/bitcoin/bitcoin/commit/3a3eabb57ae41dd2162ca8230423abf4a90ef644 should be included to fix the no-connections-up segfault.

Matt
-------------------------------------
Thanks to everybody who contributed:

Bitcoin version 0.4.0 is now available for download at:
  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.0/

The main feature in this release is wallet private key encryption;
you can set a passphrase that must be entered before sending coins.
See below for more information; if you decide to encrypt your wallet,
WRITE DOWN YOUR PASSPHRASE AND PUT IT IN A SECURE LOCATION. If you
forget or lose your wallet passphrase, you lose your bitcoins.
Previous versions of bitcoin are unable to read encrypted wallets,
and will crash on startup if the wallet is encrypted.

Also note: bitcoin version 0.4 uses a newer version of Berkeley DB
(bdb version 4.8) than previous versions (bdb 4.7). If you upgrade
to version 0.4 and then revert back to an earlier version of bitcoin
the it may be unable to start because bdb 4.7 cannot read bdb 4.8
"log" files.

Notable bug fixes from version 0.3.24:
--------------------------------------

Fix several bitcoin-becomes-unresponsive bugs due to multithreading
deadlocks.

Optimize database writes for large (lots of inputs) transactions
(fixes a potential denial-of-service attack)



Wallet Encryption
-----------------
Bitcoin supports native wallet encryption so that people who steal your
wallet file don't automatically get access to all of your Bitcoins.
In order to enable this feature, choose "Encrypt Wallet" from the
Options menu.  You will be prompted to enter a passphrase, which
will be used as the key to encrypt your wallet and will be needed
every time you wish to send Bitcoins.  If you lose this passphrase,
you will lose access to spend all of the bitcoins in your wallet,
no one, not even the Bitcoin developers can recover your Bitcoins.
This means you are responsible for your own security, store your
passphrase in a secure location and do not forget it.

Remember that the encryption built into bitcoin only encrypts the
actual keys which are required to send your bitcoins, not the full
wallet.  This means that someone who steals your wallet file will
be able to see all the addresses which belong to you, as well as the
relevant transactions, you are only protected from someone spending
your coins.

It is recommended that you backup your wallet file before you
encrypt your wallet.  To do this, close the Bitcoin client and
copy the wallet.dat file from ~/.bitcoin/ on Linux, /Users/(user
name)/Application Support/Bitcoin/ on Mac OSX, and %APPDATA%/Bitcoin/
on Windows (that is /Users/(user name)/AppData/Roaming/Bitcoin on
Windows Vista and 7 and /Documents and Settings/(user name)/Application
Data/Bitcoin on Windows XP).  Once you have copied that file to a
safe location, reopen the Bitcoin client and Encrypt your wallet.
If everything goes fine, delete the backup and enjoy your encrypted
wallet.  Note that once you encrypt your wallet, you will never be
able to go back to a version of the Bitcoin client older than 0.4.

Keep in mind that you are always responsible for your own security.
All it takes is a slightly more advanced wallet-stealing trojan which
installs a keylogger to steal your wallet passphrase as you enter it
in addition to your wallet file and you have lost all your Bitcoins.
Wallet encryption cannot keep you safe if you do not practice
good security, such as running up-to-date antivirus software, only
entering your wallet passphrase in the Bitcoin client and using the
same passphrase only as your wallet passphrase.

See the doc/README file in the bitcoin source for technical details
of wallet encryption.


Full changelog ("git shortlog --no-merges v0.3.24..")
-----------------------------------------
Abraham Jewowich (1):
      Fix bug with accessing vchData[0] when vchData is empty.     Fix
typo in CBase58Data::CompareTo

Alex B (2):
      Romanian translation added
      Spanish translation update

Alex Waters (1):
      Updated readme file

Daniel Folkinshteyn (1):
      Update the list of seednodes.

Dawid Spiechowicz (1):
      added polish wallet encryption messages

Dean Lee (1):
      Update to the Chinese Simp translation

Dev Random (4):
      Linux gitian config with separate wxWidgets build
      Mingw gitian with separate wxWidgets and boost
      Mingw gitian build with deterministic bitcoin.exe by use of faketime
      Add Gitian Build descriptors for Boost and wxWidgets.

Doug Huff (1):
      Make mlock() and munlock() portable to systems that require the
address to be on a page boundary.

Dylan Noblesmith (1):
      mlock() all private keys in memory

Eric Hosmer (1):
      Added crypter to makefile.vc.

Fabian H jr. (1):
      Updated checkpoints, maybe Tx fee should be reduced to 0.0001
from 0.0005 and maximum minimum tx should be 0.0010.

Gavin Andresen (24):
      Do-nothing MapPort() ifndef USE_UPNP.  fixes #450
      Don't std::advance past beginning of transactions array.  Fixes #465
      Remove unused ScanMessageStart function
      Compile with DEBUG_LOCKORDER to detect inconsistent lock
orderings that can cause deadlocks
      CHECKMULTISIG unit tests.
      Highlight mis-matching locks
      Fix rpc-hanging deadlocks
      Fixed potential deadlocks in GUI code.     Also changed
semantics of CWalletTx::GetTxTime(); now always returns the time the
transaction was received by this node, not the average block time.
And added information about -DDEBUG_LOCKORDER to coding.txt.
      Fix typo ("you own security")
      SetCrypted() obtains keystore lock, to be safe.
      Logic running with -keypool=0 was wrong (empty keys were being
returned). Fixes #445
      Fix RPC call name in error message.
      obtain cs_wallet mutex to protect vchDefaultKey
      Fixed regression I introduced: wallets with lots of transactions
were unusable in GUI.
      Fix bad merge: getaccountaddress was broken for new accounts
      Give hard-coded seed nodes a random last-seen time, to randomize
order they're tried.
      Do not try to download blockchain from 0.3.23 nodes
      If compiled -DDEBUG_LOCKORDER and run with -debug, print out
every mutex lock/unlock (helpful for debugging
something-is-holding-a-mutex-too-long problems)
      Stay connected to seed nodes; disconnecting causes problems if
you are trying to make the initial blockchain download.
      Versions 0.3.20 THROUGH 0.3.23 have trouble with blockchain
downloads; avoid them
      Bumped version numbers to 0.4.0rc1
      Optimize database writes for transactions with lots of TxIns.
 Patch from ArtForz, who discovered the problem.
      Fix AddAddress cs_mapaddresses/db transaction deadlock
      Fix QA email address

Giel van Schijndel (15):
      fix warning on 64bit systems: cast to pointer from integer of
different size [-Wint-to-pointer-cast]
      fix warnings: expression result unused [-Wunused-value]
      fix warnings: using the result of an assignment as a condition
without parentheses [-Wparentheses]
      fix warning: comparison of unsigned expression < 0 is always
false [-Wtautological-compare]
      fix warning: X enumeration values not handled in switch [-Wswitch-enum]
      fix warning: unused variable 'X' [-Wunused-variable]
      fix warning: unused function 'SigIllHandlerSSE2' [-Wunused-function]
      fix warning: variable nMinDepth set but not used
[-Wunused-but-set-variable]
      fix warning: control reaches end of non-void function [-Wreturn-type]
      Make some global variables less-global (static)
      Cleanup makefiles such that diffs to them are smaller
      Move func 'REF' from util.h to serialize.h
      Start moving protocol-specific code to protocol.[ch]pp
      Move CAddress to protocol.[ch]pp
      Move CInv to protocol.[ch]pp

Han Lin Yap (2):
      Comment "deprecated"
      Add a note to only include .po file

Jay Weisskopf (4):
      Add logos/branding currently found on bitcoin.org into NSIS installer.
      Set default compression for NSIS installer to LZMA.
      Remove NSIS branding from bottom divider.
      Increase resolution of Windows icon.

Jeff Garzik (8):
      Update CWallet::LoadWallet for proper return type.
      Bump version to 0.3.25
      doc/README: word wrap into something readable
      CAddrDB::LoadAddresses: properly initialize CAddress
      src/makefile.unix: remove -DFOURWAYSSE2
      Add reference python miner, in contrib/pyminer/
      README.md: word wrap text file
      Revert "Define MSG_NOSIGNAL to 0 on platforms where it is unavailable."

Jeroenz0r (1):
      Translation from "Open Bitcoin" to "Verstuur Bitcoins"

JoelKatz (1):
      Fix UNIX-specific thread handle leak.

Johannes Henninger (1):
      Identify as "Bitcoin + version number" when mapping UPnP port

Luke Dashjr (7):
      Update nTime after nExtraNonce to avoid potential race
(extraNonce being reset due to just-occurred time change after nTime
is set)
      Reset extraNonce only every 15 seconds, just in case some miner
is updating time himself and stuff
      Reset extraNonce only when prevBlock changes, so miners can
continue updating the time on their work until it's stale
      Support for boost filesystem version 3
      ignore stuff
      Save coinbase, not just extraNonce
      Bugfix: Use timestamp in coinbase rather than "bits", needed to
ensure coinbase txn is unique even if address is the same

Matt Corallo (35):
      Add minversion to wallet.
      Add wallet privkey encryption.
      Set the number of SHA512 rounds based on the speed of the computer.
      Push unlocked_until in getinfo.
      Dynamically remove/insert the Options for encryption in the menus.
      Add the walletlock RPC method to lock the wallet manually.
      Add Wallet Encryption section to README
      Use DB Transactions when encrypting wallet.     This speeds up
the encryption process significantly.
      Make an invalid addrIncoming so that old clients crash.
      Update makefile.linux-mingw to work with crypter and UPnP fix.
      Fix makefile.linux-mingw
      Fix crashes when a wallet is locked and GetReservedKey() is called
      Generate Warning when using default key.
      Fix Build in GetReservedKey() in wallet.cpp
      Fix bad return values in LoadWallet.
      Actually use mapAlreadyAskedFor.
      Fix EncryptKeys crash introduced by a9ba4710, identified by TD.
      Check for duplicate txins in CheckTransaction.
      Make it clear that setting proxy requires restart to fully apply.
      Don't listen if on TOR (resolves #441).
      Add missing include to serialize.h
      Add file for transaction tests.
      Cleanup test suite output to be more useful.
      Unify copyright notices.
      Missed a 'password' should be 'passphrase'.
      Fix incorrect RPC error messages
      Add specific wallet encryption details to doc/README
      Upgrade dependancies and tweak build process.
      Update binary mos to latest translations.
      Fix build process to actually work.
      Add binary mo for new translation.
      Update gitian build descriptors to produce proper builds.
      Update bitcoin icon to make nsis setup exe deterministic.
      Update binary mo to match latest po translation.
      Restructure gitian files and add download config files.

Michael Bemmerl (4):
      Basically some grammatical fixes of the German translation.
      Added German wallet encryption messages translation.
      Changed Russian translation according to comment in issue 395
      Updated German translation

Michal Zima (1):
      Updated czech translation

Nils Schneider (2):
      log low-level network messages only when fDebug is set
      missed printf in AbortMessage(); merged printfs in EndMessage

Patrick Varilly (1):
      Single DB transaction for all addresses in a message

Pieter Wuille (11):
      Prepare codebase for Encrypted Keys.
      Do not use obsolete CPrivKey for passing keys around
      Bugfix: add autogenerated addresses to address book
      get rid of mapPubKeys
      Use CBitcoinAddress instead of string/uint160
      split off CBase58Data from CBitcoinAddress
      Fix for small change outputs
      Bugfix: don't overuse limited ExtractAddress
      avoid strAddress + validity checks
      SocketHandler thread can be detached
      Updated dutch translation

Stphane Gimenez (1):
      Single DB transaction for addresses from DNS seeds

Vegard Nossum (6):
      Add missing includes to key.h
      Add missing include to script.h
      Add missing includes to net.h
      Fix testing setup
      Add prototype for EvalScript() to script.h
      Add a file for script tests

Venkatesh Srinivas (4):
      Test for SO_NOSIGPIPE rather than assuming all BSDs support it.
      Qualify make_tuple with boost:: namespace.
      Use 'unsigned char' rather than 'char' for pchMessageStart.
      Define MSG_NOSIGNAL to 0 on platforms where it is unavailable.

Wladimir J. van der Laan (2):
      remove magic number: change threshold for nLockTime to constant
      make SetHash160 return a value (as specified in the function signature)

cjdelisle (1):
      wxWidgets needs to be at least version 2.9.1 because wallet
crypto uses ToStdString() which is not in 2.9.0

ovdeathiam (1):
      Edited locale/pl/LC_MESSAGES/bitcoin.po via GitHub


-------------------------------------
Gavin said:


I currently have 2,ADDR1,ADDR2,ADDR3 (2-of-3 example) as this new address
type.


Agreed.


This is similar to the way the current implementation works.  It uses
HASH160, but there's no attempt to save space by hashing the sum of the
pubkeys.  The major advantage of summing is shorter address for the end
user to copy-paste.  The disadvantage is the need for long term storage of
the key set so you know what keys to sign with.


--
Bobby Groff




-------------------------------------
On Monday, September 19, 2011 11:00 AM, "Luke-Jr" <luke@dashjr.org> wrote:

A stable version is a good idea. This is why I'm still using 0.3.19
(with some modifications): none of the bugfixes after this version help
me much, and I don't need any of the new features. I've also thought
about starting an unofficial stable version with my modifications to
0.3.19 and some backported bugfixes.


-------------------------------------
First of all I do agree that a method for adjusting the difficulty in a
huge power drop is needed (I don't see it so much in power rises).

The current block generation with a fixed difficulty was chosen because it
it clear when to adjust and to what target difficulty it has to be
adjusted. If we were to use synchronized time windows and select the
hardest block it gets incredibly complicated as synchronization is not
possible in distributed systems. Even the smallest drift would allow for
forks in the chain all over the place. Furthermore the delay in propagation
will also cause forks.

If 1/2 of the network see one block as the hardest, and for the rest of the
network it came too late then we'll have a fork that stays with us quite a
while.

The block chain is described as a timestamp server in the paper, but it is
more of a proof-of-existence before, as the contained timestamp cannot be
trusted anyway.

Regards,
Chris

2011/11/23 Jorge Timn <timon.elviejo@gmail.com>

-------------------------------------

Why?

The block timestamp rules currently give HOURS of wiggle-room for
timestamps. We can't change those rules without risking a chain split.

Here's a thumbnail sketch of what I'm thinking:

When new tip-of-chain blocks are received, IF their timestamp is
unreasonable with respect to system time and the previous block's
timestamp, then add them to a 'discouraged' list.  (but follow the
current rules for outright rejecting blocks based on timestamps too
far in the future or past)

Modify the getwork code to build on the second-from-tip block if the
first-on-tip block is on the discouraged list.

Assuming a majority of pools/miners adopt the "discourage blocks with
stale timestamps" rule, that should squash any incentive for cartels
to try to start playing with difficulty-- you would have to have 50+%
power to start, or you risk producing mostly orphan blocks.


I'll trade more security for "make at least one pool operator have to
do some work" any day.

-- 
--
Gavin Andresen


-------------------------------------
On Thursday, September 08, 2011 12:51:02 PM Mike Hearn wrote:

In fact, I think the alert system should relay (note, NOT display) messages 
*regardless of the key used*, so it isn't yet another "our client gets special 
status" thing, and can be used for other clients as well.


-------------------------------------
On Wed, Oct 26, 2011 at 4:58 AM, Michael Grnager <gronager@ceptacle.com> wrote:

Why? If somebody is sending me bitcoins, then they'll have to get
either an address or one or more public keys from me. OP_EVAL just
lets me give them a short address that represents an arbitrary number
of keys combined in an arbitrary way.

I agree with Gregory: it shouldn't matter if that address is
HASH(public key) or HASH(op_eval_script), the issues are the same (if
you lose or cannot re-create the key/script then you're in trouble).

Maybe I'm missing something; are you worried that blockexplorer won't
know that coins sent to HASH(op_eval_script) are actually a
complicated transaction until the coins are spent again?  I'd consider
that a feature, not a bug, because only the people involved in the
transaction need to know the details until after the transaction is
complete.

Feel free to contact me about your 'tiered implementation for thin
clients' -- I don't think OP_EVAL will make that significantly harder.

I also agree with Alan: using OP_EVAL is not mandatory, I'm proposing
that CHECKMULTISIG becomes a standard transaction type.

-- 
--
Gavin Andresen


-------------------------------------
I expect that I will make a lot of mistakes, and probably ask too many
questions - but I hope you can bear with me.

I've been trying to keep a low profile as I get better acquainted with the
project. I'm clearly in the company of some very smart people - and would
like to keep it that way.

I've tried to do my research on the main contributors, and it seems that
Matt is the only one to escape my Google stalking. If you have any questions
about my background - feel free to inquire.

It's difficult to ascertain what needs QA work first, so any guidance or
suggestion is appreciated. I'm available via social networks, email, phone,
fax?, IM, IRC, etc. Let me know your preference, or don't and I'll bugger
off.

I'll try to stay out of the way, and do my best to make the development
cycle easier. Let me know if I'm stepping on toes, or being annoying. I
won't be offended.

As for the commit testing, I want to have an idiot proof solution to get as
many people testing as possible (eventually). With code like this, I think
it's better to go full-auto with the ACKs.

-Alex
-------------------------------------
When I first found bitcoin, I was a bit surprised there were no paid by
community developers working on it. However, the bounties would be a
more democratic way of guiding the progress as well as allow things to
happen without a stable flow of money.

Having said that, if it's feasible, having someone hired full time to
work on the software would be great. I'm too much of a newcomer myself
to be able to provide any financial support for that though. I could
most likely contribute towards some bug bounties but if there was a bug
I'd want to offer bounty for, I'd be fixing it myself already.

- Joel

On Wed, 2011-07-27 at 09:07 -0700, Rick Wesson wrote:




-------------------------------------
Gavin tagged 0.4 release today, so here are my gitian builds.
These zips are in gitian-download format which means they can be
automatically downloaded and pgp-verified using the gitian-updater
script (see
https://github.com/devrandom/gitian-builder/blob/master/share/gitian-updater). Currently they only contain my sig, but if other devs have time to gitian build and re-roll the same zip with other sigs added as well it would make updating via gitian scripts easy and secure :).

http://dl.dropbox.com/u/29653426/bitcoin-0.4.0-linux-gitian.zip
http://dl.dropbox.com/u/29653426/bitcoin-0.4.0-win32-gitian.zip

SHA1:
3794ec0ce8a3ea96200b3970937c5f224313267d  bitcoin-0.4.0-linux-gitian.zip
a4857b2238a102d8f4ba9a2bdfed74ddd985ad3d  bitcoin-0.4.0-win32-gitian.zip

Email PGP signed as always.

Matt
-------------------------------------
You are describing the problem DANE addresses, see
http://tools.ietf.org/html/draft-ietf-dane-protocol-12


Using Secure DNS to Associate Certificates with Domain Names For TLS

Abstract

   TLS and DTLS use PKIX certificates for authenticating the server.
   Users want their applications to verify that the certificate provided
   by the TLS server is in fact associated with the domain name they
   expect.  TLSA provides bindings of keys to domains that are asserted
   not by external entities, but by the entities that operate the DNS.
   This document describes how to use secure DNS to associate the TLS
   server's certificate with the intended domain name.


For those of you against DNSSEC, DANE leverages it significantly.

The point I have been attempting to make is if one to rely on HTTPS,
leveraging DANE will allow you to mitigate CAs and use self signed
cers but you will need to leverage DNSSEC to bind the self signed cert
using DANE and if you are going to rely on DNSSEC for DANE to support
HTTPS, why not short-circut this madness and just publish your
identifiers and secure the zone via DNSSEC and link in a stub resolver
in the client.

Short story: transform user@authority.tld  --> _btc.user.athority.tld TXT 1z....

A short i-d is probably a better way to explain, so I will task myself
to do that.

-rick


On Mon, Dec 19, 2011 at 6:46 AM, solar <solar@heliacal.net> wrote:


-------------------------------------
I believe he meant rebase onto wallet encryption.

On Tue, 2011-06-28 at 13:39 -0500, Doug Huff wrote:

-------------------------------------
Got a fix for the encrypted-wallet mining issue:
- unique_coinbase

It depends on (and merges) the getwork_dedupe fix already common on pools and 
other miners who pay attention to the latest mining fixes.

To merge:
  git fetch git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git \
    unique_coinbase && git merge FETCH_HEAD


-------------------------------------
Fixed:
https://github.com/bitcoin/bitcoin/commit/8d3e1becf0fa6c27c7df4a52daf181282a3d2468

It seems that somehow strings from the old Wx UI had ended up in
bitcoinstrings.cpp. I re-ran the string extraction script and the duplicated
messaged should be gone.

JS

On Tue, Oct 25, 2011 at 7:02 AM, John Smith <witchspace81@gmail.com> wrote:

-------------------------------------
FYI
It's in a disabled feature (replacement), so I'm not sure how important this
is, but it doesn't look good.

---------- Forwarded message ----------
From: Dean Gores <dmgores@gmail.com>
Date: Sun, Oct 23, 2011 at 11:15 AM
Subject: bitcoin scope issue in main.cpp
To: laanwj@gmail.com


You have "i" and "output" declared in the same scope in "main.cpp",
AcceptToMemoryPool.  Below is the offending code.

           for (int i = 0; i < vin.size(); i++)
           {
               COutPoint outpoint = vin[i].prevout;
               if (!mapNextTx.count(outpoint) ||
mapNextTx[outpoint].ptx != ptxOld)
                   return false;
           }


Cheers,
Dean Gores
-------------------------------------
2011/11/17 Martinx - ジェームズ <thiagocmartinsc@gmail.com>


I've noticed this same behavior with 0.5 release candidates.  I remember
seeing it with 0.4 also, so I think it's not a regression.  I haven't yet
pinned down the cause.  It would be nice to fix; especially for those
downloading the blockchain for the first time.

 Also, where can I find the number of connections using new Bitcoin-QT?

Hover over the signal icon in the lower right corner.  The icon looks like
a cellphone signal indicator.  The number of connections is displayed in a
tooltip.

-- 
Michael
-------------------------------------
RE: IIBAN numbers:

Nifty!  Thanks for the pointers, I think we should avoid reinventing
wheels whenever possible.

When composing my last response in this thread I wrote, and then erased:

"There doesn't have to be one solution: I'd like to see some
experimentation, with clients supporting different schemes for bitcoin
address aliases, and maybe supporting plugins to extend the schemes
supported (a plugin would take a string, do some
behind-the-scenes-magic, and return a bitcoin address or public key)."

Defining Bitcoin as an IIBAN "institution", with 36^6 "accounts",
seems like a forward-thinking idea, although I'm not clear on exactly
how those 2.2billion "accounts" would get allocated and mapped into
bitcoin addresses.

I imagine some central organization that maps IIBAN account numbers to
domain names... and then clients (or plugins in the clients) query
that trusted central organization and then the account holder's domain
to get a (possibly unique) public key or bitcoin address.

As long as IIBANs are not the ONLY way of aliasing bitcoin addresses
to more-human-friendly strings I think that would be a fine way to do
it.

-- 
--
Gavin Andresen


-------------------------------------
On Monday, December 19, 2011 12:04:34 PM Jordan Mack wrote:

Sure, I meant HTTP as the underlying protocol.
TLS/SSL should of course be required in some form.


JSON-RPC won't go on forever. In any case, bitcoind's use of JSON-RPC is 
exactly why I (and many other developers) have come to the realization how 
poorly supported JSON really is. Most of the common languages do have a 
library, but almost all of them have one issue or another (particularly around 
the very undefined Number type).

XML shares the same binary-data problem as JSON, too.
As slush mentioned, no additional serialization is necessary anyway.


Because computers work with binary. I don't think anyone wants to implement a 
fully functional script assembler just to send funds.


This suggests you need to learn more about how Bitcoin works ;)
https://en.bitcoin.it/wiki/Script


-------------------------------------
For some reason my mail client let me respond off-list here, didnt mean
to...

On Mon, 2011-07-04 at 14:23 -0400, Gavin Andresen wrote:
Not strictly true, if the keys are loaded, but not added to
mapAddressBook or setKeyPool, they wont be used for any new
transactions, or shown to the user, but the user is still able to
receive Bitcoins to those keys.
Not really, most backupwallet-based scripts will backup wallet.dat,
encrypt wallet.dat, upload wallet.dat.  Now it backups up wallet.dat and
the encrypt part fails because there is no wallet.dat, only
wallet_e.dat.  If we rename to wallet.dat on output, now the user's
restore might not work...
True, but that is only a solution for Linux and Mac and then you are
back to unreadable error on Windows load and other unforeseeable errors
for odd scripts.

I suppose I just really dont like the idea of renaming wallet.dat,
everything knows the filename and is used to it.
Yep, just something simple that says, no reading this to old versions is
needed, IMO the older version should freak out if it sees keys that it
doesn't know about (as it could also indicate wallet corruption in some
rare cases), but nMinVersion works just as well, in any case this should
only very rarely be a problem...how often will we change the wallet
format?
-------------------------------------
Also important: it supports cross compiling:

http://www.cmake.org/Wiki/CMake_Cross_Compiling

JS

On Sat, Jul 2, 2011 at 7:29 AM, John Smith <witchspace81@gmail.com> wrote:

-------------------------------------
On Thu, Jul 14, 2011 at 7:50 PM, Luke-Jr <luke@dashjr.org> wrote:


Writing zeros just once should be sufficient:
http://cmrr.ucsd.edu/people/Hughes/DataSanitizationTutorial.pdf

-Arthur
-------------------------------------
http://www.python.org/dev/peps/ is a good reference if you're
interested in seeing how PEPs work in action. I would be more than
willing to maintain a similar index if that's what people want.

Something to note is that Python does not use Git or GitHub (AFAIK).
So we would need to update 001 to reflect the BEP involvement with
Git, or transition away from it completely (which I discourage).

My full-time experience as a project manager with Basecamp, Redmine,
Teamlab, Pivotal Tracker, SVN, and custom VC has taught me that it is
hard to find a good solution for the organization of the development
life cycle. Having examined Bitcoin for the past three weeks, it is
hard to discern the willingness to implement meta changes.

It looks like Git/GitHub is working, but not ideal for everyone. My
opinion is that there will always be a missing feature in VC systems.
My major gripes with GitHub are the lack of prioritization options,
voting system, and reporting/metrics.

Gavin has asked me to research various O/S projects, to see how they
are doing things. I have been focused mostly on organizing a pull
testing system, and learning the testing process - but I can spend
more time on meta organization if that is in demand. It would be
helpful to me if I could hear some feedback on what needs changing,
and how important it is.

My recommendation is that we continue with the current system, but
plan alternative organization voting around the time of 0.5 release.
This could be an alternative to GitHub, or a supplement, or neither.
Seeing as we are still in Beta, I don't believe there needs immense
structure until we approach 1.0. The PEP system is outstanding, and is
clearly a solid alternative/supplement to consider.

-Alex


-------------------------------------
While I do think that anonymity (or pseudonymity) is a nice feature, I don't
think it deserves the full focus of the developers. The core of the protocol
is about making transactions in a secure and fast way, not allowing
everybody to be anonymous, whether they want to or not. TOR already is a
good options for those that want to stay anonymous, and there is no need to
pull support into the main client, if only a few will use it. I think very
few of the developers actually claimed that Bitcoin is anonymous, and has
never been a big advertising point from the "official" side of Bitcoin,
network analysis has been always known to break anonymity.

I see no need for action from the developer side.

-cdecker

On Fri, Aug 5, 2011 at 2:01 PM, Joel Joonatan Kaartinen <
joel.kaartinen@gmail.com> wrote:

-------------------------------------
Are we designing protocols or applications, its easier and better for all
involved if we design a protocol and then let the applications implement
it.

Lets stick to understanding how labels (dns) or URIs can be leveraged to
securly obtain a bitcoin address, rather than reviewing capabilities of
current applications.

-rick

On Wed, Dec 14, 2011 at 10:04 PM, Zell Faze <zellfaze@yahoo.com> wrote:

-------------------------------------
On Wed, Aug 24, 2011 at 10:19 AM, Gregory Maxwell <gmaxwell@gmail.com>wrote:

there yet; however the trend is for more transactions and we will bump into
the limit. Being good architects we should consider how to scale or
explicitly state why its a good idea not to.

-rick




no one ever "knows" what the network dynamics are going to be in developing
infrastructure -- so lets not kid our selves, in being able to estimate this
before the code is even written.

-rick
-------------------------------------
On Sat, 31 Dec 2011, Chris Double wrote:


It will limited ability manipulate scripts on the stack through the use of 
arithmetic and hashing operations, and if OP_CAT, OP_SUBSTR and friends 
are ever restored, it will have even more abilities.

-- 
Russell O'Connor                                      <http://r6.ca/>
``All talk about `theft,''' the general counsel of the American Graphophone
Company wrote, ``is the merest claptrap, for there exists no property in
ideas musical, literary or artistic, except as defined by statute.''
-------------------------------------
On Wed, Nov 2, 2011 at 7:22 PM, Christian Decker
<decker.christian@gmail.com> wrote:

That's how I take it to mean:  "satoshi client" is the client
-started- by satoshi, that is actively distributed through
github.com/bitcoin/bitcoin and bitcoin.org-linked downloads.  Changing
to QT doesn't change the lingo.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sat, September 3, 2011 00:05, Nils Schneider wrote:

I think the two could be considered complementary. Basicaly the existing
MinorFs provides to the pseudo-persistent-process that private members
provide to objects. 'Encapsulation of variables that still can be
delegated by the object that encapsulates them'. In the MinorFs2 that I
just started writing, I try to lower the barrier to using MinorFs by
providing facilities to do pick a granularity for 'object' more suitable
for most lines of development (where pseudo persistent processes are an
unnatural concept).

Think of BitCoin running as user certain user as an object and a piece of
malware running as the same user as a second object. You can than think of
the users home directory as a global variable, while MinorFs gives a
private home to both the bitcoin object and the malware object. The
bitcoin object can delegate parts of its private state to other objects,
but as long as bit-coin doesn't do that, the private state won't be
disclosed.

Its a good idea to have data on disk encrypted even if you use something
like Minorfs, if only to protect against bootable media attacks.


No.


Basically the existing MinorFs will work already with the existing BitCoin
due to the fact that Bitcoin seems to extract $HOME from an environment
variable, but there are some caveats:

* It needs a bash script for starting up bitcoin with $HOME set to the
  MinorFs home.
* Bitcoin can be started in only one way. That is, bitcoin started from
the gnome menu is interpret being a completely differnt bitcoin than
bitcoin started from an xterm.
* There can only be one bitcoin started and running at once.
* All potential malware needs to run with at least an AppArmor profile
that keeps it from reading /proc/$PID for pids other than itself.

In the new version I'm contemplating, there would I think at least be a
minor change to bitcoin needed:

* bitcoin would have to use a small library that provides a
'minorfs_getpwuid' function.

This function will work like getpwuid on any system without an active
MinorFs2, and for any non apparmor confined process.
On a system with MinorFs running it should return a passwd structure with
the home changed to the MinorFs2 home.


All read and write operations will map directly to the underlying
file-system, so basically it comes with the same lack of guarantee that
any
file-system comes with once the underlying media becomes flaky.


Haven't really thought about that, what is considered the currently proper
way to keep backups for bitcoin?





-------------------------------------
Alex,

On Sun, Sep 11, 2011 at 7:45 AM, Alex Waters <ampedal@gmail.com> wrote:


It has been under development for a long time, the thread on the bitcointalk
forum is "substantial evidence" that many people are using it (also, I
receive quite a lot of mail about it, and the number of followers on github
steadily fluctuates around ~30).  So nothing obvious is broken, at least, I
think has worked better than the Wx UI for quite a while.

But as I've said before I'm fine with keeping bitcoin-qt as a parallel,
experimental, release for a while.  I think that's the only way to get more
testing with people that don't want to or can't build from source (could
just mark the download as "New GUI, experimental" or so...).

To be honest I think it should be merged at least as experimental ASAP, it
would save a lot of GUI complaints on the forum about things I've
implemented months ago already. However I will only put up a pull request as
soon as it is clear that it will actually be integrated. It is too much work
for me to keep the pull request up-to-date if it lingers for months like
many others have.

JS
-------------------------------------
On Thu, Sep 29, 2011 at 12:49 PM, solar <solar@heliacal.net> wrote:


I don't get the 'dragging in' part. Bitcoin already depends on OpenSSL for
ecdsa, bignum, and SSL for RPC. Please, please don't try to reimplement
these locally :-)

JS
-------------------------------------


Talking to myself here.  I just sent this message then found this 
brilliant set of articles in the Dev & Tech forum which answers the 
question very nicely: *https://bitcointalk.org/index.php?topic=41722.0 
<https://bitcointalk.org/index.php?board=6.0>
*
Anyway just as an FYI I've been running v0.0.0.0.0.0.0.0.1 for about an 
hour.  It's only running 10 concurrent connections due to girlfriend 
complaining she couldn't watch youtube but here's some early results.

New nodes: 19319 // node address discovered but no contact attempt made yet
Contacted nodes: 754
Uncontactable nodes: 3253
Limbo nodes: 9 //not as exciting as it sounds, just nodes with connect 
in progress
Total nodes: 23335 // about 5000 from initial IRC discover, the rest are 
from getaddr

Versions: {
300=1,
31900=7,
31902=1,
32000=2,
32001=7,
32002=22,
32100=100,
32200=24,
32300=277,
32400=317,
32500=2}

Fails: {
ConnectException: Connection refused=377,
IOException: Socket is disconnected=87,
SocketException: Network is unreachable=2,
ProtocolException: Error deserializing message =1,
NoRouteToHostException: No route to host=115,
SocketException: Connection reset=149,
SocketTimeoutException: connect timed out=2521}


-------------------------------------
On Wed, Aug 24, 2011 at 9:46 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

Could you provide a reference to why in your estimation it is "to early."
 Simpy stating this as fact isn't enough to sway demand.

how about we agree that increasing precision is a goal and worry about how
to encode that once its on the road map.



-------------------------------------
...
...

As a miner I fully support route (2) and do not think that this would
cause any serious issues or discontent among miners. Most miners
surely are running ntpd already. Those who mess with the clock
intentionally will have to play ball.

--
Vladimir
-
http://bitcoin.org.uk/forums - clean and moderated bitcoin forum


-------------------------------------
Gavin,

 Where is my "Bitcoin Address" within this new QT version?

 The windows appear but, I can't find my bitcoin address.

Cheers,
Thiago

On 16 November 2011 14:34, Gavin Andresen <gavinandresen@gmail.com> wrote:

-------------------------------------
This a reworking of a post I made on the bitcoinj list under a
different topic but it's something I'd like to throw out there for
input.

I'm going to build a proof of concept this weekend of the multiplexing
proxy that Gavin and Mike were talking about here:
http://sourceforge.net/mailarchive/message.php?msg_id=28049519

Initially just a dumb as doornails proxy between one local bitcoind
and one remote node.  Once I've got that far the next step is to work
out how deal with request-response exchanges from multiple remote
nodes.  I discussed this tatcm on IRC last night.  The problem is
after relaying several requests from different remote nodes to the
local daemon you expect multiple responses to come back.  How identify
which response matches which client's request. Bitcoind can implicitly
identify the recipient based on which connection made the request.  By
piling all the requests onto one channel we lose this identifier.  I
can think of 3 approaches to dealing with this:

1/ Generate a unique key from the request and can also be generated
from the response.  e.g. getheaders key could be "headers" +
hash_start.  We locally store a mapping to client (or clients) that
requested it and pass it to bitcoind.  When we get a headers packet
back unique key = "headers" + hash_of_first_header, so we can lookup
the clients who requested it and send it back.

The unique key should have the following properties:
 - can be reliably generated from both the request and the response.
 - identical requests from different clients should generate the same
unique key (this allows us to recycle responses)

Problems:

This is dependent on each pair of request/response messages being
guaranteed to contain information needed to create an identical unique
key.  I haven't looked in detail at every request/response pair yet to
confirm this.  If it is the case then this is an onerous obligation to
place on the protocol to fulfil this condition for all future protocol
changes.

To obtain guaranteed uniqueness may require large keys.  Is
'almost-unique' an option?  e.g. generating a key off a getblocks
request using the first n bytes of each block_locator_hash would be
much smaller/faster and very likely to be unique.  Are the risks of
sending back the wrong response to a request acceptable?


2/ Modify bitcoind to accept sequence numbers for request/response
type messages, similar to 'id' field in json-rpc.  This is more
reliable but potentially quite invasive to the bitcoin protocol.  It
also loses the inherent de-duplication of requests that we get with
the previous solution.  If it were to be implemented I'd suggest
something like a separate sequence number message.  i.e. proxy sends
seq message containing a unique ID.  The contract is that the seq
message refers to the next message that comes over the wire.  When the
response is ready the bitcoind sends a seq message with matching id
then sends the response message.  A separate seq message at least
leaves the existing protocol untouched as the handling will remain
unchanged unless a request type message is preceded by a seq message.

This approach allows the proxy remain a lot thinner and dumber but we
lose a lot of the de-duplicating efficiencies from the first approach.
 If we want to add this capability as well we essentially need to
implement option 1 as well although in this case we have a reliable
fallback.  i.e. If we can't generate a unique key then we just use
single request/response matching via the seq id.

3/ Make the proxy intelligent enough to handle these requests itself.
Using getheaders as an example again.  Proxy maintains it's own local
cache of headers.  when a getheaders message comes in the proxy checks
if it has all requested.  If not it requests the missing ones from the
local daemon, adds to it's cache and builds a headers response itself.
 In this case the proxy definately has to be protocol version aware...

Advantages:
 - This probably achieves the best combination of request/response
matching reliability and de-duplication of work.

Disadvantages:
- Complexity.  The proxy needs to be far more protocol aware which
creates a maintenance dependency for future protocol changes.

Having spent the last couple of days studying the protocol I'm
inclined toward the first approach as an initial easy implementation
with a view to moving to the 3rd approach.  It appears that most
response type messages could be relatively easily constructed from a
local cache.  Before I looked at the protocol I would have said no way
to the 3rd but the depth of protocol awareness for 1 or 3 is not
really much different.  Option 2 allows for a much dumber and thinner
proxy but loses a lot of potential efficiencies and if those were to
be regained it would require the same level of protocol awareness
inherent in 1 and 3 anyway.  It would also require someone on the
bitcoind side to put their hand up to add the seq message
functionality as I don't have any c skills to speak of.

Ultimately option 3 is where I was seeing the proxy progressing to at
some point far in the future but the routing problem needs to be
solved right from the beginning as I see it.

I hope I'm not over complicating it.  If anyone can think of a simpler
approach to the request/response routing problem I'm all ears.


-------------------------------------
On Fri, Aug 5, 2011 at 1:16 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:


Well it's good that the bitcoin network is seeing some security testing.

So I understand that we have a combination of problems at the moment:

1) A DDoS possibility  (if this is really the cause of the network
connectivity problems)

2) An attacker can figure out which node first broadcasted a transaction, by
connecting to the entire network or having everyone connect to his node(s)

3) The recipient re-broadcasts transactions (is Theymos right here?),
allowing both the sender and recipient to be found

Drawok's suggestion about using UDP packets with spoofed sender addresses is
interesting, as UDP has another advantage; you can open up an "inbound" UDP
port on almost any NAT router without any UPNP magic: just send out an UDP
packet, the router will wait a certain time for answers (on a mapped port
number) and relay these back.

It also has some potential issues; the client needs special privileges to
spoof sender addresses, and some ISPs might filter out packets with
non-matching sender addriess (unsure how common this is).

JS
-------------------------------------
Hey!

John Smith wrote:

That was a good suggestion - thanks! I implemented it along these lines
and now the Instawallet server can breath again. Well, more or less at
least, as now "sendfrom" starts acting up and I have to look into that
next.

Here is a branch with the code for the cache:
https://github.com/javgh/bitcoin/tree/balancecache . It's currently based
on a somewhat old version of the codebase as I'm running with a number of
other modifications. So it won't easily apply to something newer. I hope
to be able to switch to a recent version at some point (mostly hoping for
some improvements in the fee handling area before I do that) and then I
can hopefully provide a cleaner version of this patch. For now, I just
document it here for anyone who might need this as well and can piece it
together themselves (I attached a patch file).

Basically I create a list of all account balances every time a new a new
block comes in or a transaction that affects my wallet appears. The list
is stored in a "map" right now. This seems fast enough for me. I didn't
use a hash map for now, because I'm fairly new to C++ and was a little
confused on what to use (is there a "standard" hash map to use in the STL?
or do people use boost or what?). But my VPS is low on memory anyway, so I
guess that's kind of a justification as well to go for a tree-based
implementation of map.

Cheers!
Jan
-------------------------------------
What about this one?

@@ -1276,13 +1278,13 @@ bool CBlock::AcceptBlock()
     // Get prev block index
     map<uint256, CBlockIndex*>::iterator mi = 
mapBlockIndex.find(hashPrevBlock);
     if (mi == mapBlockIndex.end())
-        return error("AcceptBlock() : prev block not found");
+        return DoS(10, error("AcceptBlock() : prev block not found"));


Is it certain that it cannot be triggered by a peer having some huge number 
more blocks than you?


-------------------------------------
On Sun, Aug 7, 2011 at 11:07 PM, Venkatesh Srinivas
<me@endeavour.zapto.org> wrote:

applied


Looks good at first glance.  Creating pull requests @ github for these two.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On 08/03/2011 02:00 PM, Mike Hearn wrote:
Many home routers ignore ICMP requests (mine does) and as far as I know
Windows Vista/7 only responds to pings that originate from a LAN
address/private address range in order to stay more "hidden".


-------------------------------------
one possible bootstrap method of last resort,

1. create a convention of bitcoind listening on a specific last octest
of IPv4 address, let's say, .14 when possible. Those of us who have
access to IP space would use .14's.

2. if no other bootstrap method works, client could start scanning
x.x.x.14 addresses, perhaps in some semi-intelligent order (starting
from more pobable /8's and /16's), if enough people place bitcoind on
x.x.x.14 than after a 10-100 thousand checks it bound to find a
bitcoind peer.

It's messy, with all the excessive scanning etc... but it does not
depend on anything except a bunch of bitcoind by convention preferring
listening on x.x.x.14's.

Given that this is a method of last resort in bootrap chain it whould
hopefully not lead to DDOS on those unlucky to own *.14 and not
running bitcoind there. Also the more people are running bitcoind on
.14, the quicker it would find a peer, the less scanning to do. It is
kind of self-regualting.

For whatever it worth...


On 13 June 2011 10:56, Jeff Garzik <jgarzik@exmulti.com> wrote:


-------------------------------------
On Friday, September 23, 2011 7:15:48 PM Pieter Wuille wrote:

Email and XMPP are suitable. Just sign the message with the "from" key.


False. Deterministic keypairs remove the necessity of bidirectional 
communication. A standard for a "public key root" "address" could be 
worthwhile.

Both of these combined retain pseudonomity, while providing stateless 
transactions with out-of-band data.


-------------------------------------
This is great!  Good job guys!

Jim

On Mon, Jun 27, 2011 at 1:46 PM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
On Mon, Dec 19, 2011 at 10:43 PM, Jordan Mack <jordanmack@parhelic.com>wrote:


Agreed. Please don't roll your own onion network. It is very non-trivial to
get security and anonymity to an acceptable level. Securing cryptocurrency
itself is a big enough challenge already.

Another reason it is better to use Tor is because of the mixing effect. A
bitcoin-specific onion network would be subject to easy traffic analysis if
it only carries Bitcoin messages.

effect. Developers could even choose to integrate Tor functionality into

Yes, good idea. I've thought about making a "bitcoin tor bundle", analogous
to the firefox Tor bundle that is available from the Tor site itself.

Probably would need to package the block chain with it, as downloading that
over Tor takes ages and causes unnecessary load on the network...

Wladimir
-------------------------------------
Hi,

I thought that it will not harm to share the project I've just began
to work on: gobtc

gobtc aim is to build a flexible FLOSS Bitcoin peer implementation,
that people could use in their applications to directly participate in
Bitcoin network.

Project home: http://github.com/dpc/gobtc

As this is a crosspost to bitcoin-dev and go-nuts  mailinglist, for
unfaimiliar with any of the terms

Bitcoin: http://bitcoin.org/
Go Language: http://golang.org/

Rationale is: Go language seems perfectly fitted for writing efficient
networking applications, and is providing build in standard library
support for a lot technologies used in Bitcoin.

If anyone is interested in participating, I'm encouraging to get in
touch with me. I'm already in touch with one person who is willing to
share some working code.

Regards,
-- 
Dawid Ciężarkiewicz


-------------------------------------
On Sep 15, 2011, at 1:17 PM, Gavin Andresen wrote:


No, it requires the entirety of the p2p network code be reworked and large patches aren't accepted.

No reason to take that off list, it's an issue that's been acknowledged on irc numerous times and is in the public channel logs.

-- 
Douglas Huff
-------------------------------------
There are other issues besides IP address anonymization that would
need to be addressed. I'm sure at least a good number of you have read
http://arxiv.org/abs/1107.4524 and have seen Dan Kaminsky's
slideshows.

i.e. all fund aggregations (transactions with multiple inputs using
different public keys) make it easy to associate all the public keys
to a single entity. Large movements of bitcoin to addresses that
haven't been seen before are often interesting events. Then you can
correlate transactions with trades on exchanges or with other data
sources for time and amount.

However, going back to what had been said earlier, the bitcoin
protocol itself is not really designed to address these issues. It is
designed with the goal of rapidly propagating transactions over a
network and getting a bunch of peers to be able to independently
verify that they occurred in a particular order and that the
signatures are valid.

The subject of how to anonymize cryptocurrencies is a separate one,
IMHO...and one which needs to address not only how to hide the
identity of those who relay transactions but also how to organize and
manipulate wallets as to thwart attempts at block chain analysis. And
these topics, although interesting in and of themselves, was not what
this thread was intended to address. This thread was intended to
address the issue of extending the protocol to allow for independently
running thin or specialized services that can all interface via the
bitcoin protocol without requiring one to step outside the protocol
with special gateway access.


-------------------------------------
On Thu, 2011-09-08 at 07:42 -0700, David Perry wrote:

The alert system requires a signature verification when it receives an
alert, but so do blocks and transactions so it really isn't a DoS target
(remember that the alert system requires alerts to be signed by a key
that only gavin and satoshi have).

The alert system could prove very, very valuable.  In much software it
carries the risk for abuse or simply seems wrong that the developers can
send a message to everyone's computer to notify them of something, but
keep in mind that Bitcoin is financial software.  If there is an urgent
problem (like the overflow bug) there must be a way to notify people to
upgrade immediately, which is exactly what alerts provide.  Since alerts
no longer carry the ability to put Bitcoin into RPC safe-mode, they are
literally just a message and I see no reason why they should be removed.



-------------------------------------
Begin forwarded message:


-- 
Doug Huff

On Jun 28, 2011, at 1:35 AM, Mike Hearn wrote:


-- 
Doug Huff


-------------------------------------
I've been pushing for the Bitcoin Stack-Exchange as our main
user/merchant support site:

<http://area51.stackexchange.com/proposals/30763/bitcoin-crypto-currency>

I think the Stack Exchange format is ideal, since the
acceptable/unacceptable topics are defined in advance, and it has a good
user moderation/reputation system.  The site will be for technical and
conceptual questions only, no politics or philosophy, and obviously no
buying and selling.  This makes it unattractive to the kooks and
hucksters, and therefore unattractive to the trolls as well.

At the time of this writing, we still need 64 more people to commit to
using the site before it will launch, 48 of which need to be established
Stack Exchange users.  At the rate we've been going, the site should be
up around the end of August.  I'd like to make it happen before then, so
please join up!

-------------------------------------
Dan gave a brief explanation of "blitcoin" on the forums:
  https://bitcointalk.org/index.php?topic=34458.0

"As reported, I've got a BitCoin deanonymization mechanism.  It's not
complicated.

Connect to every node in the cloud, discoverable via sweeping/IRC/get_peers
messages.  The first IP to consistently relay transactions for a given
identity, is the given identity.

Of course the entire BitCoin cloud doesn't allow inbound connections
(although you can do rather evil stuff with UPNP to force that open too).
But this isn't a problem -- there's only about 3000 to 8000 IPs that are
BitCoin nodes that accept inbound connections.  Since everyone else depends
on them, you just need to create your own mass cluster of IPs that are a
decent chunk of the P2P network.  Nodes on average have seven outbound
connections, so it should take only a few hundred unique to be one of the
first-hop peers even for the outbound-only set."

... so it is a de-anonymize-via IP address not de-anonymize-via Bitcoin
address.  And might go partway to explaining why we're having trouble with
network connectivity...

-- 
--
Gavin Andresen
-------------------------------------
Monday, July 11, 2011, 12:31:20 AM, Jeff Garzik wrote:
What  about creating a branch and start libbtc by implementing a small
module  like irc or p2p connection handling and use the new lib in the
client. I think this would be a proper start for a new clean code base
without  having  a  non  functional  client  for some time and it also
provides  some  kind  of red line between libbtc (cleaned up code) and
the old code base, making it easy to maintain order.
Would this approach be accepted for a merge?


Monday, July 11, 2011, 12:36:53 AM, Matt Corallo wrote:
It  was  more  meant  as an rhetorical question. A documented decision
would give anyone the chance of arguing against the usage of a library
instead  of asking stupid questions. A mailing list archive suits well
for  this  type  of information, so let me try to get some information
here.  Db4  is  an  excellent  choice  if  you  need  indexed database
functionality without SQL interface. But compared to an stl map lookup
and  fopen,  fwrite  and  fclose  it  is much harder to understand and
brings  a  lot  performance  overhead.  This  is  true as long as your
information are small enough to stay in main memory. A stl map storing
file  offsets  is  also  not that hard to write and understand. On the
other  side  using  an  SQL  interface  would  bring  the advantage of
swapping  database  providers.  An enterprise website could use oracle
while the average user could use sqlite. Also is db4 used for any type
of disk storage, this makes files like wallet.dat some kind of hard to
read. It is in no way more secure than storing private key's in an xml
file. But it is much harder to maintain and understand by the user and
the average programer.

I'm  forced  to to use windows by the type of clients I'm working for.
And  during  leisure  I  like  to use a System that does not need much
effort to simply do what it is made for. ;)

It  is  not  that  interesting  as it looks first. There is no good in
running multiple chains for production use. To share the difficulty is
indeed  a  good  start  to  solve  the problem. That's also one of the
things  I  don't  like  off  the QBitcoin client. What I meant is just
to have the possibility to have all adjustable parameters in one place
and  to  be  able  to  quickly build an internal testnet without crazy
firewalling  to prevent it from dying. The first would allow to detect
problematic ddos protection settings early and giving the average user
the  possibility  to adjust all important settings if he knows what he
does.  That  includes  not  only alternate chains. One could choose to
include  transactions  only  at  a  higher  fee  or  at no fee at all.
Everyone could do such things by changing the code anyway. But not all
brilliant administrators or users are programmers.

Good code is the best documentation anyway.

Monday, July 11, 2011, 3:01:51 AM, Luke-Jr wrote:
There  is  no  other  client  that  uses  C  and is meant to be a full
implementation  and platform independent except QBitcoin. QBitcoin seems
to  have  no  public repository to work on or I have overlooked it ?!?
Starting  a  new client on my own is just like starting an other never
ending and never used open source project.

While there is no authority, there is just one fully working client to
look  at.  This  may  lead to an working but instable network if other
clients are trying to interpret net.cpp and fail on it in details.

As  I  said, there is no need for an other never ending story. I would
like  to  know  if  my affords have a chance to get merged or accepted
before I start to work on it.

Tuesday, July 12, 2011, 4:31:07 AM, Gavin Andresen wrote:
It  is  some  kind of arrogant to believe that anyone would stop using
bitcoin  if some programers decide to stop working for some month. And
it  is  also fond to not fix bugs in the old code base if they appear.
Also  there are lots of people out there using old clients anyway. The
important  improvement is more about quick extendibility and therefore
more  feature  rich secure code. This would not only help the official
code  base,  it would also improve trust and result in better external
bitcoin related projects.

That  would be true if possible, but I'm pretty sure that the only way
to  detect  deadlocks  is  by either analyzing the code or single step
simulating it, what is really tricky on network applications.

Tuesday, July 12, 2011, 6:19:28 AM, Jeff Garzik wrote:
We  seem  to have very different opinions on that, but let's try to be
objective.  I  belive  that every class should be able to stand on its
own.  That way it can be reused in other projects or situations in the
same  project.  And  it  is  much  more easy to catch and extend class
behavior  if  it  is isolated to one file instead of multiple files or
mixed between other class methods in one file. On the other hand, what
is  bad  on  having  50-80  code  files in bitcoin? In terms of source
control  it  even  gives some kind of easier to read history and fewer
merge  conflicts.  When  you  start  writing  a  class for exactly one
propose  in  one specific situation used by one other class you should
think   about  writing  a  nested  class,  which  can  and  should  be
implemented in the same cpp file. That way you can achieve you similar
code in one location while accepting the rule others like.
Another nice side effect is the ability to see a class dependency list
be looking at the include listing.

Tuesday, July 12, 2011, 8:21:12 AM, John Smith wrote:
Don't  get  me  wrong. If boost would be used for something meaningful
there  would  be  no point in removing it. Everything non questionable
about boost does already find its way into most stl implementations.
And  everything  that find it's way into C++ 0x does it for the reason
that  it  is  better handled by an language extension than by an boost
construct. Otherwise there would be no point in extending the language.

Michael



-------------------------------------
2011/12/17, theymos <theymos@mm.st>:

This idea is really interesting. Is there any drawback I don't see?


-------------------------------------
<html>
  <head>
    <meta content="text/html; charset=ISO-8859-1"
      http-equiv="Content-Type">
  </head>
  <body bgcolor="#FFFFFF" text="#000000">
    <blockquote type="cite"><span>Nice. I'll check with justmoon when I
        hopefully meet him at the conference.</span></blockquote>
    <br>
    It's all fine with me. As soon as the original client switches to
    the new format, we will, too.<br>
    <br>
    <br>
    <br>
    On 11/13/2011 09:52 PM, Amir Taaki wrote:
    <blockquote
      cite="mid:1321217573.68019.YahooMailNeo@web121004.mail.ne1.yahoo.com"
      type="cite">
      <div style="color:#000; background-color:#fff; font-family:times
        new roman, new york, times, serif;font-size:12pt">
        <div><span>Nice. I'll check with justmoon when I hopefully meet
            him at the conference. If all is OK, hopefully 0.6 will be
            the last protocol version bump for a while.<br>
          </span></div>
        <div><br>
        </div>
        <div style="font-family: times new roman, new york, times,
          serif; font-size: 12pt;">
          <div style="font-family: times new roman, new york, times,
            serif; font-size: 12pt;"><font face="Arial" size="2">
              <hr size="1"><b><span style="font-weight:bold;">From:</span></b>
              Mike Hearn <a class="moz-txt-link-rfc2396E" href="mailto:mike@plan99.net">&lt;mike@plan99.net&gt;</a><br>
              <b><span style="font-weight: bold;">To:</span></b> Amir
              Taaki <a class="moz-txt-link-rfc2396E" href="mailto:zgenjix@yahoo.com">&lt;zgenjix@yahoo.com&gt;</a><br>
              <b><span style="font-weight: bold;">Cc:</span></b>
              <a class="moz-txt-link-rfc2396E" href="mailto:bitcoin-development@lists.sourceforge.net">"bitcoin-development@lists.sourceforge.net"</a>
              <a class="moz-txt-link-rfc2396E" href="mailto:bitcoin-development@lists.sourceforge.net">&lt;bitcoin-development@lists.sourceforge.net&gt;</a><br>
              <b><span style="font-weight: bold;">Sent:</span></b>
              Saturday, November 12, 2011 7:31 PM<br>
              <b><span style="font-weight: bold;">Subject:</span></b>
              Re: [Bitcoin-development] [RFC] BIP 14 - Protocol Version
              and User Agent<br>
            </font><br>
            <meta http-equiv="x-dns-prefetch-control" content="off">
            <div id="yiv1420890034">Looks pretty reasonable to me. If
              Gavin changes the mainline client to use this format I'll
              change BitcoinJ as well. It'll need a bit of API work so
              clients are sure to set it up properly.<br>
              <br>
              <div class="yiv1420890034gmail_quote">
                On Thu, Nov 10, 2011 at 10:16 PM, Amir Taaki <span
                  dir="ltr">&lt;<a moz-do-not-send="true" rel="nofollow"
                    ymailto="mailto:zgenjix@yahoo.com" target="_blank"
                    href="mailto:zgenjix@yahoo.com">zgenjix@yahoo.com</a>&gt;</span>
                wrote:<br>
                <blockquote class="yiv1420890034gmail_quote"
                  style="margin:0 0 0 .8ex;border-left:1px #ccc
                  solid;padding-left:1ex;">
                  <div>
                    <div
                      style="color:#000;background-color:#fff;font-family:times
                      new roman, new york, times, serif;font-size:12pt;">
                      <div>Hi,</div>
                      <div><br>
                      </div>
                      <div><a moz-do-not-send="true" rel="nofollow"
                          target="_blank"
                          href="https://en.bitcoin.it/wiki/BIP_0014">https://en.bitcoin.it/wiki/BIP_0014</a></div>
                      <div><br>
                      </div>
                      <div>Thanks to Gavin Andresen for proof reading
                        and suggesting clarifications. Thanks to Patrick
                        Strateman for suggesting the hierarchical format
                        and pointing out some flaws of browser
                        user-agents to me.</div>
                      <div><br>
                      </div>
                      <div>The timeline is written in the past tense
                        since BIPs are meant to be readable in the
                        future for explaining why we took certain
                        decisions with bitcoin. A nice cache for future
                        historians when bitcoin is ubiquitous ;)<br>
                      </div>
                      <div><br>
                      </div>
                      <div>The next version 0.6 should be the protocol
                        version which becomes peeled off from the
                        current client. There are still some changes
                        migrating into the protocol that need to be
                        finished.</div>
                      <div>
                        <br>
                      </div>
                    </div>
                  </div>
                  <br>
------------------------------------------------------------------------------<br>
                  RSA(R) Conference 2012<br>
                  Save $700 by Nov 18<br>
                  Register now<br>
                  <a class="moz-txt-link-freetext" href="http://p.sf.net/sfu/rsa-sfdev2dev1">http://p.sf.net/sfu/rsa-sfdev2dev1</a><br>
                  _______________________________________________<br>
                  Bitcoin-development mailing list<br>
                  <a moz-do-not-send="true" rel="nofollow"
                    ymailto="mailto:Bitcoin-development@lists.sourceforge.net"
                    target="_blank"
                    href="mailto:Bitcoin-development@lists.sourceforge.net">Bitcoin-development@lists.sourceforge.net</a><br>
                  <a moz-do-not-send="true" rel="nofollow"
                    target="_blank"
                    href="https://lists.sourceforge.net/lists/listinfo/bitcoin-development">https://lists.sourceforge.net/lists/listinfo/bitcoin-development</a><br>
                  <br>
                </blockquote>
              </div>
              <br>
            </div>
            <meta http-equiv="x-dns-prefetch-control" content="on">
            <br>
            <br>
          </div>
        </div>
      </div>
      <br>
      <fieldset class="mimeAttachmentHeader"></fieldset>
      <br>
      <pre wrap="">------------------------------------------------------------------------------
RSA(R) Conference 2012
Save $700 by Nov 18
Register now
<a class="moz-txt-link-freetext" href="http://p.sf.net/sfu/rsa-sfdev2dev1">http://p.sf.net/sfu/rsa-sfdev2dev1</a></pre>
      <br>
      <fieldset class="mimeAttachmentHeader"></fieldset>
      <br>
      <pre wrap="">_______________________________________________
Bitcoin-development mailing list
<a class="moz-txt-link-abbreviated" href="mailto:Bitcoin-development@lists.sourceforge.net">Bitcoin-development@lists.sourceforge.net</a>
<a class="moz-txt-link-freetext" href="https://lists.sourceforge.net/lists/listinfo/bitcoin-development">https://lists.sourceforge.net/lists/listinfo/bitcoin-development</a>
</pre>
    </blockquote>
    <br>
  </body>
</html>


-------------------------------------
Bad update. Macports has a couple of boost packages. Install the newer 1.46
ones.

-- 
Douglas Huff
On Oct 5, 2011 1:43 PM, "Gavin Andresen" <gavinandresen@gmail.com> wrote:
------------------------------------------------------------------------------
-------------------------------------
On Wed, Jul 27, 2011 at 1:31 AM, Gavin Andresen <gavinandresen@gmail.com>wrote:



Make a list of bugs. Offer BTC bounties for fixing each one according to how
serious/difficult it is. They don't have to be high, just a few BTC. It'll
also help people get interested in the project and *current* source base
(instead of wanting to implement Yet Another Incomplete Client from
scratch).

Or we could do the same as the mozilla/chrome projects, offer bounties for
finding new security holes and serious bugs.

A policy like "that spiffy new feature you want won't be considered until
you've helped close some open bugs" won't work. This is open source, people
can just make their own fork with the spiffy new feature without fixing any
bugs.

JS
-------------------------------------
I've got minna patches for nio based on bitcoinj. I've enumerated the
network a few times and am working on a DNS seed service as well as some
weather reports.

Happy to start a branch when the committers are ready.

-rick


On Tue, Sep 6, 2011 at 12:42 AM, Steve <shadders.del@gmail.com> wrote:

-------------------------------------
Bitcoin is the protocol. The client protocol identifier needs a unique name. It is not a public name that anybody ever sees except protocol developers.

For instance with libbitcoin, there might be several clients using it, but they'd all have the same protocol identifier.

I think calling it Satoshi is apt homage to the person who made the original client reference protocol.

Satoshi
BitcoinCommunityOriginal
...

Take your pick.



________________________________
From: Luke-Jr <luke@dashjr.org>
To: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Cc: Amir Taaki <zgenjix@yahoo.com>
Sent: Wednesday, November 2, 2011 10:46 PM
Subject: Re: [Bitcoin-development] Lock protocol version numbers

On Wednesday, November 02, 2011 6:33:12 PM Amir Taaki wrote:

What is "Satoshi 0.5" anyway? 0.5's server is bitcoind and GUI is Bitcoin-Qt; 
the wx GUI client is gone, which is more or less what "Satoshi" referred to in 
the past...
-------------------------------------
personally, if the software works better (less bugs) then btc will be more
valuable. offering bounty is orthorginal to finding the right technical lead
that will hurd the effort.

put a bounty (salary) on the person to lead the effort, not the bugs

-rick


On Wed, Jul 27, 2011 at 7:28 AM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
These branches are ready for merging to mainline. Note that these are not the 
same ones I sent earlier today, but part of a larger batch I have just 
finished rebasing.

Branches can be viewed at:
    http://luke.dashjr.org/programs/bitcoin/w/bitcoind/luke-jr.git/heads

git pull git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git <branchname>

=

coinbaser: allow customizing what addresses are paid by generation, with
           failover to the standard "50 BTC to me" behaviour; also adds the
           "setworkaux" JSON-RPC call to add arbitrary data to the coinbase,
           which can be used to implement merged-mining (has safeguards
           against creating invalid coinbases)

    Eligius has tested this quite a bit under the 0.3.23 codebase.

=

txinfo: adds "pooledtx" (number of transactions in memory pool),
        "currentblocktx" (number of txns in the last block created), and
        "currentblocksize" to the output of the JSON-RPC 'getinfo' method;
        adds "block_hash" and "block_index" to transactions shown by
        'listtransactions' and similar JSON-RPC methods

    Been using this since 0.3.21 without issues.

=

force_send: disables automatically adding "minimum" fees for JSON-RPC
            methods-- instead, it returns an error or, iff the user sets the
            new second parameter "force" to the 'settxfee' JSON-RPC call,
            sends the transaction with the user-specified fee

    This only affects JSON-RPC users, who should be assumed to understand the
    risk of sending with insufficient fees.

=

eligius_relay: relay transactions that satisfy Eligius's minimum fee when it's
               lower than the default rules
eligius_sendfee: allow sending the lower fee between default and Eligius, and
                 adds relay.eligius.st to the DNS seed list

    Merge or not, up to you guys... I don't really care.

=

bugfix_CreateThread_ThreadSocketHandler_errReporting: report an error in
                                                      debug.log


-------------------------------------
On 2011 December 19 Monday, Jorge Timn wrote:

The problems with HTTPS have been social rather than technical.  Multiple CAs 
have been strong-armed by governments or tricked into issuing fake 
certificates by scammers.  There is no technical measure around that.  By 
using the CA certificate we are saying to the system "here is someone I trust 
to issue a certificate".  So far, with a large number of CAs, that trust is 
misplaced.

I'm of the opinion though that this problem is outside the remit of bitcoin to 
solve.

Perhaps we should be more strict about which CA certificates are trusted by 
the bitcoin client: say restrict it to those who have demonstrably good 
practices for verifying identity; rather than the ridiculous amount of trust 
that comes pre-installed for me in my browser.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Tue, 2011-07-26 at 09:50 -0700, Rick Wesson wrote:
That is one point, but yes.
Because it allows for the giving of different addresses to each client
based on IP much easier.  Its possible with DNS by setting TTL to 0 and
hoping that Bitcoin clients will be using their own resolver, but that
is far from guaranteed.  Additionally, HTTPS stuff has already been
coded and implemented, so there's that...

Frankly, HTTPS' advantages are very small here, but since they exist,
and DNS has no advantages that I can see, I don't see any reason to go
with DNS here.  I much prefer using a HTTPS library (of which there are
many which have had much more thorough security audits) than a
DNSSEC-implementing DNS recursion library with the root trust anchors
and root servers built-in (are there any?).

Maybe I'm missing something here?

Matt
-------------------------------------
Thanks Mike, that's exactly the kind of detailed review I was looking
for.  I think you're right an all points.

I'll simplify:  I'll add a -banscore option (default 100), and if a
node accumulates more than -banscore misbehavior points it'll get
dropped and banned for -bantime (default 60*60*24) seconds.

I'll make bad signatures a banning offense, and I'll remove the
number-of-sigops and non-standard-transaction penalties.

I used a mutable field with const setter to avoid modifying a bunch of
methods to take non-const blocks/transactions instead of const; I
think it is appropriate because a block/transaction's DoS score is
really meta-data and not part of it's state.

I'll make GetTime() unit-test friendly as you suggest.

-- 
--
Gavin Andresen


-------------------------------------
With all due respect, I continue to disagree on the topic of using HTTP 
for data interchange.

Yes, an HTTP multipart response will accomplish the need for multiple 
named resources. The problem is that parsing of a multipart response 
isn't simple, and library support is weak across many languages. The 
widely adopted cURL library does not support multipart response parsing 
at all.

JSON is widely adopted, human readable, and has parsing libraries 
available for every major language. There is a bit of additional bloat, 
but I believe it is warranted in this case because of the convenience 
and ease it brings to developers.

If the idea is to "KISS", and provide a method that is both quick and 
easy to implement for the average developer, then JSON is a stand out 
option. Using HTTP for the data interchange will make things difficult 
for a lot of developers if multipart responses are used. JSON will be 
greeted with open arms.



On 12/19/2011 9:09 AM, slush wrote:



-------------------------------------


On Saturday, November 05, 2011 12:17:58 PM Christian Decker wrote:

I can agree with this point though. If clients break the network protocol/do not comply properly with it, they should be disconnected and shunned. Hard love. We don't want any ambiguity in the protocol.

Fail hard and fast.

However my feeling about the user-agent string is that it is a vanity item, but here we'd be enforcing a format that everybody can understand and read. Lets say with libbitcoin- I'm sure that users of libbitcoin would like to have their client name in the string somehow. This was we can quickly understand which code-bases are being used and all the variants that exist build on those code-bases.

Together with system information (how many Linux users are there?) and various system settings (how many 32bit users are there), and so on.
-------------------------------------
On Thu, Dec 15, 2011 at 04:26:38PM +0800, Walter Stanish wrote:

Just replying to this one comment: yes, some interaction is always
necessary, but not necessarily directly with the entity hosting the wallet.
There are some EC crypto tricks to do this (often mentioned under
"deterministic wallets" before):

The wallet-hosting entity has a private key x, with public key X.
The address-generating entity knows X, and generates a fresh private
key y for each transaction. For each, it calculates Z=y*X, and asks
the client to pay to hash160(Z). Afterwards, it can send a bunch of
y's to the wallet hosting service, which can reconstruct z=y*x for
each. Alternatively, the y's can be generated according to a predefined
scheme instead.

-- 
Pieter


-------------------------------------
This issue has been simmering for a while...

I agree with the following general principles, and it sounds like
others on the forums do too:

GP1) Alternative implementations of a protocol are beneficial to the ecosystem.

GP2) Tying together protocol and client version is sub-optimal, and
undesirable long term.

The current, coarse-grained scheme was clearly preferred by satoshi.
He knew what a chore creating a fully compliant client would be, and
when I joined (July 2010), was actively discouraging alternative
client efforts.  Also, tying protocol and client version together
certainly eased the deployment of changes.

Protocol development has clearly slowed, and we have at least one
major alternative client in the works (bitcoinj), so it seems fair to
revisit those assumptions and preferences.

Here are several mini-proposals for the Satoshi Client (anyone got a
better nickname?) along these lines, which should better prepare the
bitcoin protocol for the long term:

MP1) Avoid creating four-component version numbers (W.X.Y.Z), and use
pszSubVer as a client identification string.  This proposal originally
came from Mike Hearn, IIRC.

MP2) remove IP transactions in v0.4

MP3) create constants for protocol version, and audit code to split
client version from protocol version.  This is a THORNY patch, and far
more difficult than https://github.com/bitcoin/bitcoin/pull/63
implies.  The code has various data structures and such versioned, so
it is difficult to pick out at quick glance which 'version' is which.

MP4) split protocol and client versions in v0.4 -- though you will not
actually notice a change until v0.4.1, when the client version changes
but the protocol version does not.

MP5) Use a single bit inside 'nServices' to indicate the presence of
an optional "capabilities" message.  The purpose of this is to enable
minor protocol changes without having to change the protocol version.
Thus, nodes may advertise /features/ rather than simply "I support all
features >= version X".  Most mature protocols support this sort of
thing, rather than the simpler, coarse-grained version number system.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Monday, October 03, 2011 12:53:51 AM Gregory Maxwell wrote:

Perhaps as a safeguard:
(3) Before applying the new rule, require 50% of the last Y blocks contain a
    coinbase with a "I am upgraded" code
(4) Until the new rule is active, include an "I am upgraded" code in every
    block; after it's active, this can be turned off


Why would legitimate community members ever intentionally transmit an invalid 
transaction? ;)


-------------------------------------
Yes, I know that. It compiles.

If we pulled all the 'This is legal in C++' tricks in the bitcoin source it
would be even less maintainable and readable than now. But whatever...

JS

On Sun, Oct 23, 2011 at 10:51 PM, theymos <theymos@mm.st> wrote:

-------------------------------------
On Monday, July 25, 2011 11:35:34 PM Rick Wesson wrote:

1. Right now you practically need a unique Bitcoin address per transaction.
2. DNSSEC is on the edge of becoming illegal in the US.
3. Emails aren't merely domains.

I would propose something like resolving foo@bar.net to a SRV lookup for 
_bitcoinaddressresolution._tcp.foo.bar.net, expecting a cert for bar.net, 
making a HTTPS request for /bitcoinaddressresolution?foo@bar.net, and also 
sending an email to foo@bar.net (the usual way) signed with the keys used for 
the transaction. ;)


-------------------------------------

ok, imagine if firstbits didn't exist. instead of going to firstbits,
you would have gone to your terminal, opened up brmlabs website, and
copied the address from there?

there may be some arguments for name-> address translation, but i'm
sorry to say, that your example is not one of them. if anything, it
seems to suggest that firstbits is completely useless, since it saves
approximately zero effort.


-------------------------------------
Suggestions:

- massively increasing all the anti-DoS limits in 0.4, so far they've caused
a lot more damage than they solved.

- broadcasting an "upgrade now" type announcement. The alert system is
intended for informing users when there's a threat to system stability and
that's exactly what has been happening recently.
-------------------------------------
Nice to meet you.  Its always nice to have more dedicated developers.

On Mon, 2011-08-22 at 15:02 -0400, Fred Concklin wrote:
autotools yay.  Also, have you seen jenkins.bluematt.me?
No one has complained too much about mine yet, so I think you are safe.
And Id bet everyone here is exited to have you.

Matt



-------------------------------------
On Wednesday, August 24, 2011 12:46:42 PM Gregory Maxwell wrote:

Dynamically adapting would be by design never too early/late. Changing from a 
fixed 1 MB will fork the block chain, which should be a minimized event.


Depends on the implementation, I'd think.


So? You can already have redundant transactions simply by changing the order 
of inputs/outputs. A good client would minimize the transaction size by 
reducing them, of course.


I already tried to address this in my original mail. If I had those 4 coins, I 
would use a denominator of 987 and discard the difference as fees.


-------------------------------------
On Tue, 2011-09-06 at 20:32 -0400, Alex Waters wrote:
When did it switch from 0.4 to 4.0?
I feel like the user-facing quality of the software should not be
over-emphasized when it really is very beta in quality.
https://bitcointalk.org/index.php?topic=4750.0 (a bit outdated, but it
should still work fine)
https://bitcointalk.org/index.php?topic=5851.msg86700#msg86700
If the instructions were updated with fresh links/versions/etc, they
should work 100%.
No package needed, just apt-get the relevant packages?
doc/build-unix.txt is (though in some cases somewhat ubuntu-specific)
quite good IMHO.
If you are feeling lazy, I can convince jenkins.bluematt.me to churn out
windows and ubuntu builds almost identical to those that will come out
of gitian (ie the same build as the official release builds) if you
want.
Something like the current jenkins scripts could also be easily hacked
up to automatically sanity-test pull requests as they come in and catch
common errors (or just sanity failures).



-------------------------------------
You have to be seriously joking to call the bitcoin protocol elegant. A message based system over TCP with constantly changing endians that needs to lookup its own IP address on several websites is not elegant. It is functioning, not elegant.

Also it is kind of dick to come guns blaring and start insulting slush who runs one of the biggest mining pools and is working on electrum, and sipa who develops the satoshi bitcoin.

Khalahan said:


Namecoin has the same problem as DNS. From the document:

"The disadvantage of DNS TXT records is that updating a record takes 
time. This encourages people to not use new addresses per transaction 
which has certain security issues."


________________________________
 From: Rick Wesson <rick@support-intelligence.com>
To: Andy Parkins <andyparkins@gmail.com> 
Cc: bitcoin-development@lists.sourceforge.net 
Sent: Friday, December 16, 2011 5:41 PM
Subject: Re: [Bitcoin-development] Fwd: [BIP 15] Aliases
 
Its a negative example -- in that the IETF does not specify anything
in the PATH part of the URI. The scheme, sure, but not in the path,
there are many types of URI schemes ( start with RFC 2396 )

There is significant upside to having your own scheme and having apps
understand how to integrate with it. Frankly, having just one client
(I understand there are more) is an artifact that hinders acceptance
and participation. If you want to go the route of https then
specifying a scheme is your path forward

I still believe that it is experience that is leading this thread down
the rat-hole of CGI and HTTP requests. The stuff isn't magic, it is
just what you are used to. Review the bitcoin protocol, there is an
elegance there -- not found in the https schemes proposed thus far.
CGI isn't a protocol, nor does it address usability/identity issues.

Providing a mapping from user@authority.tld addresses usability and
identity. I'd like to see an elegant transformation, specifically I
take to task anyone that advocates
https://authority/foo/user?tx=1zhd789632uilos as elegant.

-rick


On Fri, Dec 16, 2011 at 9:10 AM, Andy Parkins <andyparkins@gmail.com> wrote:

------------------------------------------------------------------------------
Learn Windows Azure Live! Tuesday, Dec 13, 2011
Microsoft is holding a special Learn Windows Azure training event for 
developers. It will provide a great way to learn Windows Azure and what it 
provides. You can attend the event by watching it streamed LIVE online. 
Learn more at http://p.sf.net/sfu/ms-windowsazure
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
On Fri, Sep 30, 2011 at 12:25 PM, Mike Hearn <mike@plan99.net> wrote:

The ease of omitting useful cases is why I was strongly supporting the
full RPN boolean validation, even though it's harder to get good
testing confidence.


-------------------------------------
RE: splitting off the "send commands to a running bitcoin" :

I'm mildly against it. It would be less confusing for newbies, at the
cost of forcing everybody who has already written backup scripts or
other interact-with-running-bitcoin tools to tweak their code. The
coding will be easy, but do you really want to spend the time to
answer all the "I installed Bitcoin X.Y and now my backup script
doesn't work" questions and modify the wiki pages and ...

I'd rather that time be spent working on any remaining build issues so
we can switch to bitcoin-qt.  I don't care if it is autotools or qmake
or QT creator, I just care that it works on Windows and Linux under
gitian and has clear instructions so I can build it on my Mac.

-- 
--
Gavin Andresen


-------------------------------------
On Thu, Jul 7, 2011 at 4:49 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

autotools is indeed "the devil we know" which works automatically on
all supported platforms save VC++  It is also the easiest to package,
as all distros already have macros and scripts specifically designed
to integrate autotools packages into their package build systems.
cmake simply does not have that level of uptake.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On 8/5/2011 12:18 AM, Gregory Maxwell wrote:

To the transaction radar it doesn't much matter whether its connections 
are outgoing or incoming (assuming it can keep its nodes' IPs secret and 
it has reasonable uptime). So you could say that this is an argument 
*for* this kind of double spend protection if it means the creation of 
nodes/clusters accepting 10000+ incoming connections while making few 
outgoing connections. My point is, the amount of connections a node has 
has nothing to do with its effect on the in/out balance.

Some words on the shortage of listeners itself:

Could this be because the network right now consists largely of end 
users with residential type networks? With BitTorrent a lot of users go 
through the trouble of opening up ports in their router manually in 
order to get more peers and better download speeds - this is not (yet?) 
a widespread practice with Bitcoin. (I know Bitcoin has UPnP support, 
but I haven't found any numbers on how widely the IGD protocol is 
actually deployed. Wikipedia says that "some NAT routers" support it and 
that it's not an IETF standard. All routers I've actually seen in real 
life had it disabled by default.)

In the long term all the trends favor more clients allowing incoming 
connections: End users will tend to move towards lighter clients and the 
ones that stick with full nodes will tend to configure them better - 
meaning opening ports etc. - as documentation improves.

As for downright malicious nodes: It should be possible to come up with 
some sensible policies to temp ban nodes that don't relay any useful 
messages or try to flood you. This is an ongoing optimization problem in 
any peer-to-peer network and I expect us to make progress with this over 
time.


On 8/5/2011 12:16 AM, Matt Corallo wrote:

I had only seen you mention a "miner backbone" which is sort of a more 
long-term vision, whereas Transaction Radar exists today. I didn't read 
everything though, so if you mentioned this idea specifically, please 
just consider my post as further support for your position.




-------------------------------------
Now I get it. Thank you.
You save space by having shorter scripts in transactions.


-------------------------------------
On Thu, Jul 28, 2011 at 6:49 PM, Gregory Maxwell <gmaxwell@gmail.com> wrote:


Maybe they have magic build instructions in the readme file! :-)

JS
-------------------------------------
On Wed, Oct 5, 2011 at 1:18 AM, Brian McQueen <mcqueenorama@gmail.com> wrote:

However you want. The P2P network isn't all the essential to bitcoin.
With patches you can import and export transactions to text from a
regular client.

The distributed algorithm and the block chain are far more essential
to bitcoin than the p2p network is, you could interconnect all bitcoin
systems with morse code operators running spark gap transmitters with
nary an IP packet in sight and it would still be bitcoin.


-------------------------------------
On Monday, August 29, 2011 4:10:01 PM Gavin Andresen wrote:

Can we get some form of the signmessage method in?


-------------------------------------
On Saturday, July 02, 2011 2:03:49 PM John Smith wrote:

puddinpop's stuff is all ancient/obsolete. If you want people to consider it, 
you should probably make a new branch.


-------------------------------------
I installed boost via the mac ports.  Its got lobboost_thread-mt, but
it doesn't have libboost_thread.a. Should I modify the makefile or get
a different version of boost?

-- 
Make a Small Loan, Make a Big Difference - Check out Kiva.org to Learn How!


-------------------------------------
On Saturday, December 17, 2011 6:46:34 PM Gregory Maxwell wrote:

I missed that bit. I'm willing to defer full OP_EVAL support on Eligius in 
order to enable key recovery...


-------------------------------------
On Mon, Jun 13, 2011 at 5:38 AM, Christian Decker
<decker.christian@gmail.com> wrote:

And how does the client discover HTTP trackers?  You're either
hardcoding -those- into the client, or adding an additional bootstrap
step to discover them.  Either way, it has the same problems as other
current methods.

The history and experience of gnutella's web caches vs. UDP host
caches seems highly relevant here.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I took it off the list because snarky comments are not appropriate for
bitcoin-dev, and I was being snarky.

Please try to keep your comments on-topic; if you want to talk about
fixing -maxreceivebuffer (a change I would wholeheartedly embrace, the
code I slapped together was reacting to phantomcircuit's "here's a
python script that will kill any bitcoin node on the network" 0-day
exploit), then please start a new topic.


-- 
--
Gavin Andresen


-------------------------------------
Some of us take private disclosures of vulnerabilities very seriously.

In any case, the ClearCoin CSRF vulnerability is fixed.  Thank you for
bringing it to my attention.

On Sun, Jun 19, 2011 at 5:54 PM, Doug Huff <dhuff@jrbobdobbs.org> wrote:


-- 
--
Gavin Andresen
http://clearcoin.com/


-------------------------------------
On Thursday, October 13, 2011 9:32:48 AM Gavin Andresen wrote:

Once again, this does not fix anything (they're already strict enough for the 
2-week window), and just creates new problems.


Flawed concept. Only even potentially useful for extreme cases (ie, a miner 
intentionally making lots of 1 MB blocks of junk).



-------------------------------------
On Tuesday, December 13, 2011 8:06:15 AM Gavin Andresen wrote:

Seems like introducing a gaping security risk to me.


Could always use a fixed address and email somebody@foo.com a signed message.


-------------------------------------
On Fri, Aug 19, 2011 at 12:48 PM, Luke-Jr <luke@dashjr.org> wrote:

Your change appears to be technically correct.  It is disappointing
for #ifdefs to crap up the code, though...

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
OK I pulled a couple other minor bits.

The only remaining question, IMO, is whether or not we should pull

     Make UPnP default on Bitcoin but not on Bitcoind.
     https://github.com/bitcoin/bitcoin/pull/372

We are all kicking the can on this decision to Gavin I believe <grin>
I think the two strong arguments for upnp are
     - other p2p apps widely deployed, notably skype, use it
     - it will make a significant positive impact in the number of
       nodes supporting incoming connections

so my personal (read: not speaking for anyone else) opinion is to turn
on upnp for bitcoin _and_ bitcoind.

Other than that, here's what we're looking at for 0.3.24:

Dawid Spiechowicz (1):
      added polish translation

Doug Huff (1):
      Add OSX App bundle and correct build instructions to reflect reality.

Eric Hosmer (1):
      Updated Visual C++ makefile.

Gavin Andresen (1):
      Boost unit-testing framework.     make -f makefile.{unix,osx,mingw} test_b

Giel van Schijndel (2):
      rpc server: send '403 Forbidden' to rejected clients
      rpc: don't send 403 when using SSL to prevent DoS

Han Lin Yap (3):
      Double check translation and improved a translation string
      Update swedish translation
      Consistent Bitcoin example address

James Burkle (1):
      Edited init.cpp to include a check that -datadir exists

Jeff Garzik (4):
      FormatFullVersion: build fix related to recent translation improvement
      doc/release-process.txt: minor updates
      CWalletTx::GetAmounts(): pass NULL for CKeyStore*, rather than false     t
      Enable DNS seeding by default.

Joerie de Gram (1):
      Fix connection failure debug output

Jordan Lewis (8):
      Only include irc.h when needed
      Only include db.h when we have to.
      Only included rpc.h when necessary
      Only include net.h when we have to
      Only include init.h when we have to
      Only include strlcpy.h when we have to
      Remove some globally unused headers from headers.h
      Only include certain boost headers if necessary.

Matt Corallo (3):
      Update translations and remove obsolete translations.
      Add new DNSSeed dnsseed.bluematt.me.
      Only use dnsseeds and static seeds when not on testnet.

Pieter Wuille (5):
      move wallet code to separate file
      CWallet class
      Bugfixes walletclass
      Fix segfault when creating new wallet
      Limit response to getblocks to half of output buffer size

Shane Wegner (1):
      Fix missing includes needed for Boost 1.46.

Wladimir J. van der Laan (1):
      add GetTotalBlocksEstimate() function, move magic number to constant

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Mon, Jul 4, 2011 at 10:26 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Yeah, same thoughts here.


Tagged -tip as -rc2.

Bug reports are mostly quiet, so maybe we can even get the release
before you leave.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sun, 2011-07-31 at 11:21 +0000, John Smith wrote:

See pull 363 and 442 :)

Matt



-------------------------------------
Current git HEAD has been proposed to Gavin & the rest of the dev team
as 0.3.23-rc1.

As soon as Gavin gives his ACK, we have builds ready to upload.

We wanted this to be a fast, bugfix-only release.  The main focus was
to deploy a fix for connections taking forever, due to a large portion
of the network not accepting incoming TCP connections.

git shortlog for 0.3.23-rc1 (presuming Gavin's ACK):
Dean Lee (1):
      Updated Chinese Simp translation

Doug Huff (3):
      Fix rfc1918 and rfc3927 compliance for ignoring non-internet-routable host
      Add common temp files to .gitignore.
      Demystify a few magic numbers.

Han Lin Yap (2):
      Added Swedish translation
      Remove unused variable

Jeff Garzik (4):
      Bump version to 0.3.23.
      Reduce minimum TX fee for new transactions, to 0.0005.
      Lower minimum relay TX fee to 0.0001 (from 0.0005) BTC.
      Add minimal release process docs.

Matt Corallo (1):
      Fix CPU Usage bug when using -nolisten and have no connections.

Nils Schneider (1):
      create keypool in LoadWallet()

Pieter Wuille (3):
      Update transactions already in the wallet when rescanning.
      Fix for small change outputs
      Faster timeout when connecting


-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Example patch: http://tinyurl.com/6679go5

Changes:
* Additions to your wallet always are category:"receive", no matter what kind
  of transaction
* Generated coins have an extra key, from:"generation"
* All transactions have a new key, status:
  * "orphan" -- Another block chain invalidated this transaction (only for
                generation?)
  * "validating" -- Default stage for transactions; 0-2 confirmations for
                    ordinary sends, and 0-100 for generated coins
  * "processing" -- 3-6 confirms for ordinary sends; 101-120 for generated
  * "confirmed" -- over 6/120 confirmations
  * "expired" -- for ordinary sends that have timed out without getting into a
                 block, or had its inputs otherwise respent

This change is proposed to fix webservices being ignorant of generated 
transactions by keeping a standard category/format for all similar types of 
entries.

Thoughts?


-------------------------------------
Reminder these are still ready for merging...

Jeff, you seem to have rewritten *part of* bugfix_CreateThread_leak and 
neglected to attribute the original author (as my branch did/does).



-------------------------------------
Fixing listtransactions (and listreceivedby/etc) so coin generation
transactions to particular addresses/accounts are credited to that
address/account is a good idea.

I don't think changing listtransactions output would be on the
priority list for any web services operators (in fact, I think most
would scream bloody murder if the output changed in a way that forced
them to change their code). The accounts-related things that I think
ARE on their high-priority list are:

1) Fixing getbalance and listtransactions performance problems when
you have hundreds of thousands of transactions and thousands of
accounts.

2) push-notification of coins received to accounts, so they don't have
to poll for changes.

-- 
--
Gavin Andresen


-------------------------------------
On 22.10.2011 12:51, Nils Schneider wrote:

If you add Norwegian Bokml, I can do that one. Language code "nb".

Regards,
Geir Harald Hansen



-------------------------------------
Interesting thread.

Given the following paragraph and the limited feedback garnered upon
its announcement to this list last month, I couldn't help but chime in
again to mention IIBAN, an Internet Standards Draft available at
http://tools.ietf.org/html/draft-iiban-00 (A related proposal for
internet connected financial market identification, IMIC, is also
available: http://tools.ietf.org/html/draft-imic-00) which - fair
declaration of bias - I authored on behalf of my employer, Payward
Inc., while working on Bitcoin-related development.


I believe that IIBAN solves this problem fairly elegantly:

(1) Mature transposition error detection (think "Oops, that's a zero
not an 'oh'! I wrote it wrong!"). This functions via checksum digits
using a known algorithm, leveraging decades of experience in
conventional financial institutions. The same functionality provides
for simple suggested error correction on common transposition errors
(0->O, 1->I, etc.).

(2) Fixed length.

(3) Far shorter than both bitcoin addresses and many national bank
account numbers at 13 characters (less than half of the size of a
bitcoin address).

(4) Fewer characters (no lowercase), resulting in less transposition
issues and greater legibility.

(5) Superset-compatible with existing financial networks utilizing the
IBAN standard (mandated in Europe, increasingly popular elsewhere),
resulting in greater ease of uptake.

(5) Centralized, delegatable namespace allocation but with clear rules
governing allocation that aim to minimize potential room for any
potential abuse of power.

(6) Settlement system neutral - ie: not bitcoin-centric. By leaving
Bitcoin to be Bitcoin, Bitcoin developers can focus on core concerns
rather than becoming embroiled in formatting and user experience
concerns. Also, a single address could be paid via multiple channels
(conventional financial systems, bitcoin, LETS systems, etc.)
resulting in greater ease of uptake and higher user confidence over
time since published banking information is no longer held hostage to
the assumed longevity, liquidity, legality or other liabilities of an
individual settlement system (such as Bitcoin).

(7) Provides defined private address spaces for internal transfers
(eg: within an organization's own systems, for financial simulations,
MMORPGs, etc.) and a documentation/public works of fiction address
space to address common usage concerns in similar network addressing
schemes.

(8) Heterogeneous management of different parts of the address space.

Whilst the proposed IANA (Internet Assigned Numbers Authority)
management of IIBAN's initial institution namespace is indeed
centralized and will no doubt raise eyebrows from within parts of the
community for that reason alone, the IIBAN draft is liberal in its
assignment policy, which can be viewed within the draft document
linked to above, and whose terms are binding for IANA.  It's also
worth noting that four of the most similar global systems deployed
today, SWIFT's BIC and IBAN, the ITU's E.164 international telephone
numbering scheme and IANA's IP address space management are
implemented as similar centralized-but-delegated style schemes.

Furthermore, due to the flat nature of the registry, a
http://convergence.io/ style 'trust agility' model (ie: multiple
'centralized' parties share their network view, and user-prioritized
source consensus/acceptance/approval determine end-user perspective)
is wholly compatible.

In closing, a quick mention that a new version of the IIBAN draft will
be released very shortly including a draft IIBAN institutions registry
that will be established in order to facilitate implementation and
testing. Drop me an email if you'd like a portion of the address space
and your early assignment will appear within that draft.

Regards,
Walter Stanish
Payward, Inc.


-------------------------------------
On Tue, Sep 6, 2011 at 4:55 PM, Luke-Jr <luke@dashjr.org> wrote:

Turned this into a pull request:
  https://github.com/bitcoin/bitcoin/pull/505

I reviewed the code but have not tested.

Rough sketch of a test plan:

Run clean testnet-in-a-box bitcoind, with -keypool=1
Encrypt the wallet
Run bitcoind getnewaddress until it tell you keypool is exhausted
Generate a couple of blocks via internal miner -- verify: coinbase
transactions have unique txids even though they pay-to default key
Generate a couple of blocks via getwork RPC call -- verify: coinbase
transactions have unique txids


-- 
--
Gavin Andresen


-------------------------------------
Sorry for keeping this short but I'm in holiday and reading/writing on my
phone is a pain.

On Aug 24, 2011 4:12 PM, "Gavin Andresen" <gavinandresen@gmail.com> wrote:
It's a great way for companies to secure their assets.

Since. we have the possibility o add other signature schemes to the protocol
we could add an rsa-like scheme which allows m-out-of-n signatures. It works
by distributing shares of the key which are points on a curve having the
actual key as 0-value. It does not require special length for the key so if
ecdsa allows something similar there need not be anything changed.

Would be a first step.

Just wanted to point you in that alternative direction as it would possibly
keep backward compatibility and allow multisignature.

Regards,
Chris
------------------------------------------------------------------------------
-------------------------------------
OK, after a lot of good discussion and a tiny bit of results, I would
submit that Wallet Encryption is in a pull-able state.  Can I get final
comments/ACKs

Matt

On Mon, 2011-06-27 at 03:20 +0200, Matt Corallo wrote:
-------------------------------------
On 2011 July 13 Wednesday, Mike Hearn wrote:

"all" is a strong word :-)

I'm doing a similar thing, and so far I have (and it's definitely incomplete) 
the following for these magic-constants that are often literals in the offical 
client:

	TBlock *GenesisBlock;
	TBitcoinHash ProofOfWorkLimit;
	uint16_t DefaultTCPPort;
	uint32_t Magic;
	uint8_t BitcoinAddressPrefix;

	unsigned int COINBASE_MATURITY;
	unsigned int COINBASE_MINIMUM_SCRIPT_SIZE;
	unsigned int COINBASE_MAXIMUM_SCRIPT_SIZE;
	unsigned int MAX_BLOCK_SIZE;
	unsigned int MAX_BLOCK_SIZE_GEN;
	unsigned int MAX_BLOCK_SIGOPS;
	unsigned int MINIMUM_TRANSACTION_SIZE;
	TCoinsElement MIN_MONEY;
	TCoinsElement MAX_MONEY;
	TCoinsElement MIN_TX_FEE;

	TCoinsElement INITIAL_MINING_REWARD;
	unsigned int INFLATION_PERIOD;

	unsigned int BLOCK_TIMESTAMP_WINDOW;
	unsigned int DIFFICULTY_TIMESPAN;
	unsigned int NEW_BLOCK_PERIOD;

	unsigned int INV_MAX;
	unsigned int GETDATA_MAX;
	unsigned int GETBLOCKS_RESPONSES_MAX;
	unsigned int GETHEADERS_RESPONSES_MAX;
	unsigned int ADDR_MAX;
	unsigned int ADDR_MIN_TIME;
	unsigned int ADDR_MAX_TIME_OFFSET;
	unsigned int ADDR_DEFAULT_TIME_PENALTY;
	unsigned int ASSUME_OFFLINE_AFTER;
	unsigned int OFFLINE_UPDATE_INTERVAL;
	unsigned int ONLINE_UPDATE_INTERVAL;

	map<unsigned int, TBitcoinHash> Checkpoints;

	static const TBitcoinHash NULL_REFERENCE_HASH;
	static const unsigned int NULL_REFERENCE_INDEX;

Any suggestions for others gratefully received.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Woohoo, 0.6.0 merging time!

I'll merge some GUI pull requests for 0.6.x this/next week.

Wladimir

On Tue, Dec 20, 2011 at 9:49 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:

-------------------------------------
On Fri, Jul 1, 2011 at 10:05 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:

Just tagged v0.3.24rc1...

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wed, Aug 10, 2011 at 06:59:14PM +0200, Matt Corallo wrote:

No I didn't start writing anything - I've been quite busy the past few weeks,
and will be more so the coming weeks. Anyway, some ideas:

Either we try to make everything single threaded, and aim towards a bitcoin
library which you pass events (which can be network, rpc, UI, ...) and
it always processes in finite time, without any separate threads. That
would be a serious rewrite, and maybe a limitation on potential growth
(there *will* be a time where a full node doesn't run on anything but
a 16-core machine...).

The alternative is doing a very careful checking/rework of the locking
system. I think you want some per-object locking instead of per single
data structure. Making it so fine-grained forces careful checking of
the order in which things are locked. That is hard to keep track of,
and probably doesn't gain you very much (just a guess, experiments could
prove me wrong, obviously)

I would propose a system with one lock for the node-handling code
(mapTransactions, mapBlockIndex, mapOrphanBlocks, ...), one lock for
the wallet-handling code (mapWallet, CKeyStore), and one lock for
network-handling code. No access to any inner data structures of
these components is exposed, and everything goes through accessor
functions. All exposed functions of each component take the respective
lock upon entering the component. This includes functions that only
need read-only access (which currently often don't take a lock at
all, iirc).

However, I think we can move to reader-writer locks (boost's shared_mutex).
A lot of code does not need an exclusive lock on the data, as multiple
threads reading the internal data structures simultaneously is not a
problem. This would mean that all inspector functions are wrapped in a
lock_shared/unlock_shared blocks, all mutator functions are wrapped in
a lock_upgrade/unlock_upgrade block, and code that actually modifies
data structures is wrapped in a unlock_upgrade_and_lock/
unlock_and_lock_upgrade block. 

This is clearly part of a larger code-cleanup effort, as it would mean
moving all code in GUI and RPC that take locks on various things, to
the component they are taking locks on. That's immediately a nice step
towards "librarification" of the code...


I think it should be more or less finished by now in terms of
functionality, at least for dumpprivkey, importprivkey, removeprivkey.
I'm somewhat less sure about dumpwallet/importwallet, as some changes
to the json dump format might be useful still. It does require testing
though...


I'd really like to see that - with or without autotools, if some degree
of consistent config/build architecture can be maintained for the
different platforms.


I was working on a draft for a reworked fee system. I didn't get to
write things out nicely, but the main idea was: assign a score to each
transaction group, in a way that scores always keep increasing over time.
Keep the memory pool sorted according to those scores, and drop the lowest
scoring ones when a configurable memory limit is reached (no limit on the
score itself). Finally, for mining, select the top N transaction groups
from the pool in such a way that an average configurable fee per byte
is maintained. 

As each mining node chooses a (hopefully more or less fixed, or at least
only slowly changing) cutoff score above which transactions are included,
the network should converge to a more or less fixed probability distribution
for the score at which transactions are included.

Nodes can measure and estimate this distribution, and calculate expected time
to inclusion for a given fee.

The devil is in the details, as it is kinda hard to define a scoring system
for transactions that is independent from the current exchange value of
bitcoins, from which kind of transactions are common on the network, but still
tries to mimic the cost for the network to handle that transaction.



Anyway, as said, I currently don't have the time to implement these ideas
right now. I do read the mailing list, though :)

-- 
Pieter


-------------------------------------
On Wednesday, November 02, 2011 6:33:12 PM Amir Taaki wrote:

What is "Satoshi 0.5" anyway? 0.5's server is bitcoind and GUI is Bitcoin-Qt; 
the wx GUI client is gone, which is more or less what "Satoshi" referred to in 
the past...


-------------------------------------
On Thursday, July 28, 2011 1:25:46 AM Alan Grimes wrote:

I put the page together a while ago with logical segregation of the current 
Bitcoin concept. wxBitcoin originally implemented the entire thing as one big 
blob. Miners got moved out first. Spesmilo took the next step of separating 
out a GUI. Wallet and node are currently tightly tied together in bitcoind, 
though it can function as only one of the two just as well. So in practice, it 
is fully possible to run it like that, but I'm not aware of any de facto use 
yet.


Generally, nodes need to make outbound connections too, at least to get 
started.


The miner can really get by with just an address from the wallet--
it needs somewhere to put its generated coins ;)


You can run a system-wide bitcoind (or equivalent) to handle p2p connectivity, 
and have each user run a dedicated wallet bitcoind (with the -connect option) 
with a unique JSON-RPC port (for Spesmilo) or wx GUI. I don't think there is 
any automated setup for this kind of arrangement. I personally foresee the p2p 
being implemented on a SOHO router as the end goal (or even better-- 
multicast).


-------------------------------------
On Wed, Aug 10, 2011 at 10:14 AM, Matt Corallo <bitcoin-list@bluematt.me>wrote:


UI would obviously still have RPC functionality with -server. I don't mean
dropping that. The UI links both the UI and the network code (for now, until
this is separated out and the preferred UI<->core communication method is
through RPC).

I just mean that the *headless* daemon is separate from the UI executable,
which is the case for any other sane client/server-based program in
existence, from bittorrent nodes to game servers.

It would also make it possible to build the command line RPC client
(bitcoin-cl) *without* building the server or UI. Useful if you want to
remotely control a Bitcoin daemon but not want to build it locally.

JS
-------------------------------------
On Mon, Jul 4, 2011 at 5:18 PM, Douglas Huff <dhuff@jrbobdobbs.org> wrote:

Silently breaking them, not so much.

Or do you think people are going to notice that they've started
backing up a zero byte file?


-------------------------------------
I'd be happy with a sort of BitTorrent like snubbing, and dropping in
extreme cases.
Sharing blacklist decisions would be dangerous. We could even extend the
protocol to include some sort of choking/unchoking in order to warn peers
that we might drop him if he continues to misbehave.

In general I think that we have to be careful in what we consider
misbehaving, it should be really conservative to begin with, and extend the
rules over time. Making them too restrictive might make future development
difficult, not to speak of alternative clients.

Regards,
Chris

On Thu, Sep 15, 2011 at 4:06 AM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
Oh, one other thing - as you point out yourself, escrow is only one use case
for multsig transactions. So I suggest you don't use the word in the patch.
Maybe instead call them multisign or multipay transactions.
-------------------------------------
A quick release would be good. The network is getting really sick:

   http://forum.bitcoin.org/index.php?topic=26894.40

I brought up the latest rc3 on plan99.net.

Though it's not relevant for this release, there seems to be some kind
of shutdown issue. I did a "bitcoin stop" and then waited for the log
to indicate successful shutdown. But the parent process didn't quit,
leaving a zombie. I did a kill -9 on the parent to get rid of it, and
then the addr.dat file became corrupted. I had to remove it and the
"database" directory as running the db_recover command didn't work.

On Wed, Jul 6, 2011 at 10:05 PM, Jeff Garzik <jgarzik@exmulti.com> wrote:


-------------------------------------
On Wed, Aug 24, 2011 at 12:15 PM, Luke-Jr <luke@dashjr.org> wrote:


Too early for that.


The quantized scheme limits the amount of difficulty skew miners can
create by lying about timestamps to about a half a percent. A rolling
window with the same time constant would allow much more skew.


Increasing precision I would agree with but, sadly, causing people to
need more than 64 bit would create a lot of bugs.

infinite numerator + denominator is absolutely completely and totally
batshit insane. For one, it has weird consequences that the same value
can have redundant encodings.

Most importantly, it suffers factor inflation: If you spend inputs
1/977 1/983 1/991 1/997 the smallest denominator you can use for the
output 948892238557.

Not to mention that the idiots writing financial software can only
barely manage to not use radix-2 floating point on everything. Asking
them to use arbitrary rational numbers with mixed radix will never
fly.


Please lets not make bitcoin _less_ trustworthy.

The 100 block maturity on generated coins is good. The generation from
an orphaning is lost forever like the losing side of a double spend,
but far far worse... because orphaning happens all the time on its own
without any malice.

I agree it's obnoxious that you can't pad your generation payouts
without creating more transactions, but I don't see a solution for
that. Repeat the addresses... make up for it by increasing your payout
threshold.


-------------------------------------
* 6b8a5ab Bump version to 0.4.1

This should be some pre-0.5.0, not 0.4.1 which will be the stable team's first 
release...


-------------------------------------
It's legal for a scope to define variables with names that conflict with
the names of variables in higher-level scopes.


-------------------------------------
Rebased onto wallet class and ready for "wtf is this crap" messages ;)

https://github.com/bitcoin/bitcoin/pull/352

Matt 
-------------------------------------
I have a pull request here:

https://github.com/bitcoin/bitcoin/pull/319


  Bitcoin "escrow" are coins that are under the control of multiple
  parties.  The initial implementation allows n parties to vote, with
  k good signatures needed (k <= n).

  This eliminates single points of failure and reduces the trust required
  in many transaction use cases.

Use cases include Escrow (without trusting the escrow agent with the
coins), immediate payment and funds locked with multi-party signatures.

This was inspired by https://forum.bitcoin.org/index.php?topic=8821.0 and
https://forum.bitcoin.org/index.php?topic=4723.msg68804 .

Feedback on the pull is very much appreciated.





-------------------------------------

-------------------------------------
This was posted to IRC:
http://davids.webmaster.com/~davids/bitcoin-3diff.txt

Includes several useful features that all the big pools have been
screaming for...  notably HTTP/1.1 keep-alive support.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Nice work, Detective Wuille!

Patch for the deadlock issue:

https://github.com/bitcoin/bitcoin/pull/500

I took a different approach to fix from the one Pieter suggested,
performing the database operation after the cs_mapaddresses deadlock
is released.  Please review to check my logic, it did survive my
start/stop/restart... stress test.

And I did review every place in the code that starts a database
transaction, to look for similar issues, and they are all OK.


RE: improving DEBUG_LOCKORDER:  requires some thought.  Deadlocks are
still possible with TRY_CRITICAL_SECTION, if some codepaths TRY and
some don't.


On Tue, Sep 6, 2011 at 7:55 AM, Pieter Wuille
<pieter.wuille@cs.kuleuven.be> wrote:


-- 
--
Gavin Andresen


-------------------------------------
On Thursday, August 04, 2011 4:29:01 PM Luke-Jr wrote:

My apologies. BlueMatt showed me how my comment here was wrong.
Hopefully I'll remember how GitHub shows merges like this in the future.


-------------------------------------
RE: 2 of 3 being far more useful:

So create a clean pull request, unit tests, and test plan for an
"IsStandard" 2-of-3 transaction, either using CHECKMULTISIG or
groffers proposal:

0
OVER 2SWAP CHECKSIG SWAP HASH160 {pk1hash} EQUAL BOOLAND ADD
OVER 2SWAP CHECKSIG SWAP HASH160 {pk2hash} EQUAL BOOLAND ADD
OVER 2SWAP CHECKSIG SWAP HASH160 {pk3hash} EQUAL BOOLAND ADD
2 GREATERTHANOREQUAL

The low-level support is relatively easy, reporting these transactions
in listtransactions and figuring out if or how to report them in your
wallet balance is tricky.

I generated and then spent three multisig transactions on testnet:
 http://blockexplorer.com/testnet/block/0000000000cfe382f690777e3b52ea255717122465db6fcfd80efdf2d0080d8b

Code I used to send them is:
 https://github.com/gavinandresen/bitcoin-git/tree/multisig_testing
(that code is NOT intended for mainline bitcoin, I just needed a way
of testing the new transactions).

-- 
--
Gavin Andresen


-------------------------------------


Incorporating NTP seems overkill. Most OSes come with NTP support integrated
these days (even XP did?), there is no excuse to not be running it,
especially on a server.

If you want to

Requiring it for miners sounds very reasonable.

JS
-------------------------------------
On Monday, September 26, 2011 5:38:41 PM Gavin Andresen wrote:

It's not future. It's presently allowed in blocks. Which means it's perfectly 
valid to relay (and also perfectly value to NOT relay or accept). Ergo, 
shouldn't be punished.


Um, no? It implies you have 99 blocks since the coinbase, and he has 100 and 
wants to spend. In this scenario, it's proper to reject his transaction *until 
you have the next block*, but it doesn't make sense to punish for it.



-------------------------------------
On Wed, Jul 27, 2011 at 11:14 AM, Joel Joonatan Kaartinen <
joel.kaartinen@gmail.com> wrote:


Good idea. I'm not sure if the github bug tracker supports extension
attributes, but it'd be a great place to add it. Also, people can let know
that they're already working on a feature using a comment, to prevent double
work.

The biggest problem will be organizational, in getting the BTC together for
bounties; only a high profile member such as Gavin will have enough trust to
ask for support. Or maybe there's something left in the faucet? :-)

Unrelated: what also might help is publishing a roadmap. Plan a few "bug fix
only" releases before scheduling addition of new features. It's also helpful
for people that wonder that direction the project is going in...

JS
-------------------------------------
Win32, Linux and source releases (MacOSX soon) for bitcoin v0.3.23
have been uploaded to
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.23/

This is another quick bugfix release, trying to deal with the influx
of new bitcoin users.

Priority for next version:  wallet encryption

Main items of note:

    * P2P connect-to-node logic changed to reduce timeout a bit.  The
network saw a huge influx of new users, who do not permit incoming
connections.  This change is a short-term hack, to more quickly hunt
for useful P2P connections.  Better "leaf node" logic is in the works,
but this should let us limp along until then.
    * Transaction fee reduced to 0.0005 for new transactions (see note below)
    * Client will relay transactions with fees as low as 0.0001 BTC
(see note below)


NOTE:  There has been some fee confusion recently.  Free transactions
are supported and relayed as they always have been, according to
special anti-spam rules.  See
https://en.bitcoin.it/wiki/Transaction_fees for details.

Full git changelog:

Dean Lee (1):
      Updated Chinese Simp translation

Doug Huff (3):
      Fix rfc1918 and rfc3927 compliance for ignoring non-internet-routable host
      Add common temp files to .gitignore.
      Demystify a few magic numbers.

Han Lin Yap (2):
      Added Swedish translation
      Remove unused variable

Jeff Garzik (4):
      Bump version to 0.3.23.
      Reduce minimum TX fee for new transactions, to 0.0005.
      Lower minimum relay TX fee to 0.0001 (from 0.0005) BTC.
      Add minimal release process docs.

Matt Corallo (1):
      Fix CPU Usage bug when using -nolisten and have no connections.

Nils Schneider (1):
      create keypool in LoadWallet()

Pieter Wuille (3):
      Update transactions already in the wallet when rescanning.
      Fix for small change outputs
      Faster timeout when connecting

There were no changes between -rc1 and -final.  Wanted to get this out
ASAP, and move on to wallet crypto.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
But the protocol must have a deterministic way to determine if a block
must be accepted or rejected.
I don't know what NTP is, but if you can have a perfect distributed
clock your proposal may work.

2011/11/23, Andy Parkins <andyparkins@gmail.com>:


-- 
Jorge Timn


-------------------------------------
Quick update on why there is no final 0.5 release out yet:

Short answer: because I'm really paranoid about bitcoin binary builds,
and the switch to Qt means a change in the way the builds are done.

Long answer:

Linux builds should be all set; the 'gitian' trusted build process works nicely.

Windows builds are being difficult; we need a gcc expert to help debug
the 'gitian' cross-compile (see
https://github.com/bitcoin/bitcoin/pull/587 ).

Unless somebody steps forward and says "I'll support compiling
bitcoin-qt/bitcoind with Visual Studio) I'm going to remove
src/makefile.vc and make sure the readmes say that only the mingw
toolchain is supported.

Mac builds were slightly broken for the 0.4 release (they don't run on
OSX 10.5-- you need 10.6 or greater). I'm "recompiling the world" to
hopefully fix that, and hope to have mac binaries available soon (let
me know if you can help test, especially if you have a 32-bit Intel
mac running 10.5).

On my wish list for builds (anybody want to volunteer?):

I think it'd be spiffy to have a .pro file to compile bitcoind;
maintaining N different makefiles is annoying and error-prone.

-- 
--
Gavin Andresen


-------------------------------------
On Sunday, July 10, 2011 6:37:15 PM Michael Offel wrote:

Because it's a good tool for the job? Or you mean the version?
Debian stable: 4.8
Gentoo stable: 4.8
Ubuntu LTS   : 4.8


Boost is pretty much standard C++ nowadays.


Blame your text editor if it can't show long lines sanely. The only problem I 
see with the style itself is the use of spaces instead of tabs.


There are many rewrites in progress, often with much better designs.


Bitcoin is supposed to be an authorityless project. There is no official.


Fix it yourself and submit the changes. If they don't get merged, fork.


-------------------------------------
On Monday, September 26, 2011 5:53 PM, "Luke-Jr" <luke@dashjr.org> wrote:

Yeah, my node has always relayed these transactions. The limit seems
pointless to me, especially when it's per kB: people will just add
more data.

The coinbase maturity DoS limit should not have a chance of immediately
kicking the node, as I believe this could happen normally in rare cases.
Rejecting these transactions is also pretty cheap, AFAIK. A small DoS
score seems reasonable, though.


-------------------------------------
On Sun, Jul 10, 2011 at 6:37 PM, Michael Offel <Michael.Offel@web.de> wrote:

agreed -- contributions welcome



It is a long term goal to move towards 'libbitcoin"


agreed -- contributions welcome


very low priority.


contributions to existing style guide welcome


very low priority



We know the code isn't what people would prefer, but that's what we've
inherited.  Everybody has suggestions, but given limited development
resources we're swamped as is.  (hence all the "contributions welcome"
responses)

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On 2011 August 11 Thursday, Mike Hearn wrote:

That wasn't the part I said he didn't understand.  It was assuming that you 
can just declare that people should work on bug fixes and not features was a 
misunderstanding.  People work on open source (at least at first) to get a 
feature they want.  They aren't just going to show up and cry "command me 
lord".


I don't expect them to; as I said, I'm not after everything I say being 
accepted out of hand, certainly as I haven't even turned up with patches.  And 
you are absolutely correct that that would be worrying if it were so.  What I 
object to is no guidance is offered to get the suggester what they want, a 
"you could have this if you did it like this", or "perhaps if you explained a 
bit more".  It's just "no, your idea is based on your weak understanding of 
bitcoin," perhaps I'm being overly arrogant, but I think I understand it a lot 
more than you presume I do.

I do try not to get emotional about these things; and email is not the best 
medium for conveying level of distress -- I'm certainly not banging on my 
keyboard, close to a heart attack.  My motivation is only that I would like to 
see bitcoin do well, and I do see that the treatment of potential new people, 
while not offensive (nobody says f*ck off), is not encouraging.


Honestly you needn't have bothered.  They've been reviewed to death at this 
point; and I'm not that interested in fighting to get them into a project that 
doesn't want them.  I'll just play with my bricks over in the corner if that's 
okay?  I offered the list as a demonstration that ideas don't get constructive 
help as to how progress can be made on them (i.e. how to make them 
acceptable), they just get rejected.

Anyway; as you've put the time in, I'll do the same and respond.


The service bits just seemed like the "bitcoin way" as the field already 
existed.  Personally I would prefer an additional "capabilities" request with 
a variable number of ASCII strings in it, each indicating a capability, and if 
that's good with all of you -- excellent.


I know you "told me this", but I think you are wrong.  This is an example of 
the problem I'm trying to get across -- I see things differently; but rather 
than try and either fix my misunderstanding or see what I'm trying to achieve, 
it's rejected.

I've already got it well on its way to being implemented is how I know you are 
wrong.  It's perfectly possible to validate backwards because you are 
constructing a coherent chain based on an unvalidated start point.  You then 
request the parent block and either (a) you finally reach the genesis block, 
you have reached a hard-coded valid point and the entire chain is therefore 
instantly validated or (b) you have a new start block, floating but validated 
to be part of the chain, if not absolutely validated.  Further, with some 
checkpoints hard coded you don't even need to reach the genesis block to get a 
validated chain.  The body of a block obviously can't be faked because of the 
Merkle hash.

And finally... who says I care about validation?  Perhaps I plan a situation 
where I implicitly trust the peer I'm talking to (which is exactly what I do 
plan).  "There are more things in heaven and earth, Horatio, than are dreamt 
of in your philosophy".


I was told it had severe privacy implications; and you told me that it would 
be better to wait for some sort of filtering system that was planned, which 
I'd not heard of.  I admit it wasn't exactly clear to me how what you 
described helped with my suggestion.  Your suggestion here is a good 
alternative; but wouldn't it waste bandwidth?  After all a receving node has 
no idea whether I have been connected to another node for 24 hours before I 
connect to it, and hence wouldn't need the list.


Yep.  I can well imagine that when alternative clients start appearing, some 
will have bugs.  It will be very handy to either work around those bugs or 
simply deny version 1.4.17 of "Andy's Sexy Bitcoin Client" from connecting.  
Even just for monitoring network state it's useful.  There is already talk, I 
see, of establishing how much of the network runs each released bitcoin 
version.


The benefit I'm aiming at is to imagine a thin client that has done a fast 
startup and only downloaded the headers.  Then, it has a finite number of 
addresses it's interested in and wants to grab only the relevant bodies from 
the full chain.  Or, fast startup is to grab all the headers, and then slowly 
grab the transactions from the blocks.

The cost is

 if( !bodyOnly )
   sendHeader();
 sendBody();

I can't say I'm that invested in it; but it was another one for the list of 
"well I don't see what use that is" responses.


I do feel free to write any patch I like.  It's such a trivial patch though, 
that I feel certain you are being faceitous, knowing full well that it 
wouldn't be accepted.  I'm trying to look five years in the future.  I'm not 
suggesting it be turned off now -- that's impossible and I'm not an idiot.  
I'm trying to think of what the protocol should be and have a way of moving to 
that.

The patch that is needed then is the one that makes the change gracefully.


The sequence number (and perhaps I've misunderstood) allows me to replace a 
transaction I've already submitted.  I can't replace just one of the inputs, I 
have to replace the whole transaction.  It's therefore the transaction that 
should have the sequence number.  A signed transaction received with a higher 
sequence number should displace a lower one.

I'm happy to accept that I have missed the use of the current sequence numbers 
in contracts.  (To be fair, the wiki says "Transaction version as defined by 
the sender. Intended for "replacement" of transactions when information is 
updated before inclusion into a block.")

Perhaps putting it in TxIn was because no one thought of having 
OP_PUSH_SEQUENCENUMBER as a script operator.


Of the above, only one could be lack of understanding (txIn).

As to not valuing backward compatibility -- I certainly do.  That shouldn't be 
used as an excuse to freeze the protocol forever.  There are version fields in 
there, sensibly so; they should be used to fix problems.   As I said a few 
times, the incompatible changes don't have to activate straight away, they can 
be delayed using the block number.  Make it a block number four years away if 
you want, but the sooner those changes go in (whatever they may be), the more 
likely it is you'll get the majority of the network to change over.  And once 
the alternative clients start appearing, the opportunity is gone -- if it's 
hard to get one client to change, imagine how hard it will be to change five.

As I said above though, I don't want these fights.  I know full well that what 
I want is not what you all want as far as client ideas go.  I only started 
this response because I thought Gavin's "we don't want new developers for new 
features, we want bug fixes" was a bit of a foolish thing to say.




Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Eligius, I have two bitcoinds running on the same system:
- a hub node, which is dedicated to relaying network activity between the
  hundreds of nodes Eligius peers with
- a work node, which is dedicated to managing mining, and only ever connects
  to the hub node

Lately, the hub node has been dying (yet to determine cause; I haven't changed 
anything recently), leaving the work node with no connections. The work node, 
of course, starts responding to getworks with "not connected" messages. 
Strangely enough, the sockets used for these are never cleaned up properly, 
and eventually overflow the system's socket limits.

I am using a very heavily patched 0.3.23, so this bug could be related to one 
of those patches (perhaps the threaded JSON-RPC?), but I felt like I should 
mention it somewhere else just in case before 0.4 final got released. I have 
not tried to reproduce it on an unpatched bitcoind yet, and am extremely busy 
lately so I might not get a chance before you guys finish 0.4.


-------------------------------------
The purpose of creating BIP 0010 now, is to encourage a standard that 
developers /want/ to adopt, from the outset.  Every developer who is 
planning to touch multi-signature transactions, is going to have to 
solve the problem of multi-sig tx exchanges, eventually.  By offering an 
excellent solution before they've started asking the question, there's a 
good chance people will use it.   Hear me out...

Protocols get fragmented when there's multiple competing ways to do 
something, each having some advantages the others don't have.  This 
leads to developers with differing priorities picking different ones, or 
creating their own.   However, I believe that the problem BIP 0010 seeks 
to solve is a fairly straightforward problem.  There's not a lot of 
variety in the solutions that could compete against it.  People just 
need a way to pass this data around, and they want it to be as 
convenient to use, and as easy to implement as possible.  In that sense, 
I think BIP 0010 (or some future variant) is fairly optimal as a 
building block for higher-level protocols.

If anyone has ideas for why someone would want to create a competing 
idea to BIP 0010 (besides not being aware of it when they start), I'd 
like to discuss it.  I'm fairly confident that any such ideas could just 
be added to BIP 0010 and thus reset the question of why anyone would 
need a competing idea.



On 11/09/2011 03:03 PM, Michael Grnager wrote:

-------------------------------------
On Wed, Jun 15, 2011 at 8:06 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

Looking back I have to agree that binding the protocol to the client version
was in fact good, since it allowed for a fast evolution along with the then
only client. My proposal to split the both may have come too early, but I
personally grew frustrated when implementing my own networking stack. With
the protocol having matured, and changes becoming ever less frequent, I'd be
happy for the split to happen.

I called it Mainline client (like the original Bittorrent client) as a hint
that this is the reference implementation everybody should refer to, but
Satoshi Client has a nice sound too :-)

The version number being incremented each time a breaking change to the
protocol has been made? Mike and I discussed that quite a while back, and
using the String as client specific identifier with a version number (mainly
for statistical purposes) sounds like a good idea, similar to User Agent
strings in HTTP.


Yeah, sorry for that one :-)
I posted the request to the issue tracker before that pull, and I was asked
to submit a pull request with the needed changes, which sounded a bit
strange for a conceptual change like this one. Isn't a gradual switch
possible? I'd leave the version number as is and simply don't increment it,
so if the code does not rely on specific values for pszSubVer it shouldn't
break at all.

So we could consider version 40000 the first "stable" protocol release?
Sounds good.

Always happy to hear you like my idea :D

All in all I'm really looking forward to this.

Regards,
Chris

-------------------------------------
Hey Laszlo,

We're just wanting to make sure that it's ok to include your Info.plist and BitcoinAppIcon.icns into the upstream source repository so that osx build can be automated without needing external source requirements (outside of lib deps).

Is this licensed under MIT or similar or would you be willing to put it in the Public Domain or other compatible license.

-- 
Doug Huff


-------------------------------------
On Fri, Jul 1, 2011 at 12:35 PM,  <jan@uos.de> wrote:
[snip]

I also don't like upnp, but I strongly support it being on because
leaving it off is not really an alternative.

IMO a forum poll is the wrong tool to use to decide if bitcoin keeps
working or not. ;) If the alternative were upnp vs some other way to
reasonably increase the number of listeners... e.g. "upnp always vs
upnp only if there has been no inbound connections in X minutes" that
would be another matter.

The bitcoin/bitcoind difference seems confusing to me, since when
someone complains about connectivity I'll have to remember to ask
which they are using... but enabling it for the gui is probably
sufficient in terms of network health.

But it'll probably happen anyways: I imagine most bitcoind users build
locally and don't bother installing the upnp library. I know I don't.


Yea, listening at all is more interesting than upnp— though almost any
harm that listening can cause can also be caused by outgoing
connections since the protocol is symmetric.

(e.g. if you have an exploit, you don't need to connect to people, you
can just sibyl attack the network and exploit people who connect to
you— not quite as effective but I think enough that UPNP isn't a great
additional risk)

If you want to talk about worrying people about security:  The IRC
connections seriously set off alarm bells, especially when someone
looks and sees something indistinguishable from a botnet in IRC.  It's
been blocked by major ISP multiple times. So, until we get IRC
disabled nothing else is really all that significant from a security
hebe-geebies perspective.

On Fri, Jul 1, 2011 at 1:50 PM, Matt Corallo <bitcoin-list@bluematt.me> wrote:

Well, users who don't like it can still disable listening— which is
healthier for the network right now than leaving listening on but not
actually working.

We can fix the incentive structure somewhat: We should give preference
in the form of preferred forwarding from/to to nodes that we've
connected to vs connected to us, potentially improved relay rules. Not
only does this given an incentives to listen (faster txn processing,
hearing about blocks earlier) but it also would reduce the
effectiveness of some DOS attacks.   Not something for 0.3.24,
however.


-------------------------------------
On Thursday, June 30, 2011 11:23:56 PM Jeff Garzik wrote:

"Native Long Polling Support" should be renamed. Real native long polling 
would be for solo miners.

"A fix from Luke Dash Jr." -- I have a branch with this; I didn't check that 
his version is up to date.

"RPC Turbocharge" -- If this incorporates only my changes for multithreading, 
it breaks JSON-RPC over SSL.



-------------------------------------
It is possible to made changes to the distributed algorithm which make
previously valid txn invalid without necessarily creating any lasting
chain splits.  This has been proposed for the addition of the eval
opcode by using one of the existing NOPs.

One challenge is that if transactions are emitted which are invalid
under the new scheme but valid under the old after the block height
that the rule is coded to take effect and a super-majority of miners
are not yet upgraded the upgrade may cause a long reorganization and
serious disruption.

Here I explain one possible way of avoiding this.

Upgraded nodes get the following rules:
(0) Never forward or mine a txn which would be invalid under the new rule.
(1) Apply old behavior before height X unconditionally.
    (X set far enough in the future to get reasonable deployment by
large miners)
(2) Begin applying the new rule only after the first point in the chain
    after X when none of the last Y blocks have contained an invalid transaction
    under the new rules.

After the software has been released members of the bitcoin community then
begin _intentionally_ transmitting transactions which are invalid under
the new rules. (What would have been an attack under simplest deployment plan)

By setting Y high enough that all major miners have a chance to mine
in the window,
this actually becomes an effective vote for the change by miners with
a stochastic
super-majority threshold.  All nodes are able to exactly determine at what block
the election has completed because it is an objective fact of the chain.

With this scheme the new encoding will only become active when enough mining
capacity supports it (or at least helpfully refuses to mine the who class
of transactions) so that a large reorganization will not happen due to
incompatible blocks during deployment.

This could be further enhanced with conflicting block discouragement (e.g.
refusing to extend or forward a rules violating block until it is burred)
but I think this scheme is sufficient without that, and that this is generally
superior to discouragement for this purpose.

Cheers.


-------------------------------------
Its cool, with both cryptography and bitcoin, its also an internet first.
Here's the idea: file's that go away and then come back later.
Realistically, the first version of this project needs to be files
that get encrypted, but can't be decrypted until a particular future
date - time-released cryptography.

Here's the simple demonstration of the concept, which is known to be
inadequate, but it demonstrates the time-released cryptography
concept.  The true proposed solution is a P2P architecture shown
later, but first this simple model demonstrates the idea.  Cryptoclock
provides a list of unique public keys on a calendar, one for each day
out into the future.  Each day the hosting site releases the
associated private key for the current day, allowing all files
encrypted with the associated public key to be decrypted.  In effect,
files would be popping open each day when the key of the day is
released.  Maybe wikileaks documents pop open, or stashed bitcoin keys
so the stashed money can be retrieved.

Simple Public Cryptoclock Model:

1) Choose the public key for Jan 12, 2012
2) Encrypt your file with that public key
3) Erase your clear copy of file

At this point the file is locked up and nobody can get at it.  If
people ask for the data, you can't get it.  Ideally nobody can.  Its
not available.

4) Wait until Jan, 12, 2012
5) Get the key of the day from the cryptoclock - maybe it goes out via twitter
6) Unlock your file - now you've got your data back

There are problems with this, that can be discussed separately, but
its known to be inadequate. At a minimum, its not cool that the
private key is delivered to the world, because the file should not pop
open to everybody who has a copy - just for the owner.  Also, the
hosting site has a bad problem with securing the private keys, and
actually must be able to deny having them at all, in order to be free
of persecution and to be trusted.  The keys must be gone - they must
be unavailable, not just on some USB stick in a box.

P2P Solution:

First stab at a general solution.  This solves two problems, the
secret key will return automatically to the file owner, and the secret
key will truly be unavailable.

* Key Sharding

Assume P2P network of special cryptoclock nodes built on bitcoind, and
the transactions have to be of the contract variety, to eliminate the
risk of distributing the key.  Shards will NOT be put on the block
chain but will be distributed via http.  Shard holders will be
compensated for holding the shards when the key is rebuilt.

1) User1 has a file to hide.  User1 puts it into node1 of the cryptoclock.
2) Node1 produces a public/private keypair (pb1, pv1)
3) Node1 encrypts the file with public key 1 (pb1) and wipes out the clear file
4) Node1 shards private key1 (pk1)
5) Node1 encrypts and distributes the shards to the P2P network as follows
5.1) Node1 sends a small bitcoin deposit txn to Node2 with a URL
message in the script and a random number (rn1)
5.2) Node2 issues a GET to the URL with the signed rn1 to node1
5.4) Node1 receives the GET and verifies the signature on rn1 and
returns the shard and a 200 to node2

This mechanism will distribute the private key in pieces to any number
of nodes, known only by their bitcoin addresses.  Repeat this for each
shard of the private key.  The number of shards and copies is
proportional to the security of the storage - the more you pay, the
more scattered is the key.  There should be many shards, and each
shard should have many copies.

The transaction will have have to go from node1 to node2, triggering
the retrieval GET, and it must be done in a deposit style so if the
node is not available the bc will be returned as in the case of the
Deposit example on the Contracts wiki page.

* Rebuilding the key

A future-dated transaction needs to be created to get the keys to
return to the key creator on the target date, and they must be crafted
in such a way that the shard-holders are paid at the time the keyshard
is reclaimed, producing an incentive to stay online and keep the
keyshards in the network.

The general model (bitcoin txn and http request) will also make the
key return and reassemble itself in the owners cryptoclock client on
the future date, if the future transactions are triggered reliably. A
future transaction must be made right at the start, with a locktime
set to the target date.  On the target date the shard holder's
client's transaction script is executed, which will trigger node2 to
take action on the initial deposit transaction.  Node2 will have to
notify node1 that its ready for a GET, and node1 will issue a GET to
reclaim the keyshard.   Another small deposit-style transaction to
node 1 will do this perfectly, in the same style as the first deposit
transaction.

* Cool Features

 1) Participants are paid to participate and its a natural fit - its built-in.
 2) The key returns automatically the file owner on the desired date
- it reassembles itself.
 3) Pay more for more surety - more shards for more money.

* Peer Discovery

I think keys should be distributed to bitcoin addresses, which in
general are not available to the nodes, so peer discovery needs to be
fleshed out.

This needs to be fleshed out considerably.  A peer discovery mechanism
must be produced.  Bitcoin addresses could be pulled from the block
chain, or there can be an irc channel for address discovery, or users
could establish their own trusted network of associates.

* Block Chain Usage

This model uses bitcoin in a legitimate way, using real bitcoin
transactions and putting the bitcoin engine to work and leveraging its
financial engine to establish a reasonable expense/reward system.  The
block chain has only one extra, short message for the  initial
transaction.  All application data is transacted outside the block
chain and stored outside the block chain.


-------------------------------------
Maybe I'm retarded, but where's the point in providing alliases containing
yet another hash in URL?

slush

On Sun, Dec 18, 2011 at 10:44 PM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
Hello devs,

For UI purposes I'd like to be able to associate metadata to transactions
and address book records.

To be clear, this is completely client-side and will never see the block
chain.

For transactions:

-   std::string description; // A description that the user can give to a
transaction, after he sent/received it, for example "ordered eggs"

For addresses:

-   bool visibleInInterface; // Visible in interface; useful to hide old
addresses/labels from the lists, without removing them for lookup purposes

These are my current ideas; probably, more metadata can be useful later on
(accounting category, links to 3rd party services, etc), so an extensible
system would be nice.

Any ideas as to what would be the best place to put this, while minimizing
the core changes?

I'm aware that this could also be implemented completely inside the UI code,
but I'm not sure this is nice, as it would put database handling etc there
and would mean even more data files for the user to backup/track.

JS
-------------------------------------
FYI for anybody who doesn't hang out in IRC:

I've been busy pulling patches into git HEAD for a Bitcoin version
0.6, with the goal of having a Release Candidate 1 out in a couple of
weeks.

So if you've done all your Christmas shopping and have time to help
test, code review, etc. now would be the time.

-- 
--
Gavin Andresen


-------------------------------------
On Wed, Aug 24, 2011 at 11:12:10AM -0400, Gavin Andresen wrote:

What was the reason for disabling these opcodes in the first place? I can
understand wanting to prevent excessive signature-verification, or limitation
of arithmetic to a limited amount of bits, but completely disabling all
arithmetic beyond addition and subtraction, and all bitwise operations seems
very limiting to me. Thus, if we agree to do a future incompatible update,
i would vote to re-enable these, and maybe allow arithmetic up to 520 or
1024 bits numbers.

While we're at it, some additional opcodes could be useful. Either a custom
operator to do boolean evaluation, or a few more lowlevel operations. Given
the presence of bitwise operators, you could have scripts that process a
sequence of pubkey/signature pairs, build up a number in which each bit
corresponds to a valid signature, and then do some bitwise checks on this
number. I'd argue that a "count number of bits set in number" opcode would
be very useful for this.

In short: I'm in favor of re-enabling opcodes, and possibly adding an
OP_BITCOUNT operation.

-- 
Pieter


-------------------------------------
Hi !

I am looking into enabling a split between thin clients holding the wallet and server(s) holding the blocks and txdb.

To that end I am considering to simplify the WalletTx a bit and I came across the vtxPrev in the code. As I see it vtxPrev is only used for keeping a list of supporting transactions to enable resubmit of these in case the transaction it self and all its supporting transactions are lost due to some blocks becoming invalid as they are part of a dead-end part of the chain. However...

The vtxPrev stores 3 transactions back, but as transactions need 7 block to maturity and respendability isn't it overkill - I mean it is highly unlikely that a transaction gets invalid after 7 confirmations and the vtxPrev are guarding against resubmission of transaction more than 21 confirmations back. Further, we cannot guarantee that the transaction owner is online at the time and the money could have been re-spent for others anyway.

So bottom line:
Do we need the vtxPrev at all ? Or did I miss out something ?

Cheers,

Michael




-------------------------------------
On Jul 16, 2011, at 6:35 PM, Jeff Garzik wrote:


I say just kill the forum.bitcoin.org DNS entry along with it.

-- 
Douglas Huff


-------------------------------------
On Wednesday, December 14, 2011 2:22:12 PM D.H. wrote:

That's not a valid URI.


-------------------------------------
New 'standard' transaction forms would be perfect candidates for BEPS.

I think we aught to have a formal proposal to separate the protocol
version from the client version, too.

--

Does anybody besides me think maybe we should name them something
other than "BEP" ?

I'm worried we'll regret it in two years when a google for "BEP003"
takes you to the BitTorrent EPs instead of the BitCoin EPs.

Maybe "BIP" == Bitcoin Improvement Proposal
or "PEB" == Proposal to Enhance Bitcoin
or "BER" == Bitcoin Enhancement Request

I think I like "BIP"  (PEB sounds like a diet soda, and I don't know
if BER should be pronounced "bear" or "beer").

I generally don't care about names, but it seems like a little
planning now might save some confusion later. And I don't want the
BitTorrent folks to get pissed off at us for 'stealing' their acronym,
either.


-- 
--
Gavin Andresen


-------------------------------------
On Fri, Jul 01, 2011 at 11:06:56AM -0400, Gavin Andresen wrote:

I just voted as well and now - with some extra votes in the meantime -
it's 9 / 22 / 13. So exactly 50/50 between off (22) and some form of on
(9 + 13).

I'm in favor of turning it on by default in the GUI and leaving it off
in bitcoind.

I don't like UPnP much, I find it exemplifies exactly what is wrong with
computer security today: Convenience trumps security almost every time.

BUT: I don't think this is the moment to fight UPnP. It's the standard
mechanism in use today to let a computer behind a NAT accept incoming
connections. The user has already made the decision in regards to
convenience over security. By enabling UPnP (or by buying a product that
does this automatically) they are saying: I want it to "just work"
instead of having fine-grained but more complicated control.

Bitcoin is a P2P application and as such should use this
mechanism. I think it's pretty clear that participating in a P2P network
requires one to receive messages from other peers. At least no one seems
to be concerned that Bitcoin (by default!) listens on port 8333. So I
think it's only logical to extend that to work behind NATs as well.

Cheers!
Jan


-------------------------------------
I was looking at the wiki entry for this and noticed that your
description of DNSSEC is incorrect. It is an internet standard and is
widely deployed in the root (.), many TLDs, ccTLDs and second leverl
domains.

Also understand when the IETF or ICANN adopts new (we worked on DNSSEC
no less than 10 years) standard the horizon is at least 20 years.
Nothing and I really mean nothing is adopted in mass over shorter time
scales.

I also am largely in favor of using secured zones to publish TXT
records to digital currencies. I've been thinking mainly about TXT
using the following format for bitcoin.

_btc.<lhs>.<rhs>

you can look up the following record _btc.rick.wesson.us (from
rick@wesson.us) which yealds

; <<>> DiG 9.6-ESV-R4-P3 <<>> _btc.rick.wesson.us txt
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 45136
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;_btc.rick.wesson.us.           IN      TXT

;; ANSWER SECTION:
_btc.rick.wesson.us.    299     IN      TXT     "BTC=1\;
1GCVXLfF1TcpnnDLJRHk845NZhuJWQTnUD"

;; Query time: 147 msec


while this isn't a secured zone, any leverage of DNSSEC would require
the application to have direct hooks into the stub-resolver, rather
than just leveraging the OS's implementation.

just some food for thought...

-rick



2011/12/14 Jorge Timn <timon.elviejo@gmail.com>:


-------------------------------------
Namecoin is a peer-to-peer generic name/value datastore system.
Don't forget it's not limited to .bit usage ! So, directly mapping
things to .bit url would not be the optimal way of using namecoin.

Namecoin is specificaly designed to map things to names in a fully
decentralized way. So, it's the perfect starting point to map names to
other things (a public bitcoin address, an url, etc)
You won't have all the advantages of namecoin when using other systems
like DNS and HTTP(S) as the first entry point.

What is namecoin ?

* proven technology :
- do not mix the namecoin technology and the dot-bit namespace with .bit
domains (dot-bit domains needs dot-bit compatible dns servers or proxies
+ namecoin and have a small visibility due to the nature of
top-to-bottom domain name system controlled by ICANN, namecoin needs
only namecoin to store data !)
- as proven and secure as bitcoin
- merged mining provides a secure network

* decentralized :
- a lot of nodes, and you can have your own node
- everybody can register his own name, by itself with the namecoin
software (bitcoin could even allow registration directly from it,
easily) or by using a name provider
- everybody can become a name provider (register for your friends and
resell names).

* no single point of failure :
- DNS and HTTPS have several limitations (Man in the Middle attacks, no
reliable authority of certifications, domain seizure, ...)

* designed for that :
- namecoin uses a system of namespaces to separate each usages :
http://dot-bit.org/Main_Page#Namespaces.
For example, the "personal namespace" draft
(http://dot-bit.org/Personal_Namespace) could be extended to support
mapping to a bitcoin address, or a dedicated namespace can be used if
prefered (the "bitcoin/" or "alias/" or "map/" prefixes for example).

* easily connectable to bitcoin
- they both use RPC and json to exchange informations, so connecting one
to the other is really easy
- bitcoin could even allow registration of names by sending an RPC
request to namecoin

* extensible and not limited :
- you are not forced to store a bitcoin address directly in namecoin,
you can also store an url or a domain name
- allows additional security : add a certificate fingerprint combined
with an https url (so, using DNS or HTTP(S) is not a major problem
anymore if the first point of entry is really secure and configurable
[and you use and self-signed certificate])
- really easy to update
- simple for simple cases
- possibility to use a nick, an email address or a domain as name
- other methods to get bitcoins addresses can be added later, protocol
is extensible


Examples of possible registered names in namecoin with the "personal
namespace" (with the "p/" prefix) :

* An individual person with well known public addresses :
"p/khal":
{
    "email": "khal@dot-bit.org",
    "bitcoin": "1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T",
    "namecoin": "N1KHAL5C1CRzy58NdJwp1tbLze3XrkFxx9"
}

* Another individual person with well known public addresses :
"p/khal@dot-bit.org":
{
    "bitcoin": "1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T",
    "namecoin": "N1KHAL5C1CRzy58NdJwp1tbLze3XrkFxx9"
}

* A merchant accepting payments in bitcoin, namecoin, paypal or
othercoin (to show you how the whole namespace could be used) :
"p/mymerchant.com":
{
    "bitcoin": {
        "url": "https://payto.mymerchant.com/bitcoin/",
        "fpr": "54FFA829023FC4DEF26B9339E07F7A743DF9F926"
        "cert": "https://payto.mymerchant.com/certificate.pem",
    },
    "namecoin": {
        "url": "https://payto.mymerchant.com/namecoin/",
        "fpr": "54FFA829023FC4DEF26B9339E07F7A743DF9F926"
    },
    "paypal": "xxxxxx@yyyyyyyyy.zzz",
    "othercoin": "oxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
}

* A merchant with a public address, an url to generate custom addresses
and a domain name (not sure if this case is really usefull, maybe as
fallback)
"p/mymerchant2":
{
    "bitcoin": {
        "url": "https://payto.mymerchant.com/bitcoin/",
        "fpr": "54FFA829023FC4DEF26B9339E07F7A743DF9F926",
        "dns": "_bitcoin.payto.mymerchant.com",
        "address": "1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T",
    }
}


* How to use it in bitcoin ?

Several possibilities of address syntax :
- khal, khal@dot-bit.org, mymerchant.com, mymerchant2 : no syntax limit
- mymerchant2@bitcoin : will conflict with names already containing a @
- mymerchant2@namecoin : same
- namecoin:mymerchant2 : strange syntax, confusing with the "uri scheme"
- namecoin://mymerchant2 : same
- other ?


Here is how things would be processed when people put an address to pay
to in the bitcoin client :

* address : khal
-> RPC to namecoin for "p/khal"
-> json processing for "p/khal->bitcoin"
-> result : 1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T

* address : khal@dot-bit.org
-> RPC to namecoin for "p/khal@dot-bit.org"
-> json processing for "p/khal@dot-bit.org->bitcoin"
-> result : 1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T

* address : mymerchant.com
-> RPC to namecoin for "p/mymerchant.com"
-> json processing for "p/mymerchant.com->bitcoin"
-> json processing for "p/mymerchant.com->bitcoin->url" and
"p/mymerchant.com->bitcoin->fpr"
-> https request to "https://payto.mymerchant.com/bitcoin/"
-> result : 1xyxyxyxyxyxyxyxyxyxyxyxyxyxy

* address : mymerchant2
-> RPC to namecoin for "p/mymerchant2"
-> json processing for "p/mymerchant2->bitcoin"
-> json processing for "p/mymerchant2->bitcoin->url" and
"p/mymerchant2->bitcoin->fpr"
-> https request to "https://payto.mymerchant.com/bitcoin/"
-> result : error (website unavailable, page not found, timeout, etc)
-> json processing for "p/mymerchant2->bitcoin->dns"
-> dns request for "_bitcoin.payto.mymerchant.com"
-> result : 1xyxyxyxyxyxyxyxyxyxyxyxyxyxy

Le 13/12/2011 14:06, Gavin Andresen a crit :


-- 
Best Regards,
Khalahan
http://dot-bit.org/



-------------------------------------
In CWallet::CreateTransaction there is a call to 'GetSerializeSize' on
line 979 (https://github.com/bitcoin/bitcoin/blob/master/src/wallet.cpp#L979).
It looks like:

---------8<----------
unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK)
if (nBytes >= MAX_BLOCK_SIZE_GEN/5)
  return false;
dPriority /= nBytes;
---------8<----------

'wtxNew' is a CWalletTxn. So this gets the serialized size of the
transaction, including all the extra data held in the wallet for that
transaction, and uses that size for computation of priority. Is that
correct? Should it be only the size of the CTransaction* part of the
transaction that should be used?

It looks this was from the casting shenanigans but unless I'm
mistaken, that casting doesn't actually do anything. We get a pointer
to a CTransaction but then dereference it, so the template function
'GetSerializeSize' would get the most derived class, right?

So was the intent to use the CWalletTxn size, and the casting is
superfluous, or was it supposed to be the CTransaction* portion and
the cast is an incorrect way of doing that? Or am I suffering from
late night programmer syndrome and reading it wrong?

Chris.
-- 
http://www.bluishcoder.co.nz


-------------------------------------


Begin forwarded message:


-- 
Doug Huff


-------------------------------------
On Mon, 2011-07-25 at 20:35 -0700, Rick Wesson wrote:

Yes, DNSSEC is great if you are running your own recursive name server.
However, that is probably something like 0.01% of the people out there.
If this were to be made secure, one would have to implement a full
recursive nameserver inside of Bitcoin with the root trust anchors
hardcoded in.  This seems like way overkill to do name->address mapping.
(My attack scenario here is coffee shop wifi with the default DNS
resolvers being somewhere at the ISP and a ARP (or other) MITM attack
intercepting and playing with your DNS queries).
Additionally, HTTPS mapping offers some advantages such as ease of
offering up different to different people by eg. IP address (could be
done by setting DNS TTL to 0 and assuming all users will be using a
built-in resolver, but its still not guaranteed that other clients would
use a built-in resolver and then the IP of the resolver is not the same
as the IP of the Bitcoin node).  
Not that DNS is a terrible idea, but there are clear advantages for
using HTTPS (or similar) mapping over DNS and I see no clear advantage
for using DNS over HTTPS (aside from the "that is what it is designed
for" argument, which I would claim is an invalid argument as you have to
consider the technology, not its intent).
Hold on there, Bitcoin is still tiny, I highly, highly doubt it will
make a difference to DNSSEC adoption.

-------------------------------------
Couldn't your net testing code be modified to do that to some extent?

Gavin Andresen <gavinandresen@gmail.com> wrote:




-------------------------------------
Hahaha you mean like unitialised variables, inheriting from containers with non-virtual dtors (CScript) and delicious copy pasta coding (PushMessage, bignum and serialize stuff).


No need to worry about that :)



________________________________
From: John Smith <witchspace81@gmail.com>
To: theymos <theymos@mm.st>
Cc: bitcoin-development@lists.sourceforge.net
Sent: Monday, October 24, 2011 6:02 AM
Subject: Re: [Bitcoin-development] Fwd: bitcoin scope issue in main.cpp



Yes, I know that. It compiles.

If we pulled all the 'This is legal in C++' tricks in the bitcoin source it would be even less maintainable and readable than now. But whatever...

JS


On Sun, Oct 23, 2011 at 10:51 PM, theymos <theymos@mm.st> wrote:

It's legal for a scope to define variables with names that conflict with

------------------------------------------------------------------------------
The demand for IT networking professionals continues to grow, and the
demand for specialized networking skills is growing even more rapidly.
Take a complimentary Learning@Cisco Self-Assessment and learn 
about Cisco certifications, training, and career opportunities. 
http://p.sf.net/sfu/cisco-dev2dev
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
Pull 349 (https://github.com/bitcoin/bitcoin/pull/349)
implements a pretty nice implementation of multiple signature escrowed
transactions. Especially with clearcoin gone I think that this is
something we ought to have sooner rather than later.

I've tested it on a private network and it appears to work pretty well.

It probably needs more testing and discussion before it is actually
added to the client, but one challenge is that because it requires a
new transaction type it won't be deployable until _after_ an updated
isStandard is widely used in the network.

So I think that makes a good argument for separating out the
IsStandard part of the patch and getting it out in 0.4.

Unfortunately, the patch exposes an issue with multisig validation: If
I understand it correctly, the problem is that due to redundancy in
 the script length coding opcodes it's possible to code a script
multiple ways. The signature validation code creates new template
scripts in order to evaluate signatures for one output, and the code
in bitcoin is not careful to code the new script the same way the
original one was coded, causing the signature validation to fail when
something used OP_PUSHDATA when a direct length could have been used.

Pull 349 (https://github.com/bitcoin/bitcoin/pull/349) contains one
candidate fix for this: Excluding the length opcodes from the
comparison.

This fix carries a risk of creating differences in how nodes validate
transactions leading to lasting forks. (e.g. Old clients will reject a
block which new clients would have accepted).  I do also wonder about
strange effects arising from multiple valid TXN which are identical in
meaning but have different hashes, but I guess thats already possible
in a number of different ways.

Another way of fixing this would be to just define that OP_PUSHDATA*
_cannot_ be used to push the smaller lengths which could be more
efficiently encoded with the direct length opcodes.  I think this
would have the benefit of being consistent with the current behavior
and carry no severe split risk.

Yet way of fixing it would be to change out the templating code works
to make sure it codes the template the same way the original was
coded. This seems tricky to implement to me, tricky to validate, but
it would potentially be beneficial if this same class of problem
exists for things other than the length coding.


-------------------------------------
Namecoin makes sense; as we can use the same private keys to spend the
namecoin as spending the bitcoins.

Namecoin happens to be the only secure guaranteed global unique human
rememberable string system that exists.

I suggest that sending bitcoins to a namecoin name is the way to go...
It makes even more sense since namecoin started merged mining.

On 13 December 2011 08:03, Cameron Garnham <da2ce7@gmail.com> wrote:




-- 
Cameron Garnham:
email: da2ce7@gmail.com
website: http://da2ce7.blogspot.com
telephone: +61405227831
-------------------------------------
I put the status for BIP 0001 to active now. Let me know if there's any disagreements with this. I'm on Freenode under the nickname genjix
-------------------------------------
On Tue, 2011-07-26 at 09:50 -0700, Rick Wesson wrote:
That is one point, but yes.
Because it allows for the giving of different addresses to each client
based on IP much easier.  Its possible with DNS by setting TTL to 0 and
hoping that Bitcoin clients will be using their own resolver, but that
is far from guaranteed.  Additionally, HTTPS stuff has already been
coded and implemented, so there's that...

Frankly, HTTPS' advantages are very small here, but since they exist,
and DNS has no advantages that I can see, I don't see any reason to go
with DNS here.  I much prefer using a HTTPS library (of which there are
many which have had much more thorough security audits) than a
DNSSEC-implementing DNS recursion library with the root trust anchors
and root servers built-in (are there any?).

Maybe I'm missing something here?

Matt
-------------------------------------
Win32, Linux and source releases for bitcoin v0.3.23rc1 have been uploaded to
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.23/test/

This is another quick bugfix release, trying to deal with the influx
of new bitcoin users.

Main items of note:

* P2P connect-to-node logic changed to reduce timeout a bit.  The
network saw a huge influx of new users, who do not permit incoming
connections.  This change is a short-term hack, to more quickly hunt
for useful P2P connections.  Better "leaf node" logic is in the works,
but this should let us limp along until then.
* Transaction fee reduced to 0.0005 for new transactions (NOTE: free
transactions are, of course, still supported as they always were)
* Client will relay transactions with fees as low as 0.0001 BTC

Full git changelog:

Dean Lee (1):
      Updated Chinese Simp translation

Doug Huff (3):
      Fix rfc1918 and rfc3927 compliance for ignoring non-internet-routable host
      Add common temp files to .gitignore.
      Demystify a few magic numbers.

Han Lin Yap (2):
      Added Swedish translation
      Remove unused variable

Jeff Garzik (4):
      Bump version to 0.3.23.
      Reduce minimum TX fee for new transactions, to 0.0005.
      Lower minimum relay TX fee to 0.0001 (from 0.0005) BTC.
      Add minimal release process docs.

Matt Corallo (1):
      Fix CPU Usage bug when using -nolisten and have no connections.

Nils Schneider (1):
      create keypool in LoadWallet()

Pieter Wuille (3):
      Update transactions already in the wallet when rescanning.
      Fix for small change outputs
      Faster timeout when connecting


-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I believe it is also worth mentioning the possible susceptibility of a 
DOS attack on a publicly available alias system. Assuming that an alias 
lookup triggers the creation of a new Bitcoin address, the private key 
would need to be retained indefinitely. If gone unnoticed, this could 
consume considerable resources over time. Unlike system logs and such, 
this is not something that can be so easily pruned.


-------------------------------------

*cough* Upgrade alerts.


I don't know if he'll actually do anything. Best assume this
"position" is still open.


I've seen locks that track ordering relative to other locks and assert
when they are locked out of order.

Though it's not inversion related, running ThreadSanitizer might help
find other thread safety issues:

http://code.google.com/p/data-race-test/wiki/ThreadSanitizer


-------------------------------------
Hum, it sounds like there was some misunderstanding, on my part at
least.  On IRC, people are talking about a cherry-picked release,
basically 0.3.23 + a couple specific fixes, rather than what is
current in upstream git.  I had assumed people meant releasing current
git + some specific fixes not yet in git.

Wearing the Release Mangler hat, cherry-picked branches have a few
disadvantages:

* you're throwing away the testing people have done on upstream git
* the new branch would have zero testing, as most people have been
testing 0.3.23 or upstream git
* it would be a dead-end branch, never touched after release.  bug
reports for such a release might not necessarily be applicable to last
version or current upstream or anywhere in between.

That is the convention wisdom, anyway.  But to paraphrase Pirates of
the Caribbean, release management rules aren't really rules, they're
more like... guidelines.  :)

The cherry-picked 0.3.24 release, according to IRC wisdom, wouldn't
have to worry about shipping CWallet, which needs a fix or two from
https://github.com/bitcoin/bitcoin/pull/358

I can live with, and roll a release for, either (a) 0.3.23 + select
fixes or (b) current upstream + pull #358.  My preference is (b), but
this is a community and Holy Alpaca decision, not just a call I will
make on my own.

Comments welcome...

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------

There's no way to obtain the memory pools of your peers today, so if
you're newly started up it can happen that you get blocks with unseen
transactions.

For vectors variant, I wonder if it'd be safe to report the number of
confirmations differently for the duration of a chain split. If you
have a block but a majority of peers relayed a block that split the
chain, subtract 1 from each confirmation reported via RPC.


-------------------------------------

How about releasing it on testnet first? If you want "less smart" people 
such as myself to help test, well I don't think I would get anywhere if 
I tried to abstractly reason about every possibility. Low-level testing 
is certainly important, but for me "thorough testing" requires an actual 
network of nodes (running different clients) and applications capable of 
creating and verifying real OP_EVAL transactions.

My suggestion would be: Deploy OP_EVAL on testnet quickly, let's build 
some real-life applications and if it works well, /then /let's pull the 
trigger for mainnet. If some issues or improvements arise, we'll have a 
chance to adjust it and try again.

I don't think this is too conservative or paranoid. I think this is a 
textbook use case for testnet.


On 12/29/2011 7:00 PM, Gavin Andresen wrote:

-------------------------------------
Sorry this took so long, I got distracted...
Anyway 0.3.24 RC1 builds available at
http://dl.dropbox.com/u/29653426/Bitcoin%200.3.24%20RC1.tar.bz2
SHA1:
bb829e037aef86c5d9da384c0ff3c91ce8b11d5a  Bitcoin 0.3.24 RC1.tar.bz2

Builds gitian signed and email signed as always.

Notes:
Couple things need fixed up before release wrt build engineering:
http://forum.bitcoin.org/index.php?topic=24841.0 (still haven't had a
chance to dig up a copy of Win98 and spin up a VM to test any results of
this one).
Build on Ubuntu 8.04 instead of 10.04 so that oder libcs can work (and
do thorough testing of that resulting binary on newer libcs specifically
openSUSE 11.04, see http://forum.bitcoin.org/index.php?topic=21767.0 )

Sorry to hold up release on this crap that is still unfixed after
0.3.21...

Matt


On Sat, 2011-07-02 at 17:07 -0400, Jeff Garzik wrote:

-------------------------------------
On Aug 22, 2011 2:26 PM, "Fred Concklin" <fconcklin@trucoin.com> wrote:

What? It already works fine in this regard using standard tools. Especially
easy with daemontools/runit.
-------------------------------------
[also sent to bitcoin-development@]

I'm pleased to announce BitCoinJ v0.2. There have been over 100 commits
since the first release back in March, which have added:

   - Full support for block chain re-orgs, including recognition of dead
   transactions (that will never be included in the chain).
   - Persistence of the block chain using multiple, pluggable stores. A
   BoundedOverheadBlockStore is provided that is suitable for usage on mobile
   devices where low memory usage and instant startup time are requirements.
   - A much larger test suite
   - IRC, DNS  and seed list peer discovery
   - ASN.1 key export
   - Many many bugfixes and minor API improvements.

This release represents the work of many people. In particular I'd like to
thank:

   - Andreas Schildbach
   - Miron Cuperman
   - Gary Rowe
   - Thilo Planz
   - Micheal Swiggs
   - Noa Resare
   - John Sample
   - Xiaofeng Guo

-- 
Google Switzerland GmbH
-------------------------------------
Agree, but even before that, we will meet problems of the current 1MB/10min limit.

The calculations from the scalability link surely indicates that there are 2 options for scalability either go for trusted supernodes backed by huge hardware resources or something else would be needed. The supernode approach is simple and easy to implement, but it also breaks a lot of the nice features about bitcoin. So if we want bitcoin to stay p2p we need to deploy other strategies. The hash space partitioning is one of them. And the nice thing is that it can be made to scale even for a javascript based validating and fully connected client running on a smartphone in a bitcoin future with billions of clients and transactions, and still it does not exclude you from running a trusted supernode either. 

Cheers,

M

On 21/12/2011, at 18:17, Jordan Mack wrote:





-------------------------------------
On Fri, Jul 01, 2011 at 02:07:18AM +0200, Matt Corallo wrote:

I've cleaned the commit up a bit, and created a pull request (#369) for it.



Nice, we definitely needed something like that. It wouldn't hurt to have multiple
people running such a seed, to prevent problems with occasional outages of DNS seeds,
once we move away from IRC entirely.


Agree.


Given that there is no public outcry against these programs automatically
opening holes in firewalls, I assume it's safe for us to do the same.

It should be clearly explained in the release notes, though.


Yes.

So: I'm in favor of an emergency release 0.3.24 with upnp default enabled,
dnsseed default enabled, block send limit, no-connect segfault bugfix.
Anything else?

-- 
Pieter


-------------------------------------
OK, let me try to explain what I see is the problem:

So far we the bitcoin addresses are (for all practical purposes) a one-to-one mapping between a pubkey and uint160. This mean that your wallet is defined solely by your privatekeys (from which you can extract pubkeys and then uint160 btc-addresses).

This also enables you to make a uint160 to tx mapping on a server (like on blockexplorer) and use a thin client to query for transactions just from a list of uint160 (whether it holds the private keys behind them or not).

In the case of a multisig transaction, lets say the 2of3 example, you could e.g. have all 3 corresponding uint160s but only one privkey, but still query the server and know the value of an asset of uint160s.

This, I find a nice and clean setup, where cryptographic keys can be mapped to assets.

If we now consider the OP_EVAL proposal. Here, a new use of the uint160, namely as a mapping of ripemd160(something extra and hash256(pubkey)) is introduced. This means that this clean mapping is broken. Your will have an extra "public key" being the "something extra", and there is no easy way to do the mapping from a list of private keys to public keys to uint160s that will result in the new condensed uint160, except if you also have the knowledge of the script that was used. 

I agree that it will work and I (and bitcoin-js and blockexplorer) can of change the concept of a wallet to also include scripts, but it breaks an intrinsic logic of uint160s and transactions that has so far been quite nice and clean.

So I also support checkmultisig to be the standard transaction type, but I do not appreciate the support of OP_EVAL.

Cheers,

Michael


On 26/10/2011, at 17:00, Gavin Andresen wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------
On Thursday, September 15, 2011 12:04:37 PM kjj wrote:

That would make sense if you knew the node was originating them, MAYBE--
but not given the fact that they may merely be relaying transactions.


-------------------------------------
I propose that full public key addresses be required to be "compact" (length 
33), and use version 21 (begins with '4', and is redundant with ver 20 for 20-
byte data). Any reason this wouldn't be workable?


-------------------------------------
On Fri, Aug 5, 2011 at 1:37 AM, John Smith <witchspace81@gmail.com> wrote:

Yep.


Unfortunately the nodes accepting incoming connections are small
enough in number (7000?) that you can shut down a lot by attacking
those nodes.

This was part of the motivation of turning on upnp by default in the
GUI version, but maybe we need to go further than that...


Yes, that is correct.  Bitcoin resends wallet transactions with zero
confirmations, and both sent and received transactions fall within the
"wallet tx" superset.

TBH I had forgotten about the resend on the receiver side, though.
It, of course, makes plenty of sense in the context of importing
transactions from foreign sources, e.g. receiving transactions via a
USB flash drive.


Well, it -is- possible to implement TCP over UDP <grin>  The TCP
connection sequence over UDP helps to work against spoofing, while UDP
helps to open an inbound UDP port as you describe.

Not that I'm endorsing a bitcoin-internal TCP stack... just sayin'  :)

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
BitCoinJ already sets the subver field to its name and version.
-------------------------------------
Point taken.

About the sub_version_num though. I prefer to let the field by defined clients however they wish, with just a guideline suggestion that IDENTIFIER VERSION is a format they should follow.

The idea being that different projects would have different release scheduling schemes and it'd be restrictive to lock people into the popular major.minor system.

So for the current bitcoin to find out the version number of other clients (if it was needed), it would have to parse the number from the string:

"Satoshi 0.5"

Although there would be little reason for this with a sane protocol versioning scheme.

If we're agreed then I'll start on that BIP.



________________________________
From: Gavin Andresen <gavinandresen@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Sent: Wednesday, November 2, 2011 9:34 PM
Subject: Re: [Bitcoin-development] Lock protocol version numbers

Good idea.

Sounds perfect for a BIP....

On Wed, Nov 2, 2011 at 5:23 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-- 
--
Gavin Andresen
-------------------------------------
On Fri, Sep 9, 2011 at 10:02 AM, Gavin Andresen <gavinandresen@gmail.com> wrote:


Should I go ahead and upload src + builds to SF?

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hi,

https://en.bitcoin.it/wiki/BIP_0014

Thanks to Gavin Andresen for proof reading and suggesting clarifications. Thanks to Patrick Strateman for suggesting the hierarchical format and pointing out some flaws of browser user-agents to me.

The timeline is written in the past tense since BIPs are meant to be readable in the future for explaining why we took certain decisions with bitcoin. A nice cache for future historians when bitcoin is ubiquitous ;)


The next version 0.6 should be the protocol version which becomes peeled off from the current client. There are still some changes migrating into the protocol that need to be finished.
-------------------------------------
On Wed, Jul 27, 2011 at 11:07 PM, Matt Corallo <bitcoin-list@bluematt.me>wrote:


Which, in many cases, is enough. Many times, fixing a bug is a few hours of
debugging, then fixing three lines of codes.

Sometimes it just takes a monkey to sit behind a PC and bash on it frantic
enough (with a debugger) to find and fix bugs :-) Competition to fix bugs is
(up to a certain level) good, it gets people off their ass. But I think the
competition problem is very hypothetical. It assumes there will suddenly be
*a lot* of people that want to fix the same bug. That's unrealistic...

Writing a few test-cases (which is better than the 0 we have now) also won't
take a Linus-level developer to work on it full time. A reasonable dev just
needs to put some time into it.

That leaves the more difficult work to the lead devs.

For a distributed currency I must say there is very little belief here in a
distributed process. Yes, you can also start a company and hire people to
work on it full time, but then they'll be working on helping customer not
solving bugs of the issue tracker (which might have an overlap, but not
necessarily). And it also isn't clear whether changes are contributed back
to the project.

You should not underestimate the open source community. There's a lot of
smart students eager to work on interesting, high-impact projects. Bitcoin
certainly fits that description, but the problem is that Bitcoin isn't
really that known yet with devs, and they need a little push to get
involved. And to work on the current code-base, because usually they will
look at the code and decide it's a piece of crap and want to rewrite it (new
people syndrome).

Yes, there might be one-time-and-run-off flakes, but hey that's life... you
only need to gain a few (semi)dedicated devs from it anyway, not recruit an
army of loyal minions.

I'm not saying this push has to be bounties. It could be a nice page, for
example just posting the bounties on the forum is a start, but certainly not
enough. They just get buried in troll poop, and a lot of the forum users are
... *psychological analysis removed*. You really want to reach out somehow.

It should at least have a nice page that attracts people on the
bitcoin.orgsite, and explains why you should work on Bitcoin (because
the project is so
awesome and fun) and some form of attribution (not just a mention in the
gitlog, but bounties is only one option) if you do manage to fix a bug.

Heck a scoreboard with "number of bugs squished" could be a start :-) We
need to be creative here...

JS
-------------------------------------

Excellent idea, that gets the incentives right.

RE: fixing the root cause with a forking change:

What do other people think?  I think it is too high risk for too
little benefit and shouldn't be done until we have a really compelling
reason to introduce a forking change.

The first really compelling reason I can think of is removing the
MAX_BLOCK_SIZE limit (but does something clever to prevent the
rogue-miner-sends-you-a-valid-10Terabyte-block attack).

-- 
--
Gavin Andresen


-------------------------------------
On Sat, Jul 16, 2011 at 10:54 AM, Matt Corallo <bitcoin-list@bluematt.me>wrote:



I think a simpler forum would also be easier to moderate. Main criterion: is
it helpful to users? If not, lock/remove it.

Two categories: Technical Support, Development (which can be split up
between client work, and other software/websites integrating bitcoin).

Those two can be replicated per language if a large enough group exists in
that country that is also willing to maintain order.

I have no problems with volunteering some time moderating, but not on the
current forums.

If this is really a capacity issue then IMO we should simply remove the link
and come up with an alternative medium to address user issues (such as a
moderated mailing list).  But I don't really believe this. There's a ton of
successful forums that did pick the right structure and helpful moderators,
and a lot of them are volunteer-driven.

JS
-------------------------------------
Hello all,

After reading pull/417, I'm noticing that generation transactions
always appear twice in listtransaction output:

 * one item with account "" and category "generate"/"imature"/"orphan",
   plus some transaction data.

 * one with the account associated to the destination address and
   category "received", plus the same transaction data.

Both items have the same txid.

Is this the intended behavior or should the second be removed?

Also, why is account "" enforced in the first item?
(Wrong assumption that coinbase is always built from the client
itself?).

Last, it happens that {list,get}receivedby{address,account} commands
never list or take into account generation transactions. I'm not sure
how the help message associated to those commands should be
understood. As a user, I would assume that generated transaction are
included in these listings/amounts.

Is all this related with some issues encountered by E-wallet
providers?

Thanks,
Stéphane


-------------------------------------
On Fri, Aug 26, 2011 at 01:09:37PM +0200, Mike Hearn wrote:

You're quite right - currently addresses encode a particular output script,
and the client pattern matches to know how to deal with the incoming funds.
It's far from sure this will remain the case in the future. Maybe we'll have
an out of band protocol over which a request "i want to pay you for item X"
is sent, with the required transaction output as answer.

A generic way for encoding complex transaction scripts in a compact form may
be useful for "manual" playing with them - but I agree that we should
probably wait for a use case for this.

Independent from the question of complex-script-addresses are useful, I do
think it is useful (and possible, see pull req) to allow a class of scripts
that represent boolean expressions over signature checks to pass the
IsStandard() test - that way we make sure that whenever in the future we
want to support creating such an expression, there will at least be a to
encode it in a way that the network will accept it. The only question is
what possible problems there are with accepting them.

-- 
Pieter


-------------------------------------
Sorry guys, I just realized I should've posted this to the dev list 
first, before/instead of putting it on the forums.

    https://bitcointalk.org/index.php?topic=51474

*I still have some of my private keys in plaintext. *I would guess that 
BSDDB sometimes will "overwrite" data by just discarding a pointer to 
the old data, and writing the replacement to a new location within the 
file.  In that case, examining the file with a BSDDB library tool is not 
going to find this problem.  You'll have to examine the raw binary file 
as I did.  Instructions for verifying this problem are in the post.

Can someone please verify that this is a real problem?  (and should we 
maybe remove my post until there's a remediation plan?  This is problem 
the best kind of problem to disclose after it's fixed)
-Alan


-------------------------------------
Sorry, that last message got broken off.

On Fri, Jul 8, 2011 at 6:36 AM, Stefan Thomas <moon@justmoon.de> wrote:

I agree it is cleaner, but I think breaking compatiblity with older address
(even testnet) is not a good idea right now. It is important to build an
image of stability and backward compatibility.

So I vote for the XOR 111 hack :)

JS
-------------------------------------
One more thought on putting arbitrary stuff in the scriptSig:

Miners could decide to revolt and remove the extra scriptSig
information before including the transaction in their blocks. They'd
still get the full transaction fee, and the transaction would still
validate so the block would be accepted by everybody else.

Come to think of it, if a node relaying transactions wanted to save
bandwidth costs or be annoying, it could also strip off the extra
information before forwarding it, so this isn't a reliable
communication mechanism. It is probably a much better idea to use
another protocol to gather signatures.

-- 
--
Gavin Andresen


-------------------------------------
This is the way it works for the kernel, the process on which I've
suggested we follow with bitcoin, to a small extent:

- Version X is released.  Linus now begins accepting pull requests
into torvalds/linux.git for X+1 ("merge window opens").  It is
strongly recommended that all pull requests have seen some exposure to
the public via "linux-next", which is a tree-of-trees generated from
pulling the trees of top developers.  linux-next is maintained by
another volunteer, Stephen Rothwell.

- After a week, Linus stops taking pull requests from subsystem
maintainers ("merge window closes").  At this point, a 2.5-month
stabilization and bug fix period begins.  No new features are merged
into torvalds/linux.git, and developers are expected to focus on bug
fixing.  Developers, of course, accept new features and changes into
their own trees and branches.  linux-next publishes these, while the
main torvalds/linux.git remains in bug fix mode.

- Three months after version X is released, version X+1 is released
from torvalds/linux.git top-of-tree, and the process begins anew.

- From time to time, _not_ every version, a Linux "enterprise"
distribution like Red Hat Enterprise Linux (plug plug) or Ubuntu LTS,
will maintain a kernel for a long time, for the benefit of their
customers who need stability over new feature.  Or, the community
simply decides that a kernel should be maintained for a longer period
of time.

In particular, Greg Kroah-Hartman (gregkh) maintains stable trees for
version X-1 and X-2, where he will accept fixes provided that the fix
(or a variant thereof) has been accepted in upstream.

In that case, an employee or volunteer maintains a stable branch of
the kernel.  They "backport" fixes from the main torvalds/linux.git
tree into their own gregkh/stable-2.6.36-linux.git tree.

Thus, we observe a few things that may be applied to bitcoin:

- decentralized operation, where stable branches and bitcoin-next are
not maintained by the core team
- the community decides which versions are important to maintain long term
- the core team may maintain a merge/stabilize/merge/stabilize
workflow, introducing new features without huge negative impact to
existing userbase

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
I just finished the specs and design for MinorFs2.
I hope its a good fit for bitcoin this way.

http://minorfs.polacanthus.net/wiki/Minorfs2_id_service

I think 'process-Chain granularity' or 'Worker granularity' might be
suitable for bitcoin. But possibly a more course granularity level would
be required.

http://minorfs.polacanthus.net/wiki/Minorfs2_id_service#Executatable_persistente_granularity

If there are any potential changes any of you could think of for these
specs and this design that would make bitcoin and MinorFs2 a better match
please let me know.

Rob


On Mon, September 5, 2011 13:55, Rob Meijer wrote:




-------------------------------------
Matt:  First I agree with you.  Second: your should have sent your message
directly to Alan instead of to the entire bitcoin-development list.

All: The idea is for this mailing list to be CONSTRUCTIVE discussion of
bitcoin development.  Please ask yourself "will my message help move the
bitcoin project forward or will it just make somebody angry" before posting.
 And assume that at least someone on the list just broke up with their
girlfriend and is in a crappy mood.

-- 
--
Gavin Andresen
-------------------------------------
On 2011 August 11 Thursday, Joel Joonatan Kaartinen wrote:

Yeah, shooting down a shooting down, which you've just shot down.  Where will 
it end?


How about:

"This is a good idea, but we don't want to break backward compatibility a 
little piece at a time.  Instead we'd like to collect all such changes into 
one single compatibility breaking release.  Here's the wiki page you should 
update; and here's the git branch you should push changes like this to."


I know the application/protocol version split has been discussed before, but 
please point me to the relevant discussion on: loading the block chain in 
reverse; transaction only requests; checksumming removal; verack removal; 
storing script parameters outside the script; and requesting blocks by 
transaction hash instead of block hash.

If I've missed all of these discussions and their inevitable logically 
indisputable rejection, I apologise.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Hi there!

Instawallet has enjoyed steady growth and I'm running into a bottleneck
now with "getbalance <someaccounthere>" taking quite some time to
complete. My understanding is, that this is because bitcoind runs
through all relevant transactions each time anew to compute the balance.
I was hoping the list could give me some pointers/ideas on how I can
improve this.

I might start to do account handling completely in my application at
some point, but for now I would like to continue letting bitcoind handle
this, so I don't have to worry about thinks like block chain reorgs.

Basically I don't have enough familiarity with the source code to feel
confident about doing fairly invasive changes. So right now I'm planning
to implement a very simple cache (directly in bitcoind), which just
caches calls to getbalance and simply invalidates the whole cache as
soon as a new block or a transaction that affects the wallet comes in.
I'm hoping this will help a little bit, although with blocks arriving
every 10 minutes on average it's not really the perfect solution.

Maybe one step better would be to only invalidate cache entries that are
affected by a new transaction or by transactions arriving in a block.
This would need to take block chain reorgs into account though, which
seems fairly complicated. Maybe I could simply invalidate the whole
cache on reorgs, which should be seldom enough that it's not a big
problem. Where would be a good place in the source code to hook into to
notice block chain reorgs?

The perfect solution would be, of course, if bitcoind could keep running
balances of all accounts and update them as new information becomes
available. But as I said, I don't feel that I have a good overview of
all the corner cases to make such an improvement. I guess an extensive
test suite testing all sorts of esoteric block chain reorgs would really
be a nice thing to have. :-)

Regards!
Jan


-------------------------------------
On Wed, Sep 14, 2011 at 3:52 PM, Aidan Thornton <makosoft@gmail.com> wrote:

Perhaps better thing to do is to also delay the _forwarding_ of these
blocks _and_ blocks that extend them, until extended one more time.

This policy, if adopted by the forwarding nodes (who really shouldn't
care for much other than the overall health of bitcoins) puts miners
at risk if they don't run the augmented extension policy.


Though I generally agree with Luke that we should just fix the root
cause even though it forks the chain. Not for his reasons (I don't
give a crap about the burden on _one_ pool operator— the rest cope
with bitcoind scaling fine without excessive dependance on ntime
rolling),  but simply because not fixing it makes the bitcoin security
model harder to explain and analyze.

"Here is a vulnerability, but its offset by this workaround" is
inferior to "the system is secure against this kind of attack".


-------------------------------------
On Fri, 2011-07-01 at 08:31 -0400, Gavin Andresen wrote:
Not sure about OS differentiation, seems...wrong?  Maybe disabled by
default on bitcoind but on by default on bitcoin?

-------------------------------------
On Thu, Sep 15, 2011 at 10:06 AM, Gavin Andresen
<gavinandresen@gmail.com> wrote:

Fail hard, log the reason locally. Problem becomes tractable. Also,
for any problem big enough to cause a network outage the issue won't
be reproducibility.

I support the imposition of txn rules— otherwise the dropping is
nearly pointless due to the hole that any attack can just take the
form of junk txn— but you must be super careful that an attack can't
be transitive: There should be nothing I can give a node that it will
forward on that will make that node's peers drop it. (and this needs
to remain true while forwarding rules evolve)

So, I'd suggest that you'd only drop on transactions that would
invalidate a block if included in it but the problem there is that
double spends meet that criteria. Better would, perhaps be something
like "would invalidate a block if included; except that double spends
after the last checkpoint are allowed, and nodes should not forward
any txn until they are current with their last checkpoint"

(That bit of complexity is to reduce exposure where a new node gets
hit with double spends that its yet too stupid to reject, and it
forwards them onto its friendly peers who then hang up on it thus
prolonging its period of ignorance— in general care needs to be taken
to avoid hanging up on nodes that are just too young to know better)


It would be fine to hang up on any garbage data: something is
obviously wrong. I'd be hesitant to ban on a single instance of it,
it's rare but happens. (e.g. see
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.14.150&rep=rep1&type=ps)


-------------------------------------
Actually Steve, take a look at the bitcoinj mailing list today. Somebody has
already built this and has it running. It's accumulating data at the moment,
they'll announce it more widely soon. But I think there's no need to
duplicate work.
-------------------------------------
On Fri, 2011-08-05 at 02:14 +0200, Stefan Thomas wrote:
It used to be enabled by default on virtually all routers a couple years
ago, but too many "security researchers" complained that it was a "huge
security vulnerability" (I guess they hadn't heard of stun or outgoing
connections) so its not typically disabled on most routers.
-------------------------------------
On Fri, Dec 16, 2011 at 12:36 PM, Khalahan <khal@dot-bit.org> wrote:


How can one construct a zero-trust (or nearly zero trust) namecoin
resolver without having a copy of the ever growing complete namecoin
block chain?

The bitcoin lite node mechanism will not work because a peer could
return stale records or no-result and you would have no evidence of
their deception.  (In the case of lite bitcoin nodes, telling you
about old transactions is harmless because you control your own
transactions).


-------------------------------------
On 2011 December 13 Tuesday, Amir Taaki wrote:


I don't like the idea of a hard-coded mapping at all.  We shouldn't be making 
choices on behalf of server operators.  It's up to them how they arrange their 
domain names and paths.

I also agree that DNS is not the technology to use.  DNS is a nightmare.


Why bother with an encoding scheme at all?  If the address

  genjix@foo.org

always maps to

  https://foo.org/bitcoin-alias/?handle=genjix

Then forget the hardcoding of "https" the hardcoding of "bitcoin-alias" and 
"?handle=" and the original email-looking "genjix@foo.org".  Just use the URL.  
Then the author of the service can use whatever they want.

 "Can I pay you 10 BTC?"
 "Sure, send it to 'https://bitcoinalias.foo.org/genjix/'"

While I might implement my alias server like this:

 "Sure, send it to 'https://google.com/bitcoin/?andyparkins'"
 "Sure, send it to 'https://parkins.co.uk/"

... or any other URL they want -- any of which suit might suit me and my 
webserver better than whatever mapping would otherwise be hard-coded.  The 
world is already very familiar with URLs so this is no more scary than the 
email address.  What's more, the email address form looks _too much_ like an 
email address, and will only lead to confusion ... "send it to genjix@foo.org"  
"so I use outlook express for that, right?"  "erm, no, you put it in your 
bitcoin client".

The URL form could easily be made to detect a browser connecting rather than a 
bitcoin client (and this is an area that would benefit from a standards 
document -- define the headers and user agent triggers that an alias server 
expects) and give them better instructions.

https can be specified as the default, so  "https://" can be optional when 
they're typing.  If, in the future, bitcoin gets a distributed peer-to-peer 
alias system, then a new URL type can be added easily "bcalias://andyparkins" 
might automatically find my node in the network and query it for an address 
(or whatever).

All of the above is exactly why OpenID chose to use URLs for ID.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
I agree. I think breaking compatiblity with older address (even testnet) is
not a

On Fri, Jul 8, 2011 at 6:36 AM, Stefan Thomas <moon@justmoon.de> wrote:

-------------------------------------
On Thursday 11 August 2011 17:17:23 Mike Hearn wrote:


Fair enough.


Well okay; it seems to me that that is considerably bigger task, and I'm not 
sure how likely that is to appear.  But that sounds workable, since my 
feature request is simply this filtering system with the filter set to 
"ALL"; so I can hardly complain about that.


 ... good stuff removed for brevity ...


I can't say I see what the point of all that added complexity is, contracts 
are usually more than just financial, and the ability to pick a slightly 
different set of source inputs doesn't seem like a hugely useful feature; 
but I'm willing to accept someone thinks it is a good idea and leave it at 
that.  I withdraw my "move sequence number" feature request.


What then allows the contract out of the memory pool into a chain?  The 
locktime?  No, no, forget it... I don't want to open a new can of worms.


Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Monday, August 22, 2011 3:30:04 PM Douglas Huff wrote:

He said standard *coding and implementation paradigms*. This has nothing to do 
with integration with some non-standard "init replacement" that goes against 
the whole design of Unix.

What I understand this to mean, is properly abstracting the components such 
that the node, wallet, and GUI can work together while being distinct parts.
In this sense, Fred, you may be interested in working on coming up with a 
standard for a https://en.bitcoin.it/wiki/Wallet_protocol


-------------------------------------
For now I think requiring direct-connection negotiation is best for these kinds of things. A direct connection is OK in most cases, and more complicated schemes will be more likely to fail. Maybe the IP transactions protocol can be used.

In the future, I imagine that users of ultra-lightweight clients will connect to a new P2P network built on top of the core Bitcoin network in order to receive block headers and info about sent/received transactions without leeching off of the few full nodes. This network could also be used for indirect transaction negotiation, which is similar to the goal of finding your own received transactions.

On Wednesday, November 09, 2011 3:02 PM, "Gavin Andresen" <gavinandresen@gmail.com> wrote:

I believe it's possible to spend a 0-value output, so they can't be considered automatically spent.


-------------------------------------


Begin forwarded message:


-- 
Doug Huff


-------------------------------------
Anybody have advice on how to encourage more bug-fixing and testing of
existing functionality instead of yet-more-features?

When I get back home from here in Australia I plan on trying to
lead-by-example by starting to tackle the huge backlog of reported bugs, but
I'd like to know if anybody has seen other open source projects successfully
get people to fix bugs instead of constantly adding features. Would policies
like "that spiffy new feature you want won't be considered until you've
helped close some open bugs" be effective (or would it just encourage people
to create shill accounts to open trivial-to-fix issues)?

If this was your run-of-the-mill open source project I would be much
more lackadaisical about letting in new features... but when people lose
money because bugs slip through (and several people HAVE recently lost money
because of bugs slipping through) we obviously have a pretty big problem
just making sure that the features we have now work properly.

(Thanks VERY much to those of you have HAVE been helping test and have been
submitting bug fixes; I don't mean to imply that everybody has been
feature-happy, just that it seems like a lot of potential bitcoin
contributors start out by submitting a nifty new feature that sure would be
nice to have if we weren't so busy trying to make sure the features we
already have work properly all the time).

-- 
--
Gavin Andresen
-------------------------------------
On Fri, Dec 16, 2011 at 12:54 PM, Andy Parkins <andyparkins@gmail.com> wrote:

[snip]


actually there are many differences. Specifying a standard using a
HTTP(s) transport for a look-up isn't something that has been done in
the PATH portion of the URI and that I was pointing out that there is
*NO* RFC that specifies such for a look-up provide the inverse of many
protocol specifications that did *not* choose that methodology.

What has happened is various schemes are specified, developed and
deployed. I am sure you are familure with many. sip:// ftp:// etc://
many are described at http://en.wikipedia.org/wiki/URI_scheme

NAPTR records (see http://en.wikipedia.org/wiki/NAPTR_record) are
another area that deserves research for those that desire URI schemes.

Understand that I am mearly advocating that as a group this work be
done in standards development process, and that IBANN is one such
effort.

-rick


-------------------------------------
I know most of the people actively working on bitcoin (and active on this
list) ignore the forums, for good reason. But there's a lot of people
(everyone new?) that think the most active members of the forum have a major
influence on the project's direction. Which is making us as developers look
really bad. As if we're some political faction that wants to bring down
world governments and unleash a global anarchistic doomsday scenario.

It really needs to be more down-to-earth. Ideally, the forum would simply be
a way to communicate with the *actual* users. For example, I use it for
soliciting user feedback on UI features.

JS
-------------------------------------
Is there a link to this GUI code?

John Smith wrote:

-- 
Regards,
Brendan Molloy

M: +61 434 069 776
T: @piecritic
W: http://bbqsrc.net
E: brendan@bbqsrc.net


-------------------------------------

As far as I understand the only reason for hashing the public key is
for typing convenience. Otherwise we'd all just pass raw public keys
around and use the simple form seen in the direct-to-ip case.

But as there'd need to be a higher level protocol on top of the
multipay transactions in order to verify who the other parties are,
there's no need for typing convenience. It'd all be done
automatically.


-------------------------------------
On Thu, 2011-08-04 at 19:22 +0100, Andy Parkins wrote:
But why? It results in slightly more network traffic which is exactly
what we don't want, and it adds yet another message people have to know
about.
Ferraris aren't exactly small ;)
No one cares about what the network thinks is the right transaction, its
only what miners believe that matters.
Even if the vending machine doesn't keep the full chain and doesn't
accept incoming connections, its still the target node.  What other
nodes on the network think doesn't matter as long as you get the target
to think a transaction that won't be confirmed will be.  If it doesn't
accept incoming connections you want to find nodes that do that are
connected to your target.
That is exactly my point.
Its much easier to create than to change the network code to relay info
on double-spend transactions.
No, thats not what happens now.  Currently if your node gets a
transaction which conflicts with one it already knows about, it silently
drops it without a second thought.  My point is if you actually dealt
with such cases and made good connections, you would be able to prevent
double spends nearly perfectly.
No, my suggestion is not to relay the second transaction.  The second
transaction should continue to not be relayed as it currently is,
however receiving such a transaction should trigger the node to notify
the user that the transaction should not be accepted until it makes it
into a block (in fact, you could already do this if you implemented a
debug.log parser and made well-placed connections).
Bitcoin is absolutely still an experiment and no one thinks that any
kind of future is guaranteed.  This was not meant as an argument, but
simply as "if bitcoin does end up going somewhere, it will likely be
done like this".

Matt
-------------------------------------

What's the real issue?

 - People want to use alternate representations ('aliases') of bitcoin
addresses, for various reasons.
 - The blockchain is the only way to create distributed consensus
within the bitcoin network.
 - Very few people - even those who wish to have a permanent alias -
want to have it map to a permanent bitcoin address, since this
discloses their financial history (eg: income for a business) to the
public
 - Some people want throw-away (single use) aliases, others want
permanent ones.  This means many addresses.
 - Blockchain bloat is already acknowledged as an issue.
 - The blockchain is not really a good option.

Leaving out the blockchain, there are still ways to implement aliasing.

What is the core problem for an extra-blockchain aliasing system?

At the core is usability - people basically want aliases to make it
easier to type in or remember addresses.  So a solution that
sacrifices usability too far is a broken one.

Another requirement is absolute security.  A user of the aliasing
system is going to trust it to translate a particular alias to a
bitcoin address - ie: 'where my money goes with absolutely zero chance
(by default)  of getting it back if it's sent somewhere wrong by
accident'.  Such an accident might be mistyping an alias.  It might
also be a hijacking of the alias resolution system (eg: a DNS based
system without DNSSEC, etc.).  As a case in point, we already see very
well organized attacks by domain squatters in order to steal traffic
or effect phishing under the DNS system.

So... to help see which qualities are meaningful for such an alias
system, let's look at what types of solutions to these problems exist
within conventional (ie: mature) financial systems.

First, arbitrary aliases are not in use.  This means that memory-based
mnemonics are not subject to predictable squatting-style attacks.  For
our purposes, this means that if you are payments@business1.com, I
can't go and register payments@busines1.com and take a portion of your
inbound cash whenever a client tries to pay you and typos on the send
address.  Likewise, if you're 'someuser@hostedwalletservice.com' I
can't go and register as 'someuse@hostedwalletservice.com' and pull
the same heist. IIBAN is the only aliasing proposal I have seen
mentioned within this thread that adopts this strategy, the others all
maintain this vulnerability through DNS. HTTP relies on DNS.

Second, checksum systems detect transposition errors. This is a very
powerful feature, which (I can't be bothered googling for stats, but
just think about it) cuts out the vast majority of such errors
instantly, at the time of input, before money changes hands or
anything touches the financial settlement networks.  IIBAN adopts
exactly the same mature and proven MOD97-based two digit checksum
feature that is used within the IBAN standard, proposed by the
European Union with the benefit of decades of banking experience in
many member states and now growing rapidly in use around the world.
(For something as expensive and painful to implement as a
nationally-mandated banking standard affecting all member banks, a
growth rate of 'a few countries per year' is a pretty serious growth
curve!)  With checksums, it's even possible to auto-suggest
corrections based upon common transposition errors and help the user
to check those parts of the alias for common errors more quickly.

Third, conventional financial systems typically require recipient name
(and sometimes address, or business tax numbers in some countries'
domestic schemes) as part of the transaction.  This secondary data
facilitates error checking since an incorrectly supplied destination
address can be checked against these properties.  Of course, Bitcoin
presently has no such secondary input with which to verify the
destination of a transfer, and since blockchain bloat is an
acknowledged issue and very few bitcoin users would like to see their
names appear against their transactions within the blockchain (visible
to all, for eternity!) it also seems that this feature is not going to
be added and for good reason.  However, within an external (and not
necessarily bitcoin specific) higher-level 'transaction negotation'
protocol (alluded to in earlier posts as a logical extension of the
pre transaction alias resolution mechanism, and being a pre
transaction connection of some nature between a payer and payee, or
their proxying/representing institution, in the case of hosted
wallets/aliases), such external destination validation features could
be added. (Many types are possible... data-based as per name/address
validation, cryptographic validation schemes, etc.)

Finally, an increasing number of countries use an aliasing scheme
(IBAN) that is familiar to users.  Doing so for digital currencies
such as Bitcoin increases usability (by eliminating novelty, and in
the case of IIBAN which is not specific to any given currency, the
need to register, recall and manage yet another account identifier),
which was one of the original goals. None of the other proposals
mentioned have this property.

I won't go in to other benefits previously mentioned of the IIBAN
proposal, but I still cannot see any reason to either:
 - Include aliasing within bitcoind itself
 - Re-invent the wheel
 - Scare off non-technical users
 - Dodge the fact that there are unique properties of bitcoin that
will always remain and should perhaps simply be acknowledged and
worked around OUTSIDE of the codebase, rather than within.
Unix/internet philosophy is that it's usually best to keep code as
simple as possible, to 'do one thing' and 'do it well'. For bitcoind
(despite sharing a codebase with the GUI), that something is achieving
a distributed internet-based financial system that is free from legacy
centralized currencies. It is *not* worrying about making it look
pretty or easy to use, which can be achieved by layering totally
external systems through simply translating various alternate
representations ('aliases') to the well defined bitcoin addressing
scheme.

Just to avoid any notion of table-banging (Hah! A lost cause?), this
will be the last IIBAN-related post I will make on this thread, but
there will be some further announcements in the near future.

Keep up the good work everyone.

Regards,
Walter Stanish
Payward Inc.


-------------------------------------
For the future evolution without considering DHTs:
While I think we will sooner or later have supernodes, I don't think they
will need to be trusted too much.
Supernodes will be those nodes that verify all transactions and make them
available to miners. Since miners will become more and more specialized
these supernodes are likely to be owned by the miners themself. To be a
miner either you need to verify all the transactions you include (otherwise
others might be able to find an error in your block and thus drop it) or
have someone that verifies them for you. In the end I think we'll end up
with a hierarchical network, with the miners/supernodes tighly
interconnected at the top and the lightweight clients that simply verify
transactions (or their inputs to be precise) that are destined for them at
the bottom.

As for the DHT we had a few brainstorming sessions a while back on the
forum http://bit.ly/sc2RLZ (gmaxwell didn't like it then either :D)
Forcing someone to participate in a fixed position in the block storage
network is a good way to reduce the risk of a sybil attack as Michael said.
The hash should include only information that cannot be changed by the
user, so IP can be used, but including the port is risky.

Broadcasting the transactions would not need to be done, since miners fetch
them from their storage place, alternatively we could use the inv broadcast
to notify peers about a new block/transaction and let it retrieve them from
the permanent storage (DHT or block storage network). If we route traffic
internally in the DHT we could even start caching at nodes leading to the
real location, since announcements would lead to flashcrowds, putting heavy
load on the responsible nodes. Caching is not a risk since the hash of the
object to be retrieved is already known.

Regards,
Chris

On Wed, Dec 21, 2011 at 1:41 PM, Michael Grnager <gronager@ceptacle.com>wrote:

-------------------------------------
On Wed, Aug 10, 2011 at 5:36 AM, John Smith <witchspace81@gmail.com> wrote:

Seems reasonable to me.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sun, Sep 4, 2011 at 13:59, Pieter Wuille
<pieter.wuille@cs.kuleuven.be> wrote:

My mistake: these are not actual potential deadlocks, as all locking
of cs_vRecv/cs_vSend
happens inside TRY_CRITICAL_SECTION blocks. Gavin, maybe you can add the rule to
your debug code that ignores critical sections which are only locked
through TRY_...?


Regarding the actual deadlock between IRC seeding and AddAddress:

Internally, DB also uses pthreads to implement the txn_begin()/commit() scheme,
though I'm not sure with which granularity. These need to be taken into account
when searching for deadlocks, but are obviously not detected by
DEBUG_LOCKORDER.

In particular here, the processing of "addr" created a db transaction for the
entire message, while only locking cs_mapAddresses inside AddAddress. For
IRC seeded addresses however, no db tx was precreated, and AddAddress first
locked cs_mapAddress, and then did the database write (causing a lock) inside.

A solution: in main.cpp, ProcessMessage, case "addr":

          // Store the new addresses
          CAddrDB addrDB;
+         CRITICAL_BLOCK(cs_mapAddresses) {
          addrDB.TxnBegin();
          int64 nNow = GetAdjustedTime();
          int64 nSince = nNow - 10 * 60;

              }
          }
          addrDB.TxnCommit();  // Save addresses (it's ok if this fails)
+         }
          if (vAddr.size() < 1000)


which makes sure that cs_mapAddresses is always entered before starting
a database transaction.

However, there may be similar issues in other place where TxnBegin is called
explicitly. Also, maybe there are other solutions, like changing BDB parameters
that make the db transaction fail instead of block, for example.

-- 
Pieter


-------------------------------------
Hello all,

I'd like to add notifications to the client and wallet, to decouple UI and
core communication, and especially so that UIs no longer have to poll for
changes.

I propose to use the boost::signal mechanism for that. It is basically a
glorified callback system, but allows decoupled delivery of 'signals' from
an object. Multiple other objects can listen in on an event without the
emitting object having to care.

Wallet:

class CWallet { ...
    boost::signal<void(int64)> balanceChanged;
}

void CWallet::newTx (...) {
    ...
    balanceChanged(new_balance);
    ...
}


UI:

GUI::GUI(CWallet *wallet) {
   ...
   wallet->balanceChanged.connect(boost::bind(&GUI::balanceChanged, this,
_1));
}
GUI::balanceChanged(int64 new_balance) {
   someWidget->setValue(new_balance);
}

Specific notifications that would be useful:

Wallet:

   - balanceChanged(int64): spendable balance changed
   - transactionAdded(int256): new transaction added to wallet
   - transactionUpdated(int256): transaction info changed
   - transactionRemoved(int256): transaction removed from wallet (can this
   happen? for completeness)
   - addressAdded(int160): address was added to address book
   - addressUpdated(int160): address label/other metadata was modified
   - addressRemoved(int160): address was removed from address book
   - notification(std::string message, int severity): warning/error occured
   in wallet processing, notify user
   - int askFee(std::string message, ...): ask user for fee

Network client:

   - numConnectionsChanged(int): new connections / connections broken
   - numBlocksChanged(int): new blocks came in or other changes to block
   chain
   - notification(std::string message, int severity): warning/error occured
   in network processing, notify user


JS
-------------------------------------
On Tuesday, July 26, 2011 12:54:23 AM Rick Wesson wrote:

Admittedly, my proposal to email a signed message allows one to reuse 
addresses, but there is still a privacy concern.


http://www.google.com/search?q=%22PROTECT+IP+act%22+DNSSEC


I only meant that foo.bar.net is not the same formatting.
foo@bar.net would be.


-------------------------------------
It's just simple SHA2, you can implement the whole thing easily without dragging in a huge lib like OpenSSL.  I guess I haven't looked at it recently but the original CPU miner was just implemented locally in bitcoin and didn't use any libs.

It's just that because it's block based, there is no need to ever recalculate the first half since the brute forcing value is in the second half of the block..

This was the original prototype for the OpenCL miner without eliminating redundant calculations and it shows the block1 and block2 calculations clearly.

http://heliacal.net/~solar/bitcoin/sha256.cl

Laszlo

On Sep 29, 2011, at 11:48 AM, Stefan Thomas wrote:




-------------------------------------
On Sunday, December 18, 2011 9:28:36 AM Jorge Timn wrote:

Yes, just like is already done for generation, since it is more efficient 
*overall* for the block chain. sipa's key extraction is a MUCH better 
solution, however, so if we can get that without a block chain fork, I'm 
inclined to favour it.


-------------------------------------
On Wed, 2011-08-10 at 09:36 +0000, John Smith wrote:
I would argue its less clear for the user.  Instead of opening either
bitcoind or bitcoin to get RPC or GUI, now you have to open bitcoin and
bitcoind or bitcoincl and bitcoind.  Now, obviously bitcoin and
bitcoincl can open bitcoind for you, but I think adding more executables
complicates things for little clear advantage.
As you pointed out, we have bitcoind for just this reason.
Making RPC optional for GUI users would be an interesting addition.

All this said, I totally agree with the more clear split of the source
into separate library-ish components (I'm working on part of that now).
However, I don't like the idea of splitting into more executables.  

If you are suggesting this so that bitcoin-qt can be distributed being
built off of bitcoind, I would say go ahead and pull-request bitcoin-qt.
I'm of the opinion that it should be merged whether we have autotools or
not (we already have 5 makefiles, whats a few more options in those?)
and jgarzik seemed to indicate that he would agree (Gavin?, sipa?
tcatm?).

Matt



-------------------------------------
On Tue, Sep 13, 2011 at 11:06:37AM -0400, Gavin Andresen wrote:

Here is an idea for an alternative (simple but hacky) solution:
* Keep all network rules as they are now.
* The timestamp value of mutliple-of-2016-blocks is set equal to
  the highest timestamp that occurred in the previous 11 blocks,
  instead of the current time. This will always obey the previous
  rules (it's always at least the median of the past 11 blocks,
  and never more in the future than them).

Initially, roll out software that only uses this new rule for
block creation, but doesn't enforce it. When enough miners have
upgraded, choose a point in the future where it becomes mandatory
(causing a block chain split only for those creating blocks using
old software).

If i understand the problem correctly, this will prevent an attacker
from introducing a time lapse in between the 2015-block windows.
One problem i do see, is that it prevents X-Roll-Time for miners.
Maybe a short interval (1 minute? 10 minutes?) instead of a fixed
value could be allowed for the multiple-of-2016 blocks.

Comments?

-- 
Pieter



-------------------------------------
It seems to me the fastest path to very secure, very-hard-to-lose
bitcoin wallets is multi-signature transactions.

To organize this discussion: first, does everybody agree?

ByteCoin pointed to a research paper that gives a scheme for splitting
a private key between two people, neither of which every knows the
full key, but, together, both can DSA-sign transactions.  That's very
cool, but it involves high-end cutting-edge crypto like zero-knowledge
proofs that I know very little about (are implementations available?
are they patented?  have they been thoroughly vetted/tested?  etc).
So I'm assuming that is NOT the fastest way to solving the problem.

If anybody has some open-source, patent-free, thoroughly-tested code
that already does DSA-key-splitting, speak up please.


I've been trying to get consensus on low-level 'standard' transactions
for transactions that must be signed by 2 or 3 keys; current draft
proposal is here:
 https://gist.github.com/39158239e36f6af69d6f
and discussion on the forums here:
 https://bitcointalk.org/index.php?topic=38928.0
... and there is a pull request that is relevant here:
 https://github.com/bitcoin/bitcoin/pull/319


I still think it is a good idea to enable a set of new 'standard'
multisignature transactions, so they get relayed and included into
blocks.  I don't want to let "the perfect become the enemy of the
good" -- does anybody disagree?

The arguments against are that if the proposed standard transactions
are accepted, then the next step is to define a new kind of bitcoin
address that lets coins be deposited into a multisignature-protected
wallet.

And those new as-yet-undefined bitcoin addresses will have to be 2 or
3 times as big as current bitcoin addresses, and will be incompatible
with old clients.

So, if we are going to have new releases that are incompatible with
old clients why not do things right in the first place, implement or
enable opcodes so the new bitcoin addresses can be small, and schedule
a block chain split for N months from now.

My biggest worry is we'll say "Sure, it'll only take a couple days to
agree on how to do it right" and six months from now there is still no
consensus on exactly which digest function should be used, or whether
or not there should be a new opcode for arbitrary boolean expressions
involving keypairs.  And people's wallets continue to get lost or
stolen.



-- 
--
Gavin Andresen


-------------------------------------
Yeah, the limited number of slots doesn't help either. I wonder if the
current settings are too conservative.

Your seed returns quite a few IPs that don't respond to ICMP pings - not
sure what is happening there.

03:01:53 scott:~$ for ip in `dig +short dnsseed.bluematt.me`; do echo -n -e
"Testing $ip:   "; ping -c 1 $ip|grep 'packet loss'; done
Testing 24.7.158.162:   1 packets transmitted, 1 received, 0% packet loss,
time 0ms
*Testing 50.19.225.254:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
Testing 67.242.10.199:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
Testing 72.223.56.138:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
Testing 76.92.171.255:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
Testing 76.123.10.117:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
Testing 80.3.173.28:   1 packets transmitted, 0 received, 100% packet loss,
time 0ms
*Testing 80.101.109.52:   1 packets transmitted, 1 received, 0% packet loss,
time 0ms
Testing 93.186.32.117:   1 packets transmitted, 1 received, 0% packet loss,
time 0ms
*Testing 94.19.17.167:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
*Testing 97.86.39.50:   1 packets transmitted, 1 received, 0% packet loss,
time 0ms
Testing 113.255.177.241:   1 packets transmitted, 1 received, 0% packet
loss, time 0ms
Testing 118.208.226.66:   1 packets transmitted, 1 received, 0% packet loss,
time 0ms
Testing 173.180.141.86:   1 packets transmitted, 1 received, 0% packet loss,
time 0ms
*Testing 174.119.14.66:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
*Testing 178.18.129.133:   1 packets transmitted, 1 received, 0% packet
loss, time 0ms
*Testing 193.86.163.77:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
Testing 206.255.99.164:   1 packets transmitted, 0 received, 100% packet
loss, time 0ms
Testing 216.8.180.85:   1 packets transmitted, 0 received, 100% packet loss,
time 0ms
Testing 24.1.117.3:   1 packets transmitted, 0 received, 100% packet loss,
time 0ms*
-------------------------------------
On Thursday, July 28, 2011 2:49:07 PM Gregory Maxwell wrote:

You'll get that error even with the headers installed, because the makefile 
doesn't add the proper include paths to GCC.

To build, I first: sed -i s/static/dynamic/ makefile.unix # because static 
libraries aren't standard on my OS (nor should they be)

Then: make -f makefile.unix DEBUGFLAGS="-I/usr/include/db4.8 -ggdb -O0" \
      -j4 USE_UPNP=1 bitcoind


-------------------------------------
On Thursday, December 29, 2011 12:01:20 PM roconnor@theorem.ca wrote:

So what? Why shouldn't I be able to run random code? I could always put that 
random code in the script verbatim, after all.


-------------------------------------
Hello all,

I just submitted a pull request (#649) that enables the use of compressed
public keys in Bitcoin. As discovered by roconnor (IRC), this is possible
in such a way that old clients verify and relay them without problems.
They are supported by default by OpenSSL, and all alternative
implementations that use OpenSSL should support these keys just fine as
well.

Compressed public keys are 33 bytes long, and contain the same information
as normal 65-byte keys. They only contain the X coordinate of the point,
while the value of the Y-coordinate is reconstructed upon use. This
requires some CPU, but only a fraction of the cost of verifying a
signature.

In theory, one private key now corresponds to two public keys, and thus
two different addresses. As this would probably cause confusion, this
implementation chooses only one of them (at key generation time). All
keys generated when -compressedpubkeys is active, are compressed, and
their reported address is that corresponding to its compressed pubkey.

Things that need attention:
* Do all client implementations support it?
* How to represent secrets for compressed pubkeys?
* send-to-pubkey transactions are untested, for now

-- 
Pieter


-------------------------------------

Sorry! the item duplication was due to the pull. (very stupid me)

The issue with account "" remains.

For coinbase transactions, we may list one "generated" item per txout
that corresponds to an owned address. Accounts would be associated
accordingly, in the same way as for usual "received" amounts. Account
balances would also take into account these generated amounts in the
obvious way.

Would that be ok? I think few people rely on these specific details,
and they would be happy with such a change. Moreover, this would
actually simplify the code a little bit.




-------------------------------------
On Tuesday, September 20, 2011 3:10:16 PM Jeff Garzik wrote:

This is basically what the #bitcoin-stable team wants to do.


-------------------------------------
Hi!

 I can translate it to Brazilian Portuguese.

Best,
Thiago

On 8 October 2011 18:13, Gavin Andresen <gavinandresen@gmail.com> wrote:

-------------------------------------
Reposted from the forums:

makomk reported a remote vulnerability that I pulled into the master
bitcoin/bitcoin tree on December 20. If you are running git-HEAD code
on the production network you should pull the latest code to get the
bug fixed.

This affects only anybody who has pulled and compiled their own
bitcoind/bitcoin-qt from the source tree in the last 5 days.

Gory details:

I made a mistake.  I refactored the ConnectInputs() function into two
pieces (FetchInputs() and ConnectInputs()), and should have duplicated
a check in ConnectInputs for an out-of-range
previous-transaction-output in the FetchInputs() method.  The result
was a new method I wrote to help prevent a possible OP_EVAL-related
denial-of-service attack (AreInputsStandard()) could crash with an
out-of-bounds memory access if given an invalid transaction.

The bug-fix puts a check in FetchInputs and an assertion in
AreInputsStandard. This does not affect the back-ported "mining only"
code I wrote that some miners and pools have started using.

The good news is this was found and reported before binaries with the
vulnerability were released; the bad news is this was not found before
the code was pulled and could have made it into the next release if
makomk had not been testing some unrelated code.

Before releasing 0.6, I would like to have an "intelligent,
bitcoin-specific fuzzing tool" that automatically finds this type of
bug that we can run before every release. If anybody already has one,
please speak up!

-- 
--
Gavin Andresen


-------------------------------------
Who knows, it might be the only way we'll ever hear from Satoshi again.
On Sep 9, 2011 1:21 AM, "Matt Corallo" <bitcoin-list@bluematt.me> wrote:
------------------------------------------------------------------------------
affordable
-------------------------------------
On Tuesday, September 13, 2011 11:06:37 AM Gavin Andresen wrote:

This is not currently reasonable. Rolling extranonce is not efficient, and 
using it to generate work for 400+ GH/s worth of miners every new block 
(longpoll) can easily take seconds. Noncerange helps a little, but has poor 
support presently, and still requires an otherwise-unique work per 4 GH/s.
That only leaves pools with the time header to play with. Furthermore, within-
a-minute accuracy basically forces all miners to rollntime-- I'm not against 
this result, but it does mean many miners and pools will be left out in the 
cold.


Miners already have very limited area to mess around with block times.
My understanding of these attacks is that they somehow bypass the limitations 
in place.


-------------------------------------
I think there's a significant risk to not having it at this stage.  
There's many reasons why an urgent update may been to rapidly propagated 
in this stage of the network's lifecycle.  Perhaps if there's a 
perceived threat of abuse the protocol could be altered slightly so it 
can't carry content.  Only a notification of the fact that there is an 
alert.  Then it would be up to individual clients whether they react to 
it or not.  The main clients would probably check a central trusted 
server for actual alert content.  This would give a lot more flexibility 
in how to deal with the alert.  Alert content servers could for example 
implement a json api to provide alert content with meta data like target 
client version, priority etc.

I think it should be removed in the future but not for a good while yet.

On 09/09/11 00:42, David Perry wrote:
-------------------------------------
On Wed, 2011-08-10 at 12:29 -0400, Gavin Andresen wrote:
We really don't have too many metrics here.  AFAIK the only real metric
keeping place would be my dnsseed (as well as the one run by IO- ) and
they don't look good (I show about 3x as many 0.3.23 nodes listening as
0.3.24, likely due to the rate that 0.3.23 nodes will drop connections,
made worse by recent block size increases).
Very much needed, didn't TD say something about a friend who wanted to
do research in this area?
Sipa had begin looking at doing some redoing of the locking system (to
support more broad stuff like read-only locks, etc) to solve that exact
bug, but I never heard anything about if he actually started writing
code or how far he got.
I was under the impression all that was left on the to-do for 0.4 was
wallet import/export testing and merge (and a few bug fixes like #453),
I agree #319 should be pulled sometime soon, but maybe for 0.4 just the
IsStandard parts in 0.4 as those need to get out first anyway?
Personally, I'd like to see a better bug tracking system used anyway, ie
one with a full feature set, better tagging system, etc (I really hate
github's system here, but moving would be hard...).  Anyway, many of
them are future "would be nice to have things" or a minor or annoying
bug which effects almost no one (or is at least doesnt keep anyone from
using the client) but require a lot of effort to fix.
Would be really nice.  I'm looking to move the jenkins server somewhere
(moving to college means move as much as possible to VPSs instead of my
parent's basement where I can't manage it) but it could allow for pretty
good sanity tests on patches (which they often currently fail) including
unit tests and build tests.  If someone trusted wants to part with a VPS
or can spare some bitcoins so I can grab one myself, it would be much
appreciated (or if someone wants to take over that server, that would be
nicer).
Need to talk here, I started work on splitting the block/transaction
check/store and net with the ultimate goal of making a nice api that
they communicate over (as well as wallet and potentially other) and
allowing for a different block/transaction check module for lightweight
nodes.  It would also mean a bit cleaner codebase which could allow for,
say, a partial rewrite of net code without far-reaching changes.
Whether or not its even a good idea, I don't know, but I've written some
code anyway.
I was under the impression the plan was for this to go in 0.4 aka next
release, but personally, I don't care too much either way.
Sipa did some good thinking through for algorithms that could be really
useful here, but I don't think any code was ever written, nor did he
finish (is he off doing the studying thing?)
Not sure what is meant here.  Personally, I'm animately against any kind
of notification to spread through the network in case of a double spend,
and I really think it double-spend detection could be very efficiently
done now.  I was under the impression block-chain splits were fairly
efficiently handled already?


Matt
-------------------------------------
On Fri, Sep 2, 2011 at 8:12 PM, Gavin Andresen <gavinandresen@gmail.com>wrote:


Great, congrats!

The mutex overhaul was badly needed. I'm glad to see the project move this
fast in a sudden.

JS
-------------------------------------
Payward Inc. has submitted the following draft to the IETF:
 https://datatracker.ietf.org/doc/draft-imic

Abstract:
   An Internet MIC (IMIC) identifies an internet-based financial market
   in a manner that is superset-compatible with the ISO's existing
   Market Identification Code (MIC) standard [ISO10383].

Regards,
Walter Stanish
Payward, Inc.


-------------------------------------
Gregory Maxwell wrote:


Thank you!  (I think you mean 319 here)


With Eligius mining !IsStandard transactions and probably other pools open
to the idea, I am hopeful that we can quickly get 30%+ of mining power to
upgrade, which means that we could still mine these in a reasonable time
frame (under 1 hour).

...


I'm not sure I see the problem here.  CScript.operator<< currently inserts
values into scripts using the shortest possible sequence.  As long as code
continues to conform to this convention, scripts generated by it will
verify correctly.

If new code is written that generates one of the longer sequences, it will
generate transactions that will not pass block validation since the
signature won't verify.  So such code will be useless and we can refrain
from writing it?

--
Bobby Groff





-------------------------------------
Cool thread. I enjoyed reading that :) Thanks for sharing.


________________________________
From: Christian Decker <decker.christian@gmail.com>
To: Amir Taaki <zgenjix@yahoo.com>
Cc: "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Wednesday, November 2, 2011 10:42 PM
Subject: Re: [Bitcoin-development] Lock protocol version numbers


Just for reference: https://github.com/bitcoin/bitcoin/pull/63
The issue resulted in my most useless pull request fixing two variables :-)

I second the use of sub_version_num as a Client and Version identifier.

Regards,
Chris


On Wed, Nov 2, 2011 at 11:33 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

Point taken.
-------------------------------------
I like this a lot. It's very simple to understand and would be very
easy to implement and set up.

"Sure, send it to david.bitcoin.se".

D.H.


-------------------------------------
Bitcoin v0.3.24 release candidate #1 is now available for download at
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.24/test/

This is another bug fix release.  We had hoped to have wallet
encryption ready for release, but more urgent fixes for existing
clients were needed.  Wallet encryption is ready for testing at
https://github.com/bitcoin/bitcoin/pull/352 for the git-savvy, and
-hopefully- will follow shortly in the next release, v0.4.

Notable fixes in v0.3.24:

F1) Block downloads were failing or taking unreasonable amounts of
time to complete, because the increased size of the block chain was
bumping up against some earlier buffer-size DoS limits.
F2) Fix crash caused by loss/lack of network connection.

Notable changes in v0.3.24:
C1) DNS seeding enabled by default.
C2) UPNP enabled by default in the GUI client.  The percentage of
bitcoin clients that accept incoming connections is quite small, and
that is a problem.  This should help.  bitcoind, and unofficial
builds, are unchanged (though we encourage use of "-upnp" to help the
network!)
C3) Initial unit testing framework.  Bitcoin sorely needs automated
tests, and this is a beginning.  Contributions welcome.
C4) Internal wallet code cleanup.  While invisible to an end user,
this change provides the basis for v0.4's wallet encryption.

Full changelog ("git shortlog v0.3.23.."):

Dawid Spiechowicz (1):
      added polish translation

Doug Huff (1):
      Add OSX App bundle and correct build instructions to reflect reality.

Eric Hosmer (3):
      Updated Visual C++ makefile.
      Further updated Visual C++ makefile.
      Add keystore.h to makefile.vs's header list.

Gavin Andresen (1):
      Boost unit-testing framework.     make -f makefile.{unix,osx,mingw} test_b

Giel van Schijndel (2):
      rpc server: send '403 Forbidden' to rejected clients
      rpc: don't send 403 when using SSL to prevent DoS

Han Lin Yap (3):
      Double check translation and improved a translation string
      Update swedish translation
      Consistent Bitcoin example address

James Burkle (1):
      Edited init.cpp to include a check that -datadir exists

Jeff Garzik (6):
      FormatFullVersion: build fix related to recent translation improvement
      doc/release-process.txt: minor updates
      CWalletTx::GetAmounts(): pass NULL for CKeyStore*, rather than false     t
      Enable DNS seeding by default.
      Bump version to 0.3.24.
      Bump OSX version to 0.3.24 (missed in previous commit)

Joerie de Gram (1):
      Fix connection failure debug output

Jordan Lewis (8):
      Only include irc.h when needed
      Only include db.h when we have to.
      Only included rpc.h when necessary
      Only include net.h when we have to
      Only include init.h when we have to
      Only include strlcpy.h when we have to
      Remove some globally unused headers from headers.h
      Only include certain boost headers if necessary.

Matt Corallo (5):
      Update translations and remove obsolete translations.
      Add new DNSSeed dnsseed.bluematt.me.
      Only use dnsseeds and static seeds when not on testnet.
      Make UPnP default on Bitcoin but not on Bitcoind.
      Give more detailed error messages for connection failure.

Pieter Wuille (5):
      move wallet code to separate file
      CWallet class
      Bugfixes walletclass
      Fix segfault when creating new wallet
      Limit response to getblocks to half of output buffer size

Shane Wegner (1):
      Fix missing includes needed for Boost 1.46.

Stphane Gimenez (1):
      Fix AddressBook syncrhonization between a CWallet and CWalletDB

Wladimir J. van der Laan (1):
      add GetTotalBlocksEstimate() function, move magic number to constant

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

5340ee00a777e5b87a0d742ea931760916a1fac4  bitcoin-0.3.24rc1-linux.tar.gz
f7f941a4fc33da7225262ccaad6147352dd2b342  bitcoin-0.3.24rc1-src.tar.gz
efcdf578bb60a056c43f8dd40505461ea7d7c930  bitcoin-0.3.24rc1-win32-setup.exe
0b2560b3facba4301562441f6b8dea9eb2249d77  bitcoin-0.3.24rc1-win32.zip
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIVAwUBTg/c7Nodwg8tvwyoAQIptA/+M4fSPxk994B2+CeVGX3lt0MzxQpaNpJN
elZjgf2E7gp6sBFxkDGeL2ZtWl9Txswco8UzrehVCY8ne7Q2FrBWgXs6wibwLlWb
La0ll2rA8iGysyJPgd9exaN97Etq/onBjxDYHmlKYLeH/VFdIj3LfO2CWPBGRayD
QqQzT59glNqObLN81Bnj0nHChZS682ycsgT+iGppCeynz5URhxO0IZ3FCj0PFnW1
jbUki5gTCgiuDth7ADymfd/lqN3LeZJYppd9BzjrSSUTujwvhyPUppfUMoYV8Tm+
Tg/zskTRiYcTxE182lmTYH1vKGSV8AQ5wT0JkB/HbhXqMRJgMr5Fly8tJqYKKeg9
XQvP2l0flcsUuzCecFiYeltc74P4dSe04EzYStavfYYdrW6ftkWk08yfeLb7owOI
aPgXGJkUTsWIu/Ld4GrvdXtlSeuowXkjhdjiKTgBzKuWl8KGOLVSFLmFz24LBYjK
FUxLmc1S2p71kQ2Aq+t97WhA7FKpLbf2TmHAv2KobujWDCIzJ96duGbvZpg1bYNy
Np58E31x2gGTJ7Wswddhs0ZSnIcEvZ5U6bohlpzPTKXLUxEFtg1ERoYWt/htjTCV
DKV2I6VpBww2U9atOiIe93+O6f9aYDro9HQXsLeyFHbgx//2fiuHzsvWwIoey/k4
zeUIPUe5TQk=
=O8dr
-----END PGP SIGNATURE-----


-------------------------------------
Anybody know how to contact MT about getting it back online? I still haven't finished copy-editing the BIPs and need access to them since there's a new one to be added.
-------------------------------------
Hey Andy,

Bitcoin already does something which in practice has exactly this 
effect: If a transaction is reversed, any transactions based on its 
outputs are rejected.

Hosted wallets can make use of this - but as you correctly point out, 
depending on the service, it can get tricky. What if I exchange the 
money to USD and back before withdrawing? You could have an algorithm 
where MtGox prefers to spend outputs from your own deposits as the 
inputs for your withdrawals, it's not trivial though and never 100% secure.

I have trouble thinking of a good example where you need an explicit 
block dependency as you describe. The only times you'd want to use this 
dependency of transactions on specific previous transactions is when you 
can clearly and easily associate the money. But if you can clearly and 
easily associate the money, you might as well just relate the 
transactions (use the outputs from the deposit transaction as the inputs 
of the withdrawal transaction.)

This is btw something that would strongly agree with: Hosted wallets 
should absolutely keep each account as separate public keys. With that 
you lose free and instant internal transactions, but you gain instant 
deposits and much better risk isolation.

This is just my view. Thanks and keep the thought-provoking stuff coming!

Cheers,

Stefan

On 12/8/2011 11:47 AM, Andy Parkins wrote:



-------------------------------------
On Fri, Dec 16, 2011 at 21:10, Amir Taaki <zgenjix@yahoo.com> wrote:

Well, I'm not an expert like you, but one benefit would be to be
compatible with existing software solutions that are based on using
IBANs.

H


-------------------------------------
Hey,

The Zen of Python is relevant here: http://www.python.org/dev/peps/pep-0020/

"In the face of ambiguity, refuse the temptation to guess."

If a node incorrectly implements the standard then it should be shunned immediately. Not only is this more secure, but it will ensure long term compatibility between different implementations. Gavin argues that being a bit lenient makes it easier for people working on other implementations.

I'd argue the opposite being the only person that's working on a full node implementation. Lucky I know my way around the code, so I don't have to guess. But if I did not things would be much harder. Imagine you're trying to interact with this protocol and then randomly it will suddenly disconnect you because of accumulated errors that have been building up.

Everything should be strict, explicit, unambiguous and loud.

I propose a new message type: "error" Payload is a uint64_t error_code and var_str reason.

Before disconnecting a node you can send it an error message. The error_code is the main class of error- i.e version_sent_twice. Reason is just an implementation specific string that can add context.

Other possible fields:
uint8_t seriousness (debug, info, warning, error, fatal)
uint8_t action_taken (disconnect, blacklist, .etc)



-------------------------------------
On Thu, Jul 28, 2011 at 2:43 PM, Alan Grimes <agrimes@speakeasy.net> wrote:

There is a 'vanity version' that removes the use of libdb or somehow
magically requires you to not have its development headers installed
on your system?


-------------------------------------
On Tuesday, December 13, 2011 6:07:17 AM Mike Hearn wrote:

Bitcoin-Qt 0.6 will include a QR Code generator.


No, not really. I've found that dragging and dropping links manages to corrupt 
them most of the time.


-------------------------------------
On Sat, Dec 17, 2011, at 02:06 PM, Gavin Andresen wrote:

This seems likely. Also, even if many full nodes are willing to donate
resources, there may simply be too few full nodes to handle the load.

My preferred solution for handling scalability in the future is to
have lightweight clients download only headers and Merkle trees (which
are both small and easy to distribute), and then require senders to
contact recipients directly in order to transmit their transactions.
Then lightweight clients never need full blocks to build their
balances, and full nodes don't have to handle expensive queries from
lightweight clients.

Under this scheme, the current broadcast system could be used among full
nodes for a long time. Since clients wouldn't ever need to talk to full
nodes, they could form a separate network with less reliable
broadcasting and perhaps a fancier network architecture. Members of the
full network would connect to the most reliable members of the client
network in order to broadcast headers and Merkle trees and receive
transactions. Full nodes would *not* answer any client queries, so
dealing with the client network would not require many resources, and
miners would probably have an incentive to do it. (Creating a "separate"
network like this can be done by using the services field.)

I don't think requiring senders to email some data to the recipient
would be too burdensome, though it's probably also possible to design a
system where even offline recipients can receive transactions through
the Bitcoin network.


-------------------------------------

I agree that these are critical and I'd love to help, especially on #2 and
#3.  #3 will, by necessity, include a thorough review of the code, which
may uncover latent issues.

I think that for #2 it would also be good to publish a "Best security
practices" document to try and educate the user base.


That is understandable.  However, something to think about later is that
multi-signature coins can help with #2, even with compromised end-user
machines.

--
Bobby Groff





-------------------------------------

Probably.

How many connections "should" a node use? We faced this decision in
BitCoinJ recently and I asked the patch writer to reduce the number.
It seems pretty arbitrary to me - if you aren't going to relay, a
single connection should be good enough. Yes, it makes sybil easier,
but if you pick the one node randomly enough it might be ok?


Hmm, I don't recall ever enabling it in my router but it's on and the
Bitcoin support works. UPnP is used by all kinds of common programs
like Skype and Xbox Live.


-------------------------------------
On Tue, Sep 27, 2011 at 4:08 PM, Luke-Jr <luke@dashjr.org> wrote:

Might be better to have a global flag that indicates when the node
thinks its current with the network (this could have other UI impacts,
like letting the user know if they send and their connectivity looks
non-current), and only enforce this check when the node believes that
its current.

Currency could be
=height>last_checkpoint&&top_timestamp>now()-safe_amount;  with
safe_amount to be high enough that it's very unlikely to be falsely
triggered by an improbably long gap.


-------------------------------------
On 2011 December 08 Thursday, Stefan Thomas wrote:


That part is fine; I was aware that Bitcoin did this.  How could it not?  The 
transactions form multiple signature chains of their own.  It impossible to 
have a transaction depend on a non-existent input transaction.


Quite so; this is essentially the problem my suggestion addresses.  What do 
you do when a transaction is dependent on another transaction financially but 
not technically?  That is to say that your accounting software would show a 
credit and a debit to a particular entity, but the bitcoin block chain would 
not.  In the old world we might do this as "I'll write you a cheque and you 
give me cash"; if that cheque bounces, you've lost your cash.


The MyBitcoin debacle (if we are to believe their reports) would have been 
avoided by my suggestion.  They were accepting deposits in one chain, and 
allowing withdrawls from another.  That meant that while there was a financial 
connection, there was not a bitcoin-connection.  The withdrawls happened from 
the pool address, most likely well funded, so were valid on either chain.  If 
MyBitcoin had been able to broadcast the withdrawl transactions as being based 
on the same chain as the deposit (even though it was not using transactions in 
that chain) then the attack would have failed.


I'm not sure I agree.  There is certainly a case for both types: one-to-one 
correspondence between address and account has the advantages you list but is 
highly identifiable and trackable.  However the disadvantage is that all funds 
would have to be kept online.  Places like Mt.Gox can (although there is 
evidence to suggest that they don't, tut tu) move the majority of the funds to 
five USB sticks, and keep them in five fire-proof safes or deposit boxes or 
whatever only because deposited funds are pooled.


Thanks for the encouragement.  It's appreciated.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Hi Doug,

Could we keep the Mt Gox related stuff off bitcoin-development please?
It's not related to the core software.

On Tue, Jun 28, 2011 at 4:48 AM, Doug Huff <dhuff@jrbobdobbs.org> wrote:


-------------------------------------
Payward Inc. has submitted the following draft to the IETF:
 https://datatracker.ietf.org/doc/draft-iiban

Abstract:
   An Internet IBAN (IIBAN) identifies an internet-based financial
   endpoint in a manner that is superset-compatible with the existing
   European Committee for Banking Standards (ECBS) International Bank
   Acccount Number (IBAN) standard [ISO13616].

Regards,
Walter Stanish
Payward, Inc.


-------------------------------------
Bright and early Monday morning I plan on pulling changes for the
Bitcoin 0.5 release into tip-of-git. Expect some tip-of-git chaos and
instability, I'm sure there will be issues to work through to move
from wxwidgets to qt for the GUI.

I'd like to have a release candidate ready in a week or two, giving
time for a week or two of testing, and have the 0.5 release available
a month from now, assuming no major show-stopper bugs or network
stability or denial-of-service or security vulnerabilities turn up
between now and then.

-- 
--
Gavin Andresen


-------------------------------------
Bitcoin seems to have a relatively unique problem, there is a perception that there are early adopters who still have large stashes of btc.
Not that this is wrong, they knew a good thing early, the problem is that it is hard for someone (me) to justify volunteering work on a codebase which will directly benefit other people even if they do nothing.
As far as trying to bring these people together, I don't have any silver bullet answers but I think there needs to be some kind of sponsorship of developers. I2P uses bounties but they are indeed a small community, I can see bounties going very wrong but I suppose it doesn't hurt to experiment. I think grants for active developers make more sense, then we only need someone to decide who is active enough.
Also moving in the direction of seperating bitcoin the program from Bitcoin the blockchain and accepting patches for merged mining and alt chain stuff which doesn't directly benefit Bitcoin would help decrease the "people are making money off of my back" feeling that (IMO) stands in the way of new developers.

Caleb


On 07/27/2011 08:15 PM, Jeff Garzik wrote:



-------------------------------------
Given that there was not a single response to my post, I gather there is
no to little interest in an updated MinorFs that could be used by bitcoin
on systems that support AppArmor (Ubuntu and OpenSuse).

Nevertheless I've put down the initial set of specs for a rewrite of
MinorFs for if anyone would like to comment on them to make a future match
with Bitcoin more likely, I'm open to all sugestions:

http://minorfs.polacanthus.net/wiki/Concepts_for_MinorFs2

On Fri, August 26, 2011 09:48, Rob Meijer wrote:




-------------------------------------

Agreed.

That said I'm not sure it makes sense for payers to care about the
details of how somebody is protecting their wallets (which is what new
address types means). It's possible for a users software to notice
inbound payments to a regular Bitcoin address and then immediately
respend them to multi-signed outputs. This way key management can be
simpler as you don't need to integrate it with your shopping cart
software or anything like that - you can just do the usual thing of
pre-generating a few hundred thousand addresses, fill up your cart
implementation and go. When a payment is received, your wallet
software can keep an eye on how much unlocked balance it has and start
locking value once it goes over a pre-set amount, or use any other
policy the user might have.

This fits with my belief that we'll eventually move away from senders
attaching tx fees, instead receivers will respend the fee-less
transaction adding whatever fee they believe is appropriate (eg, maybe
it's very low in the case of a buyer with good reputation, or higher
for unknown buyers). It doesn't make a whole lot of sense for buyers
to have to attach more fees just because the merchant is using complex
wallet policies.

Whitelisting the basic CHECKMULTISIG form (assuming it can be made to
work) seems uncontroversial, why not do it today? The forms designed
to make fancier addresses be embeddable inside QRcodes, can come later
if people feel it's necessary. I'm still not convinced it is.

Once malware can't just email wallets to the attacker, or steal the
keys when the user decrypts due to a second factor, the next easiest
attack is to that malware can rewrite addresses on-screen as it sees
fit, forwarding small payments so the user doesn't notice then
stealing a big one. To solve that, Bitcoin addresses need to contain
not only a pubkey[hash] but some kind of endpoint the second factor
can use to verify ownership of the key. It can be discussed later, I
don't think there are many possible designs here so it shouldn't be
too controversial.


-------------------------------------
Hi there!

As part of my green address endeavor, I'm currently trying to extend the
'gettransaction' call to include an extra field "inputaddresses" which
should return a list of the Bitcoin addresses associated with the inputs
of the transaction.

I understand that this is not generally possible, because of the different
possible structures enabled through the scripting language. But it would
be fine, if this only worked for 'regular' transactions.

So my first shot at this is to go through the inputs of a transaction and
see if the scriptSig field has only two opcodes. If that is the case, I
assume that it is of the structure <sig> <pubKey> and calculate the
Bitcoin address from <pubKey>. The patch for this is here:

https://github.com/javgh/bitcoin/compare/vps_wheezy...showinputaddresses

But then I started to wonder if this is safe. Can this be tricked somehow?
Would it be possible to create a valid transaction which has an input that
has only two opcodes but with an arbitrary pubKey at the second position?
Could someone who has a better grasp on the scripting capabilities comment
on this?

Or alternatively: should I determine the input addresses of a transaction
in a different way? if so, how?

Regards!
Jan


-------------------------------------
On Wed, Jul 27, 2011 at 4:07 PM, Rick Wesson
<rick@support-intelligence.com>wrote:


Bounties would be much less than a developer salary. The idea is not to pay
for people full time, but it would be more of a symbolic gesture to attract
developers and get them some coins.  People with coins are also more
motivated to make the project more valuable, otherwise you have a "tragedy
of the commons" problem.

Not that I don't agree Gavin with getting a salary but that's a completely
independent issue :)

JS
-------------------------------------

My own preference would be to fail hard with detection of the problem
and notification of the user if there's a GUI connected and/or running.

- Joel




-------------------------------------
I think the scope of this BIP is not so well defined right now. We need a
way for merchants to translate a human readable, and more importantly
human-writeable, address into a bitcoin address. I agree with Mike that a
fixed address is not the way to go, because addresses should be used once
for a single transaction to be able to track payments.

While firstbits sounds attractive at first, I think we can all agree that
it just isn't feasible and would not allow per-transaction addresses. DNS
sounds interesting for fixed addresses, but caching and propagation make it
difficult to use for per-transaction addresses that are to be generated
ad-hoc.

HTTP(S) is the best option I think, merchants are probably using HTTP
anyway for their shops. So something like
http://merchant.com/btc/transaction/1234 sounds reasonable. But I think it
should not be over-engineered, it should be a simple HTTP(S) request to a
merchant specified URL that returns an ASCII document containing either a
bitcoin: URI or simply the bitcoin address or even a 301 redirect. It's no
use to start defining URL schemes, it should be left to the merchants to
define how to structure them.

This would allow a merchant to decide if he prefers per-transaction
addresses, per-user transactions, fixed addresses or any combination.

Regards,
cdecker


On Tue, Dec 13, 2011 at 11:55 AM, Mike Hearn <mike@plan99.net> wrote:

-------------------------------------
Are there any PGP key servers that support EC key pairs?  OpenPGP Spec
RFC2440 defines key types for EC, just not sure if they were ever
implemented on the keyserver side.  Could even have a similar 'web of
trust' using private keys to sign people's identities similar to PGP.

Will

On 12 December 2011 23:16, Zell Faze <zellfaze@yahoo.com> wrote:

-------------------------------------
Lets look at:

https://en.bitcoin.it/wiki/Infrastructure

This is OK as a super high-level overview, but it leaves a great deal to 
be explained.

First what is the status of this? Is it fully implemented? A working 
proposal? An approved proposal? etc...

I am working on the peer and the wallet boxes in this diagram. I want to 
implement my own version because the existing code is completely 
untrustworthy, it is totally slap-dash and almost completely uncommented.

My questions related to the peer are these:

It is taken for granted that the peer will have a listening component 
that accepts connections from other peers.

Does it also have an active component? If so, what operations does it 
perform autonomously?

/me looks at wallet.h and GAH!! Someone reversed the concept of debit 
and credit! =( (GetDebit(), GetCredit())

Interesting... What is the exact relationship between the wallet and the 
miner? (The miner is irrelevant to me until I have a wallet I can trust 
enough to experiment with...)

After reading the dox on libdb, I'm leaning towards an inetd 
implementation. That is, inetd handles all the dirty work with regards 
to connections, and spawns off a server for each client. This minimizes 
the quantity of code at the cost of a wee bit of overhead (maybe 10k per 
process). Basically, the penguin acts like the KoAC in Katamari Damacy, 
if you don't do it in the regal old-fashioned way, he rains down 
thunderbolts on you and you get to write 3 or 4 times as much code.

The upside is that each peer is served by a single completely isolated 
process with extremely simple and highly auditable code.

A general problem that I haven't seen any documentation on yet is that 
most of today's operating systems are properly multi-user systems. 
Naturally, each user would keep his wallet in an encrypted store in his 
home directory. Are there any standards yet for users to set up their 
personal wallet daemon that connects to a system-wide peer node and 
provides an interface for only their own GUI?

-- 
E T F
N H E
D E D

Powers are not rights.



-------------------------------------

Agree, that is why we need to keep the different A.B segment requirement as is also imposed in the client today.


I agree that in practice the thinner nodes would most likely just serve as cache, but they need notification on tx'es involving some of their tx outs or involving some of theirs bitcoin addresses. Today there are some designs that operate with a thin client that connects to a (web)server and subscribe to listen for transactions involving a specific bitcoin address. By letting that be a part of the hash space including that address you would not reveal your address to the server and we would keep a true p2p setup.

Best regards,

Michael




-------------------------------------


User-agent strings are a good starting point, however they aren't easy for parsing so we'll make a small modification to them.

We need a hierarchy from protocol, variant, gui, flavour, build

/Satoshi:314700/bitcoin-qt:0.4/

How does that sound? In BitcoinJ's case:

/BitcoinJ:0.2/AndroidBuild:0.8/

Thoughts:

- Do we need a freely defined comments field?

/BitcoinJ:0.2[iPad; U; CPU OS 3_2_1]/AndroidBuild:0.8/
/Satoshi:314700/bitcoin-qt:0.4[Ubuntu Oneiric]/



________________________________
From: Christian Decker <decker.christian@gmail.com>
To: Mike Hearn <mike@plan99.net>
Cc: Amir Taaki <zgenjix@yahoo.com>; "bitcoin-development@lists.sourceforge.net" <bitcoin-development@lists.sourceforge.net>
Sent: Saturday, November 5, 2011 2:45 PM
Subject: Re: [Bitcoin-development] Lock protocol version numbers


On BitDroid I stopped updating the protocol version at 31700 and set the string to be both Version and Client, just like BitcoinJ :-)


On Sat, Nov 5, 2011 at 3:32 PM, Mike Hearn <mike@plan99.net> wrote:

BitCoinJ already sets the subver field to its name and version.
-------------------------------------
Hey,

Thought you might enjoy this/find it useful.

https://bitcointalk.org/index.php?topic=50994.0

Some tools for messing around with the network.
-------------------------------------
On Wednesday, September 14, 2011 9:57:00 PM Gavin Andresen wrote:

"Non-standard" transactions, or those with "insufficient" fees should not be 
penalised. These are properly relay/miner policy decisions, not protocol 
violations, and should be made more easily configurable, not punished for 
configuration.



-------------------------------------
theymos' full node and lite node write up got me thinking.

There are two problems here that we are trying to solve:
- The scalability of broadcast messages.
- The resources required to sync and verify the block chain.

I see three distinct groups of clients:
- Miners (dedicated servers & desktops)
- Full (desktops)
- Lite (mobile devices)

To address scalability of broadcasting, there could be three separate 
modes of operation (or client types). Mining nodes would retain the 
complete block chain, and share all messages between other mining nodes. 
Full nodes would retain the complete block chain, receive new block 
information from mining nodes, and share block data between each other. 
Lite clients would not contain the block chain, or any broadcast 
messages, and would query against a full client for all actions.

Mining nodes would handle the brunt of the barrage of messages. All 
block and transaction messages would have to be broadcast across all 
mining nodes. This would be essentially the same as all clients 
currently operate today.

A full client would be one step down from a mining client. They only 
need new block data, and new transactions that pertain to them (for 
instant notification). All other broadcast data is irrelevant to them. 
They would get new block data from connections to mining nodes, or from 
other peer nodes. The transaction submission could be sent directly to a 
connected mining node, or bounced through other connected full nodes, 
with a random number hops. This would disassociate the IP from the 
transaction, similarly to Tor.

To address the need for instant transaction notification, without 
broadcasting to to everyone, notification messages would be sent 
directly from one full client to the other. This is where aliases come 
in. When an alias is resolved, it includes both a Bitcoin address, and a 
list of IPs to notify of the transaction. This reveals the IP of the 
sender and receiver to each other. If the sender or receiver wishes to 
remain anonymous, then they could opt out of notification, and wait for 
the transaction to appear in the block chain.

A lite client would connect to a "trusted" full client over an encrypted 
connection. This would essentially function as a remote control to a 
full client, and allow a user to send, receive, and confirm normally, 
but without the overhead. A full client could reside on the home 
computer or server, which is owned by the user. A hosted wallet could 
also be used just as easily.

I don't like the idea of a header only client, unless this is just an 
interim action until the full block chain is downloaded in the 
background. Development of these types of clients is probably 
inevitable, but I believe that this breaks the most fundamental aspects 
of Bitcoin's security model. If a client has only headers, it cannot do 
full verification, and it is trusting the data from random anonymous peers.




-------------------------------------
On Wednesday, September 14, 2011 4:09:00 PM Gregory Maxwell wrote:

I don't support this, unless all other chain-forking-needed changes are made 
at the same time. I do point out that changing the time rules *does not help*.


The rest don't generate rewards immediately as the same block being mined. 
They either eat the loss of invalid blocks, or wait for 100+ confirmations 
before paying. Also, restricting the time rules basically breaks miners 
without rollntime support (such as Phoenix).


-------------------------------------
On Tuesday, September 13, 2011 12:48:58 PM Douglas Huff wrote:

I didn't recommend storing private keys on NAND. The USB stick would contain 
only the transaction that it being approved, and the offline-signing-wallet 
would sign it. The USB stick then contains only the signed transaction to be 
returned to an online node. At no time does it contain keys.


-------------------------------------
Actually no, the same string may have to be translated in different ways
depending on the context they appear in. That sometimes happens for italian,
and I'm sure it happens in other cases too. Not sure whether this is the
cause for duplicate strings for now, but it might.

Regards,
Chris

On Sat, Oct 22, 2011 at 6:14 PM, Geir Harald Hansen
<operator@bitminter.com>wrote:

-------------------------------------
On Tue, 2011-10-04 at 16:40 -0700, Brian McQueen wrote:

(from
http://stackoverflow.com/questions/2293962/boost-libraries-in-multithreading-aware-mode)

The -mt suffix means built in multithreading aware mode (what this means
for a threading library I have no idea), however that suffix was removed
from Linux and Mac builds in 1.42.  If you are linking against 1.42+ on
Linux/Mac, adding/removing the -mt suffix means nothing AFAICT.

Matt



-------------------------------------
ACK'd for 0.6:
585   Added Caps Lock detection to askpassphrasedialog.
569   Coinbaser
669   Multisignature and OP_EVAL support
629   QR Code generation via libqrencode
582   Bitcoin-Qt signmessage GUI

*** All of the above are available merged in my personal 'next' branch:
***     https://github.com/luke-jr/bitcoin/tree/next

Possibly good for 0.6:
454   Add -keepnode which attempts to -addnode and keep a connection open
570   Specify fees explicitly via JSON-RPC
673   Store fewer time samples
649   Compressed pubkeys
593   Full URL Support in bitcoin-qt

*** All of the above are available merged in my personal 'next-test' branch:
***     https://github.com/luke-jr/bitcoin/tree/next-test

Needs more review/support:
427   IPv6 support (lots of complicated conflicts merging)
568   Multithreaded JSON-RPC with HTTP 1.1 Keep-Alive support
565   FastGetWork optimization
555   SIGUSR1 new block notifications
415   advanced anonymity features: send from address(es), view address
      linkages, view all addresses
358   Address Book related Fixes


-------------------------------------
Gavin asked me to come up with an alternative to OP_EVAL, so here is my 
proposal.

OP_CODEHASH Initial Proposal

The idea is to add third "codehash" stack to the scripting engine (or 
alternatively a codehash state variable) and have OP_CODESEPARATOR in 
addition to its current behaviour push the hash of the remaining code in 
the script onto the codehash stack (or alternatively set the codehash 
state variable).

Then we add a new OP_CODEHASH operator that pops the codehash stack and 
pushes it onto the main stack (or alternatively push the value of the 
codehash state variable onto the mainstack which is initialized using the 
hash of the sigScript).

The new send-to-script transaction would be:

OP_CODEHASH OP_HASH160 {20-byte-hash-value} OP_EQUAL

Which can be redeemed by

{20-byte-code-hash} signatures OP_CODESEPARATOR code


When run the code will consume all the signatures leaving the 
20-byte-code-hash on the stack.  When OP_CODEHASH is interpreted as a NOP 
it is skipped, then the hash is hashed and compared to the 
20-byte-hash-value and a match is required to succeed.

When OP_CODEHASH is interpreted by a new client it pops the codehash stack 
and pushes the value onto the main stack, which in this standard 
transaction pushes a value identical to the existing {20-byte-code-hash} 
on the stack. Then again this hash is hashed and compared to to 
{20-byte-code-hash}.


This proposal covers all the desired behaviour from OP_EVAL proposal but 
with a less radical change:
   (1) you get send-to-script addresses
   (2) you cannot redeem with the old client without knowing the hash of the script

OP_CODEHASH has no dynamically generated code that is executed.  The 
language remains a weak stack based language which is clearly terminating. 
The number of operations executed is still bounded by the number of 
operations occurring in the script.  With the OP_EVAL proposal the script 
language becomes essentially Turing complete, with only an artificial 
limit on recursion depth preventing arbitrary computation and there is no 
way to know what code will run without executing it.  With the OP_EVAL 
proposal there is no way to statically analyze the script (say to count 
the number of uses of OP_CHECKSIG or OP_MULTICHECKSIG or other analysis) 
without actually executing the script.

This is just an initial proposal there are clearly some variations that 
could be done that would work just as well.

Thanks goes to luke-jr and others for their thoughts on this proposal.

Good night everyone.

-- 
Russell O'Connor                                      <http://r6.ca/>
``All talk about `theft,''' the general counsel of the American Graphophone
Company wrote, ``is the merest claptrap, for there exists no property in
ideas musical, literary or artistic, except as defined by statute.''


-------------------------------------
Pieter Wuille wrote:
This may just be me, but this really looks like an incredibly convoluted 
way to solve a bunch of problems that aren't really problems.  The 
central issue that I see, is that you assume that there is no out of 
band channel, as if people were just sending transactions to addresses 
that came to them in a dream.

I think that this assumption is only true when it doesn't matter.  For 
example, I have a donation link in my sig on the forums.  I don't care 
much who sends to it, or why, and I certainly don't need annotations or 
a refund address.  The rest of the time, payments are sent to addresses 
that already have sufficient context.

Only one of the advantages listed is actually an advantage.  That is 
that payments to stale addresses can be stopped.  This isn't much of an 
advantage though, as someone blindly sending payments (donations, 
really) to addresses found on backup tapes and web archives without 
verifying that they are still current kinda deserve what they get.  So 
it really only stops payments to services that go defunct the same day 
(more or less).

In the end, I just don't see the value in giving a URL so that I can go 
ask a server for information that could just as easily have been encoded 
in the URL directly.

Then again, I'm cynical, and didn't sleep very well last night.  Maybe 
the next person will think better of it.


-------------------------------------
On Mon, Nov 07, 2011 at 10:27:57AM -0500, Luke-Jr wrote:

In chains where no timejacking attack is going on, yes. In the common case
the timestamp is limited to a range of [5 blocks in the past ... 2 hours in
the future].

However, during a timejacking attack, the timestamps of multiple-of-2016 blocks
are essentially independent from the others. In such a case, most timestamps are
very low, and only those of multiple-of-2016-blocks correspond to the current time.
Each 2016*N-1 to 2016*N transition incurs an arbitrary large forward shift to the
present time, each 2016*N to 2016*N+1 transition does a time shift backwards again
that is allowed because the median allows single outliers. By fixing the timestamp
occasionally more tightly to the maximum, instead of the median, no such time
lapses are possible.

Updated proposed rule: limit the timestamp of multiple-of-2016-blocks to
[max(past 11 timestamps)+1 ... current_time+7200], essentially just using a maximum
instead of a median. I believe that is enough to prevent the attack.

-- 
Pieter



-------------------------------------
On Thu, 2011-09-08 at 07:42 -0700, David Perry wrote:

The alert system requires a signature verification when it receives an
alert, but so do blocks and transactions so it really isn't a DoS target
(remember that the alert system requires alerts to be signed by a key
that only gavin and satoshi have).

The alert system could prove very, very valuable.  In much software it
carries the risk for abuse or simply seems wrong that the developers can
send a message to everyone's computer to notify them of something, but
keep in mind that Bitcoin is financial software.  If there is an urgent
problem (like the overflow bug) there must be a way to notify people to
upgrade immediately, which is exactly what alerts provide.  Since alerts
no longer carry the ability to put Bitcoin into RPC safe-mode, they are
literally just a message and I see no reason why they should be removed.



-------------------------------------

He didn't. Satoshi told me very little unfortunately. What he did tell
me, I've written up about half of it. I still have high frequency
trading and some details of obscure SIGHASH types to go, but I wanted
to find examples to illustrate them first as Satoshi only gave the
vaguest of outlines.


CHECKMULTISIG allows up to 20 keys, I think. So it'd probably be
better to just have a bit of custom logic that checks if the script is
of the right form.


I suppose they could be added if need be. Template matching opcodes
might come in useful later when clients only want to download
transactions of interest to them.


Given the costs involved with adding new transaction types, I'd go for
allowing any number of signatures up to the max.


I don't understand what this is for. For triggering such a transaction
via the UI, I think establishing a higher level protocol would be
needed. It's a separate step.

For instance, it's not safe to use escrow until you've checked that
the escrow key is owned by who you think it is. Otherwise a buyer
could give you a 2-of-3 transaction where they own both keys. So there
needs to be some kind of protocol (probably HTTP based) where the
buyer communicates to the merchant a list of acceptable escrow
agencies, the merchant intersects with the list of agencies it
accepts, there needs to be a way to request a pubkey from a remote
domain, one side needs to be able to challenge that domain with a
nonce, etc. It's quite complicated and would need to be specced out
independently of supporting multipay transactions.


Yes it's one way to achieve security. Having BitBanks that store your
coins and require you to verify tx acceptance with an external device
is even stronger, because that external device can be guaranteed
virus/clone-proof. Some banks do this today for wire transfers (they
implicitly assume you get the wire details out of band or that no
virus can rewrite wiring instructions to point somewhere else).

But it'll be a while yet before any such company arises. Until then
2-of-2 transactions are probably a good halfway point.


-------------------------------------
Hi everyone,

I spent some time today with the bitcoin-qt client and autotools on mac. The qt client builds and runs with a few small changes (mostly just #including boost/filesystem/operations.hpp in a few places).

Autotools + qt will take a bit longer. I've got something *almost* working, but I won't have a chance to finish it for the rest of the week. I'll push the changes to github tomorrow (Monday) so anyone else can take a crack at it if they so wish.

cheers,
-Mark

On 2011-06-18, at 8:30 PM, Pieter Wuille wrote:




-------------------------------------
On Wed, Aug 24, 2011 at 3:21 PM, Luke-Jr <luke@dashjr.org> wrote:

Yeah, I think it is fair to apply.  Just saying... a nicer version
would be... nice.  Most projects work a bit to hide this stuff in
headers, so that the actual code is a bit clean.

Now, this is a general guideline, not a hard rule.  We have plenty of
#ifdef windows code already, for example.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Hello,

Why again did we choose for autotools as future build system instead of
cmake?

- CMake generates native build scripts for Make (all platforms), XCode,
Visual Studio. Autoconf only does Make.

- CMake has a clearer syntax, m4/autotools is very convoluted

- CMake is very fast

- CMake is supported natively in Qt Creator in the QT SDK, and is used by
many other KDE/QT as well as other open source applications. Many people
discourage the use of autotools for new projects.

A CMake build system for bitcoin is already integrated into rpcminer,
available here:

http://luke.dashjr.org/programs/bitcoin/w/puddinpop-bitcoin-pool.git/tree

JS
-------------------------------------

Indeed, someone could do this if they're interested in it, in their own
fork. That's what I said too. But it's no longer our issue.




With the "main project" here I mean the issue list of bitcoin/bitcoin
project on github, which only deals with that project (and not that of the
forks, which have their own issue lists). You can argue the "main"-ness but
it's just a mailing list message and not some official document deciding
about the future of bitcoin, so I did not feel like specifying it to that
level of detail.

JS
-------------------------------------
On Wed, Jun 15, 2011 at 9:50 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

I am a Berkley DB ignoramus , but how is specifying the wallet file
path different than using a symlink?

Also I think that allowing the user to open more than one wallet helps
the user develop an intuition for the system.
A simple task like opening transferring coins from one to the other is
currently very awkward on the same installation.

Ted


-------------------------------------
Yes, that's possible and what
https://github.com/bitcoin/bitcoin/pull/535 does. However, deprecating
midstate (and hash1) would allow for much cleaner code.

A pull request for marking midstate (and hash1) as deprecated can be
found at https://github.com/bitcoin/bitcoin/pull/538

On 29.09.2011 12:23, John Smith wrote:



-------------------------------------
On Fri, 2011-12-30 at 00:57 -0800, Amir Taaki wrote:

I believe the issue isn't lack of working, but lack of re announcing to
the router that the port needs to remain open.

Matt



-------------------------------------
A few years ago I wrote a least authority based set of filesystems named
MinorFs that worked closely together with AppArmor (suse/ubuntu) to give '
pseudo persistent processes' their own private but decomposable and
delegatable piece of filesystem storage:

http://www.linuxjournal.com/magazine/minorfs
http://www.capibara.com/blog/2011/05/25/taming-mutable-state-for-file-systems/

Currently there is only one perfect fit for MinorFs and that's the stack
AppArmor/MinorFs/E-language-persistent-application. There are some close
fits like running ssh without a passphrase (
http://minorfs.polacanthus.net/wiki/Ssh_private_keys_without_passphrase )
but these require lots of manual fiddling by the user to get working. The
ssh trick would probably work with bitcoin, but as you can see from the
link above, it would be rather cumbersome.

I am trying to get specs together for rewriting MinorFs (in Python) in a
way that would make it easy and natural for application developers that
want their application to be able to protect user data (like bitcoin
wallets) from mallware running under the same uid as that user.

Currently minorfs granularity is hard fixed to that of the 'pseudo
persistent process', and that granularity is determined as described in
the following link:

http://minorfs.polacanthus.net/wiki/Pseudo_persistent_process

When using pseudo persistent processes, you basically end up with
file-system storage that follows almost all of the modeling principles of
the object capability model. This is great when designing a least
authority program from scratch and writing it in the (object capability)
e-language using its persistence facilities.

Given however that I don't expect bitcoin, openssh, chrome, firefox, or
any other application that would benefit from what MinorFs provides to be
rewritten in E, it seems like the next version of MinorFs should give up
on the purity of its least authority model, and take an approach that
better suits common development languages and practices.

With bitcoin being a project that could benefit most from what MinorFs has
to offer, I would like to ask bitcoin developers to think about what
attributes from the current granularity level (pseudo persistent process)
should be kept, what attributes should be dropped, and what properties
should be added to arrive at an 'id' that is the best fit for granularity
of persistent private storage for bitcoin.

I really want to accommodate bitcoin developer needs in this, so all input
that helps me help you guys to get the next MinorFs version to accommodate
your needs to a level that code to use MinorFs where available can be
added to bitcoin, would be extremely welcome.

Let me know what you think,

Rob



-------------------------------------
DHTs and Bitcoin:

First, lets define the problem we want to solve: scalability - when bitcoin takes over all credit card transactions (!), and even before that, we will meet a scalability problem. The blockchain will grow rapidly, (1MB/10min or 50GB/yr) and we will constantly have transactions pending to get into a block. Further, the clients will turn into toasters just from validating all transactions. At the same time we have a level of validation and block chain distribution that we really don't need - today txes are validated by 100k clients in the future that could be 100M clients, and they are stored at way more locations than they are today. So... all this calls for a partition of the transaction/block space, and for a more flexible than 1MB / block setup.

First things first. The partitioning of the tx space. One way to partition the tx space is through a partition in hash, namely the DHT approach. There might be other schemes, but as we already have both the ability to share addresses and maintain a hash space it seems obvious.

So we would like a scheme that provides distributed validation and storage keeping a similar level of trust and security as we have today. We hence need to be able to query another node for validation and ensure it is not pulling our leg (Sybil...).

There are two important aspects of bitcoin:
1. transaction signing / validation
2. to avoid double spending

1. Is a a simple and inclusive problem to solve, 2 is more complex and exclusive. 1. can to a large extend be solved by asking for transactions and validating these against the block chain - it is hard to cheat as you can match blocks containing your transaction with the block chain headers, requiring a false node to perform heavy proof of work tasks.
If we on the other hand query other nodes for 2. just blocking an answer would be enough to enable a double spend. (at least seen from the one node querying).

Today you can, assuming you have en up to date block chain, only block pending tx'es which gives you an approximate 10 minutes scale for cheating by double spending. If we create a setup where we distribute the block index and the block chain, we can fake any older transaction as well, and leave a node to believe that a tx has not been spend. The obvious way around it is to ensure a high level of connectedness and to query several geographically distributed nodes if a tx has already been spend. But this can be quite hard and also, you don't want to flood the network with to many extra commands.

If we design the system based on the above conclusions we get:

1. A client is, based on the hash of its ip:port assigned to serve a part of the block chain, a part of the block index and possibly also a part of the bitcoin addresses (hash160).

2. Further, the client can announce that it also serves any other hashspace fractions - e.g. to enable notification of payments to its bitcoin address or use of its coins (txouts).

3. On validation of a tx, the txins are queried for at the clients serving these and a possible double spend can be monitored. We need to query more clients to ensure we are not cheated by one. And we need to maintain the requirement that they come from separate A.B address spaces (so they don't just setup a matching hash from playing with C.D and ports).

4. The proper nodes are found using Chord DHT scheme (other schemes might be suitable as well).

Thin clients keep their spendable coins to a minimum and use only one bitcoin address, that way they will only serve and listen to 3 hash fractions. If we split the current space into 4096 parts we get roughly 100 clients for each hash space.

The (only?) new attack vector, compared to the current system is the possibility that a client has only evil peers within one hash range and hence can be fooled into believing an old tx can be spend again.

The new scheme will scale well as each client will only serve a part of the hashspace and hence the number of validations and block storage can be kept at a minimum. Further, it scales well for thin clients vs more full clients as you can add as many or as few (down to 1-3) hash space parts as you want, so the new scheme includes the old scheme in the limit of subscribing to all hash space parts.

I might have overlooked something - so please fill in some comments...

Cheers,

Michael


On 18/12/2011, at 22:19, Stefan Thomas wrote:




-------------------------------------
On 12/18/2011 1:19 PM, Stefan Thomas wrote:

That's a very good point. This is needless complication at the protocol 
level. Alternatives, like Tor, could be used to provide the desired 
effect. Developers could even choose to integrate Tor functionality into 
the client itself at some point.


-------------------------------------
On 2011 December 16 Friday, Rick Wesson wrote:


HTTPS takes care of that.


This is the only real problem with HTTPS: we would be centralising part of our 
otherwise decentralised system.  CAs are certainly a risk.

However, trust is needed somewhere in the communication.  There is no way to 
securely communicate between A and B without the use of some previously 
trusted secure channel -- in Joe Sixpack's case it's by assuming that the 
browser he downloaded came with an untainted CA list, and that the CAs are 
trustworthy.  Neither of which is guaranteed.  Until and unless we get PGP 
support in browsers, CAs are all that we have.

Worrying about CAs misses the point anyway; if we're being that paranoid -- 
how did A tell B the appropriate alias to use for a lookup?  Was that channel 
secure too?  I could set up a MITM server that simply looks for the alias 
"RICKWESSON@bitcoinaliases.org" and rewrites it to 
"ANDYPARKINS@bitcoinaliases.org".  When the answer to that problem is HTTPS 
(or some other system that requires a previously authorised secure channel for 
transfer of trust), then we're back where we started, and HTTPS is acceptable.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------

Adding that code to bitcoin in a contrib/dns folder seems like a good idea.  I'd be happy to run a dns seed.

-------------------------------------
I can substantiate Gavin's point quite powerfully: a couple months ago I 
did a search for the "hardest" block in the network and found a *very 
**impressive* one:

https://bitcointalk.org/index.php?topic=29675.0

That block has a difficulty of **36 billion** when the network had a 
difficulty of **1.5 million**, which is 24,000 times harder than the 
target.  If we were going by the /actual /hardest chain instead 
target-based-hardest chain, /then this block produced in July would 
might still represent the longest chain!/

Yes, that means that whichever miner produced this block, could've held 
onto it for 2-4 months without doing anything else, and then broadcast 
it to fork the blockchain from a block produced months ago.  That's not 
theoretical, that's real data in the blockchain and it would be a disaster.

-Alan



On 11/23/2011 10:09 AM, Gavin Andresen wrote:

-------------------------------------
Hi Alan,

I have now read BIP0010 - one first idea is: add a link to it on the wiki (or remove all bip links from the wiki... - we don't want two places for BIPs...)

I am not sure where you prefer the discussion on the content of the BIP - but now you get it here, but feel free to redirect...

Likes:
* inclusion of prevout txout scripts - could prove handy
* that it is a proposal to do this similarly on all clients

Dislikes:
* the format - I guess I would prefer a normal JSON format - where the scripts gets populated step by step. As for the scriptPubKey (now an awful name...) it would be easy to just add it to the JSON, or have the prevouts simply be the actual txouts instead of {hash,n}.

Comments:
* it is good to have this proposal, but I think that once we see ways to communicate it they could very well radically steer how a format should look. Take e.g. the discussion we had with Gavin yesterday, if we had chosen to move in that direction BIP0010 would had been useless. So perhaps a bit premature?

Cheers,

Michael



On 10/11/2011, at 04:00, Alan Reiner wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------
I agree with Luke that HTTP standard has everything necessary and bloating
payload with json/xml is not necessary.

Btw that argument "we have json in client already" seems pretty wrong,
because json in server rpc solves another problem (and solve it in wrong
way, because of data type issues, but it's another story).

slush

On Mon, Dec 19, 2011 at 6:04 PM, Jordan Mack <jordanmack@parhelic.com>wrote:

-------------------------------------
Monday, July 11, 2011, 10:33:04 AM, Mike Hearn wrote:




It is indeed a very good one but I disagree in two points. First

If  someone  asks  me  this  question  about the project I'm currently
working  on  I  would never answer like that. This is important in the
threads  context  because  it  gives  me the confidence to say you can
build  very  large  C++ projects with lots of programers attached over
multiple years and still have a very clean and nice code base. And the
article does also accidently points to one of the roots of messy code.


Well,   if   you  can not identify the meaning of some hairs, they are
either  attached  to  the  wrong  place, in an unclear way or are just
missing  a  line  of  comment.  There  are  studies about what size of
function  and  up  to  what  number  of  variables per function can be
covered  by  the average code reading programer. And these numbers are
low.


Second,  I  agree  with the point that you can not give up your market
leadership by beginning from scratch and you will if you do so. Unless
you  do  it like microsoft did in his example by simultaneously extend
the  old code base. And microsoft does this all the time, just look at
Windows 9x compared to Windows NT and the dead object oriented Windows
kernel. (They did buy lots of that but that is not the point here)
The  mistake  is  to  compare  a  small  project  like  Bitcoin to any
application  like  Word  or  Netscape. The author did explicitly write
that  he  does  not  mean  that  partial  rewrite  is a bad thing. And
rewriting  the  Bitcoin  client with three or four guys is like a tiny
rewrite in a real world application like Word.
In  case of Bitcoin there is reason to believe that a rewrite would be
better.  The first version was hacked together by far less programmers
and  by at least one who did not care about readability, what tells me
that  he  possibly did never work on a real project before. And we now
have  a  known  to  work  protocol,  what  did  for sure slow down the
development a lot and caused rewrites.



Michael



-------------------------------------
Ok, so HTTP is not an option unless it shows a huge warning. I don't
know the HTTPS possible attack, but maybe it needs a warning message
too, from what you people are saying. Although using namecoin to
identify hosts may be the more secure option, it's integration with
the client seems more difficult and probably most clients won't
support it. Using namecoin to directly specify the payment address
seems a bad idea for most cases for the reasons that have been said.

For the "answer format" JSON seems ok, but I mean a "negotiating
protocol" like luke-jr says. I'd even include green addresses there
but probably many of you don't like the idea.

2011/12/19, slush <slush@centrum.cz>:

I agree.


-------------------------------------
While I think firstbits is an interesting idea, I agree with Matt on 
this one. Firstbits, while being a clever idea, produces a less 
desirable solution in comparison to the current alias proposals.

In addition to Matt's reasons, I would like to add that it is still a 
block of random characters, just shorter. It creates the undesirable 
effect of having addresses short enough that people may try to type it 
in rather than pasting or scanning, which is more error prone.

One obvious scenario for potential exploitation would be if a large 
organization adopted a firstbits address for donations. Others could 
immediately try to collect similar addresses in hopes of a typo. A 
second would be if the organization published the firstbits address on a 
poster in a public location. Someone could easily secure a firstbits 
address which was one character longer, then stencil that extra 
character on to the poster.



On 12/17/2011 8:15 AM, Matt Corallo wrote:


-------------------------------------
Is the point is to have different hosts like in jtimon@gmail.com,
jtimon@timon.es, etc. so if jtimon is already taken I can take another
host?

What about reserving directly the string "jtimon@nottaken.org" or
"jtimon::public::receiving::bitcoin" in namecoin?

I'm confused about the problem we're trying to solve.


2011/12/13, Luke-Jr <luke@dashjr.org>:


-------------------------------------
Hey, guys.

I haven't posted here before so I'll introduce myself. My name's Eric,
I've been developing cryptocurrency-related
software for several months now, I've implemented some libraries for
dealing with core bitcoin datastructures, made
some custom builds of bitcoind and interfaced it with a few apps I've written.

In doing so, I've come to appreciate just how little of the potential
for the bitcoin protocol is being exploited right now...
not only in terms of the script features but in terms of the potential
commands and node types that could exist.

For instance, the protocol spec at
https://en.bitcoin.it/wiki/Protocol_specification only has 16 commands
listed and
only one service type...despite having a full 12 bytes for a command
code and a full eight bytes for a services
type.

The fact that only one node service type is specified is probably due
to the fact that the satoshi client was written
to be a standalone monolithic app that took care of all the essential
needs for a network of peers.
i.e. block chain storage/management, transaction signing/verification,
key generation/wallet management, block mining, etc...
However, I think there's an urgent need for breaking up all these
different tasks into separate components that can run as independent
services on different types of devices.

One of the big issues I'm dealing with now pertains to block chain
storage. As of right now, it is implemented as sequential
disk files using Berkeley DB in the satoshi client. Then you have
other projects that have been using SQL tables, etc...
But I believe the direction this really needs to move towards is some
sort of distributed hash table...and the database queries
should be performed using the bitcoin protocol itself. Perhaps adding
a few more commands. As things stand right now,
the only way to query for transactions or blocks is by their hash. And
once a transaction gets incorporated into a block and
removed from the transaction pool, one can no longer query it by the
transaction hash without stepping outside the bitcoin protocol.
We need access to the disk file that stores the blocks whether it be
via Berkeley DB or SQL or whatever.

I propose an extension to the bitcoin protocol to provide methods for
performing more sophisticated queries, such as "Give me
an inventory of transactions involving this particular public key" or
"Give me an inventory all transactions in the last n blocks with
unredeemed outputs." This could be done by adding a few more commands.

Furthermore, I propose a new network services type for nodes that
serve as block chain/transaction pool storage.

Of couse, any peer that wishes to verify the integrity of the block
chain would still have to download at the very least
all the block headers...and to be completely sure, also all the blocks
themselves...and verify everything. But it would be
very nice to be able to run thin services that can rely on other
network peers to do this work. It is still possible to attain
a high level of confidence in the integrity by querying multiple peers
for similar objects and comparing. It is also possible
to run your own dedicated block chain storage servers which you trust.

There are other ideas I have for other types of services, too.

Anyhow, I'm just throwing this out there...if anyone's interested I'd
love to develop these ideas further and help put together some
specs.

-Eric Lombrozo


-------------------------------------
On Monday, July 04, 2011 1:52:53 PM Matt Corallo wrote:

It shouldn't. Backup scripts should make a copy with the JSON-RPC call.

What about changing the format of wallet.dat to something that triggers an 
error in the old clients? ie, maybe a dummy crafted-to-make-old-versions-
complain file that simply means "use ewallet.dat"?


-------------------------------------
I got Steve-from-the-Forum's boost unit test skeleton code compiling
and running, so there's now a src/test directory and you can 'make -f
makefile.unix test_bitcoin'

More tests are very welcome. I'd welcome higher-level tests (not just
code unit tests), too.

And speaking of testing:  if you know a good QA test manager type
person interested in bitcoin, I think we can wrangle up funding for
somebody to put together a team to help test bitcoin (and hopefully
pull requests). I think lack of testing resources for core bitocin is
a big weakness right now.

-- 
--
Gavin Andresen


-------------------------------------
I tagged v0.5.0rc2 this morning (then Luke hit me upside the head and
I tagged it again because I messed up).

Gitian-built binaries are uploaded to:
  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/test/

I sanity-tested the windows setup.exe in an XP virtual machine, it
installs and runs nicely. I'm about to run out; if somebody can sanity
test the windows .zip and the 32/64 bit Linux .tar.gz I'd much
appreciate it.

shasums for the uploads are:
  df994f18b6b715f6e0451b98b55ddd1946f2f353  bitcoin-0.5.0-win32-setup.exe
  bfbad8acae987467976d535e48653ac7e28c6c76  bitcoin-0.5.0rc2-linux.tar.gz
  fb2cfd2d8ad45269025a4604c679364a934796b4  bitcoin-0.5.0rc2-win32.zip

Mac builds will be delayed a bit; there are issues creating a standalone .app.

shasums of my v0.5.0rc2 gitian.zips:
  f1fa954d179c65d1043438b78fcde8237874b9e1  bitcoin-0.5.0rc2-linux-gitian.zip
  cec50f4b5d7222e475466143eb9e37aae026a582  bitcoin-0.5.0rc2-win32-gitian.zip


-- 
--
Gavin Andresen


-------------------------------------
If we had the moding power, yes, but we don't have nearly enough people
who could mod such a forum.

Matt

On Sat, 2011-07-16 at 09:34 +0000, John Smith wrote:
-------------------------------------
On Sat, Jul 16, 2011 at 7:20 AM, John Smith <witchspace81@gmail.com> wrote:

I agree completely.

While the owner of the forums and bitcoin.org is Missing In Action and
has not responded to emails in more than a week, we do have access to
change the main www.bitcoin.org home page, to link to another forum.

Or we could simply de-link the current forum, as a first step.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
This discussion is convincing me that scheduling a blockchain split is
definitely the wrong idea at this time.  We can revisit in N months,
when we've got a roadmap and nice unit tests and a bunch of
well-tested patches for fixing all of the things that aught to be
fixed when we DO decide a blockchain split is necessary.

There seems to be rough consensus that new, imperfect standard
transactions are a good-enough short term solution.

-- 
--
Gavin Andresen


-------------------------------------
RE: "You have some unencrypted keys, should I encrypt them for you?"

That re-opens an "attacker packs the keypool with keypairs that they
know about" (if I can read/write wallet.dat, then I can delete
encrypted keypool keys and insert a bunch of unencrypted keypool keys
that I know how to spend, and rely on the user to click "OK" because
users are trained to just click "OK").

RE: breaking backup scripts:  if they use the backupwallet  RPC
command, then they will Just Work.

0.4 and later could, on wallet encryption, create a wallet_e.dat
(encrypted wallet).  Then truncate wallet.dat and set its
file-permissions to 000, so if old versions of bitcoin OR any dumb
wallet backup scripts try to read it they fail.

RE: future-proofing: wallet.dat contains nFileVersion (version of
bitcoin that last wrote the wallet).  Adding a nMinVersion that
specifies "you must be at least THIS version to read this file" seems
like a good idea so if you have version 0.4 or later future wallet
upgrades give you a reasonable message if you try to downgrade after
an incompatible change.

-- 
--
Gavin Andresen


-------------------------------------
On Wednesday, December 21, 2011 6:50:47 AM Eric Lombrozo wrote:

http://cr.yp.to/immhf/thread.html


-------------------------------------

You're absolutely right.

And you're right about the 99 confirmations, too-- I was thinking
blocks again, not transactions.

Good to get all of the wrong-ness out of my system on a Monday so I
know I'll be perfect the rest of the week.  :-)

-- 
--
Gavin Andresen


-------------------------------------
On 7/26/2011 6:31 PM, Gavin Andresen wrote:


Two things would help a lot:

1) Letting people know that bug fixing is needed and would be 
appreciated. (In fact, until I saw your email, I had no idea this was an 
issue.)

2) Maintaining a list of the most important bugs that most need to be 
fixed in a place that's easy to find.

I bet there are a lot of talented programmers who just can't quite 
figure out how best to help or don't realize that this kind of help is 
needed.

Also, even better than a bounty system would probably be a changelog 
file included in the main source distribution that credited bugfixes to 
those who contributed them for the next few releases.

DS



-------------------------------------
On 2011 November 23 Wednesday, Jorge Timn wrote:

Just as with the current system.

The defence is that on receipt of a block, its timestamp is checked against 
the node's own clock and averaged network clock.  Blocks out of that band are 
rejected.


Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Sunday, December 04, 2011 5:24:08 AM John Smith wrote:

I think it would be ideal if someone wanted to take up wxBitcoin. Maybe after 
backporting to wx 2.8...

That being said, I have no interest, as I hate wx, and prefer Qt in general ;)


Please be careful to avoid the centralization mindset. There is no "main 
project"; there is bitcoind, wxBitcoin, Bitcoin-Qt, MultiBit, and many other 
non-functional clients, which should be given equal footing (before 
considering their differences). There shouldn't be given any special treatment 
to bitcoind and Bitcoin-Qt just because "Gavin et al" happen to maintain it.


KDE literally just closed a bug of mine that I reported in 2002, because the 
component with the bug hasn't been part of KDE since 2008.


-------------------------------------
Background:

Timejacking:
  http://culubas.blogspot.com/2011/05/timejacking-bitcoin_802.html

And a recent related exploit launched against the low-difficulty
alternative chains:
  https://bitcointalk.org/index.php?topic=43692.msg521772#msg521772


Seems to me there are two fundamental problems:

1) Bitcoin should be overlapping the ranges of block timestamps that
it uses to calculate difficulty adjustments.

2) Bitcoin's "what time is it" code is kind of a hack.


Fixing (1) would mean a potential block-chain split; before
considering doing that I'd like to consider second-best solutions.

Fixing (2) is easier; incorporating a ntp library and/or simply
removing the bitcoin mining code from the client but requiring pools
and miners to have accurate-to-within-a-minute system clocks (or their
blocks will be "discouraged") seems reasonable to me. If you want to
produce blocks that the rest of the network will accept, run ntp on
your system.

I THINK that fixing (2) will make (1) a non-issue-- if miners can't
mess around with block times very much then it will be very difficult
for them to manipulate the difficulty for their benefit.

-- 
--
Gavin Andresen


-------------------------------------

Grabbing is no more an issue than mining Bitcoins is an issue. Sure, 
domain grabbers will have the domains first, but they want to profit and 
therefore are willing to sell them for whatever price they can get. Just 
like the trading of any other limited resource, this process sounds like 
somebody is getting rich for nothing, but it does tend to put the 
limited resources to good use as people who waste good domains can't 
afford them in the long run. The problem with Firstbits is that the 
names already grabbed have fixed private keys that are known by their 
originators. That makes the names untradable. This may be fixable with 
split keys, but a lot of "good" 1firstbits are already made useless in 
this way.

Names in Namecoin can be transferred/traded securely, strong 
cryptography is built in and it shares mining without bloating the 
Bitcoin block chain. I see it as a decentralized DNS alternative at a 
time when domain seizures are on the rise, even absent any court order.

So I would use one of the DNS-based solutions that Amir suggested and 
simply require standard-compliant clients to be able to look up .bit 
(i.e. Namecoin) domains as well. That way we have a pragmatic solution, 
but one that also provides security and true decentralization for the 
more paranoid of our users.


On 12/13/2011 12:41 AM, Luke-Jr wrote:



-------------------------------------
On Sun, Jun 19, 2011 at 02:30:49AM +0200, Pieter Wuille wrote:

Jaromil has his autotools branch rebased against git master, and included Mark's
NOSIGPIPE/NOSIGNAL patch (needs a commit summary, though).

Can people test this compiles+works on several systems (ubuntu, fedora(?), mingw
crosscompile, osx, ...)?

  See https://github.com/jaromil/bitcoin/commits/autotools3

For me, it works on Ubuntu 10.10 amd64, including wx gui.

-- 
Pieter


-------------------------------------
Some minor updates to the released files:

1. Linux tarball regenerated with properly named directory inside.
2. Win32 .zip archive added.
3. PGP-signed SHA1SUM.asc added to SF

The following are the updated checksums:

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

d7a34e1151dedfba5af1bf7496ed041f5b4955e5  bitcoin-0.3.23-linux.tar.gz
42e8a86a97edcafb12d09fa69b56ad0451baa140  bitcoin-0.3.23-macosx.zip
779c6bb227801a51084be9594dc185d0a054ed53  bitcoin-0.3.23-src.tar.gz
12952b1c4a15ce55564500dace18ee22eb2feaa8  bitcoin-0.3.23-win32-setup.exe
89194d3b3ee87f450f520cf365b863e0fab8bc9f  bitcoin-0.3.23-win32.zip
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIVAwUBTfp5k9odwg8tvwyoAQIJ9Q/9GHiSA8oEuQM29qu1laCD45AY9lnsJeNN
ZNRiAE92WJ7SiSKxW6V1M1phMk4IMG/0MmR8L/PRqJfWDg+6FQzAzpZLobH0Hnfl
MujhKIhRcP1zs7m/t/zwjQxRXT+N6UotfdwvO+GLbBnUSVZC2zr/9XdSs65gLIhq
lMkJUwYLEBvuXvo98Sbp5MeXHdfWUqAQufuYnMvRsCT9BcX5cP8cmaxvICLANRbc
89kU+7JQ7fauiHTnYJ0GkK/xIyCnlwfGsEe8GQsIgWF0RBpayszCxSOsuzFYMsED
7cIjN9AscDiJ3UmhXSg6xbRi4LZGXm195TmMdxJdRNHWqjfpFkxEXoW7iuUvxVDU
tiMMA+yXMTUSdbn2IxdZFLqKpgXcpf05T91g9w/ll1VMxkmOOcTSZc5dCbMMUn0z
kA12PagjDlH+xz3Qab9GNV13XlHKbG0VT8AsE1No+HJCV8qugMdI6hgZqMDucbmQ
U2KiG0EpwNx2G31l2K99yIxuumE7nDslhkfzSosVXhgHwqzr4ukl5ykFwfZnJjHF
BJ0zrcWCViGes+3awHwASQvlIGcvXprEzC0ZKEsbalZkAoCYYiGoZbNHtEMq3lZq
d0siUzwEPA31xfS/dACbX8ml8jC0jBmEy296WZ2LX7pZOcqa2ayMbGE81tg+5Nvy
UYihPYX4FS0=
=9NXu
-----END PGP SIGNATURE-----

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Thu, Aug 4, 2011 at 3:42 PM, Andy Parkins <andyparkins@gmail.com> wrote:

But they can be trivially generated on demand, and potentially result
in unbounded flooding.

Even if you carefully don't duplicate an announcement I can easily
generate an unlimited number of double-spends for the network to
flood. The normal anti-DDOS logic doesn't work because there can be no
additional proof-of-workish costs for the double spend (they'd share
whatever anti-ddos fees the first txn had).

This is somewhat soluble, I guess. Rather than NAK the transaction the
way it would work is propagating conflicts on each of the conflicted
inputs.  "I've seen at least two transactions recently trying to spend
input X, here is proof: (two txn IDs)". Even if there are more spends
of that input you don't need to hear about them, knowing about two
spends of an input is enough to consider that input (and perhaps all
inputs with an identical script to that one) temporarily suspect.
Though it would have to be done input by input.

This might be an interesting feature if not for the fact that the
software already waits a fair number of confirms before considering
something confirmed. Of course, a sybil can just filter these messages
diminishing their usefulness.

I suppose I could add this as a (7) to this list:
https://bitcointalk.org/index.php?topic=28565.msg359948#msg359948


-------------------------------------
On Thursday, September 08, 2011 3:45 PM, "Luke-Jr" <luke@dashjr.org> wrote:

An alert would have been issued if they had abused that position.


-------------------------------------
On Saturday, November 05, 2011 12:17:58 PM Christian Decker wrote:

This can be necessary in some cases. What happens when some popular client is 
found with a subtle bug, and cannot otherwise be differentiated from other 
similar-functionality clients? I have found User-Agent very valuable when 
dealing with the wide variety of miner bugs when I have enabled new 
functionality/behaviour on Eligius.


-------------------------------------
Hi all.

Just wanted to carry the discussion from the Forum over to the dev-list.

We have quite a few bootstrapping mechanisms, starting with the overly
complex (IMHO) IRC bootstrapping, which is often suspected as bot-activity.
Then we have a few hardcoded nodes and some fallback nodes. I was wondering
why we didn't adopt BitTorrent tracker bootstrapping until now? It's
basically all it does. Given a hash (SHA1 hash of the genesis bloc would be
nice ^^) it gives you a list of other nodes with the same hash.

Given that there are quite a few open trackers (accepting and tracking any
hash you throw at them) we could just decide to use 2-3 of those to
bootstrap.

The downside would be that they return bencoded data, which has to be
interpreted first, but it's easier than implementing the IRC stuff, I think.

Any comments?

Regards,
Chris
-------------------------------------
On Sun, Jul 17, 2011 at 5:12 PM, Douglas Huff <dhuff@jrbobdobbs.org> wrote:



Yes they are. Which is why the current forums will be moved to another
domain. It grew into a monstrosity.

On the other hand, I do like forums in general.  It would be nice have an
official help forum dedicated to just the client software (and protocol) and
how to use/integrate/modify it.  It should come with a link to the FAQ
before posting.

Also, as a mailing list is (kind of) limited to text only, a forum makes it
easier to discuss graphical subjects such as UI.

Then again given the kind of people bitcoin seems to attract, it might be
unrealistic to think a normal forum can be maintained... On the other hand,
people that misbehave can then be sent to the bitcointalk forums :-)

JS
-------------------------------------
Maybe I'm new to this, but this doesn't make any sense.  I thought the 
point of the BIP was to collaborate to come up with a good solution.  
That's exactly what I want to do before I implement it in my software.  
After all, they are "Bitcoin Improvement *Proposals*."  It seems like 
EXACTLY what a BIP is for... just no one needs/should use it until it 
removes the "draft" marking.

As for the protocol on top of it, my BIP was not intended to address 
that.  It's only proposing how unsigned transactions can be serialized 
and users can collect addresses.  Whatever system you want to implement 
on top of it to exchange the data is up to the developer.  My only 
motivation is that if the user clicks "Save this proposal to file", that 
any client can use the resulting file, just the same way we serialize 
any other blockdata that has a consistent representation.

-Alan



On 11/12/2011 11:58 AM, Mike Hearn wrote:

-------------------------------------

What is the bug, exactly? Perhaps it can be worked around.


-------------------------------------

To make this more difficult, nodes that receive new transactions via
blocks should relay the new transactions as if they had received them
normally. Then the double-spend transaction will be rejected by most of
the network because the other version is already widely-known.


-------------------------------------
A better retarget strategy might be to use the real average time
between all of the blocks in the interval so that no blocks are
treated specially in the calculation. I agree that this is not
important enough to fork the chain over, though. An attacker would
have to maintain control for a *very* long time because of Bitcoin's
long retarget interval. (Maybe this kind of thing is why the retarget
interval is so long?)

I don't like requiring block times to be within minutes of reality. It
would be fine if only miners had to keep accurate time, but clients will
also need to have good time in order to see if a block will be
discouraged. A discouraged block should not count toward confirmations.
If relays will also discourage blocks, then they'll need accurate
time as well.

The network should not be allowed to adjust your time by more than 40
minutes to prevent the timejacking attack, but I don't see a problem
with the other time rules. Time is only used for retargets and LockTime,
so it only needs to be generally accurate.


-------------------------------------
It's probably best to keep this discussion on just one mailing list. It's
confusing to have duplicate threads in different places. People will end up
making the same points.

To repeat what I posted elsewhere, for now I'd just start with the simplest
possible approach:

- Ignore version skew for now (disconnect older clients)

- Don't send received transactions/blocks to the bitcoind. Let it hear about
them from its own p2p connections. That way you will always receive all
valid transactions/blocks which you can then relay/cache/drop inbound
duplicates.

- Parse/handle inv/getblocks/getheaders requests so clients that connect and
catch up with the chain don't place any load on the bitcoind. If a client
requests data the proxy doesn't have in RAM, it can go fetch it from the
underlying bitcoind.

If you can make v1 work and demonstrate actual scalability improvements,
then you can always go back and make it smarter in v2.
-------------------------------------
Gregory said: "...if this causes people to wait less than the 6 blocks
that the software currently waits for before leaving unconfirmed
status then that would be sad."

People are already considering transactions 'confirmed enough' at less
than six blocks. I'm guilty, too-- 3 is/was the magic number for
ClearCoin.

And people are already experimenting with ways of safely accepting
0-confirmation transactions, like InstaWallet's "green" payments (sent
from a trusted-not-to-double-spend address).

Since there is definitely market demand for "as fast as possible"
confirmation, I'm thinking adding a placeholder to the RPC interface
might be a good idea.  Although after thinking about it some more,
maybe a signed integer "trust" rating for blocks/transactions would be
a better way of doing it...


RE: miners connecting themselves together in a semi-trusted "bitcoin
backbone"  :  agreed.

Matt submitted a patch to connect and stay-connected to a set of
nodes, but I complained about the implementation.  Seems to me the
networking code needs an overhaul, to implement a priority queue of
potential peers (trusted peers would be sorted to near the top of the
queue, peers you think are badly-behaved would be sorted to the
bottom, with lots of randomness so not everybody on the network is
trying to connect to the same set of peers). With peer rotation to
mitigate manipulate-time and other Sybil attacks.

-- 
--
Gavin Andresen


-------------------------------------
On 2011 December 21 Wednesday, Christian Decker wrote:


A thought occurred to me.  We already run a decentralised system, but it's 
done by making everyone duplicate all other work.  There is no fundamental 
reason why all work needs to be duplicated though.  What about this: every 
node randomly chooses whether to verify any particular transaction.  If we 
assume the network is large and the random factor is correctly chosen, then we 
can still guarantee that every transaction is verified.  Then, we simply add a 
protocol message that is a negative-announce transaction.  That is to say, we 
give nodes a way of telling other nodes that they think a transaction is 
invalid.  The other nodes are then free to verify _that_ assertion and forward 
the negative-announce.

Miners can then listen for negative-announcements and use them to decide were 
to dedicate their verification efforts.  They then don't need to verify all 
(or perhaps even any) transactions themselves and can dedicate their 
processing power to mining.

(I've actually mentioned this idea before, but that time I was using it as a 
double-spend prevention method).



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Hi everybody!!

 This is my first message here... I'm ThiagoCMC at bitcointalk...

 Well, one of the features that I like most is that, every time I receive
some Bitcoin amount, a new address appear at my "AddressBook"automatically,
AND, I like to track it.

 This feature is broken at 0.3.24 but it is working again! Thanks BTW!!

 But, I've read in some places that you guys are thinking in disable this
feature... Is that true?!

 PLEASE, do NOT deactivate this feature! I mean, do not deactivate ANY
feature. Instead of, just add a option to turn it ON and OFF. Right?!  ^^

 Bitcoin is the most amazing project since Linux and Git!!  :-P

 Thank you guys!!

Best,
Thiago

On 9 September 2011 11:02, Gavin Andresen <gavinandresen@gmail.com> wrote:

-------------------------------------

Exactly, I think we should starting separating the minimal protocol that is
to be supported by everybody, and the rest can be summed up in a few best
practices, no need to standardize the part that to the user is transparent.
I was on the same lines as Andy, which is that in order to have require a
payment I probably have an order/transaction pending with my vendor or have
an account to be filled, so there's a 1-to-1 mapping between the details
page and the bitcoin address I have to send to.

As a further possibility we could use <meta> tags like the OpenID server
delegation mechanism. It would allow customers to open the transaction
details page, see that everything is ok, then paste the same URL into the
bitcoin client, the bitcoin client retrieves the URL, parses the meta tag
and knows what to send where. Alternatively the Bitcoin Client sends an
Accept header which tells the server to return just the address.

As for the format I'd say either a Bitcoin address or a Bitcoin URI [1]
which ought to be flexible enough as it includes amount and messages, for
the customer to be able to track transactions.

Regards,
Chris

[1] https://en.bitcoin.it/wiki/URI_Scheme
-------------------------------------


That's a good idea. What about using GitHub's Wiki feature for BIPs?
They support MarkDown which is easy to read in text editors so we could
someday create a repo with all finalized BIPs. That's a lot easier than
importing a mediawiki dump. The last time en.bitcoin.it went down I
tried to setup a static mirror and that was nearly impossible without a
full LAMP stack. Also, BIPs should only contain images when absolutely
necessary.


ack


ack


-------------------------------------
The number of proposals <https://en.bitcoin.it/wiki/BIP_0015> is not
infinite, here are their problems :

- FirstBits : centralized
- DNS TXT Records : DNSSEC is required to have a minimum of security,
limits usage to engineers, limits usage to some domain names (i won't be
able to use a gmail address for example, because i don't control the
gmail.com domain)
- Server Service (DNS + a daemon) : Same as DNS TXT records
- HTTPS Web service : relies on HTTPS and CA, bitcoin needs to be able
to check the full certificate chain and access a list of up-to-date
certificate authorities (installed on the OS or provided with bitcoin).
And don't forget the CA model is not 100% reliable (several CA hacked
this year + possible government control...).
- IP Transactions : /This proposal seeks to enable DNS lookups for IP
transactions/ => same as above

I know that providing a namecoin daemon with bitcoin is not the lighter
solution, but, if a better one existed i guess it would have already
been integrated into bitcoin... (see in what state is my first attempt
with the HTTPS proposal : Send payments to emails, urls and domains in
GUI <https://github.com/bitcoin/bitcoin/pull/174> - /khalahan opened
this pull request April 20, 2011/)

So, what's next ?

Le 16/12/2011 20:54, slush a crit :

-- 
Best Regards,
Khalahan
http://dot-bit.org/

-------------------------------------
On Wed, Sep 14, 2011 at 3:45 PM, Gavin Andresen <gavinandresen@gmail.com> wrote:
Of course, if only a small percentage of mining power adopts this
scheme, everyone that does so will presumably be harming themselves by
doing so since they're essentially increasing the odds that the next
block they mine will become invalid...


-------------------------------------
On Thu, Dec 15, 2011 at 4:07 PM, slush <slush@centrum.cz> wrote:

wow, really. Maybe you could review some RFCs, there are thousands of
examples where some really smart engineers chose the exact opposite
path which you propose below.

-rick



-------------------------------------
On Thu, 29 Dec 2011, theymos wrote:


That's not true.  Gavin himself showed how to use OP_EVAL to loop:
OP_PUSHDATA {OP_DUP OP_EVAL} OP_DUP OP_EVAL.

Basically OP_DUP lets you duplicate the code on the stack and that is the 
key to looping.  I'm pretty sure from here we get get Turing completeness. 
Using the stack operations I expect you can implement the SK-calculus 
given an OP_EVAL that allows arbitrary depth.

OP_EVAL adds dangerously expressive power to the scripting language.

-- 
Russell O'Connor                                      <http://r6.ca/>
``All talk about `theft,''' the general counsel of the American Graphophone
Company wrote, ``is the merest claptrap, for there exists no property in
ideas musical, literary or artistic, except as defined by statute.''


-------------------------------------
I don't have a strong position for or against JSON but...What about
protocol buffers?
Would it be too much too? Would it be simple enough for developers?


-------------------------------------

... of course I write that and then start thinking about ways you
COULD use the P2P network to distribute signatures, maybe by
broadcasting (and paying fees for) complete transactions that contain
extra signatures for the transaction that you want to sign.

Here's a half-baked idea that might be brilliant or stupid:

+ Start with an escrow transaction, with 3 public keys.  I own one of the keys.
+ I broadcast a 'fee-only' transaction that pays 0 bitcoins to the key
I own. But I add extra data to the scriptSig; something like:

scriptSig:  <escrow_signature> <serialized_escrow_transaction> <sig> <pubkey>
scriptPubKey: ...standard DUP HASH160 <pubkeyhash> ...etc
nValue: 0

The other parties to the escrow transaction could monitor the
block-chain for transactions to my <pubkeyhash>, and get the signature
and proposed "spend the funds in escrow" transaction from the
scriptSig.

.......

"But won't that gunk up the block chain with more data?"

Yup.  But the parties to the transaction will have to pay for the
extra data they're including.

And everything in the scriptSigs can, theoretically, be forgotten (or
never sent) to most nodes on the network once the transaction is spent
and is buried deep enough in the block chain.  (a nValue=0 transaction
can be considered 'immediately spent').

"Can you really put arbitrary stuff in the scriptSig?"

Yup.  The IsStandard() check today allows up to 200 bytes, which
wouldn't be enough for an extra signature and <serialized
transaction>.

The standard <sig> <pubkey> is about 150 bytes; part of the
multi-signature proposal will be increasing that to 500 bytes to
accomodate 3-signatures transactions.  A simple 1-input-1-output
<serialized transaction> would be around 50 bytes or so.

"Wouldn't it be cheaper/better to NOT use the block chain to
distribute signatures?"

Yup. The only advantage I see is it might be more anonymous to use the
blockchain instead of directly connecting to, and finding out the IP
address of, the parties involved in the transaction.


-- 
--
Gavin Andresen


-------------------------------------
On Mon, Oct 24, 2011 at 10:29:57AM +0200, Jan Vornberger wrote:

Bitcoin transactions do not have input addresses - they optionally have addresses
the input coins were last sent to. I understand that being able to have a
'from' address on a transaction is useful in certain cases, but it encourages
using such 'from' addresses to identify transactions - which is imho the wrong
way to go.

As far as your green transactions idea is concerned, maybe we could provide an interface
to mark certain addresses as 'trusted', and have an RPC call to request all incoming
transaction that originate from trusted sources?

-- 
Pieter


-------------------------------------
On Tuesday, September 13, 2011 10:43:27 AM Gavin Andresen wrote:

More important in this area, IMO, is support for deterministic keychains in 
wallets. Type 2, according to gmaxwell's original spec, seems pretty ideal, 
and significantly improves security for many use cases. Since it allows a 
wallet to contain a public keychain without the matching private keychain, 
webservers, POS, and other services can be provisioned only with the keychain 
required to generate/access infinite public keys, and without the private 
keyroot needed to spend them.

The ideal scenario in this regard, as I see it, is this:
- Webserver wallets are provisioned with multiple public keychains (one per 
webserver), and configured to use a specific one for getnewaddress/etc. By 
provisioning them with *all* the public keychains, their listtransactions/etc 
can see the transactions sent to other webservers, necessary to show 
confirmations to the end user and such.
- Business keeps a locked-down *offline* wallet with the private keychains for 
all the forementioned public keychains. Only this wallet has the information 
required to spend the income. The wallet is encrypted, and can only be 
accessed by staff with the proper position/authority to authorize expenses.
- A third wallet is used by staff to prepare expense transactions. It keeps 
track of locking coins it knows are in the process of being spent, and any 
staff member can create new ones. Once created, they must submit the 
transaction to a staff member with the proper authority to bring it to the 
offline transaction-signing wallet (on a USB key), where it is signed, and 
returned to this third wallet.


Another feature that needs some attention is signmessage. It can be used to 
send a transaction id/summary to a specified email address signed by the 
sending key of the same transaction (these can be added to the send-money 
GUI). This would allow merchants to publish a single payment address and still 
be able to verify which customers sent payment.


-------------------------------------

D'oh!  I forgot about that check (and should have remembered, I had to
increase it for my 'standard' multisig transactions branch).

Assuming BIPS 11 and 12 are adopted, there will be room in the
scriptSig for more than one signature. Once that happens, implementing
green addresses as an extra signature on the first scriptSig in a
transaction seems like a better way to do it than generating two
separate transactions.

Speaking of more-than-on-signature transactions:

I'm proposing a maximum 3 signatures for an IsStandard() transaction,
which would be a 600-byte scriptSig.

It is tempting to just bump the maximum up to 8 or 10, but I think we
should stay conservative about IsStandard() transaction size until
after two things happen:

1) bitcoin-qt gets smarter about downloading just block headers, and
maybe downloading transactions without scriptSigs (for transactions it
doesn't need/care to validate... need to think about that a little
more, but ByteCoin suggested that if you're not mining then the only
transaction signatures you need to check are not-yet-confirmed
transactions to you).

2) Transaction priority / maximum block size / free-transaction area /
transaction fees is reworked.  Miners should be making the policy
decisions on minimum fee per kilobyte or ECDSA signature check, and
how many free transactions (if any) they'll include in the blocks they
create.  And bitcoin clients should be smarter about looking at what
transactions are and are not getting into the chain so they can
suggest appropriate fees to users.

-- 
--
Gavin Andresen


-------------------------------------
Crossing posts ;)

I like your idea! - It adds a pricetag to distributing a signature - and - as you mention it will be part of the standard. It is only up to the clients if they want to support it or not, but it does give you 0-conf world wide instantaneous anonymously distribution of half-baked transactions...

However, the parties will anyway need to know at least about each others public keys up front and hence the 0-conf might not be that important... Left is, as you said, some anonymity (not much extra though)...

/M


On 09/11/2011, at 21:02, Gavin Andresen wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------
On Sat, Jul 16, 2011 at 9:16 PM, Douglas Huff <dhuff@jrbobdobbs.org> wrote:

Hopefully sirius will do this when he moves forum.bitcoin.org to
forum.bitcointalk.org.

But sirius is the only one with keys to bitcoin.org DNS, so....

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
4a/ Serialize all request/response exchanges.  i.e. request comes in 
from remote node, proxy aquires lock on the proxy-localdaemon channel 
and sends request.  Channel remains locked until response is received or 
timeout (in which case remote node gets no response).  Unlock channel 
after response received and send to client.

Possibly messages that don't expect a response (e.g. relaying a tx 
broadcast from remote node) can be pushed down a locked channel to 
improve performance as they won't interfere with sequencing.  Locked 
channels may also receive other unsolicited messages from local daemon 
before the expected response message which would be dealt with the same 
as if they came from an unlocked channel.

Disadvantages:  Idle time for channel while waiting for response.  As 
per option 2 this allows the proxy to stay dumb/thin but loses 
opportunity for de-duplicating/caching unless option 1 is layered on top.

4b/ As per 4a but use all 125 available bitcoind connections in a 
channel pool.  Acquiring a lock on a channel consists of checking for an 
unlocked channel first then waiting in a queue for one to become available.


-------------------------------------
On Sat, Jul 2, 2011 at 5:05 PM, Douglas Huff <dhuff@jrbobdobbs.org> wrote:


So, what about native build script generation for other platforms? autotools
can only generate makefiles (with at least two intermediate code generation
steps), which is quite limited.

IMO cmake is simple and elegant compared to the autotools monster. I don't
see why it would be "just as bad". And I have quite some experience with
both systems. Autotools is a hell to debug. cmake certainly isn't perfect,
but at least it's a leap forward.

It also requires a dependency that isn't installed by default anywhere, as

Yes, apart from that only obscure projects such as LLVM,  Blender, and
OpenCV are using it. Nothing of any importance.

BTW for cmake there is "ccmake" which is even better than configure --help
as it offers an interactive interface for configuration.

JS
-------------------------------------
If alias resolution was guaranteed to always be just the address, then 
yes, I would opt for no serialization at all. A simple plain text 
response of an address is about as simple as it can get.

There are already a lot of good ideas floating around about how the 
alias protocol could be extended. Is it really going to stay that simple 
for long? I would personally much just have a serialized response 
upfront, rather than having to worry about backward compatibility in the 
future.

On 12/19/2011 10:17 AM, slush wrote:


-------------------------------------
On Friday, June 17, 2011 6:31:25 AM Pieter Wuille wrote:

I'm not sure the Wallet protocol implementation needs to touch the GUI code at 
all, except when porting the GUI to use it. Therefore, if the code is already 
written, I don't see any harm in merging it.


-------------------------------------
On Thursday, June 16, 2011 1:59:56 PM Jeff Garzik wrote:

Even if you do this, a cracker can still simply send your encrypted wallet to 
himself, secure-delete your local one, kill your client, and demand you 
publish your password if you want some portion of your coins back.

I'm not sure there's *any* defense for an insecure PC. Maybe Bitcoin will end 
up forcing people to reconsider their priorities when it comes to security...


-------------------------------------
Don't worry Luke will basically say that about anything not related to
a crazy base16 number representation system that no decent modern font
can display.

To contribute:

I think the separated-from-github bounty system would be great. BUT:
The bounties need to go into some form of escrow. There have been way
to many bounties that weren't paid since BTC broke the $1USD boundary.

On Wed, Jul 27, 2011 at 9:53 AM, John Smith <witchspace81@gmail.com> wrote:


-------------------------------------
On Tue, 20 Dec 2011 10:10:23 +0100
Wladimir <laanwj@gmail.com> wrote:


I actually started a freenet plugin for blockchain distribution in summer (first rough steps only). Freenet seems really fit for this purpose since its mechanisms to provide wider storage (and thus faster requesting) for much-requested keys should help a lot here. Also freenet storage is decentralized, so that's another plus that goes hand-in-hand with bitcoin principles.

There's already a specification for "btcfn" which was done in 2010: https://bitcointalk.org/index.php?topic=55089.msg655410#msg655410

I stopped work on this because other people were supposedly working on it. I asked da2ce7 about it at the conference and he said progress was "slow".

I totally agree with the sentiment that these features should not be implemented in the bitcoin node itself but outsourced to the established systems, both because it's hard and also for "hiding traffic in the masses".

-- 
Nicolas Fischer <molec@gmx.de>


-------------------------------------

At Luke's suggestion, I did a bit more digging and was able to find a
data structure in wallet settings that should cause all versions (well
all versions since Bitcoin was in github, and probably before then) to
crash on load instead of making a new wallet or opening in some bizarre
half-state.  I just put an empty object in addrIncoming (nfc what it was
used for, but it will get the desire effect and it isnt used anywhere in
the code aside from its definition).
You can see the commit at
https://github.com/TheBlueMatt/bitcoin/commit/2e8383469d7e12a495b3a1dbd41a8d211ff34fe8
Does anyone disagree and think a different solution would work better?

This resolves all known issues and suggestions that I know of on newenc
except for the invalid mlock calculations, which I will go fix right
now.  So...aside from that bug does anyone have any remaining
suggestions/blockers on newenc and, if not, can we get final ACKs on it?

Matt
-------------------------------------
(Moving here because forum thread at
https://bitcointalk.org/index.php?topic=39088 didn't yield much
discussion)

Pull request: https://github.com/bitcoin/bitcoin/pull/476
Diff: https://github.com/bitcoin/bitcoin/pull/476/files

This was originally a patch that returned bitcoin's memory pool as
list of transaction hashes and the amount of total fees, but evolved
into a full alternative to the "getwork" RPC call for clients that
create their own generation transactions.

Like getwork, this call calls CreateBlock and returns parts of it for
mining, but instead of generating its own merkle tree, it returns all
the information needed to create a generation transaction in addition
to the full contents of other transactions that should be included.
It, as is, has had some testing done with p2pool - it resulted the
first p2pool generated block with transactions:
http://blockexplorer.com/block/00000000000002436bd2ae60d67d6fc0dce44deba2ad739619a3d364f6283e64


Help text:

getmemorypool [data]
If [data] is not specified, returns data needed to construct a block to work on:
  "version" : block version
  "previousblockhash" : hash of current highest block
  "transactions" : contents of non-coinbase transactions that should
be included in the next block
  "coinbasevalue" : maximum allowable input to coinbase transaction,
including the generation award and transaction fees
  "time" : timestamp appropriate for next block
  "bits" : compressed target of next block
If [data] is specified, tries to solve the block and returns true if
it was successful.


Thank you,
Forrest Voight


-------------------------------------

Hm this would potentially allow getting the IP for any recipient Bitcoin
address, given that a client with the private key connects to the network
once in a while.

Send them a transaction that is guaranteed to not be written into a block by
a miner, then monitor who rebroadcasts it over a few days/weeks.

I guess this could also be used to find out who has the stolen coins.

JS
-------------------------------------
Can you please submit a pull request and testing plan? If these already
exist, can you please link them here?

I'm exciting to get this in, as it will close the wx issues. (and hopefully
not bring on too many qt issues)

Thanks,
Alex
-------------------------------------
Since nobody else has mentioned it: There is another (more pragmatic?) 
way to detect double spends:

1. Connect to lots of clients
2a. If they all send you the same transaction -> double spend unlikely
2b. If some don't send you the transaction (or send a conflicting one) 
-> double spend in progress

Obviously not everyone will run a double spend detector - it's much more 
easily realized as a service (just like mining.) Jan put up a proof of 
concept: http://www.transactionradar.com/

Would network support like a MSG_DOUBLESPEND be better? I used to think 
yes, but looking at the reality of Transaction Radar, I'm not so sure. 
Nothing stops such a service from scaling up and connecting to thousands 
of random nodes (especially when the network itself grows bigger), 
pushing the probabilities of missing a double spend "in the wild" to 
near zero. It could also connect directly to important miners/pools as 
others have suggested.

Of course this doesn't help against double spends where the attacker 
does his own mining*, but neither would MSG_DOUBLESPEND. Given the added 
network load I'd argue that network support for double spends is 
unnecessary and potentially damaging. DoS is more scary to me than 
non-instant transactions.

* In this case of course the hacker will be exposed to some randomness, 
and I doubt many attackers will buy 100 televisions, newspaper 
subscriptions or MP3s to get one for free. So this is only a problem for 
liquid goods with tiny spreads (any investment or stored value instrument.)



-------------------------------------
On Wed, Sep 14, 2011 at 5:36 PM, Alex Waters <ampedal@gmail.com> wrote:

I'm generally opposed to doing "too much" at once in this kind of change.

Some changes, like this one, are completely uncontroversial (except
some argument about having fork causing change at all) where some have
more complicated social/economic impacts (the block size being among
them, though probably not the worst).

Moreover, the longer we go between such changes the more the cost is
perceived to be infinite. Better to take one per year, with six months
of gap between implementation, and give everyone the right
expectations than to have prolonged arguments due to our inexperience
that only get trumped by emergency changes.

General network health and user security _requires_ periodic upgrades
in any case, and will for the foreseeable future. The whole notion
that old versions will _stop working_ would be a pretty good thing at
this point in bitcoin's existence, judging by the high number of
pre-.24 listeners still reported.


-------------------------------------
On Fri, Sep 9, 2011 at 10:02 AM, Gavin Andresen <gavinandresen@gmail.com> wrote:


Signed builds up at sourceforge:
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.0/test/


-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Couple of semi-random thoughts:

RE: detecting double spends:  I agree that extending the protocol to make
double-spend detection better is probably a bad idea.

That said, I could see extending the information reported by the
listtransactions/gettransaction API calls to report detected double spends (
== transaction uses the same inputs as another transaction in the block
chain or memory pool). IIRC, now the code just drops double spends, so if
this was done the implementation would have to be careful about being
vulnerable to a "fill memory with bogus transactions" attack.

RE: badly-behaved nodes:  I'd really like somebody to start experimenting
with algorithms for detecting well-behaved and ill-behaved nodes-- maybe
starting with a dns-seed implementation.  I suspect people are starting to
experiment with various types of Sybil attacks, which might explain why
network connectivity has been so bad.

(sent from the Sydney airport, before a very LOOONG flight back to
Massachusetts)
-- 
--
Gavin Andresen
-------------------------------------
Pull request:
  https://github.com/bitcoin/bitcoin/pull/534

Denial-of-service prevention: orphan blocks

The attack this prevents: Generate valid "orphan" blocks and send them
to a bitcoin node. Orphan blocks are blocks that are not in the main
blockchain, and before this patch the bitcoin client would store an
arbitrary number of them in memory, in case they later became part of
the main chain.

Two checks are added:

1) Orphan blocks before the last blockchain lock-in are rejected, and
if the node sends enough of those obviously-not-part-of-the-main-chain
blocks it will be disconnected and banned.

2) Orphan blocks must have a plausible proof-of-work. It is impossible
for a difficulty 1.0 block to follow a difficulty 1-million block (it
would take at least 19 months for difficulty to drop from 1-million to
1). Orphan blocks with too-low proof-of-work are ignored, and if a
node sends ten of them it is disconnected/banned.

Requiring plausible proof-of-work for orphan blocks will make this
attack too expensive to attempt (you would have to generate valid
blocks at current difficulty).

-- 
--
Gavin Andresen


-------------------------------------

OK.  I mis-remembered the poll:
   http://forum.bitcoin.org/index.php?topic=4392.0

On by default	                       8 (20%)
Off by default	                       22 (55%)
On by default in the GUI, off by default in bitcoind	 10 (25%)

-- 
--
Gavin Andresen


-------------------------------------
On Tue, Oct 25, 2011 at 6:49 AM, Mike Hearn <mike@plan99.net> wrote:

You could do it that way...  but that would be inefficient.

You give the hash to whoever is paying you, and store the hash -->
script  mapping when you do that (assuming you're not using a
deterministic wallet; if you are, you probably just increment a
counter in the wallet).

The only use case I can think of where you'd want to check for every
possible hash is if you lose your wallet, you have a wallet backup
that has your private keys in it, but DOES NOT have the hash -->
script mapping(s).

For use cases involving other people, that's probably not a problem--
you could ask them to tell you what public keys are involved, and then
add them back in to the wallet (the RPC interface I settled on for
m-of-n txns is an "addmultisigaddress" that takes the "m" and an array
of "n" public keys, creates the script, adds the hash-->script mapping
to the wallet, and returns the hash).

For use cases where all the keys belong to you... either a good,
automatic, in-the-cloud-backup or the equivalent of "-rescan" is
needed to recover in case the mappings are lost.

-- 
--
Gavin Andresen


-------------------------------------
Good morning everyone.

On Thu, 29 Dec 2011, Gavin Andresen wrote:


Well, given the state that the OP_EVAL proposal was in when I looked at it 
this week, all your code reviews you have done so far are not adequate 
anyways.

Gavin, push the OP_EVAL date back 2 months.  OP_EVAL just is not ready 
yet.


I don't understand the above paragraph.


This is not adequate: <data> OP_SHA256 OP_EVAL runs random code that is 
more than 5 bytes.


Yes, but maybe there is other static analysis miners may want to do.  I 
can't imagine every scenario.


IMHO I think the above observation is not very relevant to the merits of 
the existing OP_EVAL proposal on the table.

-- 
Russell O'Connor                                      <http://r6.ca/>
``All talk about `theft,''' the general counsel of the American Graphophone
Company wrote, ``is the merest claptrap, for there exists no property in
ideas musical, literary or artistic, except as defined by statute.''


-------------------------------------
On Thursday, September 08, 2011 1:33:15 PM John Smith wrote:

Maybe require a proof-of-work then?


-------------------------------------
On Wednesday 10 August 2011 20:57:29 Jeff Garzik wrote:


My objection is not that such a list exists, it is that potential new 
developers are, essentially, shouted down unless they are working on that 
list.  I cannot imagine that many new developers arrive under those 
circumstances.


I don't think I said anything about it being centrally managed.  git lets us 
store these branches anywhere of course.  The fact is that such a branch 
exists somewhere.


I didn't say that it required anybody's help; but it does require a bit of 
willingess on the part of the master-branch-owning developers to import from 
that branch.


They key thing with linux-next is that work done on it _does_ make it into 
the kernel.  Tell me -- how many feature branches for bitcoin are just 
sitting as a pull request on github, and are now months old and abandoned 
out of disgust by their original authors?  Here's another question: why is 
it that so many projects have "specially compiled" versions of bitcoin?  
Rhetorical question... it's because the official client doesn't do what they 
need, and won't accept their patches to add it (even optionally).

I've only been watching this list for a few weeks (since the forum turned 
into an echo chamber); but I'm completely depressed by the agressive 
rejections of every new idea anyone raises.

Don't believe me?  Here's a list of ideas I've had "no, no, no"d so far; not 
one of which would have any financial implication at all.  Only some of 
which would break backward compatibility.

 - Extra bits in the service field of the version message to allow nodes
   to indicate if they are mining; if they are willing to be seed nodes;
   if they relay transactions; if they want relayed transactions.
 - getblocks in reverse chronological order so clients can start up quicker
   while downloading the blocks in the backround.  Ironically I was told 
   "patches welcome" by someone who didn't reject this one instantly.
 - Remove verack, as it's completely unnecessary.
 - Query miners for pending transactions
 - Application version separate from client version
 - A way of requesting block bodies without headers (saving a lot of traffic
   for a thin client upgrading)
 - Double SHA-256 for a packet checksum?  Seriously?
 - Sequence number as part of TxIn instead of part of the whole transaction
 - Script parameters should be stored outside the script, and reference by
   the script.  All that ridiculous filtering of the scripts in OP_CHECKSIG
   would then go away.
 - MSG_DOUBLESPEND... nope
 - getblocks to accept MSG_TX and do something sensible

Every single one of those has been shot down by one or more of the main 
developers.  I'm not a genius, and not arrogant enough to assume that 
everything I say is right, but _nothing_?  Really?  There is no problem that 
one of the above addresses?

Given that, what do I do?  Hang around and get battered some more, or go 
away to my own little corner and work on my own implementation?

You can imagine then that when I read moans about there not being enough new 
developers fixing bugs, that I am unsurprised and unsympathetic.  I like 
bitcoin enough to hover on this list; and offer a view of your world from a 
potential developer who was chased away.



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
Looks pretty reasonable to me. If Gavin changes the mainline client to use
this format I'll change BitcoinJ as well. It'll need a bit of API work so
clients are sure to set it up properly.

On Thu, Nov 10, 2011 at 10:16 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
On Thursday, August 04, 2011 7:43:56 PM Jeff Garzik wrote:

Yes. I'm not sure it has any practical impact on the software, but there was 
what looks like a platform-specific compile fix (casting between potentially 
incompatible types) too.


-------------------------------------
On Sun, 2011-07-10 at 18:46 -0400, Luke-Jr wrote:
Read what I wrote again, and don't reply off-list.
-------------------------------------

One double-spend fighting option is for each mining pool to offer a realtime feed of accepted TXs.

I am hoping to complete the following later this month:
	
	(1) A minimal bitcoind patch that writes raw accepted TXs and BLOCKs to stdout with a prefix of ("2naXaRQj--TX\n%d\n" % (data_length))
		(Proof-of-concept done  I'll submit a pull request with "--print-accepted-txs-and-blocks" when I get a chance to clean it up)
	
	(2) A minimal NodeJS app which invokes bitcoind as a subprocess, parses the TXs and BLOCKs, and offers a realtime feed



On Aug 4, 2011, at 3:42 PM, Andy Parkins wrote:




-------------------------------------
It's propably best to create a separate p2p network for off-band
information like this. No need to involve the blockchain with it.

- Joel

On Wed, 2011-11-09 at 16:18 -0500, Gavin Andresen wrote:




-------------------------------------
On Thu, Oct 20, 2011 at 7:02 AM, Alex Waters <ampedal@gmail.com> wrote:

Does it have to be wiki pages if we're going through an editorial process
anyway, and there will be few who can actually edit the pages directly? I'd
go for simple HTML documents in a repository.

ACK

Definitely. I don't think too many requests will come right away, and by
posting them here we make sure that the most knowledgeable people are there
to check and improve what might eventually end up in the clients.

-------------------------------------
On Mon, Sep 26, 2011 at 3:18 PM, Luke-Jr <luke@dashjr.org> wrote:

No.  Technically speaking this most recent release was 0.4.0.  That is
what is serialized in the build, and what is tagged.

Any stable version based off the most recent release would be 0.4.0.1.

And of course you're following the "upstream must have merged this fix
first" rule, right?

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
joric rightly points out that there are currently backward-compatibility
issues with Wallet encryption. As it stands now:
In version 0.3.23, Bitcoin dies with "ReserveKeyFromKeyPool() : unknown
key in key pool" after writing one unencrypted private key to the
(otherwise) encrypted wallet.
In version 0.3.22 (and I'd assume prior versions as well), Bitcoin opens
fine and displays transactions, however shows a total balance of what is
help only in unencrypted keys (of which it also writes a minimum of one
before opening), and each transaction shows only confirmation count,
date, no description, and a debit/credit of 0.00.  When you try to
perform any action which attempts to read keypool, you get the
"ReserveKeyFromKeyPool() : unknown key in key pool" error.

So, the question is how best to work around Bitcoin's overwillingness to
load wallets with keys that it has no clue about.

There were several suggestions of renaming wallet.dat for encrypted
wallets.  Obviously this has many advantages and disadvantages.  It
breaks backup scripts, old clients will now create a new wallet instead
of using the old one, potentially causing users to (wrongfully) assume
their wallet is encrypted if they accidentally start opening an old
version.  Im not a huge fan of this one, mostly because if a user opens
an old version, they will get a blank transactionless wallet which IMO
is worse than an odd error message.  "My wallet is gone, Ive lost
everything, wtf???" vs "My wallet got corrupted, crap need see what I
can recover from it, I hope I dont lose much"

Another option is to simply do nothing, and let old clients get mad.  If
a user goes back to an old client, it cant spend coins using the
encrypted keys no matter what is done.  If the new client handles
multiple key types gracefully, however, it can simply say "Hey, I see
you have a mix of key types here, can I have your password to encrypt
the unencrypted ones?" and move on with no harm done.  IMO, I would much
prefer old users see error messages and be unable to use their wallet,
then accidentally create multiple wallets, and give them a screen making
them think their coins are all gone.  Comments?

PS. to prevent this in the future, Bitcoin really shouldn't continue on
as if nothing had happened when faced with unknown keys:
https://github.com/bitcoin/bitcoin/pull/378

Matt
-------------------------------------
Hi All,

I started messing around today with building a node crawler to try and 
map out the bitcoin network and hopefully provide some useful 
statistics.  It's very basic so far using a mutilated bitcoinj to 
connect (due me being java developer and not having a clue with c/c++). 
  If it's worthwhile I'll hack bitcoinj some more to run on top Netty to 
take advantage of it's NIO architecture (netty's been shown to handle 
1/2 million concurrent connections so would be ideal for the purpose).

Hoping to a get a bit of input into what would be useful as well as 
strategy for getting max possible connections without distorted data.  I 
seem to recall Gavin talking about the need for some kind of network 
health monitoring so I assume there's a need for something like this...

Firstly at the moment basically I'm just storing version message and the 
results of getaddr for each node that I can connect to.  Is there any 
other useful info that can be extracted from a node that's worth collecting?

Second and main issue is how to connect.  From my first very basic 
probing it seems the very vast majority of nodes don't accept incoming 
connections no doubt due to lack of upnp.  So it seems the active crawl 
approach is not really ideal for the purpose.  Even if it was used the 
resultant data would be hopelessly distorted.

A honeypot approach would probably be better if there was some way to 
make a node 'attractive' to other nodes to connect to.  That way it 
could capture non-listening nodes as well.  If there is some way to 
influence other nodes to connect to the crawler node that solves the 
problem.  If there isn't which I suspect is the case then perhaps 
another approach is to build an easy to deploy crawler node that many 
volunteers could run and that could then upload collected data to a 
central repository.

While I'm asking questions I'll add one more regarding the getaddr 
message.  It seems most nodes return about 1000 addresses in response to 
this message.  Obviously most of these nodes haven't actually talked to 
all 1000 on the list so where does this list come from?  Is it mixture 
of addresses obtained from other nodes somehow sorted by timestamp? 
Does it include some nodes discovered by IRC/DNS? Or are those only used 
to find the first nodes to connect to?

Thanks for any input... Hopefully I can build something that's useful 
for the network...


-------------------------------------
My fault, Ill write something up on the train back today.
Jenkins + a large enough test suite could do very nice automatic sanity
testing IMHO...that is what it is designed for (even if not to
automatically test pre-merge, but it could be adapted).  Many pull
requests build on Linux, but not on MinGW, OSX, etc so just that would
be useful IMHO.
Sipa's stuff is quite good IMHO, it still has some problems left to
solve (like choosing minor details of the underlying priority algorithm)
but aside from those, I think it could work.  I'm not sure if sipa wants
to just publish the stuff he did so far and let this list debate on the
remaining details and eventual implementation, or if he wanted to come
up with something complete before publishing, it up to him, but it is
doable.

Matt
-------------------------------------
On Tuesday, September 27, 2011 11:45:48 PM Jeff Garzik wrote:
wrote:

I tested removing midstate myself, and found at least one miner (cpuminer 
IIRC) requires it.


-------------------------------------
On Sat, Dec 17, 2011 at 7:44 PM, Jordan Mack <jordanmack@parhelic.com> wrote:

Well, the block chain data itself is internally self-validating.  As
long as you know the latest block's hash -- a big "if" -- there is no
problem downloading all other block chain data from DHT or any other
untrusted source.

In a malicious case, you would notice latest-hash differs from
non-malicious and wind up downloading multiple chains, when walking
hashes backwards through a DHT/lookup table.  So, a bit more work but
nothing fundamentally less secure _on a trust basis_.

Of course, I was focusing on data validation, which ignores other
factors such as DoS'ing the DHT.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wed, Aug 24, 2011 at 11:12 AM, Gavin Andresen
<gavinandresen@gmail.com> wrote:

It's a good tool which we should have in our tool-belt.

Though it's a bit of when you are a hammer all problems are nails.
This issue can also be addressed by things like external private key
protectors.  But someone would have to build one.

Someone might be more inclined to build such a thing if the software
had good support for tracking public keys without private keys, and
generating unsigned transactions for export to the device for signing.

[snip]

Regardless, it might be useful to contact the authors.


I agree.


One way of doing this would be to have an address which hashes an
ordered concatenation of many addresses (perhaps plus a length
argument). To redeem you provide the public keys which are signing,
plus the addresses which aren't signing, and the receiver validates.

If it can be done, then yes, I agree it would be worth forking the chain.

This _feels_ like something which could and should be done with the
existing (but disabled opcodes).


It's not exclusive, however, with a long N-address address type for
multisig destinations.  We could support that _now_ and defer the
'compressed version' until after people have experience with this
usage.  The only cost would be supporting this address type forever,
which isn't that bad.

It's also important to note that incompatibility wouldn't be complete:
The only limit is that old clients couldn't send funds to escrow
addresses— which is an issue no matter how you encode the information.


-------------------------------------
I think HTTPS, and more specifically x.509 PKI certs and CAs are generally a good idea and (historical implementation bugs aside) the concept is technically sound and secure.  What is a bad idea (in my opinion) is to trust a software vendor to decide who you should trust.. thus it is a bad idea for bitcoin software to promise any trust.

The part where the concept becomes flawed is trusting 3rd parties who have no relationship with you, to serve your interests.  Now I'm just generalizing here and this is not universally true.. but internet CAs just want to sell certificates - they generally don't care beyond that, and they abuse the certificate validity dates to charge more money.  All this is done under the guise of wanting to provide a secure experience to users without a prior relationship to the entity being identified.  I propose that trying to follow this paradigm in bitcoin alias resolution is a bad idea because it tries to solve 2 problems at once, one of which does not have any 'good' solution, and forces a specific policy.

First, we need to resolve an alias to a bitcoin address somehow.. but secondly we need to establish trust with the entity doing the alias resolution - to make sure that we can trust the response.

When resolving an alias you will have to query an untrusted server, possibly being proxied by an 'attacker'.  Presumably, an x.509 certificate will be presented, possibly self signed or chained off a self generated CA or whatever else.. but if it's your first contact then there is no possible way to know if it's correct or not.  You would have to retrieve the correct public key of the CA to compare to first, possibly out of band.  Get it from my website, compare it to my business card, send me an email and I'll send it to you, or get it from some other source using some other pre existing trust (a centralized and possibly private directory perhaps).  The point is, the reason there is so much disagreement is because there is no good way to trust the resolver if you don't create that trust relationship prior to resolving an alias from it.

I think that having to pre-trust the resolver would be an acceptable solution to all.. Those whose policy requires a simpler process can get a 3rd party CA list, much like the ones provided with web browsers and operating systems.  Those with strict verification policies can choose to pre verify every public key.. and these processes are familiar to many organizations using PKI for other things already.  In a client, presenting the usual certificate detail dialog, showing the public key, subject, issuer, and thumbprint would be sufficient to allow users to implement their own policies without forcing it one way or another.

Please consider that while some organizations or users might require strong anonymity and pre existing trust, there are others who may want to do the opposite and that is just as valid, even if you or 'everyone else' disagrees with that.  In the case of bitcoin, it will be used as part of a larger system, and whatever concerns are created by 'insecure' alias resolution may well be addressed in another part of the system.  The most successful standards and implementations are the ones which provide the most flexibility - primarily because that allows users to extend them in ways the original designers didn't necessarily plan for.

Thanks,
Laszlo



On Dec 19, 2011, at 11:44 AM, Andy Parkins wrote:




-------------------------------------
I don't think Gavin misunderstands how open source works at all. It's
completely normal for project maintainers to say "no" more often than
they say "yes". When I worked on open source for a living this was
part of the natural flow of things.

It's important to understand that ideas which receive "maybe" or "yes
but later" or "no unless you convince me" or "perhaps in a different
way" are not being shot down. These answers are requests for more work
to be done. You *cannot* get emotional about open source contributions
and any veteran will tell you this. Open source maintainers cannot and
do not say yes to every patch or idea that is proposed. I would be
very worried if Gavin did.

Now let's review these ideas:


I think the concept is reasonable but service flags might not be the
best way to do it, for instance, asking for a filtered transaction
feed is useful for lightweight clients so you'd want more precision
that can be fit into service bits.


I already told you this won't help startup time because you have to
connect blocks together in sequence. You can't build up the block
chain backwards unless you don't care about validation at all.


Or just have them send an inv containing them after connect. I don't
remember this one being "shot down".


You mean separate from protocol version, right?


The cost/benefit ratio of this one isn't obvious at all. The resource
requirements for running a full node are large enough that
re-downloading 80 bytes per block is the least of your worries if
you're upgrading.


Feel free to submit a patch to disable checksum validation and see if
Gavin accepts it. It needs to still be calculated at send time for
other implementations.


Sequence numbers are already part of the tx inputs. Or do you mean
they should be part of the whole transaction? If the latter then this
is indeed an idea that will be shot down, it's deliberate that seqnums
are part of the txinputs and it needs to be that way for contracts. It
can't be changed without forking the protocol anyway.


Some of your proposals address problems that need to be solved, but
it's not clear that way is the right way to solve them. Others reflect
either lack of understanding of the system or the fact that you don't
value backwards compatibility whereas other people do.


-------------------------------------
On Tue, 2011-12-13 at 00:37 +0100, Jorge Timón wrote:
Firstbits isn't acceptable for anything.  As Amir originally pointed
out, it doesn't scale well and worst of all it fills the blockchain with
a ton of crap to get 1 satoshi at an address so that it is
"registered".  
Firstbits is unacceptable because it causes unnecessary harm to each
Bitcoin node.  However, if one were to use a chain specifically crafted
for such a purpose isn't terrible.  That said, it still doesn't scale
well and if it becomes popular virtually every implementation would have
to rely on trusted servers at which point you are better off going back
to an HTTPS/DNSSEC-based implementation

Matt



-------------------------------------
On Sunday, December 18, 2011 7:15:26 AM Jorge Timn wrote:

"Green addresses" are also a broken-by-design feature and should be 
discouraged.


-------------------------------------
There's no project currently :-)

Starting from Matts code is probably the way to go. It's written in PHP.
Alternatively, you could write a Java app for it, as there are drop-in DNS
serving libraries you could link with BitCoinJ+sqlite. It probably wouldn't
be that hard. You'd want to sort nodes by version, how long they've been
observed to exist, the last polling time, etc.

On Wed, Aug 3, 2011 at 4:00 PM, Rick Wesson
<rick@support-intelligence.com>wrote:

-------------------------------------

Yes please use email-like addresses, whatever is decided on the underlying
protocol.

JS
-------------------------------------
On Sat, Jul 2, 2011 at 11:30 AM, Matt Corallo <bitcoin-list@bluematt.me>wrote:


CMake is also very standard, used by many projects, and is available in many
distros.

For debians it's as simple as apt-get install cmake, which is not a big
problem as you need to install the other dependencies (such as boost) as
well to build.

Fedora/redhat also seems to have the package 'cmake'. I don't think there is
any modern distro that doesn't have it as a package.

JS
-------------------------------------
Thanks for the warm welcome...

I was specifically referring to building with autotools as a starting
point. Primarily autoconf to ease the installation and testing process.

On 08/22/2011 04:12 PM, Douglas Huff wrote:
In this regard I was referring to running bitcoin in /etc/init.d on
Debian based systems. By init script, I was referring to making scripts
run at boot time.

I'll check this out.

fpc

-------------------------------------
On Mon, Jun 13, 2011 at 2:41 PM, Gavin <gavinandresen@gmail.com> wrote:

Agreed.  I'll see if I can put together a couple different solutions,
and stick them in there.  ETA 3-4 weeks though, given current bugfix
workload + personal issues (moving to a new house).

I had a thought related to this, but readily admit I haven't thought
this through:  create an RPC in bitcoin that returns a random
selection of fresh P2P node addresses, from addr.dat.  One problem I
was running into was accessing this data from outside bitcoin.

Using ArtForz' half-a-node as a base was a possibility, but creating
"getnodes" RPC seemed far easier.

djbdns (tinydns) is great for this:  it is highly scalable and stable,
and its input is a -very- simple text format, easier to generate than
BIND zone files.


Great!  A big missing piece is simply trusted people running DNS seeds
on stable connectivity, once the DNS software is there.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sun, Oct 9, 2011 at 1:12 AM, Luke-Jr <luke@dashjr.org> wrote:

What will you be using instead? Isn't bitcoind a requirement for running a
pool?
-------------------------------------
Resending to mailing list as I replied directly...
On Thu, Sep 8, 2011 at 11:03 PM, Christian Decker <
decker.christian@gmail.com> wrote:

-------------------------------------

What Daniel said.  Although I did upload the signatures to github, too:
  https://github.com/bitcoin/bitcoin/downloads

The github downloads have been unreliable, so I didn't announce that
you can download from there.

-- 
--
Gavin Andresen


-------------------------------------
At first the idea of using negative announces seems attractive, but
remember that a malicious node might trigger verification for every
transaction, which may lead to a DoS.

Regards,
Chris

On Thu, Dec 22, 2011 at 1:14 PM, Joel Joonatan Kaartinen <
joel.kaartinen@gmail.com> wrote:

-------------------------------------
On Thu, Aug 25, 2011 at 04:29:03PM -0400, Gregory Maxwell wrote:

Some extra estimates:
* single address: 21 bytes (36 characters), 27 bytes script
* 1-out-of-2: 43 bytes (66 characters), 56 bytes script
* 2-out-of-3: 67 bytes (98 characters), 88 bytes script 
* (a and b) or c: 65 bytes (96 characters), 85 bytes script

-- 
Pieter


-------------------------------------
This patch conditionally adapts the one line needed to support boost 
filesystem version 3 (default in Boost 1.46+ and required for 1.48+)

I have tested it with Boost 1.41.0 to verify it still works on these older 
versions too.
-------------------------------------
On Thursday 11 August 2011 04:20:25 Jeff Garzik wrote:


Did you even read what I wrote?  "if( blockNumber > 5000000 )" is about as 
far from immediate as you can get.  I'm not an idiot; I understand we can't 
lock people out of their money simply because of a software upgrade.  It's 
not unreasonable to expect people will have upgraded by block 500000 though 
(or whatever number the community decided upon).

Again you're missing my point... you are still shooting ideas down.


Well the community had better unhardwire itself or its going to end up with 
five developers and no more.


Voting with ones feet should be a last resort.  Wouldn't it be better not to 
end up with incompatible clients out there?


Client: I speak version 10
Server: hmmm, I don't speak version 10, I only speak version 5
Client: I am willing to lower to version 5 so I shall continue

or

Client: I speak version 10
Server: hmmm, I don't speak version 10, I only speak version 5
Client: I am unwilling to lower to version 5 so I shall hang up

or

Client: I speak version 5
Server: hmmm, I speak version 10, but I am willing to speak version 5

or

Client: I speak version 5
Server: hmmm, I speak version 10, and I am unwilling to speak version 5
        so I shall hang up

'verack' is redundant.  It sends no information and merely says that the 
other end is willing to continue.  Willing to continue is easily determined 
when the remote continues.  Handling 'verack' is an annoyance, and adds 
nothing.


Please point me at a single incompatible change that has been rejected by 
the userbase.

Further: I'm not suggesting incompatible changes alone; that would be 
insane.  I'm suggesting upgrade paths that delay incompatible changes until 
the change has propagated.


I don't think that's what's happening.  Not once have I seen the "benefits" 
side of that equation.  What I have seen is plenty of "I can't see a use 
case for that"; when the key word in that sentence is "I".


The users aren't typically going to be familiar enough with the internals of 
bitcoin to care about many of the changes I suggested.  I have repeatedly 
said I don't want to break anything, I want to transition in an orderly 
fashion (and the majority of my suggestions were backward compatible).  But 
of course, I don't actually want to do anything with bitcoind itself, it's 
been made repeatedly clear to me that anything I might ask for is not going 
to happen -- and of course what I was pointing out, _not_ asking for, was 
that you can't expect to get new developers on board if they aren't going to 
be allowed to scratch their itches.


You've just had some.  The response was "you're wrong".



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
On Fri, 2011-08-05 at 12:58 +0100, Andy Parkins wrote:
Number of connections is something that needs serious thought.  Too many
and you fill everyone's connection slots and no one can make
connections.  Too few and you don't have a network but just a bunch of
islands which would also cause serious problems.
If you aren't relaying, each connection takes almost no bandwidth, so
the question is how many do you need to be considered secure.
-------------------------------------

I sit corrected. The context is:
    // Checking ECDSA signatures is a CPU bottleneck, so to avoid
denial-of-service
    // attacks disallow transactions with more than one SigOp per 34
bytes.
    // 34 bytes because a TxOut is:
    //   20-byte address + 8 byte bitcoin amount + 5 bytes of ops + 1
byte script length
    if (GetSigOpCount() > nSize / 34 || nSize < 100)
	return DoS(10, error("AcceptToMemoryPool() : transaction with
out-of-bounds SigOpCount"));

I'm having trouble imagining some future world where valid,
new-versions-agree-to-relay-transactions have more than one SigOp per
34 bytes; can you give an example?


That would imply you're on a blockchain fork of more than 99 blocks
with respect to the person spending the transaction, in which case I'd
argue you have much bigger problems and it is a good idea for the DoS
code to kick in and kick either you or them off the network...

-- 
--
Gavin Andresen


-------------------------------------
Yes, you're right, there is a lot of code is in the "fun with knives"
category.

JS

On Mon, Oct 24, 2011 at 4:31 PM, Amir Taaki <zgenjix@yahoo.com> wrote:

-------------------------------------
With increased reports of stolen wallets, I humbly submit that wallet
crypto should be a top priority for the next version.
https://github.com/bitcoin/bitcoin/pull/232

Anyway...  start pulling :)

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Thu, Dec 29, 2011 at 08:08:38PM +0100, Pieter Wuille wrote:

I realized this may have been needlessly complicated. All is required to achieve the
same properties (plus win half-verification by old clients) is a somewhat more
restricted OP_EVAL which:
* Does not touch the stack or altstack - it looks at the last (code-position wise)
  literal pushed (and not yet consumed by another OP_EVAL) on the stack and uses
  that as script to be executed.
* Executes its subscript in an independent environment, which inherits only the
  main stack (this allows the outer script to hide information from the
  inner script by moving it temporarily to the alt stack).
* OP_EVAL is an effective no-op for the execution state of the outer script,
  except for:
  * potentially causing failure (if the subscript doesn't parse or doesn't
    terminate succesfully)
  * popping an element from the literal-only stack

A pay-to-script-hash becomes:

  OP_EVAL OP_HASH160 <scriptHash> OP_EQUAL

and is redeemed using

  [script input] <<script>>

-- 
Pieter  


-------------------------------------
2011/12/15, Jordan Mack <jordanmack@parhelic.com>:

You're right. Then servers should not use a different address with
every lookup. Maybe don't change it more than once per
min/hour/whatever, maybe wait to see a payment to that address to
start giving another one...


-------------------------------------
On Monday, September 05, 2011 3:25:47 AM Michael Grnager wrote:

Yes, the default is "UPnP supported, disabled by default" (USE_UPNP=0), not 
"UPnP not supported" (USE_UPNP=). This is documented in build-unix.txt ...


-------------------------------------
I have a proposal and design for a new project built on bitcoin.
Where should I post my initial proposal and design to start a
discussion?  Its of interest to bitcoin folks and a wide range of
others.  Its totally cool and a first-of-its-kind and I want to start
discussing it.  I'd like to discuss it on this list if its
appropriate.  Its entirely built on bitcoind, so I need your comments.

B

-- 
Make a Small Loan, Make a Big Difference - Check out Kiva.org to Learn How!


-------------------------------------
Does it make more sense to have the flood limit based on size in bytes
versus # of blocks?

(I'm a n00b, so pardon my ignorance). :)

D.

On Tue, Jun 14, 2011 at 10:44 AM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
On Thu, 2011-12-15 at 13:59 -0600, theymos wrote:
I'm not against this, but I think its way overcomplicated when compared
to the DNS or HTTPS methods.
OK, not too debatable, but considering how terrible bitcoind's account
handling is, the second might not be easy to get right...
This is where I think this method becomes way overcomplicated.  Not only
do you have to update the IP-Transaction code, but now you have to
implement the full DNS System that is the other option as well.  Note
that to make this secure, we have to have a full DNSSEC-capable resolver
built-into bitcoind (there are libs, but it has to happen).  Yes you can
ask the user "does this fingerprint look right to you? Y/N" but that
always opens you up to a ton of users getting screwed out of coins and I
don't think it should be enabled, except in bitcoind, and since the main
target of this whole alias system is bitcoin-qt users, well...

Matt



-------------------------------------
On Wed, Aug 10, 2011 at 3:32 PM, Andy Parkins <andyparkins@gmail.com> wrote:

This is true -- though there is value to having a list of "things we
think people should focus on" for the motivated, and for new people
interested in tackling a project, but not sure what project to tackle.


A centrally managed development branch on bitcoin/bitcoin.git is not
the way to do it, however.  See the description of linux-next, in my
previous email, for a more distributed method which can easily be
layered on top of the existing bitcoin dev structure by any motivated
volunteer(s).

Think distributed.  :)  The community does not need Linus's help
(linux-next) or Gavin's help (bitcoin-next) to do this.  linux-next
became so widely used and useful that Linus requires almost all
changes to be first staged in linux-next.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Wednesday, July 27, 2011 10:20:07 AM John Smith wrote:

I'm not sure a few small bounties would justify agreeing to GitHub's steep 
demand for potentially unlimited money in their terms of service...


-------------------------------------
Using commercial CAs to establish trust is a site local administrative policy..

Bitcoin and operating systems have no technical need to concern themselves with this.  It is a shame that the system has been abused by CAs paying off operating system and web browser vendors but this is not the only way to use it.. my policy may be (as an example) to require each party I deal with to generate their own self signed cert or their own CA cert (same thing really) and then I can trust that and only that.  Obviously, commercial CAs will sell a certificate to anyone which means you trust anyone that is their customer.  This is a valid site policy but not for everyone.

Rick Wesson's suggestion about DNSSEC and such is interesting since it would provide a system for that 'first contact' exchange where you can more reliably retrieve the certificate, if the site supports it.  Some policies may not require this however - you can always get the trust established another way like downloading a cert file from a website or whatever else you consider adequately secure for your organization.

I think 3rd party CA lists and the DNSSEC/DANE idea are both useful ways to automatically establish trust out of band, but this is independent of the actual implementation of alias resolution, which happens after a trusted connection is made.  Automatically establishing trust with the alias resolver is perhaps a useful feature, but not a requirement for either side to support alias resolution.

In any case, it sounds like using HTTPS and x.509 certs would allow many of these automatic trust establishment systems to be implemented on top, allowing flexible policy configuration, which seems to be important to several people in this thread of discussion.

I think using JSON would be ok but like it's been said, you either have to serialize your binary data into some text format like base64/UUencode or represent it as an integer array, both of which are inefficient.. probably cancelling out any benefit of using JSON in the first place :)

Maybe there is no need for binary data for alias resolution though.. I imagine it would be as simple as submitting a name to resolve, and giving back a base58 address string, perhaps along with a textual comment or other extra, information data.

Being strict or lax or anything else is not really a concern for alias resolution - establishing trust is an administrative issue with a lot of different solutions and not every site or application requires trust.  HTTPS and mutual authentication may be desirable for general cases, however HTTP should work just as well if trust is established another way and thus SSL/TLS is not a requirement for the HTTP exchange to work.  As an example use case, I may be using IPsec or any number of other systems external to bitcoin and alias resolution itself.

Laszlo



On Dec 19, 2011, at 4:35 PM, Luke-Jr wrote:




-------------------------------------
On Fri, Dec 16, 2011 at 8:17 AM, Pieter Wuille <pieter.wuille@gmail.com> wrote:

You are making my point (again) regarding usability and security.
Aliases are not a https secured URI+bitcoin address.

-rick


-------------------------------------
On Friday, October 28, 2011 2:33:44 PM Gavin Andresen wrote:

This is an Ubuntu issue. Can't gitian use something else?


Better would be a GUI=0/1 option to the bitcoin-qt.pro until a nicer (ideally 
automake/autoconf) system is implemented...


-------------------------------------
Am Mo, 24.10.2011, 16:55, schrieb Gavin Andresen:

I played around with this a little bit and managed to generate such
transactions. However, I ran into the problem that IsStandard() also
checks that the size of scriptSig is not above 200. Adding an extra
signature there triggers this limit. I guess there is no way around
that?

Regards,
Jan


-------------------------------------


ACK


 If he's willing, I propose that Amir take the role of BIP editor.



ACK

As for what Nils mentioned on using GitHub's Wiki feature, Gavin seems to
have started a few proposals at
https://github.com/gavinandresen/bitcoin-git/wiki. I think this is the right
direction to head in, and a composite list of similar proposals could be
maintained on their own repository (to maintain separation from the core
Bitcoin repo.)

-Alex
-------------------------------------

No no no I never stated that the UI should no longer support RPC. If you
want the UI, with RPC, you can still run the UI executable with -server.
There are many usecases in which you want to access the UI bitcoin client
using RPC...

I only meant that it would also build the *headless* daemon by default, as
separate "bitcoind" executable. So you cannot run the UI exectuable as
headless server anymore. The -daemon option would go away. It would make the
setup a lot easier: The UI can connect to  X and display a splash screen
immediately without first looking at the command line arguments, whereas the
headless daemon can ignore all that stuff and get straight to work.




It's easy on windows:  just install Qt Creator (comes with the Qt SDK),
install the extra dependencies (build instructions are in README.rst), and
hit build.

On MacOSX I'm not sure.  I think it's similar, as a few people built it for
MacOSX and contributed settings for the .pro file...

It can build the GUI fine for every platform, however it can only build the
GUI, not the headless daemon or the command line client. You'd still need
old fashioned makefiles for those.

Cmake or autotools would be better, especially as those are intelligent
enough to auto-detect the name of libraries such as boost, and detect
presence of optional dependencies (miniupnp).

JS
-------------------------------------
RE: preventing OP_EVAL from executing the result of calculations:

Good point, the rule should be "OP_EVAL shall fail if asked to execute
8 or fewer bytes."

RE: this minor disadvantage:



It is the "Either This or That can redeem" case that motivated me to
allow 2-deep EVAL recursion.

Start with the most straightforward code for doing "this or that" (in
pseudocode):

scriptSig:  <sigs> <either the code for This or the code for That>
scriptPuKey:
  IF <hash of code> EQUALS hash of This or hash of That:
    EVAL
  ELSE
    fail validation
  ENDIF

That can be done with CODESEPARATOR/CODEHASH.

But if you want to then bundle that up so the scriptPubKey is a
standard 'pay to script', you get:

scriptSig:  <sigs> <either the code for This or the code for That>
<serialized IF... code from above>
scriptPubKey:  ... standard DUP HASH160 <> EQUALVERIFY EVAL

To be backwards compatible with old clients the scriptSig would have to be:

<hash1> <hash2> <sigs> CODESEPARATOR this_or_that_code
 CODEHASH
 CODESEPARATOR
 IF <hash of code> does not equal hash2:
   fail verification
 ENDIF

That could only be done if the definition of CODEHASH was modified to
hash only the stuff between CODESEPARATORS instead of hashing from
CODESEPARATOR to the end of the scriptSig.

RE: static analysis:


The vast majority of miners are "discouraging" (not relaying or
putting into blocks) anything besides 'standard' transaction types.

Until somebody smarter than me (like Russell) has done a deep analysis
of Script and all of its opcodes, I don't think that should change.
The standard transaction types are easy to reason about, and the
standard types extended with OP_EVAL are also easy to reason about--
you can template-match them to find out how many ECDSA operations a
CHECKMULTISIG will do, etc.

Again, in practice, I don't think EVAL as proposed is a danger.

RE: delaying EVAL rollout:  I could live with rolling out just BIP 11
(up-to-3-signature-CHECKMULTISIG as 'standard' transactions) and
delaying EVAL rollout on the main network, but I worry that will just
encourage people to delay thoroughly reviewing/testing for a couple of
months, and we'll be right back here at the beginning of March.

-- 
--
Gavin Andresen


-------------------------------------
On Mon, Dec 19, 2011 at 12:58:37AM +0100, slush wrote:

Any DNS-based alias system is vulnerable to spoofing. If I can make people's
DNS server believe that mining.cz points to my IP, I'll receive payments to
you...

If no trusted CA is used to authenticate the communication, there is no way
to be sure the one you are asking how to pay, is the person you want to pay.
Therefore, one solution is to put a bitcoin address in the identification
string itself, and requiring SSL communication authenticated using the
respective key.

This makes the identification strings obviously less useful as aliases,
but pure aliases in the sense of human-typable strings have imho
limited usefulness anyway - in most cases these identification strings
will be communicated through other electronic means anyway.

Furthermore, the embedded bitcoin address could be hidden from the user:
retrieved when first connecting, and stored together with the URI in
an address book. Like ssh, it could warn the user if the key changes
(which wil be ignored by most users anyway, but what do you do about
that?)

-- 
Pieter


-------------------------------------

I'd like to find ways to alievate this requirement.


really, pointers please. DHS was a huge funder for DNSSEC asn .mil was
the first domain to deploy it. I think you may be miss-informed.


correct, I was speaking about an "address" that used the same/simular
formatting but did not use the SMTP protocol.

-rick



-------------------------------------
On Wednesday, December 21, 2011 12:17:57 PM Jeff Garzik wrote:

[Friday, December 02, 2011] [1:57:14 PM] <gavinandresen> luke-jr: ok-- there 
seems to be general consensus to pull coinbaser for 0.6, so I'll probably pull 
it before op_eval and rework the op_eval code to use coinbaser.


At least Eclipse (235 GH/s) is using it, and slush (1.3 TH/s) intends to.


-------------------------------------
On 2011 December 15 Thursday, Walter Stanish wrote:


Quite so; the BIP15 standard shouldn't be setting the format of the URI; it 
should be setting what the format of the client-server conversation is.  
Effectively, what headers will a requesting client send?  What headers should 
a server require?  What will a server respond?


I think that's missing the point; any aliasing scheme is definitely reducing 
your anonymity, neccessarily so -- the alias has to be looked up somewhere, 
that somewhere reduces anonymity.  If anonymity is what you want, stick with 
just a bitcoin address.  The point of an aliasing server is surely to be able 
to give a single, unchanging, well known label to a transacting party, but 
still enable that party to generate a new address per transaction.

I want my webshop to be able to say "please pay 3.20 BTC to 
https://mywebshop.com/payments/orderid=27282" to enable the automatic 
connection from orderid to bitcoin address (which my payment system can then 
monitor for payment receipt).  (This is just one example).


Well yes; but then the client has no idea what address to send to unless it 
connects to that URI... interaction/address generation is done when that 
connection is made.

In short: I don't really think that this aliasing system should be concerning 
itself with preserving anonymity of the receiving party.  That is almost 
certainly already gone (I'm hardly likely to send money to someone I don't 
know unless I like gifting random cash).  The sending party loses a little 
anonymity because their IP is revealed when they connect to the aliasing 
system.  But there is very little anonymity in a supplier-client relationship 
anyway (you have to say what goods you want, and where you want them, and you 
had to interact with a website when you were ordering already).



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
I updated src/makefile.osx and doc/build-osx.txt  today, assuming that
the MacPorts versions of dependencies will be used and the -mt boost
libraries will be used.

I also modified makefile.unix and makefile.osx to auto-build
dependencies using gcc's  -MMD  option.

-- 
--
Gavin Andresen


-------------------------------------
On Tue, Oct 25, 2011 at 9:21 AM, Gavin Andresen <gavinandresen@gmail.com> wrote:

If anyone finds that solution unsatisfying, consider— It's already the
case that I could take one of your disclosed public keys and create an
infinite series of secondary keys out of it for which only you could
decode, and the only way for you to find them in the blockchain would
be to have performed the same procedure and made a note of the
addresses you're watching for.

... or really, more simply I could generate a private key on your
behalf and send funds there. ("What do you mean you didn't get the
funds? I sent them to the private key defined by the cryptographic
hash of the lyrics of your favorite song!")

So it's already the case that if I didn't get your address from you
(or through a negotiation with you), I can't expect you to receive
them.


-------------------------------------
On Sat, Jul 2, 2011 at 5:45 PM, Douglas Huff <dhuff@jrbobdobbs.org> wrote:


It doesn't for the native build systems on at least Windows and OSX. Yes,
you can get gmake to run, but it's a hack.



You don't need to use the UI. It's just a convenience. Command line can
simply be used if you want.



As I said in my opening post, there *is* a cmake build system implemented
for bitcoin.

JS
-------------------------------------
On Mon, 2011-07-11 at 00:37 +0200, Michael Offel wrote:
Yep, anyone with the time can gladly comment up the code, it would be
much appreciated, but as it stands now there are more important things
to do...like many of the things here:

Yes, thats one of the general development goal, sipa's CWallet was an
excellent start, but much more work needs done in terms of clear
splitting of the code.

My bad, was just following the previous comments...
At the time Bitcoin began being built, Ubuntu 9.04 (or was it 9.10?) was
used, as it offered the oldest libc on the newest OS.  Ubuntu 9.04 just
happened to only have db4.7.  For backward compatibility, db4.7 has been
used ever since (except, for some reason, the osx builds).  In 0.4,
db4.8 will be used.  If you are asking why bdb was used to begin with,
why not? its an excellent db and why reinvent the wheel?

Though satoshi was clearly brilliant, he didn't care much for code
cleanliness.  This is one of the next development goals (IMO).

This is something that will come with general code cleanup and
modularization.  The locks will become specific to the object (as they
should be) and the performance and clarity will be fixed.

Though it would be ideal to rewrite 90% of Bitcoin just to fix code
clarity, that is way more work than anyone has time for, in the mean
time there is more than just code cleanup that needs done.  It has to be
done in chunks.

Header files could stand to be cleaned up a bit, though all the
implementation stuff is limited to one or two lines (though sometimes
thats too much).  If you want to rewrite Bitcoin sans-boost, please do,
however Boost really isnt a huge barrier as its a build-once thing.  If
you are on Linux, all you have to do is install a bunch of packages and
build wx.  If you are on Windows, why are you on Windows? ;)

Its not due to the current coders, its due to how it was originally
written.

This one is an interesting debate.  There is no real reason to do this
aside from some questionable code cleanup.  Also, there is no reason to
encourage improperly-implemented alternate chains.  Alternate chains
should be designed in such a way as to share the main chain's difficulty
as described by Mike on the forum, not just make a new chain and hope it
sticks.

Really no reason to do that.  Although the code is messy in terms of
global usage and poorly-implemented RPC/net/etc, most of the code is
absolutely fine.  Just throw it in clearly-defined methods and classes
and it would be much more readable and less prone to mistakes.
Additionally, the things that are poorly-implemented can be slowly
changed over time in a clean and independent fashion instead of having
to rewrite massive chunks at a time.  Even if we had a full-time
development team of many, many developers, this isn't the right way to
do it.  The code itself is cleaner that it first appears, even if its
global structure is not.

True, but it is much higher priority to clean up the code than comment
it better, plus there are various other features/more user-facing issues
that need fixed as well, so...
Don't think so, the code sucks in terms of cleanliness, everyone knows
it, its just a question of who is going to and when its going to get
fixed.

Matt
-------------------------------------
On Fri, Jul 08, 2011 at 08:18:19AM +0000, John Smith wrote:

It does have another advantage: it makes testnet codes visually (after base58
encoding) different from realnet ones, which is probably the reason why the
relatively large number 111 was chosen.

The only small change that can cause the first base58 character to remain equal,
is a modification to nVersion of less than 5 in absolute value.

PS: +/- 111 is also possible, instead of XOR 111.

-- 
Pieter



-------------------------------------
On Fri, Sep 9, 2011 at 6:57 AM, Luke-Jr <luke@dashjr.org> wrote:



Stack trace or it didn't happen :p

JS
-------------------------------------
On Sep 13, 2011 11:40 AM, "Luke-Jr" <luke@dashjr.org> wrote:

I agreed up to this point. Private keys should not be stored on nand. Please
look in to the data recovery clusterfuck nand creates when concerning
sensitive data.

It is close to impossible to reliably delete such data, moreso on usb keys
than ssd, short of absolute physical destruction and noone should be
recommending this. Ever.
-------------------------------------
On Monday, October 10, 2011 9:18:07 AM Mike Hearn wrote:

Yes, does that already. Hard part right now is implementing a stateless TCP/IP 
"stack" so it can ignore DDoS sanely.


-------------------------------------
I don't think that any kind of peer disconnection should be present in the reference client implementation.  This is a lot like using packet filters and stateful firewalls - they are implemented based on local policy and they require constant tweaking because they always cause problems when some change in usage dictates allowing things that weren't allowed before.  Essentially every new service, protocol (or creative use of an existing protocol) needs to be 'opened up' so it's a hassle to change it each time.

Perhaps there is a use for this in helping implement local policy but even something that's considered a 'liberal' filtering rule today will eventually be in the way of something legitimate and will need to be adjusted.  It is not possible to just adjust this network wide when and adjustment needs to be created, so any type of built-in filtering is limiting to future innovation.

Maybe this type of thing would be better implemented in a separate bitcoin proxy - much like how a firewall can be placed between a router and network.  All traffic is legitimate to a router (bitcoind) if it's formatted correctly and can be forwarded, but the firewall can implement local policy.  The problem with providing this out-of-the-box is that even in the case of internet traffic, they are often misused and configured too restrictively so they end up causing service problems for the users behind them.

I think the idea is good, in that we need a way to filter out things we consider bad, but I don't think it is the job of the bitcoin client.  There are tons of tunable things and people will want to tweak them - what is 'a lot' to me might be nothing to someone else.  People's policies will differ greatly as you can see with everything else on the internet.


Laszlo Hanyecz
solar@heliacal.net


On Sep 15, 2011, at 4:04 PM, kjj wrote:




-------------------------------------
I'm curious whether my Non-Blocking network stack (BitDroid) isn't better
suited for detecting and tracking available peers. I have implemented
several benchmarks, including a simple peer counter listener, which would
have to be adapted to fit the DNS needs (open and check if a real peer is
listening). Being non-blocking it can open several hundreds of connections
to check reachability of the peers and at the same time keep a pool of peers
connected to listen for address broadcasts, with minimal overhead (single
thread, close to no context switches).

Just an idea :-)

Regards,
Chris

On Wed, Aug 3, 2011 at 4:18 PM, Rick Wesson
<rick@support-intelligence.com>wrote:

-------------------------------------
Matt Corallo wrote:

I'm not sure splitting the patch this way makes a big difference.  The
IsStandard part depends on the construction of the multisign script, which
is what most of the patch does anyway.  In other words, if upon further
review the script construction needs to change, IsStandard will change. 
So a full review would be better.

Also, with unit test coverage for both this feature and existing
script.cpp code, I'm hoping that this patch is relatively low risk and
actually pays down some existing test debt.

--
Bobby Groff




-------------------------------------
On Fri, Jun 17, 2011 at 06:42:30AM +0000, John Smith wrote:

The consensus seems to be to merge autotools and qtgui. However, autotools is
apparently not tested (enough) on native windows and osx platforms.

Anyone on this list with either development environnement, and willingness
to test?

-- 
Pieter



-------------------------------------
On Tue, Sep 6, 2011 at 4:17 PM, Steve <shadders.del@gmail.com> wrote:


bitcoind already uses asynchronous IO. That's not the problem.

The issue came up in a conversation about scalability. If Bitcoins
popularity continues to grow, users are very likely to migrate away from
running full verifying nodes to lightweight clients, either a different mode
of the Satoshi client or different implementations like the Android Wallet
or MultiBit.

Lightweight clients cannot verify thus should not relay. And they'll be run
by users who just want to send/receive coins from time to time, so don't
leave the programs running 24/7. The result could be running out of sockets
(like we have had problems with recently). It's especially true because
lightweight clients cannot check transactions for themselves. If they want
to show transactions appearing immediately (and they do), they have to use
"heard from lots of nodes" as a proxy for validity. So lightweight clients
are likely to be socket intensive.

We could solve this by just hoping that lots of people run full nodes. The
problem is that a full node is quite an intensive thing already, it uses
lots of CPU and disk seeks, and will just get more expensive in future. And
as transaction traffic increases, that leaves less CPU time available to
service thousands of connected clients. The ROI of bringing up a new node
decreases at the same time as the userbase increases.

One traditional approach to solving this is frontend proxies. Jabber.com/org
used this technique many years ago, and Google has also used it to scale up the
lockservice<http://static.googleusercontent.com/external_content/untrusted_dlcp/labs.google.com/en/us/papers/chubby-osdi06.pdf>
(see
section 3.1). It's effective because often maintaining connections to
thousands of clients doesn't involve much brainwork, just shifting bytes
around. This is especially true of Bitcoin. So if somebody is running a full
node already they could increase their client capacity by just bringing up a
frontend proxy and having it handle things like outbound tx
broadcasts/deduping inbound broadcasts, connection setup, relaying recently
found blocks etc. A well written proxy could probably support tens of
thousands of simultaneous clients which frees up the bitcoinds time for
verification and wallet manipulation.
-------------------------------------
In the spirit of open communication, I thought I'd try doing a monthly
"what's up" with bitcoin development. Here's what's on my radar:

 Wladimir agreed to help pull patches, especially Qt-GUI-related
patches, and is now part of the core dev team (Wladimir did the bulk
of the work on the new Qt-based GUI).

 Matt and Wladimir will be working on 0.5 release candidate 1
binaries and an updated release process to either ship the Qt
libraries or statically link against Qt; the goal is to have them
ready this weekend.

 Network stability and wallet security are still my top concerns;
start-up experience for new users (the long wait to download the block
chain) is next on my list.

 Amir's Bitcoin Improvement Process proposal hasn't been getting the
attention it deserves; I'm just as guilty as anybody, I suppose we're
all very busy. Helping improve it and writing some BIPs is high on my
priority list.

 I've setup a public-write-only
bitcoin-security@lists.sourceforge.net mailing list to be used as an
official way to report and then discuss potential security or
denial-of-service vulnerabilities in the bitcoin protocol, and invited
the following people to participate:  Amir Taaki, Mike Hearn, Stefan
Thomas, Nils Schneider, Pieter Wuille, Jeff Garzi and myself.


Stuff I've been working on or plan to be working on soon; let me know
if you are able to take on any of these, there are too many things on
my TODO list:

 Implementing/experimenting: multi-signature transactions and using
OP_EVAL and a new type of bitcoin address to create 'always secure' or
'always backed up' wallets.

 Write BIPs proposing:  OP_EVAL.  'standard' multi-signature
transactions. Maybe an informational BIP proposing how to roll out
upgrades in general.

 Denial-of-service detection/prevention (see the DoSorphans pull
request). It would be really nice if somebody with experience
simulating network behavior would take this over...

 Cross-platform testing infrastructure. I've made good progress on a
Twisted-based tool, but still have a lot to do.

 Tighten up block-time rules to fix the potential "timejacking" attack.

 Work on 'discouraging' blocks/transactions to punish
bad-for-the-common-good-but-good-for-me behaviors from miners or
nodes.

 Get back to work on headers-only-for-initial-download, so initial
startup experience is better for people.


Ongoing longer-term:

Rethink/rework transaction fees; give both miners and clients more
flexibility to create a market instead of magic hard-coded constants.

 Organization; many things would be much easier if there was a
non-profit organization like the Tor Project to pay core developers,
testers, a PR person, pay for the Jenkins nightly build server, etc
etc etc.


-- 
--
Gavin Andresen


-------------------------------------
I am in a final stage of preparation for launch of bitcoin community
portal at https://bitcoin.org.uk . It contains fairly advanced forum
functionality, blogging platform, community calendar, and even chat.
Professionally hosted on highend dedicated servers running FreeBSD in
a DC loated in Amsterdaam, NL

There is a  "by invitation only" section, which might be suitable for
bitcoin developers. Please consider starting using it and helping to
jump start it.

Additionally, if any bitcoin businesses would like to have their
"support" forums set up there so that they retail moderatorial control
over it please let me know.

Soft launch is scheduled on 15th of August, but it is fairly
functional already and open for registration. Feel free to register
and ping me for setting up appropriate permission for use of private
forums.

Any suggestions and feedback are also very welcome.

Kind Regards,
Vladimir.


-------------------------------------
+1

Putting a bounty on the test framework might put some loose change to work.

http://code.google.com/p/googletest/ would be my choice

the list of c++ frameworks is at
http://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C.2B.2B

-rick

On Sat, Jul 30, 2011 at 4:49 AM, Mike Hearn <mike@plan99.net> wrote:


-------------------------------------
That's what my proposal was for, in BIP 0010:

https://github.com/genjix/bips/blob/master/bip-0010.md

However, I just found a minor problem with it that should be addressed 
if we want to enable super-lightweight clients that only sign tx's 
without needing the blockchain.  Simply that the TxIns don't contain the 
value of the TxOuts they are spending, which means the dumb tx-signers 
with no blockchain can't tell how much input there is.  They can only 
see the output values and recipients, which means they can't figure out 
the tx fee, or how much money is in each of the TxIns they are signing.

And most users/clients will have access to the blockchain, so it's not a 
dealbreaker.  But it's something to consider.  Otherwise, I think this 
is a big step towards bringing this complicatedprotocol a little closer 
to Earth...






On 11/09/2011 05:22 AM, Michael Grnager wrote:



-------------------------------------
Bitcoin version 0.4 release candidate 1 is ready for initial testing;
please grab the source from github and try to break it.

The big, visible change is wallet private key encryption, which is NOT
turned on by default.

The big, invisible change is a reworking of internal critical section
mutexes to fix some chronic problems with bitcoind becoming
unresponsive due to deadlocks.

git shortlog --no-merges v0.3.24..
 ... will give you all the changes.

Thanks to everybody who contributed patches, and sorry if your
favorite patch is not included.

-- 
--
Gavin Andresen


-------------------------------------
On Thursday, September 08, 2011 3:43:12 PM theymos wrote:

I don't seem to recall this ever happening, despite Deepbit having over 50% 
multiple times now.



-------------------------------------
+        return DoS(10, error("AcceptToMemoryPool() : transaction with out-of-
bounds SigOpCount"));
+                        return DoS(10, error("ConnectInputs() : tried to 
spend coinbase at depth %d", pindexBlock->nHeight - pindex->nHeight));
+        return DoS(10, error("AcceptBlock() : prev block not found"));

These shouldn't be "DoS"'d, or else you open a new DoS when nodes legitimately 
relay such transactions/blocks.


-------------------------------------
On Sun, 2011-07-10 at 14:42 -0400, Luke-Jr wrote:
No, no, no, no, no.  This has been discussed several times and provides
little to no advantage for miners and has the potential to severely harm
the network.
Some form of patch that implements these does need to be pulled soon, I
would say 0.4.1 or maybe sooner.
Seems to be a feature for such a minority that until the codebase is
cleaned a ton we shouldn't add features for small minorities.  We have
seen even one or two line patches cause regressions so I, personally,
think we should really focus on cleaning the codebase (CWallet was a
great start) and then add all these minority features once the backend
stuff is really clean and efficient.
Yes, should be in for 0.4 and I think there is a pull request for it.
I think there is already a pull request, which should be merged for 0.4
IMO.
Seems like you are the only one who would benifit here, as noone else
but eligius changes coinbase output to a random set.
We don't need something that just generically changes the functions to
allow whatever fee you want, we need something more generalized to allow
more custom settings, not just blind accept if fee is x per kb or
something.  Sipa has suggested various things that should allow for more
fee control by the users while still preventing users from sending
transactions that lock their coins in limbo.
No, and no.  Just because you are willing to accept lower fees doesn't
mean the incentives are right to prevent DDoS.  The fees aren't there to
support the miners (not for a while, at least) they are there to prevent
stupid users from DDoSing and just generally wasting everyone else's
resources for no reason.
These are cool numbers to know, but I'm not sure if they have any real
uses making them just useless feature creep.
URI support would be nice.

-------------------------------------
On Tue, Jun 14, 2011 at 12:44 PM, Mike Hearn <mike@plan99.net> wrote:

The main goal was not flood control but preventing an internal buffer
memory explosion.  We already have the block chain on disk, so in
theory, if we can -eliminate- the outgoing network buffer and simply
use a pointer into the block chain file, we can send as much data as
we want.

HTTP servers certainly don't buffer huge amounts in memory; they would
keel over if so.  HTTP servers have been working on the reverse, in
fact:  moving the data-pushing over to sendfile(2) syscall and similar
optimizations.

This is an unfortunate relic of how bitcoin P2P code is written.  If
the remote side has reduced their TCP window to zero, bitcoin will
still buffer so that it may continue processing other P2P traffic from
other nodes.  That makes sense in the case of tiny, 31-byte address
messages -- one must handle the case of a half-sent message before
write(2) refuses additional data -- but not huge block chain download
messages.

The P2P code just wasn't written for huge amounts of streaming data,
and needs some serious thinking...  I agree 100% that it is an issue
we will start bumping into, if we haven't already.

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Once more before I just give up on trying...

These branches fix bugs still remaining in 0.4rc1:
- bugfix_getwork_newblk_race
- getwork_dedupe
- boost_fs3
- gitignore

Additionally, this branch adds a tolerance to human error typing in base58 
with ambiguous symbols, and should be very safe to merge:
- base58_liberal_parsing

Again, these can all be merged with:
# git fetch git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git \
#           <branch name> && git merge FETCH_HEAD


-------------------------------------
I don't think you're actually familiar with either of those tools. A run
script is not much different than an init script?

Those who live in tonal caves shouldn't crap on themselves, or something.

On Aug 22, 2011 2:49 PM, "Luke-Jr" <luke@dashjr.org> wrote:
furthering
Especially
to do
against
such
parts.
-------------------------------------
Bitcoin 0.3.24rc3 has been uploaded.

Fixes appeared after -rc2 was tagged, so we just skipped straight to -rc3.

Maybe final release on Friday?

Changes since 0.3.24rc1:

Gavin Andresen (2):
      Block-chain lock-in at 134444
      Do not use comma as thousands separator     Using the comma as thousands s

Matt Corallo (3):
      Added a couple minor things to match newer build process.
      Revert "Make UPnP default on Bitcoin but not on Bitcoind."
      Enable UPnP by default on bitcoin, but not on bitcoind (on gitian)

Pieter Wuille (1):
      Fix synchronization of default key

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

dec9ff63fe6d0cffb2abc723281a4135c22f19ef  bitcoin-0.3.24rc3-linux.tar.gz
c171c6e5128d570d5d7d5a6896b672fcab778933  bitcoin-0.3.24rc3-src.tar.gz
d4b5425eff673551a326d5326b92a06359dc1a3d  bitcoin-0.3.24rc3-win32-setup.exe
0653302ac7f8b052d58667ae30da53c4f6230be5  bitcoin-0.3.24rc3-win32.zip
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIVAwUBThS+Xdodwg8tvwyoAQINthAAqxOnungGYS1o7IB3D3M1NRPD/O/WNoB4
ANIn+oZLYy5+0yZylckT/gbkPY3PkhsIE8hVqbxGDYaDzUpjwN+DLd+EMPg5/2vr
Tp2b77Lzh6QszZzZhrs9LPLsB8Q/jzCAbbChAekkAAe4sGm0MFkxMEYaXE+RF/uj
PX36hdtmWYMzeXwf3PtbI8rAE9ESwXVVF8B7/qFvDhy4lrbXaNnGb3hGyowrNVBM
m1s4jyk/Lq5pPcoKlRN6kiujCbZBIy6VKgc74YaoMOrznHryoeYQVCg4tySfKkuG
gfiZFEL6EwYeY8ipjcRBVLFGxbwzCbIhBcBO/Je2yC+EwAOplfyy+GBE3rXLuUkn
AzMiL1i5nX6dNmkYqVE0+pbv81FeT+uc1i63CIjquLdVbxh3omdpYdYHs9q/zN/9
geHU4WnpwwZhTFEclzZUOGo8IJ0wiNsTyQv9mwVEjoslnubXh4omqbW7Tpm7cXiP
jlDZ42Ay+Z+AvafdLYP27vfjWJoMbjcu6qU2EXBOhmpkeaIcV43oEAd7suy0OLUq
8iNMpQHjlLnH0pcN8r38Tq+vuCuhPZtiPZd5dVKSF3PaCB6vAv8MulE0yhP2LEq3
Q4MzxSlgGNEWCGIv19YfMnURxGMNMKB0cyQ8SMdLDR+IIB3NB5SreeG8c8P97s5p
VnHOvTnpHyw=
=vKTJ
-----END PGP SIGNATURE-----

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
On Sunday, September 18, 2011 8:31:55 PM Amir Taaki wrote:

Please, somewhere people can freely commit to...


-------------------------------------
On Wed, Aug 3, 2011 at 10:39 AM, Mike Hearn <mike@plan99.net> wrote:

You can't "massively increase" the number of available connection
slots without risking running nodes on lower memory systems (e.g. VMs)
out of memory.

Moreover, 125 slots should be more than enough.  We need to figure out
why it isn't.


-------------------------------------
The alert system will be very important if there are ever any critical
problems in the network. For example, it is currently Bitcoin's only
defense against an attacker with >50% of the computational power, where
alerts would be used to tell people to stop accepting transactions.

Displaying a message is pretty harmless. In fact, I don't think the
message is prominent enough. The GUI client should not allow people to
see received transactions or send new transactions while an alert is in
effect (with an opt-out), and there should be an opt-in feature that
puts RPC into safe mode in response to an alert.

Alerts are no worse than transactions as a DoS attack vector. They're
much safer than typical HTTPS because there are no CAs that can break
its security.

(FYI: I also have a copy of the alert key.)


-------------------------------------

I have exported all .ts to transifex.

https://www.transifex.net/projects/p/bitcoin/resource/tx/

I'm now trying to figure out how to use it but it looks like

tx pull && git add src/qt/locale/* && git commit src/qt/locale/ && git push

will be all that's needed to push translation updates from transifex to
github.


-------------------------------------
On Wednesday, December 21, 2011 12:12:43 PM Jeff Garzik wrote:

It was per Gavin on IRC before yesterday. And there is already buy-in from 
other miners.


-------------------------------------
Hi Gavin (the list escaped the cc...),

I participated also in the hacakathon Sunday @ OnlyOneTV and I felt that this had a strong chance to diverge. So - yes - I agree - no "constitution" changes now. Further, I have thought later on on the analogy of a clerk and a safe.

WHen you enter the bank you hand over your money to the clerk (one key) - then after the clerks wallet has been filled over the day _he_ transfers the money to the safe (3 keys). My point is do we really need the customer to bypass the clerk and have 3 key addresses, or could we just leave it to the/a client to implement the multisign transaction after the money has been received - as a transfer to a safe? This would greatly simplify the problem and cover the vast majority of use cases. Not covered in this is huge single transfers where the intruder of a single key system finds it profitable to reveal their intrusion by grabbing the entire wallet.

Put in another way - do we *really* need to couple the securing of the wallet to creating a new address type ?

Cheers,

M

On 24/08/2011, at 19:57, Gavin Andresen wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------
On Friday, June 17, 2011 12:27:22 PM Gavin Andresen wrote:

So long as we can get a solid name for it. Obviously I can't continue to call 
it wxBitcoin if it's strictly Qt...


-------------------------------------
(cc'd the devs that I'm not sure are on the dev mailing list yet)


Version 0.3.23 doesn't seem to have major issues, and testing has been
unremarkable.  I think we can go ahead and push it out.

ACK for final release of 0.3.23?

-- 
Jeff Garzik
exMULTI, Inc.
jgarzik@exmulti.com


-------------------------------------
Sorry, by bad - first clean checkout for quite a while (must have changed it earlier myself...).

/M

On 05/09/2011, at 14:42, Luke-Jr wrote:


Michael Gronager, PhD
Owner Ceptacle / NDGF Director, NORDUnet A/S
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 62 14 01
E-mail: gronager@ceptacle.com




-------------------------------------


Agreed.  I'll rename to multisign.

--
Bobby Groff




-------------------------------------
On Sun, 2011-07-17 at 03:12 +0100, Robert McKay wrote:
Its not that people dislike the forums or dislike having the forums.
Its that they are giving bitcoin a very, very bad name with all the
illegal crap, etc in them to the point of even possibly creating legal
risk in the future.  So its best that the forums are marked as
unofficial and not part of Bitcoin proper but just some group of kids
who for some reason think Bitcoin is good for their drug-buying habits.

Matt
-------------------------------------
Quick brain dump on a bunch of stuff:

I'd like to get a 0.4 release out, but am still working on a fix for
the deadlock bugs that the new wallet encryption and/or the CWallet
refactoring caused. My short-term plan is to reduce the number of
locks and make sure they're always acquired in a consistent order.
Longer term, I think reworking the design to be based on
boost::asio and use fewer threads is probably the right thing to do.

Other things on the 0.4 TODO list:  block chain checkpoint (got a PULL
for that, thanks).  Updated list of hard-coded seed nodes (nanotube
did that last time). Pieter's dump/import privkey patch.

After my talk at the conference, Alex Waters approached me about being
the core bitcoin Q/A lead; he'll be working on creating test plans,
keeping on top of the issues list, testing new features, and
suggesting improvements to the code/test/release process.  And
whatever else he thinks needs to be done to improve core bitcoin.

I'll be rewriting the m-of-n signature "standard transaction" proposal
to mitigate a potential denial-of-service attack that I realized it
would open up (details later, I don't want to give bad guys ideas).


-- 
--
Gavin Andresen


-------------------------------------
On Friday 16 Dec 2011 17:41:25 Rick Wesson wrote:

You seem to have jumped off the topic; you mentioned that there were 
thousands of RFCs that we should review over why we shouldn't use a URI; and 
you've pointed at an RFC that shows how a URI can be used.

While you're right that CGI and HTTP aren't magic; they are commonplace; and 
it's important when we want an infinitely expandable mapping system that 
people can use technology they are already familiar with. People already 
have web servers, people already understand URIs.  It's not "just what we 
are used to"; people who can cope with development of the bitcoin protocol 
aren't going to be worried about protocol complexity.  It is a concern about 
what the rest of the world will have to do to get a bitcoin alias.


No it doesn't address usability at all, because it falls down on the first 
attempt: what if I want to supply a URI that allows my web service to link 
an invoice number to an issued bitcoin address?  You've forced every mapping 
service to be identical, and limited.


You've been unfair, the equivalent of your "user@authority.tld" is 
"https://authority.tld/user" or "https://user.authority.tld/" or 
"https://google.com/bitcoin/user" or any of an infinite number of other 
variations that _I_ as the mapper get to choose rather than whoever wrote 
the BIP; all of which are arguably no less "elegant" than that simple email.

There is no equivalent in the other direction though.  For someone who 
want's to supply the TX to their mapping server... where does it go in 
"user@authority.tld"?



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
For what it's worth, BitCoinJ has a NetworkParameters abstraction that
does what you suggest (groups all the constants together):

  http://code.google.com/p/bitcoinj/source/browse/trunk/src/com/google/bitcoin/core/NetworkParameters.java

It exists primarily to make unit testing easier. In the test suite, we
often build small chains and other structures. We do this by using a
NetworkParameters that has the easiest difficulty possible. It means
you can solve blocks in a few attempts, easily fast enough to build
test chains of any length you like.

I suspect that as the test suite expands, a similar abstraction will
be introduced to the Satoshi client.


-------------------------------------
On Monday, December 19, 2011 6:44:59 AM Andy Parkins wrote:

Accepted CAs is/should be a property of your *operating system*, not any 
particular software. Anyhow, restricting this further just makes it even more 
unusable. Already there is only 1 or 2 CAs that will provide a gratis 
certificate for personal/small users. If you only allow high-class CAs, I 
imagine that will restrict "no key in the URI" aliases to those who will fork 
over a lot of money.


-------------------------------------
Hi,

What is the purpose for this field? Can I safely ignore it? Currently it isn't used and I can't imagine it being too useful.

If you want to discover your own IP address from it, then that's ripe for abuse. Maybe it could be used in conjuction with your own IP lookup mechanism kind of how the clock works.

What is the main reason for this field existing?


-------------------------------------
What's wrong with the mac build? I just built on 10.7 without any issues.

-- 
Douglas Huff

On Nov 4, 2011, at 4:29 PM, Gavin Andresen wrote:


-------------------------------------
On Tue, 2011-10-25 at 11:45 +0200, Jan Vornberger wrote:

One possibility would be to create a peer sourced green address
implementation. That is, each user could, individually decide to trust
certain addresses as "green" and optionally, publish this trust. Basing
things on the published trust, you could dynamically, as opposed to
static hierarchies, evaluate the trustworthiness of each green address
you haven't personally decided to trust.

This would be somewhat involved implementation, though, as it would
require heavy statistical calculations.

- Joel



-------------------------------------
Indeed. It could make sense. That's the reason why Qt distinguishes strings
based on context as well as content.

But it could also be nonsense. Can you be more specific as to which strings?

JS

On Mon, Oct 24, 2011 at 1:24 PM, Christian Decker <
decker.christian@gmail.com> wrote:

-------------------------------------

The IANA is a good institution to rely on for mapping things, much
history and wise execution there.

-rick


-------------------------------------
Is it just me or does it seem inevitable that at some point supernodes
will emerge that other nodes trust to validate transactions for them?
Supernodes needn't even store the entire block chain and transaction
pool...it would be sufficient that they keep lists of IP addresses of
other trustworthy nodes and partition them into a hashspace.

Anonymous peers have no reputation to defend...but a trusted supernode
would, which could provide just enough incentive for the supernode to
do its best to ensure the nodes it vouches for are indeed legit. Of
course, unless the supernode is validating the entire block chain and
transaction pool itself, it could only assess the trustworthiness of
other nodes by performing random sampling.

Michael, I really like your ideas and the clarity you bring to the
issue. Regarding the potential attack vector you mention, would it be
possible to partition the hashspace to minimize the risk that an
attacker can manage to disproportionately gain control over a part of
the hashspace?


-------------------------------------
OK, but, <50% show as port open .... maybe a bug in the seed?


05:16:52 scott:~$ nmap -p 8333 `dig +short dnsseed.bluematt.me`

Starting Nmap 5.00 ( http://nmap.org ) at 2011-08-03 14:17 CEST
Interesting ports on 83.220.45.22:
PORT     STATE SERVICE
8333/tcp open  unknown

Interesting ports on
c-6de0e055.27-2-64736c11.cust.bredbandsbolaget.se(85.224.224.109):
PORT     STATE SERVICE
8333/tcp open  unknown

Interesting ports on mackila.com (88.168.105.251):
PORT     STATE SERVICE
8333/tcp open  unknown

Interesting ports on 93-81-112-85.broadband.corbina.ru (93.81.112.85):
PORT     STATE SERVICE
8333/tcp open  unknown

Interesting ports on kons-5f710a2a.pool.mediaWays.net (95.113.10.42):
PORT     STATE SERVICE
8333/tcp open  unknown

Interesting ports on 173-218-216-132.atw.suddenlink.net (173.218.216.132):
PORT     STATE SERVICE
8333/tcp open  unknown

Interesting ports on
dynamicip-188-232-23-24.pppoe.omsk.ertelecom.ru(188.232.23.24):
PORT     STATE SERVICE
8333/tcp open  unknown

Interesting ports on c-71-229-116-166.hsd1.fl.comcast.net (71.229.116.166):
PORT     STATE    SERVICE
8333/tcp filtered unknown

Interesting ports on c-76-25-209-23.hsd1.co.comcast.net (76.25.209.23):
PORT     STATE SERVICE
8333/tcp open  unknown

Nmap done: 20 IP addresses (9 hosts up) scanned in 3.50 seconds
-------------------------------------
Another quick update:

On Sun, Jul 03, 2011 at 06:29:05PM +0200, Jan Vornberger wrote:

I realized why this happens: Sendfrom triggers a rebuild of the cache
and couldn't return before the rebuild was complete.

So I changed the approach slightly: A complete rebuild of the cache will
only happen on new blocks (in case reorgs happen) whereas on new wallet
transactions the cache will just be adjusted incrementally. Seems to
work fine so far (every 4000 calls or so I double check the cache by
running a full calculation and compare the results. No mismatch happened
so far). The changes are pushed to the github branch I linked to.

One caveat I realized: The cache will not work correctly with the RPC
command "move" as I haven't implemented the necessary adjustments.
Shouldn't be too difficult, but since I don't use that command, I
haven't done this (yet).

Regards!
Jan


-------------------------------------
On Sun, Sep 11, 2011 at 5:54 AM, John Smith <witchspace81@gmail.com> wrote:

I haven't heard any objections to pulling it as soon as 0.4 is
officially released, a pull request is ready, and a couple of people
have a chance to read over the differences and ACKnowledge that
nothing sinister snuck in somewhere.

-- 
--
Gavin Andresen


-------------------------------------
On 2011 August 05 Friday, Mike Hearn wrote:


I don't really see that "number of connections" is the relevant metric.  For a 
well designed bit of software the number of connections shouldn't matter.  
There's a bit of overhead in the operating system per connection, but I'd be 
surprised if that ever became a limiting factor in a stateless system like 
bitcoin.  In fact, bitcoin would work perfectly well as a UDP system (I'm not 
advocating that of course), and then there would be no such thing as a 
connection.

Bandwidth is the measure that's relevant.

Therefore if bandwidth is the measure, just pick a bandwidth you like and 
add/accept connections until you hit that bandwidth limit (probably averaged).  
This has the advantage that it can be measured automatically, or sensibly set 
by a user.


Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------

Well, to be honest I don't think more developers adding new features
are needed right now-- I think the project's critical needs are more
people testing and helping to fix bugs and scalability issues.

In this particular case, I said I was mildly against it-- if you want
me to switch to supporting it, then reassure me you're willing to do
ALL the work to make it happen.  Send me a list of wiki pages you'll
edit to document the change and tell me that you'll be around to help
people rewrite their backup scripts.


I don't see how dividing efforts between a 'bug fix' and 'development'
branch will help fix the project's critical needs. If we did, I think
there would be less pressure to help with the boring bug-fixing and
testing of the bug-fix branch, which I think would be bad.

-- 
--
Gavin Andresen


-------------------------------------
Nils,

Sounds good. I'm also doubtful of depending on two crypto libraries when
OpenSSL does perfectly well.

However, losing compatibility with miners is not very nice. Is there really
not a way to compute midstate with OpenSSL?

JS

On Mon, Sep 26, 2011 at 7:42 PM, Nils Schneider <nils@nilsschneider.net>wrote:

-------------------------------------

Hear hear!


Sure. Alias systems are a usability focused requirement and as such
should probably not be mandated by the network itself, anyway.


It seems a clarification is in order, apologies for not being clearer.

Under the IIBAN scheme, whilst Bitcoin *could* define some default
mechanism for automatically creating IIBANs that map to Bitcoin
addresses (for example, Bitcoin client authors could provide hosted
lookup), this was not the style of integration in mind while writing
the IIBAN draft.

Rather than simply defining Bitcoin as a single 'institution'
(namespace segment) within the IIBAN standard, Payward Inc. envisages
large numbers of parties (including individuals or small groups of
individuals) operating individual Bitcoin-related (or LETS, or other
alternate currency) services to register as institutions (really just
'namespace holders') within the IIBAN registry. Each such party may
then define its own mapping system between Bitcoin, LETS, or other
alternate currency financial endpoints that it 'manages' (proxies for)
and IIBAN, within its namespace.  As detailed within the IIBAN
proposal, this process could be peer to peer or centralized,
supporting one time or short-term use addresses as well as permanent
addresses.  A permanent address within IIBAN could map via the
institution managing that portion of the IIBAN address space to a
single use address on the Bitcoin network.

Institutions are important for the following reasons (from
http://tools.ietf.org/html/draft-iiban-00#section-4.3.2):

   With the advent of decentralized virtual currencies such as [BITCOIN]
   the conventional idea of a financial institution (such as a bank) may
   be seen by some as somewhat superfluous.  However, the notion remains
   useful:

    * Conventional currencies will not disappear in the conceivable
      future, so the notion of financial institutions is expected
      to endure at least as providers of currency exchange and holding
      services.

    * Systems such as [BITCOIN] have quirks that require slightly
      delayed settlement due to the nature of their decentralized,
      consensus-based approach to fiscal transfer.  Users requiring
      instant settlement MAY thus see benefit in the use of a
      centralized proxy system or organization as an instantaneous
      financial settlement provider (the 'institution').

    * IANA MAY delegate management of portions of the IIBAN name space
      through such institutions.

Furthermore from http://tools.ietf.org/html/draft-iiban-00#section-4.3.1:

   [Under IIBAN's combined issue paradigm] proxied issue is
   facilitated through IANA managed institution registration, provision
   for two types of privately issued addresses is reserved within this
   document, and registered institutions COULD provide DHT or similar
   mechanisms for the management of their delegated name space.  The
   combined issue paradigm offers adequate provision for both
   manageability and decentralization, whilst maintaining heterogeneity.

So the idea is that many institutions each provide mappings between
IIBAN and Bitcoin, in a range of ways, and we do not see the emergence
of a single mandated standard.  There is no suggestion that Bitcoin
developers should implement a hard-coded mechanism.


This style of solution - in which a central organization becomes aware
of every single IIBAN-based transaction in the network - is not
necessary or desirable.  Instead, under the IIBAN recommendation IANA
would publish the registry of IIBAN institutions for everyone to use
without the need to query any party.

In the case of a financial transfer, a client or peer instutition
seeking to send funds to an IIBAN-denominated address would use some
hitherto-underfined mechanism* for translating the appropriate entry
within that registry (corresponding to the transfer's destination
address) to some kind of internet node representing the institution's
systems.

* This mechanism may necessitate the storage of public keys within the
IIBAN institution registry and will be addressed within the next
version of the IIBAN draft.  Community input is encouraged.

In a second yet-to-be-define protocol**, various settlement-system
neutral (ie: not specific to Bitcoin, LETS, or any other system)
transaction-related metadata would then be exchanged, prior to any
actual transaction.  Such metadata could include aspects of the
transaction such as description, financial system endpoint ('account')
holder name, account exists verification, settlement path negotiation
(based upon feasibility, transaction overheads, latency, etc.), which
party is to pay overheads, information mandated by local jurisdiction
such as business tax numbers (required in some countries of Europe, I
believe, for domestic B2B settlements), etc.

** This mechanism does need to be defined, and Payward Inc. has
completed a not insubstantial amount of research in to existing
protocols and concerns within this area, which touches upon high
frequency automated banking, financial market support, and interbank
settlement policy.  An additional Internet Draft proposing one such
potential mechanism will probably be published 'soon'.

At the conclusion of this metadata exchange, the two nodes would have
either aborted the transaction, suspended it to seek human input (such
as settlement path selection based upon fee and latency metadata
garnered), or agreed upon financial settlement system specific
information to use in executing the transaction itself, likely out of
band. In the case of Bitcoin, this *might* include information such as
the blockcount after which the transaction will be considered settled
by the receiving institution, an effective 'gentleman's agreement' on
the terms of any opt-in notion of reversibility, a one time Bitcoin
address provided by the recipient institution for the sender to make a
Bitcoin transaction to, etc.

provision of settlement system neutral financial endpoint
identification provides the benefits outlined in the previous email,
as well as the possibility to publish a permanent, fixed address
without disclosing one's corresponding Bitcoin-derived income.  From
the broader perspective of effective financial system innovation, it
hopes to provide a common basis upon which many such systems can
conceivably interoperate, regardless of their underlying systemic
differences.


Thank you for your vote of confidence.

Regards,
Walter Stanish
Payward Inc.


-------------------------------------
On Friday 16 Dec 2011 19:06:52 Gavin Andresen wrote:


I can see the PR advantages, but isn't mapping from one massively long, 
multi-character, human-opaque number (IBAN) to another (bitcoin address) a 
bit of a waste of time?

Surely the point of all this is to provide at least the possibility of a 
human-readable name for a bitcoin-address?

Isn't there a possibility that one day we might want to be able to say "send 
me those bitcoins you owe me to bitcoin.yahoo.co.uk/andyparkins"?  Or 
similar?



Andy
-- 
Dr Andy Parkins
andyparkins@gmail.com


-------------------------------------
Oops, sorry Gavin. Meant to reply to the mailing list.

---------------


People should not be using accounts for receiving funds on 
merchant sites. There are too many bugs associated with it, and it has 
innumerable problems. Like not being able to merge wallets or lack of 
find grained control when moving funds around.

https://gitorious.org/intersango/bitcoind/commit/50a6ab79ed8c5398648c52fbdc4be07f70dedadb

This is the recommended & most safest way to receive funds on a merchant site ATM.

listreceivedsince <timest> is called every so often by a cron job.
The output is parsed and placed into another table and then another job 
will go and create a deposit request from that table. The next call to listreceivedsince <timest> will call with the time of the last 
transaction, and doubles must be discarded using the txid.
Polling listtransactions is less convenient since you always repeat old 
transactions that you may not need, get generated transactions and have 
to pick a good number that goes back far enough, but not too far.


________________________________
From: Gavin Andresen <gavinandresen@gmail.com>
To: bitcoin-development@lists.sourceforge.net
Sent: Sunday, July 17, 2011 5:02 AM
Subject: Re: [Bitcoin-development] [RFC] listtransactions reformatting

Fixing listtransactions (and listreceivedby/etc) so coin generation
transactions to particular addresses/accounts are credited to that
address/account is a good idea.

I don't think changing listtransactions output would be on the
priority list for any web services operators (in fact, I think most
would scream bloody murder if the output changed in a way that forced
them to change their code). The accounts-related things that I think
ARE on their high-priority list are:

1) Fixing getbalance and listtransactions performance problems when
you have hundreds of thousands of transactions and thousands of
accounts.

2) push-notification of coins received to accounts, so they don't have
to poll for changes.

-- 
--
Gavin Andresen

------------------------------------------------------------------------------
AppSumo Presents a FREE Video for the SourceForge Community by Eric 
Ries, the creator of the Lean Startup Methodology on "Lean Startup 
Secrets Revealed." This video shows you how to validate your ideas, 
optimize your ideas and identify your business strategy.
http://p.sf.net/sfu/appsumosfdev2dev
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
I don't see reason why not. It could just be another, longer, address type.
The advantage being that it allows for shorter transactions in the block
chain (right?).

Wladimir

On Sat, Dec 17, 2011 at 7:32 AM, Luke-Jr <luke@dashjr.org> wrote:

-------------------------------------
On Tue, 2011-06-28 at 11:52 +0200, Mike Hearn wrote:

And this is also no where near the right place to be disclosing security
vulnerabilities.  Whether you like the guy/site or not, keep those prive
for a reasonable amount of time for them to be fixed (that means more
than an hour).

Matt
-------------------------------------
Hello,

newbie here, thanks for patience.

I start 0.5.0 without wallet.dat. It creates 100 new keys. I then 
encrypt them. It should be now bug free and totally secure, so I back 
the wallet up. I then click "new address", it doesn't use the old 2-100 
addresses, instead generates a new batch, because it assumes the old 
ones are leaked, but in fact they are not. I receive funds to my new 2nd 
address (which is now not backed up). I lose the new wallet. Restore 
from backup. Bitcoins lost forever?

Sorry if false alarm, thanks.

On 11/16/2011 06:34 PM, Gavin Andresen wrote:
-- 
Tadas Varanavičius
+37061529855



-------------------------------------
I see it as a good start for POS payments. I don't know what flaw
you're referring to.

Back on topic, is actually putting the whole pub key in each output
what you're proposing?


2011/12/18, Luke-Jr <luke@dashjr.org>:


-- 
Jorge Timn


-------------------------------------
Commit 865ed8a adds a new compile-time #ifdef : DEBUG_LOCKORDER

Compile with -DDEBUG_LOCKORDER and every time a lock is acquired by a
CCriticalSection a check is made to record the order of locks and
complain if they are being acquired in an inconsistent order.  Here's
what you get in debug.log when potential deadlocks are detected:

POTENTIAL DEADLOCK DETECTED
Previous lock order was:
 pwallet->cs_mapWallet  db.cpp:686
 pwallet->cs_KeyStore  db.cpp:687
 cs_KeyStore  keystore.cpp:74
 cs_vMasterKey  keystore.cpp:75
 cs_KeyStore  keystore.cpp:31
Current lock order is:
 pwallet->cs_mapWallet  db.cpp:686
 pwallet->cs_KeyStore  db.cpp:687
 cs_KeyStore  keystore.cpp:74
 cs_vMasterKey  keystore.cpp:75

POTENTIAL DEADLOCK DETECTED
Previous lock order was:
 pnode->cs_vRecv  net.cpp:1525
 cs_main  main.cpp:2372
 cs_vSend  net.h:681
Current lock order is:
 pnode->cs_vSend  net.cpp:1531
 cs_main  main.cpp:2411

I'll be working on figuring out how to eliminate these, and will be
working on some RPC stress-tests that try to exercise all the code
paths to early-detect other potential problems.

-- 
--
Gavin Andresen


-------------------------------------
Pieter, it was more rhetorical question than asking for explanation, but
thanks anyway. As an Internet application developer, I of course understand
security issues while using HTTPS and CA.

I have a gut feeling that there simply does not exist any single solution
which is both easy to use and secure enough. At least nobody mentioned it
yet. And if I need to choose between easy solution or secure solution for
aliases, I'll pick that easy one. I mean - we need some solution which will
be easy enough for daily use; it is something what we currently don't have.
But if I want to be really really sure I'm using correct destination for
paying $1mil for a house, I can every time ask for real bitcoin addresses,
this is that secure way which we currently have.

slush

On Mon, Dec 19, 2011 at 2:14 AM, Pieter Wuille <pieter.wuille@gmail.com>wrote:

-------------------------------------
Some appear to be beneficial to everybody.
Multithreading the RPC will certainly speed up quite a few services and I
see no downside in adding it. The same is true for Keep-Alive.

I'm against including the long polling support because incredibly few people
will benefit from it (pool providers) and yet it is included for everyone.

The Hub mode is good, and I would go a step further and optimize the
connection logic for all nodes by default.

Just IMHO

Regards,
Chris


On Fri, Jul 1, 2011 at 5:23 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
[n00b alert]

I humbly suggest allowing the wallet.dat location to be specified in the preferences. Being able to easily physically disconnect a wallet by unplugging a USB key seems like a good idea.

cheers,
Mark



-------------------------------------
RE: bounties:

"A couple of bitcoins to fix a bug" sounds to me like nothing but trouble
for whoever is in charge of awarding the bounties, but maybe I'm just
anti-bounty because spending 2 or 3 hours and getting $30 worth of bitcoins
for fixing a bug wouldn't motivate me.

Anybody know how cash bounties have worked for other projects?  Have any
others paid bounties on run-of-the-mill bugs, and did that cause any
problems?  I'm worried that if contributors start getting bounties that will
change the dynamic from cooperative to competitive.  For example, if
somebody has figured out how to solve 90% of some tricky bug I don't want
them to hesitate to ask for help on the last 10% because they're worried "if
I describe the progress I've made so far somebody might swoop in and steal
my bounty...."

RE: road-map and bug-fix-only-releases:  Great ideas.

RE: paid full-time project lead:  I arranged to get paid to work on bitcoin
full-time before I left for Australia; more details when I get back
week-after-next.

-- 
--
Gavin Andresen
-------------------------------------
2011/12/17, Jordan Mack <jordanmack@parhelic.com>:

I'm just saying is useful for the "green address" particular case.
People don't have to write or memorize the firstbit address, it's just
to have a shorter string to put it in the QR code. In this particular
case you don't really care about "squatting" or typographic errors
because the users are bot going to write or even see the firstbit
address. I think aliases are a better solution for the "memorizing use
case".

But anyway, reading some comments I feel I'm missing something about
this proposal. How can you save space by putting the whole public key
instead of just the address (a hash of the public key) with each
output?
Is this what it's being proposed?


-------------------------------------

Sure, but this falls short of requirements for most users.


Equivalent to hosted wallet, which is decentralization in a BIG way,
but apparently a very popular choice (for pragmatic reasons).
Probably not going away.


True.  However, probably a poor user experience for most users re:
provision of temporary addresses to the alias host.  Also the
knowledge of which entity for which inbound payment has been allocated
which temporary address would be a significant complexity in the alias
host / end user relationship that you gloss over.  This is important
for businesses, since inbound payments are only really possible to
track - AFAIK (correct me if I'm wrong, the two exceptions being the
edge case of people requesting inbound transactions where every single
transaction is of a unique amount and no 'partial payment' (2x
transactions for one inbound payment) and the case where every single
inbound payer's sending address is previously known) - by issuing
unique recipient addresses to each client.  In short, it's kind of
similar to hosted wallet as well, since you need to absolutely trust
your host (they could tell people wishing to make payments to you to
pay someone else instead!).


Many people can get namespace management rights as
'institutions' (in the current draft's terminology), then manage
the assignement of IIBANs within that space as they wish.
There would be many institutions with many IIBANs.  The
association of a bitcoin address (or many addresses, or
the capacity to generate temporary addresses as required)
with an IIBAN would be the responsibility of either that
namespace manager ('institution') or the individual who
has acquired that IIBAN via that namespace manager
('insitution').


Many institutions, many policies, no absolute centralization, though
admittedly increased centralization. However, this is a problem shared
with two of your proposals (the subset not disqualified as failing to
meet most user's requirements) when you consider that most users (if
you consider 'the whole world's mobile devices' a potential userbase,
as I prefer to do) do not have the technical skills to configure,
secure and manage their own 'always on' alias service hosts, nor the
capacity to host blockchain copies on those devices (either due to
space or bandwidth requirements. As an aside, this is a large part of
the unfortunate reality that is tending to push Bitcoin towards hosted
wallet solutions)


Near the top, beginning "It seems a clarification is in order,
apologies for not being clearer."  (Re-reading, it's still not that
clear!)

Regards,
Walter Stanish
Payward, Inc.


-------------------------------------
I just posted BIP 0010 to gist : https://gist.github.com/1321518

The goal is to provide a standard method for proposing how to spend 
multi-sig TxOuts, and collect signatures without actually having to 
understand BTC under-the-hood.  I envision, even without any program 
installed, moderately-interested users could figure out this process 
without a third-party.  The addition of an installed program that 
automatically detects .txdp files and intelligently presents the 
information to the users, could bring this functionality to even more 
users.  Perhaps I'm too optimistic, though...

This is, of course, open for discussion/improvement.  I've talked 
briefly with Gavin about this, and he suggested Base64 instead of hex 
for the block-encoding.  I'd lean towards Base58 because developers 
already have it in their codebase.  Also, the separation of fields by 
underscore characters could be changed.  Spaces would make it easier for 
C++ to read them in using stream operators "<<" and ">>".

-Alan




-------------------------------------
On Saturday, December 17, 2011 7:28:12 PM Luke-Jr wrote:

In fact, as long as we have this opportunity to enable new opcodes, maybe we 
should spend some time revisiting what doors that opens...


-------------------------------------
I got email from a tester who gave this feedback:


I agree that is likely to happen and, when it does, will be disastrous.
So I'll be reworking the wallet encrypt/rewrite code today and
creating a release candidate 6.

My previous attempt (encrypt, invalidating keypool, then unlock and write
a new keypool) resulted in unencrypted private keys in the new wallet.

I think this will work, I'll implement and test today.

Invalidate all the old keypool keys in the old wallet.Write new
keypool keys to the old wallet.Encrypt all the keys in the old
wallet.Rewrite the old wallet to create a new wallet.Shutdown/restart.
IF ANYBODY IS WILLING TO HELP:

There is still a mysterious problem with bdb throwing an exception
when dbenv.close(0) is called during shutdown. If you can compile
a -g version of bdb and then step through DbEnv::close in a debugger
and tell me why it is throwing an exception that would be
extremely helpful.
-- 
--
Gavin Andresen


-------------------------------------

On second thought, I'm not sure this is workable.  You would have to
distribute each party's pubkey ahead of time, otherwise you run the risk
that a party falls off the face of the earth and then you can't provide
the pubkeys to have hash(pubkey1+2+3) EQUALVERIFY.

If you have to distribute the pubkeys ahead of time, then the reduction in
address length becomes moot.

So it seems to be either distribute the pubkeys or distribute the
hash160(pubkey)'s.

--
Bobby Groff




-------------------------------------
On Sunday, December 18, 2011 8:14:20 PM Pieter Wuille wrote:

Like SSH, don't make it easy to ignore.
eg, to ignore it, you need to manually go in and remove it from the URI.


-------------------------------------

Ah, I see. Sounds a bit like the direction Steve is going with poolserverj.
So your custom software would handle incrementing the extraNonce,
recalculating the merkle tree/root, and so on?
-------------------------------------
I dont think anyone really made a conscious decision one way or the
other, someone submitted an autotools patch and thus people started
talking about when we were going to merge autotools.  That said, the
autotools stuff needs redone before it would be merged anyway. So it
would be up to whoever writes the build system. However, autotools is
more standard than CMake, and since its a shell script, you dont have to
install CMake which doesnt come standard on almost any distros (AFAIK).

Matt

On Sat, 2011-07-02 at 08:13 +0000, John Smith wrote:

-------------------------------------
Don't get me wrong, DNS Seeding is an excellent way to bootstrap via trusted
nodes, I'm not trying to replace it.
What I'm trying to get rid of is the IRC bootstrapping and the hardcoded
nodes in the client, they're easy targets.

BitTorrent trackers are used to handle several thousands of requests, so
they would probably scale well enough. I'm not even talking about using the
DHT trackers, but using old fashioned HTTP based trackers. The fact that
each bitcoin client would contact the tracker would make it very hard for an
attacker to get bootstrapping clients to exclusively connect to his
compromised clients. I would say that using a tracker such as OpenBittorrent
provides the same advantages as using an IRC channel.

On Mon, Jun 13, 2011 at 11:09 AM, Jeff Garzik <jgarzik@exmulti.com> wrote:

-------------------------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256



Matt Corallo <bitcoin-list@bluematt.me> wrote:


All sounds good to me.
- --
Douglas Huff
-----BEGIN PGP SIGNATURE-----
Version: APG v1.0.8

iQIVAwUBTg5FPEPHkQabDWHPAQj1lg/+K+OfHZXNj/Rn4Ei+OmGjEywTZmOWiFVy
72MvaCNLkx1XW0G3ZJJsy211q5kssvDk4b0qdBraxjT2O7JE6rxEtPkkCaEv8zNv
ASpL1AdQ8PpOsYmot9Kl0XC3Hx4fmt89I18KwgEFqywDMssDQT1bWImE3xr628id
OHFDRxWv3PQ6unuD0gd0vj4L468il4tzeqnlCCG/bwZACdZAlgxoJDhdGgrpxZf7
zsUBhFwADqZ+KoQ9PJjonXHQj7g+UG2kdz/n3QGPXjAP0eLsqCLJrpJc5t3YEj8c
3bSfbKDGA1djKrXVDOhJ3laZGnIjCBbPuWhnPfoP91S23sFlHxIG9qynrfIF0yMU
pMVd9WF98yyjbUEiZon53YGKqBEhjKgx4VLMaYVqT1/kA1vpLDGV4hyqQPsWd3ML
LAp0kqBGzlosxX0PbcgQKX2gQ+P+9IjYeKb8XA9VbnLHJYdjZw+pSUz0RYYP3Fws
iOrypLgy79dEDyhafllQEAUDQi9XGhgBcpq1r683MD7JL3ip3e1x6LFDZQ9hA9Kk
MosjgFMMcCe3R+5bozbTE1Lrsz+ycl5hW4Zi5lszilP8duhvj/InLy/JEpS3qsGc
feb5hltQqIEcBItTe/XZCFwROdMjczAl/k65Gk1CSBgDCRda8et9img1t9Z9vGK/
qvwMoWzHcCc=
=78gQ
-----END PGP SIGNATURE-----



-------------------------------------
On 2011 November 23 Wednesday, Jorge Timn wrote:

(1) The "probability of mining a block" is old-think.  The probability of 
mining a block is 100% in my system.  Instead, it becomes "the probability of 
your block being the hardest" and that requires actual hashing power 
regardless of the timestamp you write on the block.  I could write that my 
block was generated next year; but I can't fake the hashing power it needs to 
generate one year's worth of hashes.

If chain difficulty were summed correctly (sum(log(difficulty)), I guess), 
then time makes not the slightest difference anyway.  You can issue blocks at 
any time with any difficulty, and the "hardest" chain always wins.  The block 
period can be anything, and it is only the block reward that makes it 
necessary to pick a particular period for block issuing (even that could be 
worked around I guess with a variable reward, but why bother?).

(2) For the network clock; see util.cpp:GetAdjustedTime().

(3) Current clients do have an incentive: more time.  The more time they get, 
the more hashes they can try.  The current client already checks the 
timestamp:

  main.cpp:CBlock::CheckBlock()

    // Check timestamp
    if (GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)
        return error("CheckBlock() : block timestamp too far in the future");

My suggestion only requires that the two hour window be reduced; and a lower 
limit to be added.  Also: while the miners have an incentive to lie about the 
time, the nodes they broadcast to have an incentive to reject mistimed blocks, 
so you won't gain much by lying to your peers since your block won't be 
accepted -- the incentive is therefore removed.

Note: my system also prevents an attack that is possible with current bitcoin: 
recalculating the entire chain.  Let's say Visa want to take over bitcoin.  
They buy enough computing power to significantly beat the current bitcoin 
network; then they start recalculating the entire block chain; since early 
blocks were low difficulty, it's not that hard to do.  Once they overtake the 
real chain, they have effectively undone all previous transactions.  (I'm not 
suggesting this is likely; and it's actually mitigated by the hard-coded block 
hashes).  The point is that blocks are only generatable for the time when the 
rest of the network is willing to add them to the chain.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
On Thu, 2011-08-04 at 16:07 -0400, Andrew Schaaf wrote:

They already do if they provide the IP of their node (or a proxy node on
top of theirs which would be recommended for security).  This has been
my whole point the entire time.

Matt
-------------------------------------

Right, the user would have to connect directly to miners accepting
non-standard transactions.


With the latest high profile security breaches, I am hoping that the whole
things can be pulled relatively soon.  Building secure deposit systems
will improve trust in the ecosystem.

I've included a significant amount of unit tests to "pay" for the
additional feature, and I can add more if needed.

--
Bobby Groff





-------------------------------------
On Jul 17, 2011 5:46 AM, "Matt Corallo" <bitcoin-list@bluematt.me> wrote:
Speak for yourself. I think they're a cesspool.
-------------------------------------

It was also chosen for hand-writeability, weirdly enough. That's why it
excludes some confusible characters. But Satoshi didn't really understand
how people would end up using Bitcoin, he originally imagined most
transactions being done directly between pairs of IP addresses.



That's cool. I hope Matts change gets merged soon. Then the issue becomes
how do people find out about this capability? Expecting people to learn how
to hand-craft Bitcoin links won't work. But all modern operating systems
support copy/paste and drag/drop of rich content. Qt probably makes it easy
to expose an UI like this:

   *Pay me*    [Copy to clipboard]

Clicking the link in the UI would pop up an alert saying something like

   "You can drag this link to an email, chat window or editing program."

Dragging it/pushing the copy button would just set the drag/clipboard data
as a bit of text/html content. So then you can just copy/paste into an
email or HTML editor. It wouldn't work for forums that use bbCode, though I
guess there's no particular reason the forum software can't turn <a href>
into [url=] automatically.
-------------------------------------
I'd put wallet security before scaling, but inevitably, I'm not sure there's 
too much anyone can do about that. Even if the wallet is encrypted, it just 
takes a little more complex code to steal funds if you've infected your 
target.

On Thursday, June 16, 2011 12:32:57 PM Gavin Andresen wrote:
chain.


-------------------------------------
On Monday, November 07, 2011 10:02:43 AM Pieter Wuille wrote:

Reminder that there is *already* a short interval only allowed for blocks in 
general...


-------------------------------------

Darn good question. If the protection fails, would it be better for it
to 'fail hard', leaving people complaining "bitcoin won't stay
connected!"

Or fail soft, so you at least have a couple of connections.

I think fail hard is better-- we'll immediately know about the
problem, and can fix it.  Fail soft makes me nervous because  I think
that would make it more likely a bug splits the network (and,
therefore, the blockchain).



If I think you're trying to DoS me, why would I be nice to you?  I
think response messages would just give an attacker another potential
attack vector, and it is clear from the debug.log what triggers a ban.


Good question. Anybody see a reason not to?  How much tolerance (if
any) should there be for sending garbage data (I assume the
lower-level network stack almost never garbles data, is that a good
assumption)?


-- 
--
Gavin Andresen


-------------------------------------
On Wednesday, August 31, 2011 10:20:48 AM John Smith wrote:

How do you set build options with qmake?


-------------------------------------
On 2011 August 05 Friday, Gavin Andresen wrote:


Transaction forwarding could be randomised slightly, by randomising the 
outgoing relay order; and adding a random delay between each forward.  Even 
the massively connected monitor can't represent _all_ the connections on every 
real node, so it would have no way of knowing whether it got any transaction 
from the originator or because it got a fast path through the first N nodes to 
receive it.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
2011/11/23, Andy Parkins <andyparkins@gmail.com>:

A miner could try to obtain more difficulty out of time and cheat its
reported datetime (T).

Jorge Timn


-------------------------------------
Hi,

Bitcoin-qt is now feature complete (including wallet encryption), and has
been tested for a while by various people without any major problems.

It is now in status of feature freeze.

The project builds on Windows, MacOSX and Linux using qmake.

Impact to the core bitcoin functions is still minimal, and it can co-exist
with Wx in the source tree. The only thing it lacks compared to the Wx GUI
is translations, currently we only have English, Dutch and Russian.

So IMO, it is ready to be merged.

JS
-------------------------------------
Hi,

 Testing the 0.5.0 in Linux, I see a strange behaviour:

 1- Open qt-client, blockchain stops the downloading at 10%... Wait 30
minutes... not reach 11%...

 2- Close and reopen the qt-client, blockchain start again at 0%... Normal!?

 3- Now the download of the blockchain is working, reach 15% and growing...

 I have a open firewall for the Bitcoin protocol. My 0.4.0 client works
just fine, with more than 30 connections at the same machine (but another
Linux user).

 Also, where can I find the number of connections using new Bitcoin-QT?

Thanks!
Thiago

On 16 November 2011 14:34, Gavin Andresen <gavinandresen@gmail.com> wrote:

-------------------------------------
I've been wading through the pull requests and bug lists to figure out
a roadmap for the next few months.

Here are the things on my priority list:

1. Where are we at with network health? What metrics should we be
using? Is there work to be done?
And meta-issue:  can somebody volunteer to be the Bitcoin Network
Health Inspector to keep track of this?

2. We've got a chronic problem with new code causing CRITICAL_SECTION
deadlocks (see issue #453 for the latest). Detecting potential
deadlocks early should be done; longer term I think re-architecting to
be single-threaded/asio is probably the right thing to do.

3. Wallet security.  I'd like to get Matt's wallet encryption shipped
soon, along with all or part of groffer's Multisign patch (#319 --
since that will enable the creation of trojan-resistant secure wallet
solutions).

4. Bug fixing.  44 bugs in the issue list, some of which I think are
already fixed. Anybody else want to volunteer to be BugKeeper?  (job
would be: prioritize/assign bugs, make sure they get closed when
they're fixed).

5. Testing. I don't have time to personally test every PULL request,
but if a pull involves more than trivial code changes I'm not going to
pull it unless it has been thoroughly tested.  We had a very good rule
at a company I used to work for-- programmers were NOT allowed to be
the only ones to test their own code. Help finding money and/or people
for a dedicated "core bitcoin quality assurance team" is welcome.
More unit tests and automated testing is also certainly welcome.

If this was open source blogging software I'd be much less uptight
about testing and code review and bugs. But it's not, it is software
for handling money.


Stuff I'd like to see in the release-after-next:

fClient mode (download headers only, for faster initial startup; I've
started the work, talk to me if you want to take over)
Sipa's wallet and key export/import
Move from wxWidgets to qt for the GUI
Un-hardcode fee handling (anybody already working on this?)

And research-y features I'd like to see happen soon:

"Impolite peer" detection/reaction to prevent various DOS/Sybil attacks
Better detection/reaction to double spend attempts or block-chain splits
Code for mining pool participants that helps keep mining pool operators honest


Everything else I consider lower priority. But if it is important to
you, is important to other people (and non-controversial), you
thoroughly test it, and there's zero chance it introduces a security
vulnerability... then I'll have no objections to pulling it.

Did I miss anything important? I'll create a Roadmap page on the
bitcoin wiki if there is general consensus about priorities.

-- 
--
Gavin Andresen


-------------------------------------
sipa already rebased his showwallet tree. It's missing the segfault fix (or was yesterday) but said fix merges cleanly. I'm not entirely sure it's ready for pulling but it is in a functional state.

On Jun 28, 2011, at 12:48 PM, Jeff Garzik wrote:


-- 
Doug Huff


-------------------------------------
On Sun, Sep 18, 2011 at 7:30 PM, Luke-Jr <luke@dashjr.org> wrote:

My initial reaction is no. Testing and bug-fixing is the bottleneck
for making core bitcoin better, and maintaining two release lines
won't make that better.

I also think that until we get to a "1.0" that we can all agree is
ready for everybody AND their grandma to use, using the word "stable"
would be dishonest.

Would we link to your binaries if you want to create 0.4.* releases,
build binaries, then QA test and release them?

I dunno-- what do other people think?

Eventually, when there are a bunch of bitcoin implementations to
choose from, I think bitcoin.org should look like bittorrent.org -- it
should become a forum for developers to exchange ideas about the
direction of bitcoin.

-- 
--
Gavin Andresen


-------------------------------------
Has anyone considered 'snapshot' frames (blocks).

Message to node:

getsnapshot: hash

Node responds with a 'block' message.

Then the hash for that particular snapshot is hardcoded into the sourcecode. It would replace the checkpoints and use the last hash in that list.

Validating blocks is pretty fast right up until block 135k, which is where time taken balloons and starts become exponentially slower. As blockchain grows linearly, resources needed grows exponentially if you think about it.



________________________________
 From: Alan Reiner <etotheipi@gmail.com>
To: bitcoin-development@lists.sourceforge.net 
Sent: Sunday, December 18, 2011 6:06 PM
Subject: Re: [Bitcoin-development] Protocol extensions
 

The whole point of having headers built at a constant size and generation rate is to minimize the amount of data needed to "understand" of the blockchain while simultaneously maximizing integrity/security in the presence of untrusted nodes. Barring the 50%-attack, you only need a couple honest nodes out of 50 to stay safe (as long as you're waiting for your 6 confirmations). In fact, I would argue that a full node (Satoshi client), has the same level of security as a headers-only client... because they both base all their verification decisions on computations that end with comparing hashes to the longest-chain headers.

In the case that an attacker figures out how to isolate your node
    entirely and start feeing you poisoned blocks, then you are
    vulnerable with any kind of node, full or lightweight. I don't see
    where the reduced security is. 

The only issue I see is that a truly light-weight, headers-only node
    will be having to download an entire block to get one transaction it
    needs. This would be significantly alleviated if nodes can start
    requesting merkle-trees directly, even without
    merkle-branch-pruning.  If a node can ask for a tx and the
    tx-hash-list of the block that incorporated that tx, he can easily
    verify his tx against his no-need-to-trust-anyone headers, and
    doesn't have to download MBs for every one. 

As for blockchain pruning... I think it's absolutely critical to
    find a way to do this, for all nodes. I am swayed by Dan Kaminsky's scalability warnings, and my instinct tells me that leaving full verification to a select few deep-pockets nodes in the future opens up all sorts of centralization/power-corporation issues that is contrary to the Bitcoin concept. It is in everyone's best interest to make it as easy as possible for anyone to act as a full node (if possible). As such, I believe that the current system of minimizing TxOut size is the right one. TxIns take up 0 bytes space in the long-run when taking into account any blockchain pruning/snapshot idea (except for nLocktime/seq transactions where the TxIn might have to be saved). 

-Alan





On 12/18/2011 12:09 PM, theymos wrote: 
On Sat, Dec 17, 2011, at 05:27 PM, Jordan Mack wrote: 
interim action until the full block chain is downloaded in the
background. Development of these types of clients is probably
inevitable, but I believe that this breaks the most fundamental
aspects of Bitcoin's security model. If a client has only headers, it
cannot do full verification, and it is trusting the data from random
anonymous peers. 
attacker needs >50% of the network's computational power to trick
such clients. For everyone to keep being a full node, hardware costs would need to
constantly go down enough for all nodes to be able to handle enough
transactions to meet demand. If hardware doesn't become cheap enough
quickly enough, either some people would be unable to handle being full
nodes, or the max block size wouldn't rise enough to meet demand and
transaction fees would become noncompetitive. ------------------------------------------------------------------------------
Learn Windows Azure Live!  Tuesday, Dec 13, 2011
Microsoft is holding a special Learn Windows Azure training event for 
developers. It will provide a great way to learn Windows Azure and what it 
provides. You can attend the event by watching it streamed LIVE online.  
Learn more at http://p.sf.net/sfu/ms-windowsazure
_______________________________________________
Bitcoin-development mailing list Bitcoin-development@lists.sourceforge.net https://lists.sourceforge.net/lists/listinfo/bitcoin-development 

------------------------------------------------------------------------------
Learn Windows Azure Live! Tuesday, Dec 13, 2011
Microsoft is holding a special Learn Windows Azure training event for 
developers. It will provide a great way to learn Windows Azure and what it 
provides. You can attend the event by watching it streamed LIVE online. 
Learn more at http://p.sf.net/sfu/ms-windowsazure
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------------------------------
I haven't written a patch for this, I might do so if there's
sufficient interest.

Nodes that are under heavy load exhibit extremely high latency, this
makes downloading the block chain from a node that is itself
downloading the block chain basically useless as it takes 30-60
seconds for the node to respond to clients.

It could be fixed by making nodes not accept connections/advertise
until they feel sure they have the best chain, but a more general fix
is to add a "pong" which is returned by "ping". It could contain some
useful stats about the node for network crawlers, but most importantly
timing the delta between ping and pong would let you order nodes by
responsiveness. Currently if you want to do this, it has to be
indirect, using some message that is guarantee to yield a known
response.

Because old clients ignore messages they don't understand, adding the
pong response would be easy and backwards compatible. Making nodes
prefer responsive servers might need a bit of care to avoid sloshing
load around too much.

Thoughts?


-------------------------------------
On Wed, Aug 24, 2011 at 8:45 AM, Gregory Maxwell <gmaxwell@gmail.com> wrote:

-------------------------------------
On 2011 December 21 Wednesday, Amir Taaki wrote:


This seems excellent to me.

I think most developers want to do the right thing when it comes to standards, 
and it is only the inflexibility or ambiguity of a standard that means they 
don't.

This heirarchical method lets every client supply all the information they 
have -- nobody has to make a decision to leave something out.  The internal 
debate they would have "is my gui version more important than my protocol 
engine version?" is unnecessary.



Andy

-- 
Dr Andy Parkins
andyparkins@gmail.com
-------------------------------------
Alert system should be upgraded to pop up a dialog box every 30 minutes
whilst you're using the software.

Bitcoin is one of the few pieces of software I use that has no concept of
automatic updates or even notifications at all. Yet the network badly relies
on people upgrading for stability, scalability and to enable new features.

If the alert system goes away, it'd just end up being replaced by polling
something over HTTP, which is less decentralized than before. Having zero
way to communicate upgrades to end-users is a non-starter for anything
serious about mass market penetration.
-------------------------------------
Gavin Andresen wrote:
The first thing I always do when I grab the source for my colo server is 
patch util.cpp so that GetAdjustedTime() returns GetTime() with no 
adjustment.  But I'm the kind of guy that buys special GPS receivers 
because stratum 2 isn't low enough and occasionally checks ebay for 
caesium fountains.

NTP has been around for long enough now that there is no reason for the 
client to screw with the clock.  If the client sees different times on 
the network, it should issue a warning, and if it is off too far, it 
should give an error and fail to run (and/or peers should reject it).

But that doesn't solve the whole problem, because the block timestamp 
checking is based on the assumption that the node is looking at the 
bitcoin clock rather than the, ahem, real clock.  If we change the idea 
of network time to NTP, we will then need to write (and test!) new block 
timestamp rules to account for the new assumptions.

I'm not sure that just fixing item 2 is going to stop the attacks found 
by ArtForz, et al.  Some of the attacks Art pointed out are particularly 
bad because they change the incentive structure of the system, at least 
in the short term.  We need to flip that back around ASAP.

Also, this is going to cause problems for at least one pool operator.


-------------------------------------

This essay is old but still relevant, I think:

  http://www.joelonsoftware.com/articles/fog0000000069.html

Despite that, there are efforts to write a fresh implementation. For
example, BitCoinJ:

  http://code.google.com/p/bitcoinj/

It is not a complete implementation. It's targeting the "simplified
payment verification" mode as a first base, and is mostly intended for
mobile phones today as that's a niche the current codebase can't meet.
In the (very) long run, it may evolve into a full node.


The code was written by Satoshi who is long gone, and I doubt he would
care much for this type of list anyway. He was a do-er rather than a
talker.


-------------------------------------
Mac OSX version of bitcoin client finally posted at
https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.24/

Updated sums (stored as SHA1SUMS.asc on SF):
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

4909c17a1cc025c6f6c88d036f0b487c51c510f6  bitcoin-0.3.24-linux.tar.gz
fed0afebe0b0c0f77a637600ac4abecbe5d098ed  bitcoin-0.3.24-macosx.zip
58531249230f769fdc755822b41e0f18ba59512c  bitcoin-0.3.24-src.tar.gz
d4b5425eff673551a326d5326b92a06359dc1a3d  bitcoin-0.3.24-win32-setup.exe
520aed70ee28a0a91ed49dd983639cb1fab2a93c  bitcoin-0.3.24-win32.zip
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIVAwUBTiTMHNodwg8tvwyoAQL8CRAAgraSWP12lbwrhpiElvB7LIWoPbiE1dUx
i2ZO4MVJYKMbyuHu55j1Uq7a4ZqpNhXqq7U6efnoDTCl9sdpyhKxiql0SpsYBLs1
IehX4UEVGVMUE5uepmOs+cYnYuAhNzvxNqKFPv3D7uEOXPmSxlUa4s0GEnTgVR1l
0GFYf2T615MoGAak3+afahp4WB4XlHshttHT2P3o2/7N4Oh7iwFFtkmOj/Sb3Prc
C8skW83kUZ4i8W1HlZTmtr4YlQbKnx6bF6mbkTY1aQa1AV/8htenALkmR2+eCgsd
EY9WM8qruxnVLt/ao+VYw5jYLSYVKHt31ZD4rJM+5lKcTtU1NmNsGloen+hdLwC+
hggqnUQmvBzM7SKqvg4zI9SbgGR5fS3poTrFX7yDKZyLSPcjBND/lWi8evRiSEP0
yftCKL7zotdRy6QTG7tI1Fye1fyYuQdTB1nimE+7VJ8Q2O4DwE0iZKMuXm3GfaOr
T20Znvns9caMKED9T1gg42QgYM6EMMbeukBUkIXPt2tloDnn2tMzvvrKzgGBS1Lc
qv2ndhBCunBxNCQCHly4T2Rz8TJnm2XglS0d/VygcMuMSL0San5DwXYNnN4P0xD/
MXOdqrxcusIzKBbSHWPqInRmYUTymDtcqXWK3Cz6kRUXjBkRoSvDs8PBAvnaC236
1xol6uyMqZo=
=aMy0
-----END PGP SIGNATURE-----


-------------------------------------
dnsseed on, block send, segfault bugfix:  Agreed.

upnp: I think should be enabled on Windows/Mac, but remain
off-by-default on Linux.

I think adding another block-chain checkpoint is a good idea, too.

-- 
--
Gavin Andresen


-------------------------------------
This is the first proposal I've seen regarding mapping something like
user@host that actually makes sense to me.

Bitcoin itself is decentralised by design, in my opinion it seems obvious
that it needs to continue to maintain this feature.


On Fri, Dec 16, 2011 at 8:59 AM, theymos <theymos@mm.st> wrote:

-------------------------------------
[snip]


To restate your (con dnssec) points:
   o DNS resolution of bitcoin addresses is bad because of potential
MITM attacks
   o DNSSEC is not a security measure for mitigating DNS resolution of
bitcoin addresses
      because the application would require its own dnssec enabled stub resolver

Please restate
   o HTTPS is your preferred method for resolution because?

If you can enumerate your advantages so I can develop a proper
response to the points you have raised.

thanks,

-rick


-------------------------------------
Reposting here from the forums:

Good news: I'm just about to get a Bitcoin-Qt version 0.5 Release
Candidate 1 out, with a much-improved GUI.

Bad news: all the translations for the old wxWidgets Bitcoin are
obsolete, and the process for making translations is different.

Is anybody willing to write new translations?  Here's what you'll need to know:

Three translations already exist: de nl and ru.
Translations are stored in ".ts" files in the src/qt/locale folder
The 'QT Linguist' tool can be used to create translations
... or maybe an online tool like Transifex could/should be used to
crowd-source the work

And is anybody willing to take the job of coordinating translation
efforts, figuring out if Transifex is a good tool to use, and writing
some documentation to make it easy for people to create and submit new
translations?


References:
  https://github.com/bitcoin/bitcoin/blob/master/src/qt/locale
  http://doc.qt.nokia.com/latest/linguist-manual.html
  http://www.transifex.net/

-- 
--
Gavin Andresen


-------------------------------------
I think it's possible to add it yourself. Just click on "add translation"

On 22.10.2011 14:26, Geir Harald Hansen wrote:



-------------------------------------
